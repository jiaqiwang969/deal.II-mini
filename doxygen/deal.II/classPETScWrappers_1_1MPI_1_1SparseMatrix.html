<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1MPI_1_1SparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::MPI::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPETScWrappers_1_1MPI_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::MPI::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__sparse__matrix_8h_source.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::MPI::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1MPI_1_1SparseMatrix__inherit__graph.svg" width="206" height="202"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPETScWrappers_1_1MPI_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a315d6badf3f70e87ddf2a784ab5a6436"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a315d6badf3f70e87ddf2a784ab5a6436">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a315d6badf3f70e87ddf2a784ab5a6436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29f79582d2d2681b5f55167761d84168"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> = <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td></tr>
<tr class="separator:a29f79582d2d2681b5f55167761d84168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae584b9befbadcc9293f710bde79b3d21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> = PetscScalar</td></tr>
<tr class="separator:ae584b9befbadcc9293f710bde79b3d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7999b55f6e18fdcb9a0c8f4609f4eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ad7999b55f6e18fdcb9a0c8f4609f4eb8">~SparseMatrix</a> () override</td></tr>
<tr class="separator:ad7999b55f6e18fdcb9a0c8f4609f4eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e3abd3a9f663b13ebce9191b143ea9"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ac7e3abd3a9f663b13ebce9191b143ea9"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ac7e3abd3a9f663b13ebce9191b143ea9">SparseMatrix</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a>, const SparsityPatternType &amp;sparsity_pattern, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_rows_per_process, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_columns_per_process, const unsigned <a class="el" href="classint.html">int</a> this_process, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations=true)</td></tr>
<tr class="separator:ac7e3abd3a9f663b13ebce9191b143ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0092f1d907d29212c0b8bd0c644cae0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a0092f1d907d29212c0b8bd0c644cae0e">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> d)</td></tr>
<tr class="separator:a0092f1d907d29212c0b8bd0c644cae0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130d139e9ef5e4569cc6271ee199d72c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a130d139e9ef5e4569cc6271ee199d72c">copy_from</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a130d139e9ef5e4569cc6271ee199d72c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287ce9bac8a06bbc02a8159a2b821a0a"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a287ce9bac8a06bbc02a8159a2b821a0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a>, const SparsityPatternType &amp;sparsity_pattern, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_rows_per_process, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_columns_per_process, const unsigned <a class="el" href="classint.html">int</a> this_process, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations=true)</td></tr>
<tr class="separator:a287ce9bac8a06bbc02a8159a2b821a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada623c75b093257140547fae23a73b1e"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ada623c75b093257140547fae23a73b1e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ada623c75b093257140547fae23a73b1e">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_rows, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_columns, const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a>)</td></tr>
<tr class="separator:ada623c75b093257140547fae23a73b1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f6a6ca194d954faa0ba49acf29bd518"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a0f6a6ca194d954faa0ba49acf29bd518">reinit</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;other)</td></tr>
<tr class="separator:a0f6a6ca194d954faa0ba49acf29bd518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa85242545b5d377c3734526c3c72ee"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a2fa85242545b5d377c3734526c3c72ee">get_mpi_communicator</a> () const override</td></tr>
<tr class="separator:a2fa85242545b5d377c3734526c3c72ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab12c63ba4f6a2e0d6d9e2c275b0e63ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab12c63ba4f6a2e0d6d9e2c275b0e63ba">DeclException2</a> (ExcLocalRowsTooLarge, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of local rows &quot;&lt;&lt; arg1&lt;&lt; &quot; must be larger than the total number of rows &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:gab12c63ba4f6a2e0d6d9e2c275b0e63ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afb5db3c1463666ece5abd2a880f7e0"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a9afb5db3c1463666ece5abd2a880f7e0">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:a9afb5db3c1463666ece5abd2a880f7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c898e34c68304eb76c843c7ef215183"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a2c898e34c68304eb76c843c7ef215183">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:a2c898e34c68304eb76c843c7ef215183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae11774f0d639c6d6b7d5fffe5ede29c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ae11774f0d639c6d6b7d5fffe5ede29c6">locally_owned_domain_indices</a> () const</td></tr>
<tr class="separator:ae11774f0d639c6d6b7d5fffe5ede29c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac33c46847f3028baacd2e15e5538978b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ac33c46847f3028baacd2e15e5538978b">locally_owned_range_indices</a> () const</td></tr>
<tr class="separator:ac33c46847f3028baacd2e15e5538978b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a1dbabb70ef99a4be889474c4c5dc4756">mmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446bb9a2e86487360cd8c73c021197e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a446bb9a2e86487360cd8c73c021197e4">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a446bb9a2e86487360cd8c73c021197e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1b895d26bc6c0a0cf96d37d00e5853c4">clear</a> ()</td></tr>
<tr class="separator:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5067751068b7290030fe97cc8cadd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af5067751068b7290030fe97cc8cadd02">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:af5067751068b7290030fe97cc8cadd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af2a6e591d33f2af5e44a20c8b3e30943">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d04e83f54969c8c504da62bdee60a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a90d04e83f54969c8c504da62bdee60a8">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a90d04e83f54969c8c504da62bdee60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc988c43c687b2af0b7e4352def7f19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abc988c43c687b2af0b7e4352def7f19b">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:abc988c43c687b2af0b7e4352def7f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae9fe7cc7dd404261b63b7ee651233de1">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a017ad4b1e0e18954db42d489e91ed0bb">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b079c5bf7843592a347a9874752eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a97b079c5bf7843592a347a9874752eef">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a97b079c5bf7843592a347a9874752eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068368a605f2661042e104f0ad3eef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a068368a605f2661042e104f0ad3eef47">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a068368a605f2661042e104f0ad3eef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8298c20ffaf1ba83c286e119fd53e7d0">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abec5dd7bf11e94aeeeca18e94576c06e">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be932238458b6c1cd83b51571891a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5be932238458b6c1cd83b51571891a6a">add</a> (const PetscScalar factor, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a5be932238458b6c1cd83b51571891a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918fe8858fea210e01de289340c2468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:af918fe8858fea210e01de289340c2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d67d301ec5cb4181b071168a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25c2d67d301ec5cb4181b071168a6783">clear_rows</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;rows, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:a25c2d67d301ec5cb4181b071168a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264ec17db96d955590626c8da8e6aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ae264ec17db96d955590626c8da8e6aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8eddd61ef58cb9f312b47b0e3c165f7a">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89476484bfd365c60972c76d3a893925"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a89476484bfd365c60972c76d3a893925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2bb6345b774b4029dc1cc04b6c5ecedf">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i) const</td></tr>
<tr class="separator:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d397cb51074c94824c3db0a21e6210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m</a> () const</td></tr>
<tr class="separator:ae6d397cb51074c94824c3db0a21e6210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31319c249e3ff1bf572c79ee0f41bade"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a31319c249e3ff1bf572c79ee0f41bade">n</a> () const</td></tr>
<tr class="separator:a31319c249e3ff1bf572c79ee0f41bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b350e8500ad00885d36508ded03c159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size</a> () const</td></tr>
<tr class="separator:a8b350e8500ad00885d36508ded03c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca73a7174b92973d2a57e41af737fd1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range</a> () const</td></tr>
<tr class="separator:adca73a7174b92973d2a57e41af737fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988bc02bfef4479879867a411eb2b682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a988bc02bfef4479879867a411eb2b682">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> index) const</td></tr>
<tr class="separator:a988bc02bfef4479879867a411eb2b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc9652ade95e371d4191e28461eeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adfcc9652ade95e371d4191e28461eeb8">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:adfcc9652ade95e371d4191e28461eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0aee7127b31ea26d3847ce7d4d9236ad">row_length</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row) const</td></tr>
<tr class="separator:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1976b38af71b46e0fa5f3b4837f2fd05">l1_norm</a> () const</td></tr>
<tr class="separator:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ba7168f27d27bae50b653587fd8f"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afd06ba7168f27d27bae50b653587fd8f">linfty_norm</a> () const</td></tr>
<tr class="separator:afd06ba7168f27d27bae50b653587fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5ab9e8f1061cef606eaeb0993ce3d887">frobenius_norm</a> () const</td></tr>
<tr class="separator:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0c76f22865de9a597b7342f87463e"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae7e0c76f22865de9a597b7342f87463e">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:ae7e0c76f22865de9a597b7342f87463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aef113fe7fed539cc6e5a75f457571"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0aef113fe7fed539cc6e5a75f457571">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:aa0aef113fe7fed539cc6e5a75f457571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bff0bbfcb1159616cb078ae9d68374"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a95bff0bbfcb1159616cb078ae9d68374">trace</a> () const</td></tr>
<tr class="separator:a95bff0bbfcb1159616cb078ae9d68374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b99bfc37fc183a7d978ec48f83623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4b99bfc37fc183a7d978ec48f83623">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:aad4b99bfc37fc183a7d978ec48f83623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455541189a44467806299d3f0e0d2005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a455541189a44467806299d3f0e0d2005">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a455541189a44467806299d3f0e0d2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e08f3caffe58c6213f1a142140d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a228e08f3caffe58c6213f1a142140d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa53f7571665e69020dd5c1c90cf2e04d">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714cb0c98ae635dd7591b40192dc9240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a714cb0c98ae635dd7591b40192dc9240">Tvmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a714cb0c98ae635dd7591b40192dc9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab7d09f592d2683c8d9cb7e422dfc2e57">residual</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const</td></tr>
<tr class="separator:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417ad4470cefee04a01c4595b609d310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a417ad4470cefee04a01c4595b609d310">begin</a> () const</td></tr>
<tr class="separator:a417ad4470cefee04a01c4595b609d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7d876a5651cfc339c93a5406b4f7eb79">begin</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2141ca2fb58139da5e1f532634958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6cc2141ca2fb58139da5e1f532634958">end</a> () const</td></tr>
<tr class="separator:a6cc2141ca2fb58139da5e1f532634958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748f0b7f03b5b7452a38b92561d2943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0748f0b7f03b5b7452a38b92561d2943">end</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a0748f0b7f03b5b7452a38b92561d2943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11a01597f3233c1f817a09471c937e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac11a01597f3233c1f817a09471c937e3">operator Mat</a> () const</td></tr>
<tr class="separator:ac11a01597f3233c1f817a09471c937e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85273881d243958293bf3155e605ba67"><td class="memItemLeft" align="right" valign="top">Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a85273881d243958293bf3155e605ba67">petsc_matrix</a> ()</td></tr>
<tr class="separator:a85273881d243958293bf3155e605ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76b6ce3247735964836a82eedff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacd76b6ce3247735964836a82eedff6d">transpose</a> ()</td></tr>
<tr class="separator:aacd76b6ce3247735964836a82eedff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f6b575f15d540cf10688b30d09941"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9f2f6b575f15d540cf10688b30d09941">is_hermitian</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a9f2f6b575f15d540cf10688b30d09941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127fd1b40ab452473f96cc298694528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad127fd1b40ab452473f96cc298694528">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:ad127fd1b40ab452473f96cc298694528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515e640202d1ad50bd9baa13c404cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7515e640202d1ad50bd9baa13c404cb1">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a7515e640202d1ad50bd9baa13c404cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7a8873fc01cd20682e079dbb8f225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0af7a8873fc01cd20682e079dbb8f225">memory_consumption</a> () const</td></tr>
<tr class="separator:a0af7a8873fc01cd20682e079dbb8f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa059253b9ee3357d06dbd37816a1d22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afa059253b9ee3357d06dbd37816a1d22">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:afa059253b9ee3357d06dbd37816a1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4656c942eaca0ea491fba37a0a6225eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4656c942eaca0ea491fba37a0a6225eb">DeclException2</a> (ExcWrongMode, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You first have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;)</td></tr>
<tr class="separator:a4656c942eaca0ea491fba37a0a6225eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9795580277a7bc3a4348443768b6c0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9795580277a7bc3a4348443768b6c0fd">prepare_action</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> new_action)</td></tr>
<tr class="separator:a9795580277a7bc3a4348443768b6c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0e10ef38e7bb5901bc5678a8a4ffd6d">assert_is_compressed</a> ()</td></tr>
<tr class="separator:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add</a> ()</td></tr>
<tr class="separator:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b00916f856722282dcd9abb408581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set</a> ()</td></tr>
<tr class="separator:a9d1b00916f856722282dcd9abb408581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49501300c99d6fea596a39fbe38b8961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">mmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:a49501300c99d6fea596a39fbe38b8961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c266e288f1d409c1b09eae7114792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:ab97c266e288f1d409c1b09eae7114792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfce46e53089351cc7fe6b9ea44e167f"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a></td></tr>
<tr class="separator:abfce46e53089351cc7fe6b9ea44e167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1deda2ab63ef62230745b4ff99bd26d6">last_action</a></td></tr>
<tr class="separator:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ae46377c65ba286db6d4f7f98fde872b3"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ae46377c65ba286db6d4f7f98fde872b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#ae46377c65ba286db6d4f7f98fde872b3">do_reinit</a> (const SparsityPatternType &amp;sparsity_pattern, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_rows_per_process, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;local_columns_per_process, const unsigned <a class="el" href="classint.html">int</a> this_process, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations)</td></tr>
<tr class="separator:ae46377c65ba286db6d4f7f98fde872b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae4e61d74115d8d6e6aa8cf0533ce3e7"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:aae4e61d74115d8d6e6aa8cf0533ce3e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#aae4e61d74115d8d6e6aa8cf0533ce3e7">do_reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_rows, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_columns, const SparsityPatternType &amp;sparsity_pattern)</td></tr>
<tr class="separator:aae4e61d74115d8d6e6aa8cf0533ce3e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a480a46d7e16cbc9ef06e5442cb1cec2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a480a46d7e16cbc9ef06e5442cb1cec2a">communicator</a></td></tr>
<tr class="separator:a480a46d7e16cbc9ef06e5442cb1cec2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a parallel sparse matrix class based on PETSc, with rows of the matrix distributed across an <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> network. All the functionality is actually in the base class, except for the calls to generate a parallel sparse matrix. This is possible since PETSc only works on an abstract matrix type and internally distributes to functions that do the actual work depending on the actual matrix type (much like using virtual functions). Only the functions creating a matrix of specific type differ, and are implemented in this particular class.</p>
<p>There are a number of comments on the communication model as well as access to individual elements in the documentation to the parallel vector class. These comments apply here as well.</p>
<h3>Partitioning of matrices</h3>
<p>PETSc partitions parallel matrices so that each <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> process "owns" a certain number of rows (i.e. only this process stores the respective entries in these rows). The number of rows each process owns has to be passed to the constructors and <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit()</a> functions via the argument <code>local_rows</code>. The individual values passed as <code>local_rows</code> on all the <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> processes of course have to add up to the global number of rows of the matrix.</p>
<p>In addition to this, PETSc also partitions the rectangular chunk of the matrix it owns (i.e. the <code>local_rows</code> times <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a31319c249e3ff1bf572c79ee0f41bade">n()</a> elements in the matrix), so that matrix vector multiplications can be performed efficiently. This column-partitioning therefore has to match the partitioning of the vectors with which the matrix is multiplied, just as the row-partitioning has to match the partitioning of destination vectors. This partitioning is passed to the constructors and <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit()</a> functions through the <code>local_columns</code> variable, which again has to add up to the global number of columns in the matrix. The name <code>local_columns</code> may be named inappropriately since it does not reflect that only these columns are stored locally, but it reflects the fact that these are the columns for which the elements of incoming vectors are stored locally.</p>
<p>To make things even more complicated, PETSc needs a very good estimate of the number of elements to be stored in each row to be efficient. Otherwise it spends most of the time with allocating small chunks of memory, a process that can slow down programs to a crawl if it happens to often. As if a good estimate of the number of entries per row isn't even, it even needs to split this as follows: for each row it owns, it needs an estimate for the number of elements in this row that fall into the columns that are set apart for this process (see above), and the number of elements that are in the rest of the columns.</p>
<p>Since in general this information is not readily available, most of the initializing functions of this class assume that all of the number of elements you give as an argument to <code>n_nonzero_per_row</code> or by <code>row_lengths</code> fall into the columns "owned" by this process, and none into the other ones. This is a fair guess for most of the rows, since in a good domain partitioning, nodes only interact with nodes that are within the same subdomain. It does not hold for nodes on the interfaces of subdomain, however, and for the rows corresponding to these nodes, PETSc will have to allocate additional memory, a costly process.</p>
<p>The only way to avoid this is to tell PETSc where the actual entries of the matrix will be. For this, there are constructors and <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit()</a> functions of this class that take a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> object containing all this information. While in the general case it is sufficient if the constructors and <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a287ce9bac8a06bbc02a8159a2b821a0a">reinit()</a> functions know the number of local rows and columns, the functions getting a sparsity pattern also need to know the number of local rows (<code>local_rows_per_process</code>) and columns (<code>local_columns_per_process</code>) for all other processes, in order to compute which parts of the matrix are which. Thus, it is not sufficient to just count the number of degrees of freedom that belong to a particular process, but you have to have the numbers for all processes available at all processes. </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00365">365</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a315d6badf3f70e87ddf2a784ab5a6436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a315d6badf3f70e87ddf2a784ab5a6436">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a315d6badf3f70e87ddf2a784ab5a6436">PETScWrappers::MPI::SparseMatrix::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00371">371</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a29f79582d2d2681b5f55167761d84168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f79582d2d2681b5f55167761d84168">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">PETScWrappers::MatrixBase::const_iterator</a> =  <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare an alias for the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00288">288</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="ae584b9befbadcc9293f710bde79b3d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae584b9befbadcc9293f710bde79b3d21">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">PETScWrappers::MatrixBase::value_type</a> =  PetscScalar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Declare an alias in analogy to all the other container classes. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00298">298</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. Create an empty matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00034">34</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ad7999b55f6e18fdcb9a0c8f4609f4eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7999b55f6e18fdcb9a0c8f4609f4eb8">&#9670;&nbsp;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::~<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor to free the PETSc object. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00047">47</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac7e3abd3a9f663b13ebce9191b143ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e3abd3a9f663b13ebce9191b143ea9">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::<a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rows_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_columns_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>this_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize using the given sparsity pattern with communication happening over the provided <code>communicator</code>.</p>
<p>For the meaning of the <code>local_rows_per_process</code> and <code>local_columns_per_process</code> parameters, see the class documentation.</p>
<p>Note that PETSc can be very slow if you do not provide it with a good estimate of the lengths of rows. Using the present function is a very efficient way to do this, as it uses the exact number of nonzero entries for each row of the matrix by using the given sparsity pattern argument. If the <code>preset_nonzero_locations</code> flag is <code>true</code>, this function in addition not only sets the correct row sizes up front, but also pre-allocated the correct nonzero entries in the matrix.</p>
<p>PETsc allows to later add additional nonzero entries to a matrix, by simply writing to these elements. However, this will then lead to additional memory allocations which are very inefficient and will greatly slow down your program. It is therefore significantly more efficient to get memory allocation right from the start. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00055">55</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0092f1d907d29212c0b8bd0c644cae0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0092f1d907d29212c0b8bd0c644cae0e">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00090">90</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a130d139e9ef5e4569cc6271ee199d72c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130d139e9ef5e4569cc6271ee199d72c">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a copy of the PETSc matrix <code>other</code>. It is assumed that both matrices have the same <a class="el" href="classSparsityPattern.html">SparsityPattern</a>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00097">97</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a287ce9bac8a06bbc02a8159a2b821a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287ce9bac8a06bbc02a8159a2b821a0a">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rows_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_columns_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>this_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize using the given sparsity pattern with communication happening over the provided <code>communicator</code>.</p>
<p>Note that PETSc can be very slow if you do not provide it with a good estimate of the lengths of rows. Using the present function is a very efficient way to do this, as it uses the exact number of nonzero entries for each row of the matrix by using the given sparsity pattern argument. If the <code>preset_nonzero_locations</code> flag is <code>true</code>, this function in addition not only sets the correct row sizes up front, but also pre-allocated the correct nonzero entries in the matrix.</p>
<p>PETsc allows to later add additional nonzero entries to a matrix, by simply writing to these elements. However, this will then lead to additional memory allocations which are very inefficient and will greatly slow down your program. It is therefore significantly more efficient to get memory allocation right from the start. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00113">113</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ada623c75b093257140547fae23a73b1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada623c75b093257140547fae23a73b1e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a matrix where the size() of the IndexSets determine the global number of rows and columns and the entries of the <a class="el" href="classIndexSet.html">IndexSet</a> give the rows and columns for the calling processor. Note that only ascending, 1:1 IndexSets are supported. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00137">137</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a0f6a6ca194d954faa0ba49acf29bd518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f6a6ca194d954faa0ba49acf29bd518">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize this matrix to have the same structure as <code>other</code>. This will not copy the values of the other matrix, but you can use <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html#a130d139e9ef5e4569cc6271ee199d72c">copy_from()</a> for this. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00074">74</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2fa85242545b5d377c3734526c3c72ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa85242545b5d377c3734526c3c72ee">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> communicator object in use with this matrix. </p>

<p>Implements <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae1aadd5aebcdc166b840df3430a23606">PETScWrappers::MatrixBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00625">625</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a9afb5db3c1463666ece5abd2a880f7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afb5db3c1463666ece5abd2a880f7e0">&#9670;&nbsp;</a></span>matrix_norm_square() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector \(v\) with respect to the norm induced by this matrix, i.e. \(\left(v^\ast,Mv\right)\). This is useful, e.g. in the finite element context, where the \(L_2\) norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00482">482</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2c898e34c68304eb76c843c7ef215183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c898e34c68304eb76c843c7ef215183">&#9670;&nbsp;</a></span>matrix_scalar_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the matrix scalar product \(\left(u^\ast,Mv\right)\).</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00491">491</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae11774f0d639c6d6b7d5fffe5ede29c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae11774f0d639c6d6b7d5fffe5ede29c6">&#9670;&nbsp;</a></span>locally_owned_domain_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::locally_owned_domain_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the domain space of this matrix, i.e., the partitioning of the vectors this matrix has to be multiplied with. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00500">500</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac33c46847f3028baacd2e15e5538978b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac33c46847f3028baacd2e15e5538978b">&#9670;&nbsp;</a></span>locally_owned_range_indices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::locally_owned_range_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the partitioning of the range space of this matrix, i.e., the partitioning of the vectors that result from matrix-vector products. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00526">526</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1dbabb70ef99a4be889474c4c5dc4756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbabb70ef99a4be889474c4c5dc4756">&#9670;&nbsp;</a></span>mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication \(C = AB\), or, \(C = A \text{diag}(V) B\) given a compatible vector \(V\).</p>
<p>This function calls <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">MatrixBase::mmult()</a> to do the actual work. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00552">552</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a446bb9a2e86487360cd8c73c021197e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446bb9a2e86487360cd8c73c021197e4">&#9670;&nbsp;</a></span>Tmmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., \(C = A^T B\), or, \(C = A^T \text{diag}(V) B\) given a compatible vector \(V\).</p>
<p>This function calls <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">MatrixBase::Tmmult()</a> to do the actual work. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00563">563</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae46377c65ba286db6d4f7f98fde872b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46377c65ba286db6d4f7f98fde872b3">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rows_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_columns_per_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>this_process</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as previous functions. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00298">298</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="aae4e61d74115d8d6e6aa8cf0533ce3e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae4e61d74115d8d6e6aa8cf0533ce3e7">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as previous functions. </p>

<p class="definition">Definition at line <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html#l00155">155</a> of file <a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b895d26bc6c0a0cf96d37d00e5853c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b895d26bc6c0a0cf96d37d00e5853c4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00092">92</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af5067751068b7290030fe97cc8cadd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5067751068b7290030fe97cc8cadd02">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the element (<em>i,j</em>) to <code>value</code>.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds a new entry to the matrix if it didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist. If <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a id="af2a6e591d33f2af5e44a20c8b3e30943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a6e591d33f2af5e44a20c8b3e30943">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="a90d04e83f54969c8c504da62bdee60a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d04e83f54969c8c504da62bdee60a8">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="abc988c43c687b2af0b7e4352def7f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc988c43c687b2af0b7e4352def7f19b">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="ae9fe7cc7dd404261b63b7ee651233de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fe7cc7dd404261b63b7ee651233de1">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="a017ad4b1e0e18954db42d489e91ed0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017ad4b1e0e18954db42d489e91ed0bb">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>).</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds a new entry to the matrix if it didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist. If <code>value</code> is not a finite number an exception is thrown. </p>

</div>
</div>
<a id="a97b079c5bf7843592a347a9874752eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b079c5bf7843592a347a9874752eef">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a068368a605f2661042e104f0ad3eef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068368a605f2661042e104f0ad3eef47">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="a8298c20ffaf1ba83c286e119fd53e7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8298c20ffaf1ba83c286e119fd53e7d0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="abec5dd7bf11e94aeeeca18e94576c06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5dd7bf11e94aeeeca18e94576c06e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>If the present object (from a derived class of this one) happens to be a sparse matrix, then this function adds some new entries to the matrix if they didn't exist before, very much in contrast to the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class which throws an error if the entry does not exist.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a5be932238458b6c1cd83b51571891a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be932238458b6c1cd83b51571891a6a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the matrix <code>other</code> scaled by the factor <code>factor</code> to the current matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00430">430</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af918fe8858fea210e01de289340c2468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af918fe8858fea210e01de289340c2468">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove all elements from this <code>row</code> by setting them to zero. The function does not modify the number of allocated nonzero entries, it only sets some entries to zero. It may drop them from the sparsity pattern, though (but retains the allocated memory in case new entries are again added later).</p>
<p>This operation is used in eliminating constraints (e.g. due to hanging nodes) and makes sure that we can write this modification to the matrix without having to read entries (such as the locations of non-zero elements) from it &ndash; without this operation, removing constraints on parallel matrices is a rather complicated procedure.</p>
<p>The second parameter can be used to set the diagonal entry of this row to a value different from zero. The default is to set it to zero. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00127">127</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a25c2d67d301ec5cb4181b071168a6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c2d67d301ec5cb4181b071168a6783">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row()</a>, except that it works on a number of rows at once.</p>
<p>The second parameter can be used to set the diagonal entries of all cleared rows to something different from zero. Note that all of these diagonal entries get the same value &ndash; if you want different values for the diagonal entries, you have to set them by hand. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00136">136</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae264ec17db96d955590626c8da8e6aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264ec17db96d955590626c8da8e6aad">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PETSc matrices store their own sparsity patterns. So, in analogy to our own <a class="el" href="classSparsityPattern.html">SparsityPattern</a> class, this function compresses the sparsity pattern and allows the resulting matrix to be used in all other operations where before only assembly functions were allowed. This function must therefore be called once you have assembled the matrix.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00193">193</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8eddd61ef58cb9f312b47b0e3c165f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eddd61ef58cb9f312b47b0e3c165f7a">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the entry (<em>i,j</em>). This may be an expensive operation and you should always take care where to call this function. In contrast to the respective function in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class, we don't throw an exception if the respective entry doesn't exist in the sparsity pattern of this class, since PETSc does not transmit this information.</p>
<p>This function is therefore exactly equivalent to the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a></code> function. </p>

</div>
</div>
<a id="a89476484bfd365c60972c76d3a893925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89476484bfd365c60972c76d3a893925">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the matrix entry (<em>i,j</em>). If this entry does not exist in the sparsity pattern, then zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00165">165</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a2bb6345b774b4029dc1cc04b6c5ecedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6345b774b4029dc1cc04b6c5ecedf">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic.</p>
<p>Since we do not have direct access to the underlying data structure, this function is no faster than the elementwise access using the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a> function. However, we provide this function for compatibility with the <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> class. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00181">181</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae6d397cb51074c94824c3db0a21e6210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d397cb51074c94824c3db0a21e6210">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of rows in this matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00237">237</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a31319c249e3ff1bf572c79ee0f41bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31319c249e3ff1bf572c79ee0f41bade">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of columns in this matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00250">250</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8b350e8500ad00885d36508ded03c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b350e8500ad00885d36508ded03c159">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the local dimension of the matrix, i.e. the number of rows stored on the present <a class="el" href="namespacePETScWrappers_1_1MPI.html">MPI</a> process. For sequential matrices, this number is the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m()</a>, but for parallel matrices it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range()</a>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00263">263</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adca73a7174b92973d2a57e41af737fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca73a7174b92973d2a57e41af737fd1">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> &gt; PETScWrappers::MatrixBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which rows of this matrix are stored locally. The first number is the index of the first row stored, the second the index of the one past the last one that is stored locally. If this is a sequential matrix, then the result will be the pair (0,<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae6d397cb51074c94824c3db0a21e6210">m()</a>), otherwise it will be a pair (i,i+n), where <code>n=<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00276">276</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a988bc02bfef4479879867a411eb2b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988bc02bfef4479879867a411eb2b682">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::MatrixBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range()</a>. </p>

</div>
</div>
<a id="adfcc9652ade95e371d4191e28461eeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc9652ade95e371d4191e28461eeb8">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00290">290</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0aee7127b31ea26d3847ce7d4d9236ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee7127b31ea26d3847ce7d4d9236ad">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of entries in a specific row. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00302">302</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1976b38af71b46e0fa5f3b4837f2fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1976b38af71b46e0fa5f3b4837f2fd05">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l1-norm of the matrix, that is \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\), (max. sum of columns). This is the natural matrix norm that is compatible to the l1-norm for vectors, i.e. \(|Mv|_1\leq |M|_1 |v|_1\). (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00338">338</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afd06ba7168f27d27bae50b653587fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06ba7168f27d27bae50b653587fd8f">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the linfty-norm of the matrix, that is \(|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|\), (max. sum of rows). This is the natural matrix norm that is compatible to the linfty-norm of vectors, i.e. \(|Mv|_infty \leq |M|_infty |v|_infty\). (cf. Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00351">351</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5ab9e8f1061cef606eaeb0993ce3d887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab9e8f1061cef606eaeb0993ce3d887">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00364">364</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae7e0c76f22865de9a597b7342f87463e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0c76f22865de9a597b7342f87463e">&#9670;&nbsp;</a></span>matrix_norm_square() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector \(v\) with respect to the norm induced by this matrix, i.e. \(\left(v,Mv\right)\). This is useful, e.g. in the finite element context, where the \(L_2\) norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation.</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then the given vector has to be a distributed vector as well. Conversely, if the matrix is not distributed, then neither may the vector be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00376">376</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa0aef113fe7fed539cc6e5a75f457571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aef113fe7fed539cc6e5a75f457571">&#9670;&nbsp;</a></span>matrix_scalar_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the matrix scalar product \(\left(u,Mv\right)\).</p>
<p>The implementation of this function is not as efficient as the one in the <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> class used in deal.II (i.e. the original one, not the PETSc wrapper class) since PETSc doesn't support this operation and needs a temporary vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00385">385</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a95bff0bbfcb1159616cb078ae9d68374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bff0bbfcb1159616cb078ae9d68374">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the trace of the matrix, i.e. the sum of all diagonal entries in the matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00395">395</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aad4b99bfc37fc183a7d978ec48f83623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4b99bfc37fc183a7d978ec48f83623">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00408">408</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a455541189a44467806299d3f0e0d2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455541189a44467806299d3f0e0d2005">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00419">419</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a228e08f3caffe58c6213f1a142140d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228e08f3caffe58c6213f1a142140d3f">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M*src</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00441">441</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa53f7571665e69020dd5c1c90cf2e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53f7571665e69020dd5c1c90cf2e04d">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let <em>dst = M<sup>T</sup>*src</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00452">452</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adb7231c9d5f340181ac3c45827f5b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7231c9d5f340181ac3c45827f5b9e4">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M*src</em> on <em>dst</em> with <em>M</em> being this matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00463">463</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a714cb0c98ae635dd7591b40192dc9240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714cb0c98ae635dd7591b40192dc9240">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M<sup>T</sup>*src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add()</a> but takes the transposed matrix.</p>
<p>Source and destination must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then both vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00474">474</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab7d09f592d2683c8d9cb7e422dfc2e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d09f592d2683c8d9cb7e422dfc2e57">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the residual of an equation <em>Mx=b</em>, where the residual is defined to be <em>r=b-Mx</em>. Write the residual into <code>dst</code>. The <em>l<sub>2</sub></em> norm of the residual vector is returned.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector.</p>
<p>Note that if the current object represents a parallel distributed matrix (of type <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), then all vectors have to be distributed vectors as well. Conversely, if the matrix is not distributed, then neither of the vectors may be. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00574">574</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a417ad4470cefee04a01c4595b609d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417ad4470cefee04a01c4595b609d310">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator starting at the first entry. This can only be called on a processor owning the entire matrix. In all other cases refer to the version of <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a417ad4470cefee04a01c4595b609d310">begin()</a> taking a row number as an argument. </p>

</div>
</div>
<a id="a7d876a5651cfc339c93a5406b4f7eb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d876a5651cfc339c93a5406b4f7eb79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>.</p>
<p>Note that if the given row is empty, i.e. does not contain any nonzero entries, then the iterator returned by this function equals <code>end(r)</code>. Note also that the iterator may not be dereferenceable in that case. </p>

</div>
</div>
<a id="a6cc2141ca2fb58139da5e1f532634958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2141ca2fb58139da5e1f532634958">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Final iterator. This can only be called on a processor owning the entire matrix. In all other cases refer to the version of <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6cc2141ca2fb58139da5e1f532634958">end()</a> taking a row number as an argument. </p>

</div>
</div>
<a id="a0748f0b7f03b5b7452a38b92561d2943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748f0b7f03b5b7452a38b92561d2943">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. It points to the first element past the end of line <code>r</code>, or past the end of the entire sparsity pattern.</p>
<p>Note that the end iterator is not necessarily dereferenceable. This is in particular the case if it is the end iterator for the last row of a matrix. </p>

</div>
</div>
<a id="ac11a01597f3233c1f817a09471c937e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11a01597f3233c1f817a09471c937e3">&#9670;&nbsp;</a></span>operator Mat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::operator Mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion operator to gain access to the underlying PETSc type. If you do this, you cut this class off some information it may need, so this conversion operator should only be used if you know what you do. In particular, it should only be used for read-only operations into the matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00590">590</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a85273881d243958293bf3155e605ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85273881d243958293bf3155e605ba67">&#9670;&nbsp;</a></span>petsc_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat &amp; PETScWrappers::MatrixBase::petsc_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the underlying PETSc type. It can be used to modify the underlying data, so use it only when you know what you are doing. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00596">596</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aacd76b6ce3247735964836a82eedff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd76b6ce3247735964836a82eedff6d">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make an in-place transpose of a matrix. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00602">602</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a4a1057a35382b7c328e6c85b0f5ab35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1057a35382b7c328e6c85b0f5ab35e">&#9670;&nbsp;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether a matrix is symmetric. Default tolerance is \(1000\times32\)-bit machine precision. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00614">614</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a9f2f6b575f15d540cf10688b30d09941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2f6b575f15d540cf10688b30d09941">&#9670;&nbsp;</a></span>is_hermitian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_hermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether a matrix is Hermitian, i.e. it is the complex conjugate of its transpose. Default tolerance is \(1000\times32\)-bit machine precision. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00624">624</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ad127fd1b40ab452473f96cc298694528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad127fd1b40ab452473f96cc298694528">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the PETSc matrix object values using PETSc internal matrix viewer function <code>MatView</code>. The default format prints the non- zero matrix elements. For other valid view formats, consult <a href="http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html">http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html</a> </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00636">636</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a7515e640202d1ad50bd9baa13c404cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7515e640202d1ad50bd9baa13c404cb1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the elements of a matrix to the given output stream.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>The output stream to which to write. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_output</td><td>This argument is ignored. It exists for compatibility with similar functions in other matrix classes. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00651">651</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0af7a8873fc01cd20682e079dbb8f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7a8873fc01cd20682e079dbb8f225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::MatrixBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number bytes consumed by this matrix on this CPU. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00682">682</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afa059253b9ee3357d06dbd37816a1d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa059253b9ee3357d06dbd37816a1d22">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcSourceEqualsDestination&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are attempting an operation on two matrices that &quot; &quot;are the same&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but the operation requires that the &quot; &quot;two objects are in fact different.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a4656c942eaca0ea491fba37a0a6225eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656c942eaca0ea491fba37a0a6225eb">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcWrongMode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You first have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception. </p>

</div>
</div>
<a id="a9795580277a7bc3a4348443768b6c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9795580277a7bc3a4348443768b6c0fd">&#9670;&nbsp;</a></span>prepare_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>new_action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure that the add/set mode that is required for actions following this call is compatible with the current mode. Should be called from all internal functions accessing matrix elements. </p>

</div>
</div>
<a id="aa0e10ef38e7bb5901bc5678a8a4ffd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e10ef38e7bb5901bc5678a8a4ffd6d">&#9670;&nbsp;</a></span>assert_is_compressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::assert_is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function that checks that there are no pending insert/add operations. Throws an exception otherwise. Useful before calling any PETSc internal functions modifying the matrix. </p>

</div>
</div>
<a id="aa6e49d52a74cc86386a9aff01fa88c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e49d52a74cc86386a9aff01fa88c74">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For some matrix storage formats, in particular for the PETSc distributed blockmatrices, set and add operations on individual elements can not be freely mixed. Rather, one has to synchronize operations when one wants to switch from setting elements to adding to elements. <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> automatically synchronizes the access by calling this helper function for each block. This function ensures that the matrix is in a state that allows adding elements; if it previously already was in this state, the function does nothing. </p>

</div>
</div>
<a id="a9d1b00916f856722282dcd9abb408581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1b00916f856722282dcd9abb408581">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same as <a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add()</a> but prepare the matrix for setting elements if the representation of elements in this class requires such an operation. </p>

</div>
</div>
<a id="a49501300c99d6fea596a39fbe38b8961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49501300c99d6fea596a39fbe38b8961">&#9670;&nbsp;</a></span>mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Base function to perform the matrix-matrix multiplication \(C = AB\), or, if a vector \(V\) whose size is compatible with B is given, \(C = A \text{diag}(V) B\), where \(\text{diag}(V)\) defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix \(A\) and \(B\) have compatible sizes. The size of \(C\) will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix \(C\) will be reset by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00558">558</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab97c266e288f1d409c1b09eae7114792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97c266e288f1d409c1b09eae7114792">&#9670;&nbsp;</a></span>Tmmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Base function to perform the matrix-matrix multiplication with the transpose of <code>this</code>, i.e., \(C = A^T B\), or, if an optional vector \(V\) whose size is compatible with \(B\) is given, \(C = A^T \text{diag}(V) B\), where \(\text{diag}(V)\) defines a diagonal matrix with the vector entries.</p>
<p>This function assumes that the calling matrix \(A\) and \(B\) have compatible sizes. The size of \(C\) will be set within this function.</p>
<p>The content as well as the sparsity pattern of the matrix \(C\) will be changed by this function, so make sure that the sparsity pattern is not used somewhere else in your program. This is an expensive operation, so think twice before you use this function. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00566">566</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb72d666c41a0ac3c16def795c0c99b">&#9670;&nbsp;</a></span>BlockMatrixBase< SparseMatrix ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00617">617</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a480a46d7e16cbc9ef06e5442cb1cec2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a480a46d7e16cbc9ef06e5442cb1cec2a">&#9670;&nbsp;</a></span>communicator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> PETScWrappers::MPI::SparseMatrix::communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy of the communicator object to be used for this parallel vector. </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00594">594</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abfce46e53089351cc7fe6b9ea44e167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfce46e53089351cc7fe6b9ea44e167f">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat PETScWrappers::MatrixBase::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A generic matrix object in PETSc. The actual type, a sparse matrix, is set in the constructor. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00956">956</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a1deda2ab63ef62230745b4ff99bd26d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deda2ab63ef62230745b4ff99bd26d6">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::MatrixBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether the last action was a write or add operation. </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00961">961</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a></li>
<li>source/lac/<a class="el" href="petsc__parallel__sparse__matrix_8cc_source.html">petsc_parallel_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
