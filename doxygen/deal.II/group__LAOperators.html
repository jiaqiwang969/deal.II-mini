<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__LAOperators.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Linear Operators</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Linear Operators<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Linear Operators:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__LAOperators.svg" width="330" height="38"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator&lt; Range, Domain, BlockPayload &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1BlockLinearOperatorImplementation_1_1EmptyBlockPayload.html">internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt; PayloadBlockType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html">LinearOperator&lt; Range, Domain, Payload &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1EmptyPayload.html">internal::LinearOperatorImplementation::EmptyPayload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackagedOperation.html">PackagedOperation&lt; Range &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Creation of a BlockLinearOperator</h2></td></tr>
<tr class="memitem:gae26d59caa3e6e227f35c61f470cbde98"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gae26d59caa3e6e227f35c61f470cbde98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae26d59caa3e6e227f35c61f470cbde98">block_operator</a> (const BlockMatrixType &amp;matrix)</td></tr>
<tr class="separator:gae26d59caa3e6e227f35c61f470cbde98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b64c23c5ff0b8aa7d84bf41b102e92"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga07b64c23c5ff0b8aa7d84bf41b102e92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga07b64c23c5ff0b8aa7d84bf41b102e92">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;)</td></tr>
<tr class="separator:ga07b64c23c5ff0b8aa7d84bf41b102e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d663a86353a5666fec7dd9746084ccd"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga1d663a86353a5666fec7dd9746084ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1d663a86353a5666fec7dd9746084ccd">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;)</td></tr>
<tr class="separator:ga1d663a86353a5666fec7dd9746084ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">block_diagonal_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename BlockPayload , typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gad48a267ed219e65f5316204a8e9c87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3b78c08372b54dc7bc9a2cf6b497baba">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga4f98cbf0ce0df665a068394a306fd0b7">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">block_diagonal_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Manipulation of a BlockLinearOperator</h2></td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2e93f2424bc70a566a1a46ee8c0b1c31">block_forward_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga8b2bf4fd828e4ee7539bcc16c8b19777">block_back_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2e93f2424bc70a566a1a46ee8c0b1c31">block_forward_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga8b2bf4fd828e4ee7539bcc16c8b19777">block_back_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Vector space operations</h2></td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Composition and manipulation of a LinearOperator</h2></td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Creation of a LinearOperator</h2></td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50e510550627aa8892168f313d18d86"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad50e510550627aa8892168f313d18d86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad50e510550627aa8892168f313d18d86">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;)</td></tr>
<tr class="separator:gad50e510550627aa8892168f313d18d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592c1896d2eab9faca22a852384f0079"><td class="memTemplParams" colspan="2">template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga592c1896d2eab9faca22a852384f0079"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga592c1896d2eab9faca22a852384f0079">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;)</td></tr>
<tr class="separator:ga592c1896d2eab9faca22a852384f0079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7fafc02e3d9690336d00b033e2d4351"><td class="memTemplParams" colspan="2">template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename Matrix &gt; </td></tr>
<tr class="memitem:gaf7fafc02e3d9690336d00b033e2d4351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaf7fafc02e3d9690336d00b033e2d4351">linear_operator</a> (const Matrix &amp;)</td></tr>
<tr class="separator:gaf7fafc02e3d9690336d00b033e2d4351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a70111839180da28ccfebb4c588eca"><td class="memTemplParams" colspan="2">template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename OperatorExemplar , typename Matrix &gt; </td></tr>
<tr class="memitem:ga52a70111839180da28ccfebb4c588eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a> (const OperatorExemplar &amp;, const Matrix &amp;)</td></tr>
<tr class="separator:ga52a70111839180da28ccfebb4c588eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga373310de5b48d5a70b9cdd47834da48f">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga373310de5b48d5a70b9cdd47834da48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2043a16b6855670766f46780a39f03f3">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga2043a16b6855670766f46780a39f03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a> (const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename OperatorExemplar , typename Matrix &gt; </td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga14dbc8c2c27ea3fd45576528a891c6e2">linear_operator</a> (const OperatorExemplar &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Vector space operations</h2></td></tr>
<tr class="memitem:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gafa632ef2b50c80c96ed831ac7cfcb018">operator+</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;first_comp, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;second_comp)</td></tr>
<tr class="separator:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5209738cb7a57b293ee76a5f822429"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaab5209738cb7a57b293ee76a5f822429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaab5209738cb7a57b293ee76a5f822429">operator-</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;first_comp, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;second_comp)</td></tr>
<tr class="separator:gaab5209738cb7a57b293ee76a5f822429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64fff253a63070b2662a17edcfe4a44"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gae64fff253a63070b2662a17edcfe4a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae64fff253a63070b2662a17edcfe4a44">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, typename Range::value_type number)</td></tr>
<tr class="separator:gae64fff253a63070b2662a17edcfe4a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaefd932f9b2760c5d21a8d6af4af2c22d">operator*</a> (typename Range::value_type number, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab4c6466be816b7aa10ef2ed2e9cab80c">operator+</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const Range &amp;offset)</td></tr>
<tr class="separator:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga81c3ca2764ebc61b5820cdc51602b9d1">operator+</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga052b4292d8beeea5fe2eeafd8f925884">operator-</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const Range &amp;offset)</td></tr>
<tr class="separator:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa5b434083f131cddd947fc2ac8a16774">operator-</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaa5b434083f131cddd947fc2ac8a16774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gafa632ef2b50c80c96ed831ac7cfcb018">operator+</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;first_comp, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;second_comp)</td></tr>
<tr class="separator:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5209738cb7a57b293ee76a5f822429"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaab5209738cb7a57b293ee76a5f822429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaab5209738cb7a57b293ee76a5f822429">operator-</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;first_comp, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;second_comp)</td></tr>
<tr class="separator:gaab5209738cb7a57b293ee76a5f822429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64fff253a63070b2662a17edcfe4a44"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gae64fff253a63070b2662a17edcfe4a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae64fff253a63070b2662a17edcfe4a44">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, typename Range::value_type number)</td></tr>
<tr class="separator:gae64fff253a63070b2662a17edcfe4a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaefd932f9b2760c5d21a8d6af4af2c22d">operator*</a> (typename Range::value_type number, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab4c6466be816b7aa10ef2ed2e9cab80c">operator+</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const Range &amp;offset)</td></tr>
<tr class="separator:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga81c3ca2764ebc61b5820cdc51602b9d1">operator+</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga052b4292d8beeea5fe2eeafd8f925884">operator-</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const Range &amp;offset)</td></tr>
<tr class="separator:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa5b434083f131cddd947fc2ac8a16774">operator-</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaa5b434083f131cddd947fc2ac8a16774"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Creation of a PackagedOperation object</h2></td></tr>
<tr class="memitem:gae329832e88340f453852ca1c19464c27"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:gae329832e88340f453852ca1c19464c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae329832e88340f453852ca1c19464c27">operator+</a> (const Range &amp;u, const Range &amp;v)</td></tr>
<tr class="separator:gae329832e88340f453852ca1c19464c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f822e8264ec476eb33d256a02789ce"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga31f822e8264ec476eb33d256a02789ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga31f822e8264ec476eb33d256a02789ce">operator-</a> (const Range &amp;u, const Range &amp;v)</td></tr>
<tr class="separator:ga31f822e8264ec476eb33d256a02789ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaf4e1b30b9e1cea48976ca1ae4c81a92e">operator*</a> (const Range &amp;u, typename Range::value_type number)</td></tr>
<tr class="separator:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1a013ccd3864453868b21771d08cdc"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga9e1a013ccd3864453868b21771d08cdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga9e1a013ccd3864453868b21771d08cdc">operator*</a> (typename Range::value_type number, const Range &amp;u)</td></tr>
<tr class="separator:ga9e1a013ccd3864453868b21771d08cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga643bfc3ac1e993293b9bb1ddb2b83618">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const Domain &amp;u)</td></tr>
<tr class="separator:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6a7163ca5e3375fae50b17a0e4a35253">operator*</a> (const Range &amp;u, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga0082d09d3a4bac88dbacea1ffbbf78e5">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;comp)</td></tr>
<tr class="separator:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1ddbda7644b9b62e30e4b45d8ed0ec09">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae329832e88340f453852ca1c19464c27"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:gae329832e88340f453852ca1c19464c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae329832e88340f453852ca1c19464c27">operator+</a> (const Range &amp;u, const Range &amp;v)</td></tr>
<tr class="separator:gae329832e88340f453852ca1c19464c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f822e8264ec476eb33d256a02789ce"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga31f822e8264ec476eb33d256a02789ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga31f822e8264ec476eb33d256a02789ce">operator-</a> (const Range &amp;u, const Range &amp;v)</td></tr>
<tr class="separator:ga31f822e8264ec476eb33d256a02789ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaf4e1b30b9e1cea48976ca1ae4c81a92e">operator*</a> (const Range &amp;u, typename Range::value_type number)</td></tr>
<tr class="separator:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1a013ccd3864453868b21771d08cdc"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga9e1a013ccd3864453868b21771d08cdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga9e1a013ccd3864453868b21771d08cdc">operator*</a> (typename Range::value_type number, const Range &amp;u)</td></tr>
<tr class="separator:ga9e1a013ccd3864453868b21771d08cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga643bfc3ac1e993293b9bb1ddb2b83618">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const Domain &amp;u)</td></tr>
<tr class="separator:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6a7163ca5e3375fae50b17a0e4a35253">operator*</a> (const Range &amp;u, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga0082d09d3a4bac88dbacea1ffbbf78e5">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;comp)</td></tr>
<tr class="separator:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1ddbda7644b9b62e30e4b45d8ed0ec09">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Creation of a LinearOperator related to the Schur Complement</h2></td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Creation of PackagedOperation objects related to the Schur Complement</h2></td></tr>
<tr class="memitem:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const Range_1 &amp;f, const Range_2 &amp;g)</td></tr>
<tr class="separator:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const Domain_2 &amp;y, const Range_1 &amp;f)</td></tr>
<tr class="separator:gab965c40b54990bbcbc129a1cd218ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const Range_1 &amp;f, const Range_2 &amp;g)</td></tr>
<tr class="separator:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const Domain_2 &amp;y, const Range_1 &amp;f)</td></tr>
<tr class="separator:gab965c40b54990bbcbc129a1cd218ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h3>Linear Operator</h3>
<p>deal.II includes support for describing linear transformations in a very general way. This is done with a <a class="el" href="classLinearOperator.html">LinearOperator</a> class that, like <a class="el" href="group__Concepts.html#ConceptMatrixType">the MatrixType concept</a>, defines a minimal interface for <em>applying</em> a linear operation on a vector.</p>
<div class="fragment"><div class="line">std::function&lt;void(Range &amp;, const Domain &amp;)&gt; vmult;</div><div class="line">std::function&lt;void(Range &amp;, const Domain &amp;)&gt; vmult_add;</div><div class="line">std::function&lt;void(Domain &amp;, const Range &amp;)&gt; Tvmult;</div><div class="line">std::function&lt;void(Domain &amp;, const Range &amp;)&gt; Tvmult_add;</div></div><!-- fragment --><p>Thus, such an object can be used as a matrix object in all <a class="el" href="group__Solvers.html">iterative solver</a> classes, either as a matrix object, or as <a class="el" href="group__Preconditioners.html">preconditioner</a>.</p>
<p>The big advantage of the <a class="el" href="classLinearOperator.html">LinearOperator</a> class is that it provides syntactic sugar for complex matrix-vector operations. As an example consider the operation \((A+k\,B)\,C\), where \(A\), \(B\) and \(C\) denote (possibly different) <a class="el" href="classSparseMatrix.html">SparseMatrix</a> objects. In order to construct a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> that performs above computation when applied on a vector, one can write: </p><div class="fragment"><div class="line"><a class="code" href="classSparseMatrix.html">::SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, B, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>;</div><div class="line"><span class="keywordtype">double</span> k;</div><div class="line"><span class="comment">// Setup and assembly...</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_b = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(B);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_c = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(C);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op = (op_a + k * op_b) * op_c;</div></div><!-- fragment --><p> Now, <code>op</code> can be used as a matrix object for further computation.</p>
<p>The <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator()</a> function can be used to wrap an ordinary matrix or preconditioner object into a <a class="el" href="classLinearOperator.html">LinearOperator</a>. A linear operator can be transposed with <a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator()</a>, or inverted by using the <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a> together with an iterative solver.</p>
<p>For objects of type <a class="el" href="classLinearOperator.html">LinearOperator</a>, all vector space operations, i.e., addition and subtraction, scalar multiplication and composition (of compatible linear operators) are implemented: </p><div class="fragment"><div class="line"><a class="code" href="classLinearOperator.html">::LinearOperator&lt;&gt;</a> op_a, op_b;</div><div class="line"><span class="keywordtype">double</span> k;</div><div class="line"></div><div class="line"><span class="comment">// vector space addition, subtraction and scalar multiplication</span></div><div class="line">op_a + op_b;</div><div class="line">op_a - op_b;</div><div class="line">k * op_a;</div><div class="line">op_a * k;</div><div class="line"></div><div class="line"><span class="comment">// in-place variants</span></div><div class="line">op_a += op_b;</div><div class="line">op_a -= op_b;</div><div class="line">op_a *= k;</div><div class="line"></div><div class="line"><span class="comment">// operator composition</span></div><div class="line">op_a * op_b;</div><div class="line">op_a *= op_b; <span class="comment">// If op_b is an endomorphism of the domain space of op_a</span></div></div><!-- fragment --><p><a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator()</a> and <a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator()</a> provide further encapsulation of individual linear operators into blocked linear operator variants.</p>
<p>The step-20 tutorial program has a detailed usage example of the <a class="el" href="classLinearOperator.html">LinearOperator</a> class.</p>
<dl class="section note"><dt>Note</dt><dd>As explained below, when using <a class="el" href="classLinearOperator.html">LinearOperator</a> as <code>res = op_a*x</code> a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> class instance is generated behind-the-curtains. Consequently, the user program has to include header files for both classes for compilation to be successful. In an attempt to make easier the decision of which headers to include in what circumstances and to prevent hidden templates-related compiler errors, all headers relevant to <a class="el" href="classLinearOperator.html">LinearOperator</a> are grouped in the <code>&lt;deal.II/lac/linear_operator_tools.h&gt;</code> header file.</dd></dl>
<h3>Packaged Operation</h3>
<p>An application of a <a class="el" href="classLinearOperator.html">LinearOperator</a> object to a vector via <code>operator*</code> yields a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores this computation.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> class allows lazy evaluation of expressions involving vectors and linear operators. This is done by storing the computational expression and only performing the computation when either the object is implicitly converted to a vector object, or <a class="el" href="classPackagedOperation.html#a5738d078d44dcc7cf3efb5e09e1af51a">PackagedOperation::apply()</a> (or <a class="el" href="classPackagedOperation.html#a9ce32616ad171364d0567c38444d52ee">PackagedOperation::apply_add()</a>) is invoked by hand. This avoids unnecessary temporary storage of intermediate results.</p>
<p>As an example consider the addition of multiple vectors: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> a, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>, c, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div><div class="line"><span class="comment">// ..</span></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> result = a + b - c + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div></div><!-- fragment --><p> Converting the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> <code>a + b - c + d</code> to a vector results in code equivalent to the following code </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> a, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>, c, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div><div class="line"><span class="comment">// ..</span></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> result = a;</div><div class="line">result += <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>;</div><div class="line">result -= c;</div><div class="line">result += <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div></div><!-- fragment --><p> that avoids any intermediate storage. As a second example (involving a <a class="el" href="classLinearOperator.html">LinearOperator</a> object) consider the computation of a residual \(b-Ax\):</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseMatrix.html">::SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>;</div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>, x;</div><div class="line"><span class="comment">// ..</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(A);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> residual =  b - op_a * x;</div></div><!-- fragment --><p> Here, the expression <code>b - op_a * x</code> results again in an object of type <a class="el" href="classPackagedOperation.html">PackagedOperation</a> that stores the <em>sequence of operations</em> that should be performed using the two vectors and the linear operator. Converting the expression to a vector (as happens here with the assignment to the vector <code>residual</code>) executes the computation (see the following note).</p>
<dl class="section note"><dt>Note</dt><dd>Lazy evaluation of a computational expression necessarily involves references to the underlying vector and matrix objects. For example, the creation of a <code>residual_expr</code> object <div class="fragment"><div class="line"><span class="keyword">auto</span> residual_expr =  b - op_a * x;</div></div><!-- fragment --> stores the computational expression of the residual with references to the vector <code>b</code> and matrix <code>A</code>. It does not perform any computation at this point. In particular, if <code>b</code> or <code>A</code> are changed <b>after</b> the creation of <code>residual_expr</code> every subsequent evaluation of the expression is performed with the new values <div class="fragment"><div class="line"><span class="keyword">auto</span> residual_expr =  b - op_a * x;</div><div class="line">residual_expr.apply(tmp);  <span class="comment">// tmp is a Vector&lt;double&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// modify b, or A</span></div><div class="line"></div><div class="line">residual_expr.apply(tmp2); <span class="comment">// tmp2 is a Vector&lt;double&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// tmp and tmp2 are different</span></div></div><!-- fragment --> Thus, as a safeguard, if you want to compute the result of an expression right away, always explicitly use a vector type on the left side (and not <code>auto</code>): <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> residual =  b - op_a * x; <span class="comment">// computes the residual at this point</span></div></div><!-- fragment --></dd></dl>
<p>The step-20 tutorial program has a detailed usage example of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> class. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae26d59caa3e6e227f35c61f470cbde98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26d59caa3e6e227f35c61f470cbde98">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function that encapsulates a <code>block_matrix</code> into a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>.</p>
<p>All changes made on the block structure and individual blocks of <code>block_matrix</code> after the creation of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00585">585</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga07b64c23c5ff0b8aa7d84bf41b102e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b64c23c5ff0b8aa7d84bf41b102e92">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variant of above function that encapsulates a given collection <code>ops</code> of LinearOperators into a block structure. Here, it is assumed that Range and Domain are block vectors, i.e., derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>. The individual linear operators in <code>ops</code> must act on the underlying vector type of the block vectors, i.e., on Domain::BlockType yielding a result in Range::BlockType.</p>
<p>The list <code>ops</code> is best passed as an initializer list. Consider for example a linear operator block (acting on <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>) </p><div class="fragment"><div class="line">op_a00 | op_a01</div><div class="line">       |</div><div class="line">---------------</div><div class="line">       |</div><div class="line">op_a10 | op_a11</div></div><!-- fragment --><p> The corresponding block_operator invocation takes the form </p><div class="fragment"><div class="line">block_operator&lt;2, 2, BlockVector&lt;double&gt;&gt;({op_a00, op_a01, op_a10, op_a11});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00652">652</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaa37c982a2dd7106e7efc1b380b501bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37c982a2dd7106e7efc1b380b501bd5">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function extracts the diagonal blocks of <code>block_matrix</code> (either a block matrix type or a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>) and creates a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> with the diagonal. Off-diagonal elements are initialized as null_operator (with correct reinit_range_vector and reinit_domain_vector methods).</p>
<p>All changes made on the individual diagonal blocks of <code>block_matrix</code> after the creation of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00706">706</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1d663a86353a5666fec7dd9746084ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d663a86353a5666fec7dd9746084ccd">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variant of above function that builds up a block diagonal linear operator from an array <code>ops</code> of diagonal elements (off-diagonal blocks are assumed to be 0).</p>
<p>The list <code>ops</code> is best passed as an initializer list. Consider for example a linear operator block (acting on <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>) <code>diag(op_a0, op_a1, ..., op_am)</code>. The corresponding block_operator invocation takes the form </p><div class="fragment"><div class="line">block_diagonal_operator&lt;m, BlockVector&lt;double&gt;&gt;({op_00, op_a1, ..., op_am});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00762">762</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaaaedcd8e4d6ed8ff7c6340f05deda5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A variant of above function that only takes a single <a class="el" href="classLinearOperator.html">LinearOperator</a> argument <code>op</code> and creates a blockdiagonal linear operator with <code>m</code> copies of it. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00811">811</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2e93f2424bc70a566a1a46ee8c0b1c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e93f2424bc70a566a1a46ee8c0b1c31">&#9670;&nbsp;</a></span>block_forward_substitution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements forward substitution to invert a lower block triangular matrix. As arguments, it takes a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>block_operator</code> representing a block lower triangular matrix, as well as a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>diagonal_inverse</code> representing inverses of diagonal blocks of <code>block_operator</code>.</p>
<p>Let us assume we have a linear system with the following block structure:</p>
<div class="fragment"><div class="line">A00 x0 + ...                   = y0</div><div class="line">A01 x0 + A11 x1 + ...          = y1</div><div class="line">...        ...</div><div class="line">A0n x0 + A1n x1 + ... + Ann xn = yn</div></div><!-- fragment --><p>First of all, <code>x0 = A00^-1 y0</code>. Then, we can use x0 to recover x1: </p><div class="fragment"><div class="line">x1 = A11^-1 ( y1 - A01 x0 )</div></div><!-- fragment --><p> and therefore: </p><div class="fragment"><div class="line">xn = Ann^-1 ( yn - A0n x0 - ... - <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We are not using all blocks of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> arguments: Just the lower triangular block matrix of <code>block_operator</code> is used as well as the diagonal of <code>diagonal_inverse</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00876">876</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga8b2bf4fd828e4ee7539bcc16c8b19777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2bf4fd828e4ee7539bcc16c8b19777">&#9670;&nbsp;</a></span>block_back_substitution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_back_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function implements back substitution to invert an upper block triangular matrix. As arguments, it takes a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>block_operator</code> representing an upper block triangular matrix, as well as a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>diagonal_inverse</code> representing inverses of diagonal blocks of <code>block_operator</code>.</p>
<p>Let us assume we have a linear system with the following block structure:</p>
<div class="fragment"><div class="line">A00 x0 + A01 x1 + ... + A0n xn = yn</div><div class="line">         A11 x1 + ...          = y1</div><div class="line">                         ...     ..</div><div class="line">                        Ann xn = yn</div></div><!-- fragment --><p>First of all, <code>xn = Ann^-1 yn</code>. Then, we can use xn to recover x(n-1): </p><div class="fragment"><div class="line">x(n-1) = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)(n-1)^-1 ( y(n-1) - <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><p> and therefore: </p><div class="fragment"><div class="line">x0 = A00^-1 ( y0 - A0n xn - ... - A01 x1 )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We are not using all blocks of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> arguments: Just the upper triangular block matrix of <code>block_operator</code> is used as well as the diagonal of <code>diagonal_inverse</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00994">994</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gad5b7eee8927ffd58475199d70e445b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7eee8927ffd58475199d70e445b16">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}+\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) + \mathrm{second\_op}(x)\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00390">390</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga19125a34d76f661b3da533c97afda332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19125a34d76f661b3da533c97afda332">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}-\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) - \mathrm{second\_op}(x)\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00449">449</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87b07e6da906c2a1a5ec6a45be2d5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b07e6da906c2a1a5ec6a45be2d5d7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar multiplication of a ScalarOperator object <code>op</code> with <code>number</code> from the left.</p>
<p>The <code>Domain</code> and <code>Range</code> types must implement the following <code>operator*=</code> member functions accepting the appropriate scalar Number type for rescaling:</p>
<div class="fragment"><div class="line">Domain &amp; operator *=(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Domain::value_type</a>);</div><div class="line">Range &amp; operator *=(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Range::value_type</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00487">487</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga88637d015b1e6962c60305e7e739ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88637d015b1e6962c60305e7e739ffa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar multiplication of a ScalarOperator object from the right.</p>
<p>The <code>Domain</code> and <code>Range</code> types must implement the following <code>operator*=</code> member functions for rescaling:</p>
<div class="fragment"><div class="line">Domain &amp; operator *=(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Domain::value_type</a>);</div><div class="line">Range &amp; operator *=(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Range::value_type</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00554">554</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga148e5775d722a0e051f1b4a815650431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e5775d722a0e051f1b4a815650431">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Composition of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}*\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(\mathrm{second\_op}(x))\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00587">587</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6bdc65fb2db56230e6bc7d545e81295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdc65fb2db56230e6bc7d545e81295d">&#9670;&nbsp;</a></span>transpose_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; transpose_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the transpose linear operations of <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00660">660</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87e38fbde431397c069a88692bd24ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e38fbde431397c069a88692bd24ae7">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an object representing the inverse of the <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code>.</p>
<p>The function takes references <code>solver</code> and <code>preconditioner</code> to an iterative solver and a preconditioner that are used in the <code>vmult</code> and <code>Tvmult</code> implementations of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object.</p>
<p>The <a class="el" href="classLinearOperator.html">LinearOperator</a> object that is created stores a reference to <code>solver</code> and <code>preconditioner</code>. Thus, both objects must remain a valid reference for the whole lifetime of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. Internal data structures of the <code>solver</code> object will be modified upon invocation of <code>vmult</code> or <code>Tvmult</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00701">701</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga484b23159d208db5fc2706b470bf3863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484b23159d208db5fc2706b470bf3863">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of above function that takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>preconditioner</code> as preconditioner argument. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00758">758</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga058953c3b4cfae4a9cd6fa75509960a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058953c3b4cfae4a9cd6fa75509960a2">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of above function without a preconditioner argument. In this case the <a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator()</a> of the <code>op</code> argument is used as a preconditioner. This is equivalent to using <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00816">816</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3deff1665b4dad59643251895e7f5239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deff1665b4dad59643251895e7f5239">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Special overload of above function that takes a <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> argument. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00836">836</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1a0a3fb15266869710e63e78658cfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0a3fb15266869710e63e78658cfaed">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the identity of the vector space <code>Range</code>.</p>
<p>The function takes an <code>std::function</code> object <code>reinit_vector</code> as an argument to initialize the <code>reinit_range_vector</code> and <code>reinit_domain_vector</code> objects of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00866">866</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gad50e510550627aa8892168f313d18d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad50e510550627aa8892168f313d18d86">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the identity of the vector space <code>Range</code>.</p>
<p>The function takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> and uses its range initializer to create an identity operator. In contrast to the function above, this function also ensures that the underlying Payload matches that of the input <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00899">899</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga592c1896d2eab9faca22a852384f0079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592c1896d2eab9faca22a852384f0079">&#9670;&nbsp;</a></span>null_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; null_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a nulled variant of the <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code>, i.e. with optimized <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">LinearOperator::vmult</a>, <a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">LinearOperator::vmult_add</a>, etc. functions and with <a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">LinearOperator::is_null_operator</a> set to true. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00919">919</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gacad49906c99b700ca6cafdef67977d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad49906c99b700ca6cafdef67977d0c">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that acts as a mean value filter. The vmult() functions of this matrix subtract the mean values of the vector.</p>
<p>The function takes an <code>std::function</code> object <code>reinit_vector</code> as an argument to initialize the <code>reinit_range_vector</code> and <code>reinit_domain_vector</code> objects of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00956">956</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6cedb0a75c51801a6052bf7343b90685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cedb0a75c51801a6052bf7343b90685">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that acts as a mean value filter. The vmult() functions of this matrix subtract the mean values of the vector.</p>
<p>The function takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> and uses its range initializer to create an mean value filter operator. The function also ensures that the underlying Payload matches that of the input <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00998">998</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaf7fafc02e3d9690336d00b033e2d4351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7fafc02e3d9690336d00b033e2d4351">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A function that encapsulates generic <code>matrix</code> objects that act on a compatible <a class="el" href="classVector.html">Vector</a> type into a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The <a class="el" href="classLinearOperator.html">LinearOperator</a> object that is created stores a reference to the matrix object. Thus, <code>matrix</code> must remain a valid reference for the whole lifetime of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object.</p>
<p>All changes made on <code>matrix</code> after the creation of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object are reflected by the operator object. For example, it is a valid procedure to first create a <a class="el" href="classLinearOperator.html">LinearOperator</a> and resize, reassemble the matrix later.</p>
<p>The Matrix class in question must provide the following minimal interface:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// (type specific) information how to create a Range and Domain vector</span></div><div class="line">  <span class="comment">// with appropriate size and internal layout</span></div><div class="line"></div><div class="line">  <span class="comment">// Application of matrix to vector src, writes the result into dst.</span></div><div class="line">  vmult(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line">  <span class="comment">// Application of the transpose of matrix to vector src, writes the</span></div><div class="line">  <span class="comment">// result into dst. (Depending on the usage of the linear operator</span></div><div class="line">  <span class="comment">// class this can be a dummy implementation throwing an error.)</span></div><div class="line">  Tvmult(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>The following (optional) interface is used if available:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Application of matrix to vector src, adds the result to dst.</span></div><div class="line">  vmult_add(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line">  <span class="comment">// Application of the transpose of matrix to vector src, adds the</span></div><div class="line">  <span class="comment">// result to dst.</span></div><div class="line">  Tvmult_add(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>If the Matrix does not provide <code>vmult_add</code> and <code>Tvmult_add</code>, they are implemented in terms of <code>vmult</code> and <code>Tvmult</code> (requiring intermediate storage). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01379">1379</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga52a70111839180da28ccfebb4c588eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a70111839180da28ccfebb4c588eca">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename OperatorExemplar , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const OperatorExemplar &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of above function that takes an operator object <code>operator_exemplar</code> as an additional reference. This object is used to populate the reinit_domain_vector and reinit_range_vector function objects. The reference <code>matrix</code> is used to construct vmult, Tvmult, etc.</p>
<p>This variant can, for example, be used to encapsulate preconditioners (that typically do not expose any information about the underlying matrix). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01407">1407</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaac20bebeb1b53fd00f838b63baac0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac20bebeb1b53fd00f838b63baac0456">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variant of above function that takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>operator_exemplar</code> as an additional reference. The reinit_domain_vector and reinit_range_vector function are copied from the <code>operator_exemplar</code> object.</p>
<p>The reference <code>matrix</code> is used to construct vmult, Tvmult, etc.</p>
<p>This variant can, for example, be used to encapsulate preconditioners (that typically do not expose any information about the underlying matrix). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01461">1461</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gafa632ef2b50c80c96ed831ac7cfcb018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa632ef2b50c80c96ed831ac7cfcb018">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of two <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>first_comp</code> and <code>second_comp</code> given by vector space addition of the corresponding results. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00295">295</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaab5209738cb7a57b293ee76a5f822429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5209738cb7a57b293ee76a5f822429">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction of two <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>first_comp</code> and <code>second_comp</code> given by vector space addition of the corresponding results. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00328">328</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gae64fff253a63070b2662a17edcfe4a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64fff253a63070b2662a17edcfe4a44">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar multiplication of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>comp</code> with a scalar <code>number</code> given by a scaling <a class="el" href="classPackagedOperation.html">PackagedOperation</a> result with <code>number</code>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00363">363</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaefd932f9b2760c5d21a8d6af4af2c22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd932f9b2760c5d21a8d6af4af2c22d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar multiplication of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>comp</code> with a scalar <code>number</code> given by a scaling <a class="el" href="classPackagedOperation.html">PackagedOperation</a> result with <code>number</code>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00403">403</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gab4c6466be816b7aa10ef2ed2e9cab80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c6466be816b7aa10ef2ed2e9cab80c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a constant <code>offset</code> (of the <code>Range</code> space) to the result of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00419">419</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga81c3ca2764ebc61b5820cdc51602b9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c3ca2764ebc61b5820cdc51602b9d1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a constant <code>offset</code> (of the <code>Range</code> space) to the result of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00434">434</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga052b4292d8beeea5fe2eeafd8f925884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052b4292d8beeea5fe2eeafd8f925884">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract a constant <code>offset</code> (of the <code>Range</code> space) from the result of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00449">449</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaa5b434083f131cddd947fc2ac8a16774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b434083f131cddd947fc2ac8a16774">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract a computational result from a constant <code>offset</code> (of the <code>Range</code> space). The result is a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that applies this computation. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00466">466</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gae329832e88340f453852ca1c19464c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae329832e88340f453852ca1c19464c27">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the addition of two vectors.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code> and <code>v</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00529">529</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga31f822e8264ec476eb33d256a02789ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31f822e8264ec476eb33d256a02789ce">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the subtraction of two vectors.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code> and <code>v</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00574">574</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaf4e1b30b9e1cea48976ca1ae4c81a92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e1b30b9e1cea48976ca1ae4c81a92e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the scaling of a vector with a <code>number</code>.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00617">617</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga9e1a013ccd3864453868b21771d08cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e1a013ccd3864453868b21771d08cdc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the scaling of a vector with a <code>number</code>.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00642">642</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga643bfc3ac1e993293b9bb1ddb2b83618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga643bfc3ac1e993293b9bb1ddb2b83618">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object from a <a class="el" href="classLinearOperator.html">LinearOperator</a> and a reference to a vector <code>u</code> of the Domain space. The object stores the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> \(\text{op} \,u\) (in matrix notation). <code>return</code> (<code>return_add</code>) are implemented with <code>vmult(__1,u)</code> (<code>vmult_add(__1,u)</code>).</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vector must remain a valid reference for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00667">667</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga6a7163ca5e3375fae50b17a0e4a35253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7163ca5e3375fae50b17a0e4a35253">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object from a <a class="el" href="classLinearOperator.html">LinearOperator</a> and a reference to a vector <code>u</code> of the Range space. The object stores the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> \(\text{op}^T \,u\) (in matrix notation). <code>return</code> (<code>return_add</code>) are implemented with <code>Tvmult(__1,u)</code> (<code>Tvmult_add(__1,u)</code>).</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vector must remain a valid reference for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00702">702</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga0082d09d3a4bac88dbacea1ffbbf78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0082d09d3a4bac88dbacea1ffbbf78e5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Composition of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object with a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The object stores the computation \(\text{op} \,comp\) (in matrix notation). </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00729">729</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga1ddbda7644b9b62e30e4b45d8ed0ec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ddbda7644b9b62e30e4b45d8ed0ec09">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Composition of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object with a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The object stores the computation \(\text{op}^T \,comp\) (in matrix notation). </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00773">773</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga76acca911f21089cd3bb385d20ccc995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76acca911f21089cd3bb385d20ccc995">&#9670;&nbsp;</a></span>schur_complement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; schur_complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that performs the operations associated with the Schur complement. There are two additional helper functions, <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a> and <a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution()</a>, that are likely necessary to be used in order to perform any useful tasks in linear algebra with this operator.</p>
<p>We construct the definition of the Schur complement in the following way:</p>
<p>Consider a general system of linear equations that can be decomposed into two major sets of equations: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{K}\mathbf{d} = \mathbf{f} \quad \Rightarrow\quad \left(\begin{array}{cc} A &amp; B \\ C &amp; D \end{array}\right) \left(\begin{array}{cc} x \\ y \end{array}\right) = \left(\begin{array}{cc} f \\ g \end{array}\right), \end{eqnarray*}
</p>
<p> where \( A,B,C,D \) represent general subblocks of the matrix \( \mathbf{K} \) and, similarly, general subvectors of \( \mathbf{d},\mathbf{f} \) are given by \( x,y,f,g \) .</p>
<p>This is equivalent to the following two statements: </p><p class="formulaDsp">
\begin{eqnarray*} (1) \quad Ax + By &amp;=&amp; f \\ (2) \quad Cx + Dy &amp;=&amp; g \quad . \end{eqnarray*}
</p>
<p>Assuming that \( A,D \) are both square and invertible, we could then perform one of two possible substitutions, </p><p class="formulaDsp">
\begin{eqnarray*} (3) \quad x &amp;=&amp; A^{-1}(f - By) \quad \text{from} \quad (1) \\ (4) \quad y &amp;=&amp; D^{-1}(g - Cx) \quad \text{from} \quad (2) , \end{eqnarray*}
</p>
<p> which amount to performing block Gaussian elimination on this system of equations.</p>
<p>For the purpose of the current implementation, we choose to substitute (3) into (2) </p><p class="formulaDsp">
\begin{eqnarray*} C \: A^{-1}(f - By) + Dy &amp;=&amp; g \\ -C \: A^{-1} \: By + Dy &amp;=&amp; g - C \: A^{-1} \: f \quad . \end{eqnarray*}
</p>
<p> This leads to the result </p><p class="formulaDsp">
\[ (5) \quad (D - C\: A^{-1} \:B)y = g - C \: A^{-1} f \quad \Rightarrow \quad Sy = g&#39; \]
</p>
<p> with \( S = (D - C\: A^{-1} \:B) \) being the Schur complement and the modified right-hand side vector \( g&#39; = g - C \: A^{-1} f \) arising from the condensation step. Note that for this choice of \( S \), submatrix \( D \) need not be invertible and may thus be the null matrix. Ideally \( A \) should be well-conditioned.</p>
<p>So for any arbitrary vector \( a \), the Schur complement performs the following operation: </p><p class="formulaDsp">
\[ (6) \quad Sa = (D - C \: A^{-1} \: B)a \]
</p>
<p>A typical set of steps needed the solve a linear system (1),(2) would be:</p><ol type="1">
<li>Define the inverse matrix <code>A_inv</code> (using <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a>).</li>
<li>Define the Schur complement \( S \) (using <a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement()</a>).</li>
<li>Define iterative inverse matrix \( S^{-1} \) such that (6) holds. It is necessary to use a solver with a preconditioner to compute the approximate inverse operation of \( S \) since we never compute \( S \) directly, but rather the result of its operation. To achieve this, one may again use the <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a> in conjunction with the Schur complement that we've just constructed. Observe that the both \( S \) and its preconditioner operate over the same space as \( D \).</li>
<li>Perform pre-processing step on the RHS of (5) using <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a>: <p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
</li>
<li>Solve for \( y \) in (5): <p class="formulaDsp">
\[ y = S^{-1} g&#39; \]
</p>
</li>
<li>Perform the post-processing step from (3) using <a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution()</a>: <p class="formulaDsp">
\[ x = A^{-1} (f - By) \]
</p>
</li>
</ol>
<p>An illustration of typical usage of this operator for a fully coupled system is given below. </p><div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="schur__complement_8h.html">deal.II/lac/schur_complement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Given BlockMatrix K and BlockVectors d,F</span></div><div class="line"></div><div class="line"><span class="comment">// Decomposition of tangent matrix</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> B = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,1));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> C = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> D = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,1));</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of solution vector</span></div><div class="line"><span class="keyword">auto</span> x = d.block(0);</div><div class="line"><span class="keyword">auto</span> y = d.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of RHS vector</span></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(0);</div><div class="line"><span class="keyword">auto</span> g = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Construction of inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> prec_A = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,prec_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(S,...,prec_S);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="comment">// PackagedOperation that represents the condensed form of g</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv * rhs;</div><div class="line"></div><div class="line"><span class="comment">// Compute x using resolved solution y</span></div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p>In the above example, the preconditioner for \( S \) was defined as the preconditioner for \( D \), which is valid since they operate on the same space. However, if \( D \) and \( S \) are too dissimilar, then this may lead to a large number of solver iterations as \( \text{prec}(D) \) is not a good approximation for \( S^{-1} \).</p>
<p>A better preconditioner in such a case would be one that provides a more representative approximation for \( S^{-1} \). One approach is shown in step-22, where \( D \) is the null matrix and the preconditioner for \( S^{-1} \) is derived from the mass matrix over this space.</p>
<p>From another viewpoint, a similar result can be achieved by first constructing an object that represents an approximation for \( S \) wherein expensive operation, namely \( A^{-1} \), is approximated. Thereafter we construct the approximate inverse operator \( \tilde{S}^{-1} \) which is then used as the preconditioner for computing \( S^{-1} \). </p><div class="fragment"><div class="line"><span class="comment">// Construction of approximate inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv_approx = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(preconditioner_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv_approx,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S_approx operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"></div><div class="line"><span class="comment">// Inner solver: Typically limited to few iterations</span></div><div class="line"><span class="comment">//               using IterationNumberControl</span></div><div class="line"><span class="keyword">auto</span> S_inv_approx = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S_approx,...,S_approx_prec);</div><div class="line"></div><div class="line"><span class="comment">// Construction of exact inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// Outer solver</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S,...,S_inv_approx);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv * rhs;</div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p> Note that due to the construction of <code>S_inv_approx</code> and subsequently <code>S_inv</code>, there are a pair of nested iterative solvers which could collectively consume a lot of resources. Therefore care should be taken in the choices leading to the construction of the iterative inverse_operators. One might consider the use of a <a class="el" href="classIterationNumberControl.html">IterationNumberControl</a> (or a similar mechanism) to limit the number of inner solver iterations. This controls the accuracy of the approximate inverse operation \( \tilde{S}^{-1} \) which acts only as the preconditioner for \( S^{-1} \). Furthermore, the preconditioner to \( \tilde{S}^{-1} \), which in this example is \( \text{prec}(D) \), should ideally be computationally inexpensive.</p>
<p>However, if an iterative solver based on <a class="el" href="classIterationNumberControl.html">IterationNumberControl</a> is used as a preconditioner then the preconditioning operation is not a linear operation. Here a flexible solver like <a class="el" href="classSolverFGMRES.html">SolverFGMRES</a> (flexible GMRES) is best employed as an outer solver in order to deal with the variable behavior of the preconditioner. Otherwise the iterative solver can stagnate somewhere near the tolerance of the preconditioner or generally behave erratically. Alternatively, using a <a class="el" href="classReductionControl.html">ReductionControl</a> would ensure that the preconditioner always solves to the same tolerance, thereby rendering its behavior constant.</p>
<p>Further examples of this functionality can be found in the test-suite, such as <code>tests/lac/schur_complement_01.cc</code> . The solution of a multi- component problem (namely step-22) using the schur_complement can be found in <code>tests/lac/schur_complement_03.cc</code> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00248">248</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="ga2c071b6555ac9e2eb543b7da5100889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c071b6555ac9e2eb543b7da5100889b">&#9670;&nbsp;</a></span>condense_schur_rhs() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range_2 &gt; condense_schur_rhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_2 &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the system of equations </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p> this operation performs the pre-processing (condensation) step on the RHS subvector <code>g</code> so that the Schur complement can be used to solve this system of equations. More specifically, it produces an object that represents the condensed form of the subvector <code>g</code>, namely </p><p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00298">298</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="gab965c40b54990bbcbc129a1cd218ee21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab965c40b54990bbcbc129a1cd218ee21">&#9670;&nbsp;</a></span>postprocess_schur_solution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt; postprocess_schur_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain_2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the system of equations </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p> this operation performs the post-processing step of the Schur complement to solve for the second subvector <code>x</code> once subvector <code>y</code> is known, with the result that </p><p class="formulaDsp">
\[ x = A^{-1}(f - By) \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00336">336</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="gad48a267ed219e65f5316204a8e9c87a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad48a267ed219e65f5316204a8e9c87a0">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename BlockPayload , typename BlockMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that encapsulates a <code>block_matrix</code> into a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>.</p>
<p>All changes made on the block structure and individual blocks of <code>block_matrix</code> after the creation of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00585">585</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3b78c08372b54dc7bc9a2cf6b497baba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b78c08372b54dc7bc9a2cf6b497baba">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n, typename Range , typename Domain , typename BlockPayload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variant of above function that encapsulates a given collection <code>ops</code> of LinearOperators into a block structure. Here, it is assumed that Range and Domain are block vectors, i.e., derived from <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>. The individual linear operators in <code>ops</code> must act on the underlying vector type of the block vectors, i.e., on Domain::BlockType yielding a result in Range::BlockType.</p>
<p>The list <code>ops</code> is best passed as an initializer list. Consider for example a linear operator block (acting on <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>) </p><div class="fragment"><div class="line">op_a00 | op_a01</div><div class="line">       |</div><div class="line">---------------</div><div class="line">       |</div><div class="line">op_a10 | op_a11</div></div><!-- fragment --><p> The corresponding block_operator invocation takes the form </p><div class="fragment"><div class="line">block_operator&lt;2, 2, BlockVector&lt;double&gt;&gt;({op_a00, op_a01, op_a10, op_a11});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00652">652</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaa37c982a2dd7106e7efc1b380b501bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37c982a2dd7106e7efc1b380b501bd5">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function extracts the diagonal blocks of <code>block_matrix</code> (either a block matrix type or a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>) and creates a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> with the diagonal. Off-diagonal elements are initialized as null_operator (with correct reinit_range_vector and reinit_domain_vector methods).</p>
<p>All changes made on the individual diagonal blocks of <code>block_matrix</code> after the creation of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00706">706</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga4f98cbf0ce0df665a068394a306fd0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f98cbf0ce0df665a068394a306fd0b7">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variant of above function that builds up a block diagonal linear operator from an array <code>ops</code> of diagonal elements (off-diagonal blocks are assumed to be 0).</p>
<p>The list <code>ops</code> is best passed as an initializer list. Consider for example a linear operator block (acting on <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>) <code>diag(op_a0, op_a1, ..., op_am)</code>. The corresponding block_operator invocation takes the form </p><div class="fragment"><div class="line">block_diagonal_operator&lt;m, BlockVector&lt;double&gt;&gt;({op_00, op_a1, ..., op_am});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00762">762</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaaaedcd8e4d6ed8ff7c6340f05deda5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variant of above function that only takes a single <a class="el" href="classLinearOperator.html">LinearOperator</a> argument <code>op</code> and creates a blockdiagonal linear operator with <code>m</code> copies of it. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00811">811</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2e93f2424bc70a566a1a46ee8c0b1c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e93f2424bc70a566a1a46ee8c0b1c31">&#9670;&nbsp;</a></span>block_forward_substitution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements forward substitution to invert a lower block triangular matrix. As arguments, it takes a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>block_operator</code> representing a block lower triangular matrix, as well as a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>diagonal_inverse</code> representing inverses of diagonal blocks of <code>block_operator</code>.</p>
<p>Let us assume we have a linear system with the following block structure:</p>
<div class="fragment"><div class="line">A00 x0 + ...                   = y0</div><div class="line">A01 x0 + A11 x1 + ...          = y1</div><div class="line">...        ...</div><div class="line">A0n x0 + A1n x1 + ... + Ann xn = yn</div></div><!-- fragment --><p>First of all, <code>x0 = A00^-1 y0</code>. Then, we can use x0 to recover x1: </p><div class="fragment"><div class="line">x1 = A11^-1 ( y1 - A01 x0 )</div></div><!-- fragment --><p> and therefore: </p><div class="fragment"><div class="line">xn = Ann^-1 ( yn - A0n x0 - ... - <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We are not using all blocks of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> arguments: Just the lower triangular block matrix of <code>block_operator</code> is used as well as the diagonal of <code>diagonal_inverse</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00876">876</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga8b2bf4fd828e4ee7539bcc16c8b19777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2bf4fd828e4ee7539bcc16c8b19777">&#9670;&nbsp;</a></span>block_back_substitution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_back_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function implements back substitution to invert an upper block triangular matrix. As arguments, it takes a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>block_operator</code> representing an upper block triangular matrix, as well as a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> <code>diagonal_inverse</code> representing inverses of diagonal blocks of <code>block_operator</code>.</p>
<p>Let us assume we have a linear system with the following block structure:</p>
<div class="fragment"><div class="line">A00 x0 + A01 x1 + ... + A0n xn = yn</div><div class="line">         A11 x1 + ...          = y1</div><div class="line">                         ...     ..</div><div class="line">                        Ann xn = yn</div></div><!-- fragment --><p>First of all, <code>xn = Ann^-1 yn</code>. Then, we can use xn to recover x(n-1): </p><div class="fragment"><div class="line">x(n-1) = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)(n-1)^-1 ( y(n-1) - <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><p> and therefore: </p><div class="fragment"><div class="line">x0 = A00^-1 ( y0 - A0n xn - ... - A01 x1 )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>We are not using all blocks of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> arguments: Just the upper triangular block matrix of <code>block_operator</code> is used as well as the diagonal of <code>diagonal_inverse</code>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00994">994</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gad5b7eee8927ffd58475199d70e445b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7eee8927ffd58475199d70e445b16">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}+\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) + \mathrm{second\_op}(x)\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00390">390</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga19125a34d76f661b3da533c97afda332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19125a34d76f661b3da533c97afda332">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}-\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) - \mathrm{second\_op}(x)\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00449">449</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87b07e6da906c2a1a5ec6a45be2d5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b07e6da906c2a1a5ec6a45be2d5d7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a ScalarOperator object <code>op</code> with <code>number</code> from the left.</p>
<p>The <code>Domain</code> and <code>Range</code> types must implement the following <code>operator*=</code> member functions accepting the appropriate scalar Number type for rescaling:</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Domain::value_type</a>);</div><div class="line">Range &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Range::value_type</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00487">487</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga88637d015b1e6962c60305e7e739ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88637d015b1e6962c60305e7e739ffa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a ScalarOperator object from the right.</p>
<p>The <code>Domain</code> and <code>Range</code> types must implement the following <code>operator*=</code> member functions for rescaling:</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Domain::value_type</a>);</div><div class="line">Range &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Range::value_type</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00554">554</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga148e5775d722a0e051f1b4a815650431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e5775d722a0e051f1b4a815650431">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Composition of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}*\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(\mathrm{second\_op}(x))\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00587">587</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6bdc65fb2db56230e6bc7d545e81295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdc65fb2db56230e6bc7d545e81295d">&#9670;&nbsp;</a></span>transpose_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; transpose_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the transpose linear operations of <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00660">660</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87e38fbde431397c069a88692bd24ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e38fbde431397c069a88692bd24ae7">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object representing the inverse of the <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code>.</p>
<p>The function takes references <code>solver</code> and <code>preconditioner</code> to an iterative solver and a preconditioner that are used in the <code>vmult</code> and <code>Tvmult</code> implementations of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object.</p>
<p>The <a class="el" href="classLinearOperator.html">LinearOperator</a> object that is created stores a reference to <code>solver</code> and <code>preconditioner</code>. Thus, both objects must remain a valid reference for the whole lifetime of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. Internal data structures of the <code>solver</code> object will be modified upon invocation of <code>vmult</code> or <code>Tvmult</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00701">701</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga484b23159d208db5fc2706b470bf3863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484b23159d208db5fc2706b470bf3863">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function that takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>preconditioner</code> as preconditioner argument. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00758">758</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga058953c3b4cfae4a9cd6fa75509960a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058953c3b4cfae4a9cd6fa75509960a2">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function without a preconditioner argument. In this case the <a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator()</a> of the <code>op</code> argument is used as a preconditioner. This is equivalent to using <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00816">816</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3deff1665b4dad59643251895e7f5239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deff1665b4dad59643251895e7f5239">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special overload of above function that takes a <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> argument. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00836">836</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1a0a3fb15266869710e63e78658cfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0a3fb15266869710e63e78658cfaed">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the identity of the vector space <code>Range</code>.</p>
<p>The function takes an <code>std::function</code> object <code>reinit_vector</code> as an argument to initialize the <code>reinit_range_vector</code> and <code>reinit_domain_vector</code> objects of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00866">866</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga373310de5b48d5a70b9cdd47834da48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373310de5b48d5a70b9cdd47834da48f">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the identity of the vector space <code>Range</code>.</p>
<p>The function takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> and uses its range initializer to create an identity operator. In contrast to the function above, this function also ensures that the underlying Payload matches that of the input <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00899">899</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2043a16b6855670766f46780a39f03f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2043a16b6855670766f46780a39f03f3">&#9670;&nbsp;</a></span>null_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; null_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a nulled variant of the <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code>, i.e. with optimized <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">LinearOperator::vmult</a>, <a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">LinearOperator::vmult_add</a>, etc. functions and with <a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">LinearOperator::is_null_operator</a> set to true. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00919">919</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gacad49906c99b700ca6cafdef67977d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad49906c99b700ca6cafdef67977d0c">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that acts as a mean value filter. The <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult()</a> functions of this matrix subtract the mean values of the vector.</p>
<p>The function takes an <code>std::function</code> object <code>reinit_vector</code> as an argument to initialize the <code>reinit_range_vector</code> and <code>reinit_domain_vector</code> objects of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00956">956</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6cedb0a75c51801a6052bf7343b90685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cedb0a75c51801a6052bf7343b90685">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that acts as a mean value filter. The <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult()</a> functions of this matrix subtract the mean values of the vector.</p>
<p>The function takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> and uses its range initializer to create an mean value filter operator. The function also ensures that the underlying Payload matches that of the input <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00998">998</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6b74b7ed76e4aeea2c67c0bbb03e3e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that encapsulates generic <code>matrix</code> objects that act on a compatible <a class="el" href="classVector.html">Vector</a> type into a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The <a class="el" href="classLinearOperator.html">LinearOperator</a> object that is created stores a reference to the matrix object. Thus, <code>matrix</code> must remain a valid reference for the whole lifetime of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object.</p>
<p>All changes made on <code>matrix</code> after the creation of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object are reflected by the operator object. For example, it is a valid procedure to first create a <a class="el" href="classLinearOperator.html">LinearOperator</a> and resize, reassemble the matrix later.</p>
<p>The Matrix class in question must provide the following minimal interface:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// (type specific) information how to create a Range and Domain vector</span></div><div class="line">  <span class="comment">// with appropriate size and internal layout</span></div><div class="line"></div><div class="line">  <span class="comment">// Application of matrix to vector src, writes the result into dst.</span></div><div class="line">  <a class="code" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line">  <span class="comment">// Application of the transpose of matrix to vector src, writes the</span></div><div class="line">  <span class="comment">// result into dst. (Depending on the usage of the linear operator</span></div><div class="line">  <span class="comment">// class this can be a dummy implementation throwing an error.)</span></div><div class="line">  <a class="code" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>The following (optional) interface is used if available:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Application of matrix to vector src, adds the result to dst.</span></div><div class="line">  <a class="code" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line">  <span class="comment">// Application of the transpose of matrix to vector src, adds the</span></div><div class="line">  <span class="comment">// result to dst.</span></div><div class="line">  <a class="code" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>If the Matrix does not provide <code>vmult_add</code> and <code>Tvmult_add</code>, they are implemented in terms of <code>vmult</code> and <code>Tvmult</code> (requiring intermediate storage). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01379">1379</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga14dbc8c2c27ea3fd45576528a891c6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14dbc8c2c27ea3fd45576528a891c6e2">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename OperatorExemplar , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const OperatorExemplar &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function that takes an operator object <code>operator_exemplar</code> as an additional reference. This object is used to populate the reinit_domain_vector and reinit_range_vector function objects. The reference <code>matrix</code> is used to construct vmult, Tvmult, etc.</p>
<p>This variant can, for example, be used to encapsulate preconditioners (that typically do not expose any information about the underlying matrix). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01407">1407</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaac20bebeb1b53fd00f838b63baac0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac20bebeb1b53fd00f838b63baac0456">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function that takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>operator_exemplar</code> as an additional reference. The reinit_domain_vector and reinit_range_vector function are copied from the <code>operator_exemplar</code> object.</p>
<p>The reference <code>matrix</code> is used to construct vmult, Tvmult, etc.</p>
<p>This variant can, for example, be used to encapsulate preconditioners (that typically do not expose any information about the underlying matrix). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01461">1461</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gafa632ef2b50c80c96ed831ac7cfcb018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa632ef2b50c80c96ed831ac7cfcb018">&#9670;&nbsp;</a></span>operator+() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>first_comp</code> and <code>second_comp</code> given by vector space addition of the corresponding results. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00295">295</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaab5209738cb7a57b293ee76a5f822429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5209738cb7a57b293ee76a5f822429">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>first_comp</code> and <code>second_comp</code> given by vector space addition of the corresponding results. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00328">328</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gae64fff253a63070b2662a17edcfe4a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64fff253a63070b2662a17edcfe4a44">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>comp</code> with a scalar <code>number</code> given by a scaling <a class="el" href="classPackagedOperation.html">PackagedOperation</a> result with <code>number</code>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00363">363</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaefd932f9b2760c5d21a8d6af4af2c22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd932f9b2760c5d21a8d6af4af2c22d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[16/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> objects <code>comp</code> with a scalar <code>number</code> given by a scaling <a class="el" href="classPackagedOperation.html">PackagedOperation</a> result with <code>number</code>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00403">403</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gab4c6466be816b7aa10ef2ed2e9cab80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c6466be816b7aa10ef2ed2e9cab80c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a constant <code>offset</code> (of the <code>Range</code> space) to the result of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00419">419</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga81c3ca2764ebc61b5820cdc51602b9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c3ca2764ebc61b5820cdc51602b9d1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a constant <code>offset</code> (of the <code>Range</code> space) to the result of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00434">434</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga052b4292d8beeea5fe2eeafd8f925884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052b4292d8beeea5fe2eeafd8f925884">&#9670;&nbsp;</a></span>operator-() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract a constant <code>offset</code> (of the <code>Range</code> space) from the result of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a>. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00449">449</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaa5b434083f131cddd947fc2ac8a16774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b434083f131cddd947fc2ac8a16774">&#9670;&nbsp;</a></span>operator-() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract a computational result from a constant <code>offset</code> (of the <code>Range</code> space). The result is a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that applies this computation. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00466">466</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gae329832e88340f453852ca1c19464c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae329832e88340f453852ca1c19464c27">&#9670;&nbsp;</a></span>operator+() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the addition of two vectors.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code> and <code>v</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00529">529</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga31f822e8264ec476eb33d256a02789ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31f822e8264ec476eb33d256a02789ce">&#9670;&nbsp;</a></span>operator-() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the subtraction of two vectors.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code> and <code>v</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00574">574</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaf4e1b30b9e1cea48976ca1ae4c81a92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e1b30b9e1cea48976ca1ae4c81a92e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[17/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the scaling of a vector with a <code>number</code>.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00617">617</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga9e1a013ccd3864453868b21771d08cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e1a013ccd3864453868b21771d08cdc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[18/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that stores the scaling of a vector with a <code>number</code>.</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vectors must remain valid references for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> or <code>v</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00642">642</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga643bfc3ac1e993293b9bb1ddb2b83618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga643bfc3ac1e993293b9bb1ddb2b83618">&#9670;&nbsp;</a></span>operator*() <span class="overload">[19/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object from a <a class="el" href="classLinearOperator.html">LinearOperator</a> and a reference to a vector <code>u</code> of the Domain space. The object stores the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> \(\text{op} \,u\) (in matrix notation). <code>return</code> (<code>return_add</code>) are implemented with <code>vmult(__1,u)</code> (<code>vmult_add(__1,u)</code>).</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vector must remain a valid reference for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00667">667</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga6a7163ca5e3375fae50b17a0e4a35253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7163ca5e3375fae50b17a0e4a35253">&#9670;&nbsp;</a></span>operator*() <span class="overload">[20/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object from a <a class="el" href="classLinearOperator.html">LinearOperator</a> and a reference to a vector <code>u</code> of the Range space. The object stores the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> \(\text{op}^T \,u\) (in matrix notation). <code>return</code> (<code>return_add</code>) are implemented with <code>Tvmult(__1,u)</code> (<code>Tvmult_add(__1,u)</code>).</p>
<p>The <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object that is created stores a reference to <code>u</code>. Thus, the vector must remain a valid reference for the whole lifetime of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object. All changes made on <code>u</code> after the creation of the <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object are reflected by the operator object. </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00702">702</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga0082d09d3a4bac88dbacea1ffbbf78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0082d09d3a4bac88dbacea1ffbbf78e5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[21/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Composition of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object with a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The object stores the computation \(\text{op} \,comp\) (in matrix notation). </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00729">729</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga1ddbda7644b9b62e30e4b45d8ed0ec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ddbda7644b9b62e30e4b45d8ed0ec09">&#9670;&nbsp;</a></span>operator*() <span class="overload">[22/22]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Composition of a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> object with a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The object stores the computation \(\text{op}^T \,comp\) (in matrix notation). </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00773">773</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga76acca911f21089cd3bb385d20ccc995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76acca911f21089cd3bb385d20ccc995">&#9670;&nbsp;</a></span>schur_complement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; schur_complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that performs the operations associated with the Schur complement. There are two additional helper functions, <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a> and <a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution()</a>, that are likely necessary to be used in order to perform any useful tasks in linear algebra with this operator.</p>
<p>We construct the definition of the Schur complement in the following way:</p>
<p>Consider a general system of linear equations that can be decomposed into two major sets of equations: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{K}\mathbf{d} = \mathbf{f} \quad \Rightarrow\quad \left(\begin{array}{cc} A &amp; B \\ C &amp; D \end{array}\right) \left(\begin{array}{cc} x \\ y \end{array}\right) = \left(\begin{array}{cc} f \\ g \end{array}\right), \end{eqnarray*}
</p>
<p> where \( A,B,C,D \) represent general subblocks of the matrix \( \mathbf{K} \) and, similarly, general subvectors of \( \mathbf{d},\mathbf{f} \) are given by \( x,y,f,g \) .</p>
<p>This is equivalent to the following two statements: </p><p class="formulaDsp">
\begin{eqnarray*} (1) \quad Ax + By &amp;=&amp; f \\ (2) \quad Cx + Dy &amp;=&amp; g \quad . \end{eqnarray*}
</p>
<p>Assuming that \( A,D \) are both square and invertible, we could then perform one of two possible substitutions, </p><p class="formulaDsp">
\begin{eqnarray*} (3) \quad x &amp;=&amp; A^{-1}(f - By) \quad \text{from} \quad (1) \\ (4) \quad y &amp;=&amp; D^{-1}(g - Cx) \quad \text{from} \quad (2) , \end{eqnarray*}
</p>
<p> which amount to performing block Gaussian elimination on this system of equations.</p>
<p>For the purpose of the current implementation, we choose to substitute (3) into (2) </p><p class="formulaDsp">
\begin{eqnarray*} C \: A^{-1}(f - By) + Dy &amp;=&amp; g \\ -C \: A^{-1} \: By + Dy &amp;=&amp; g - C \: A^{-1} \: f \quad . \end{eqnarray*}
</p>
<p> This leads to the result </p><p class="formulaDsp">
\[ (5) \quad (D - C\: A^{-1} \:B)y = g - C \: A^{-1} f \quad \Rightarrow \quad Sy = g&#39; \]
</p>
<p> with \( S = (D - C\: A^{-1} \:B) \) being the Schur complement and the modified right-hand side vector \( g&#39; = g - C \: A^{-1} f \) arising from the condensation step. Note that for this choice of \( S \), submatrix \( D \) need not be invertible and may thus be the null matrix. Ideally \( A \) should be well-conditioned.</p>
<p>So for any arbitrary vector \( a \), the Schur complement performs the following operation: </p><p class="formulaDsp">
\[ (6) \quad Sa = (D - C \: A^{-1} \: B)a \]
</p>
<p>A typical set of steps needed the solve a linear system (1),(2) would be:</p><ol type="1">
<li>Define the inverse matrix <code>A_inv</code> (using <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a>).</li>
<li>Define the Schur complement \( S \) (using <a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement()</a>).</li>
<li>Define iterative inverse matrix \( S^{-1} \) such that (6) holds. It is necessary to use a solver with a preconditioner to compute the approximate inverse operation of \( S \) since we never compute \( S \) directly, but rather the result of its operation. To achieve this, one may again use the <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a> in conjunction with the Schur complement that we've just constructed. Observe that the both \( S \) and its preconditioner operate over the same space as \( D \).</li>
<li>Perform pre-processing step on the RHS of (5) using <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a>: <p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
</li>
<li>Solve for \( y \) in (5): <p class="formulaDsp">
\[ y = S^{-1} g&#39; \]
</p>
</li>
<li>Perform the post-processing step from (3) using <a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution()</a>: <p class="formulaDsp">
\[ x = A^{-1} (f - By) \]
</p>
</li>
</ol>
<p>An illustration of typical usage of this operator for a fully coupled system is given below. </p><div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="schur__complement_8h.html">deal.II/lac/schur_complement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Given BlockMatrix K and BlockVectors d,F</span></div><div class="line"></div><div class="line"><span class="comment">// Decomposition of tangent matrix</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> B = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,1));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> C = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> D = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,1));</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of solution vector</span></div><div class="line"><span class="keyword">auto</span> x = d.block(0);</div><div class="line"><span class="keyword">auto</span> y = d.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of RHS vector</span></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(0);</div><div class="line"><span class="keyword">auto</span> g = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Construction of inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> prec_A = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,prec_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(S,...,prec_S);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="comment">// PackagedOperation that represents the condensed form of g</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv * rhs;</div><div class="line"></div><div class="line"><span class="comment">// Compute x using resolved solution y</span></div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p>In the above example, the preconditioner for \( S \) was defined as the preconditioner for \( D \), which is valid since they operate on the same space. However, if \( D \) and \( S \) are too dissimilar, then this may lead to a large number of solver iterations as \( \text{prec}(D) \) is not a good approximation for \( S^{-1} \).</p>
<p>A better preconditioner in such a case would be one that provides a more representative approximation for \( S^{-1} \). One approach is shown in step-22, where \( D \) is the null matrix and the preconditioner for \( S^{-1} \) is derived from the mass matrix over this space.</p>
<p>From another viewpoint, a similar result can be achieved by first constructing an object that represents an approximation for \( S \) wherein expensive operation, namely \( A^{-1} \), is approximated. Thereafter we construct the approximate inverse operator \( \tilde{S}^{-1} \) which is then used as the preconditioner for computing \( S^{-1} \). </p><div class="fragment"><div class="line"><span class="comment">// Construction of approximate inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv_approx = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(preconditioner_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv_approx,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S_approx operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"></div><div class="line"><span class="comment">// Inner solver: Typically limited to few iterations</span></div><div class="line"><span class="comment">//               using IterationNumberControl</span></div><div class="line"><span class="keyword">auto</span> S_inv_approx = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S_approx,...,S_approx_prec);</div><div class="line"></div><div class="line"><span class="comment">// Construction of exact inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// Outer solver</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S,...,S_inv_approx);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv * rhs;</div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p> Note that due to the construction of <code>S_inv_approx</code> and subsequently <code>S_inv</code>, there are a pair of nested iterative solvers which could collectively consume a lot of resources. Therefore care should be taken in the choices leading to the construction of the iterative inverse_operators. One might consider the use of a <a class="el" href="classIterationNumberControl.html">IterationNumberControl</a> (or a similar mechanism) to limit the number of inner solver iterations. This controls the accuracy of the approximate inverse operation \( \tilde{S}^{-1} \) which acts only as the preconditioner for \( S^{-1} \). Furthermore, the preconditioner to \( \tilde{S}^{-1} \), which in this example is \( \text{prec}(D) \), should ideally be computationally inexpensive.</p>
<p>However, if an iterative solver based on <a class="el" href="classIterationNumberControl.html">IterationNumberControl</a> is used as a preconditioner then the preconditioning operation is not a linear operation. Here a flexible solver like <a class="el" href="classSolverFGMRES.html">SolverFGMRES</a> (flexible GMRES) is best employed as an outer solver in order to deal with the variable behavior of the preconditioner. Otherwise the iterative solver can stagnate somewhere near the tolerance of the preconditioner or generally behave erratically. Alternatively, using a <a class="el" href="classReductionControl.html">ReductionControl</a> would ensure that the preconditioner always solves to the same tolerance, thereby rendering its behavior constant.</p>
<p>Further examples of this functionality can be found in the test-suite, such as <code>tests/lac/schur_complement_01.cc</code> . The solution of a multi- component problem (namely step-22) using the schur_complement can be found in <code>tests/lac/schur_complement_03.cc</code> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00248">248</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="ga2c071b6555ac9e2eb543b7da5100889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c071b6555ac9e2eb543b7da5100889b">&#9670;&nbsp;</a></span>condense_schur_rhs() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range_2 &gt; condense_schur_rhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_2 &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the system of equations </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p> this operation performs the pre-processing (condensation) step on the RHS subvector <code>g</code> so that the Schur complement can be used to solve this system of equations. More specifically, it produces an object that represents the condensed form of the subvector <code>g</code>, namely </p><p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00298">298</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="gab965c40b54990bbcbc129a1cd218ee21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab965c40b54990bbcbc129a1cd218ee21">&#9670;&nbsp;</a></span>postprocess_schur_solution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt; postprocess_schur_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain_2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For the system of equations </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p> this operation performs the post-processing step of the Schur complement to solve for the second subvector <code>x</code> once subvector <code>y</code> is known, with the result that </p><p class="formulaDsp">
\[ x = A^{-1}(f - By) \]
</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00336">336</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
