<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__LAOperators.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Linear Operators &lt;h3&gt;Linear Operator&lt;/h3&gt;</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Linear Operators &lt;h3&gt;Linear Operator&lt;/h3&gt;<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Linear Operators &lt;h3&gt;Linear Operator&lt;/h3&gt;:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__LAOperators.svg" width="398" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator&lt; Range, Domain, BlockPayload &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1BlockLinearOperatorImplementation_1_1EmptyBlockPayload.html">internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt; PayloadBlockType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html">LinearOperator&lt; Range, Domain, Payload &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classinternal_1_1LinearOperatorImplementation_1_1EmptyPayload.html">internal::LinearOperatorImplementation::EmptyPayload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPackagedOperation.html">PackagedOperation&lt; Range &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
创建一个BlockLinearOperator</h2></td></tr>
<tr class="memitem:gae26d59caa3e6e227f35c61f470cbde98"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gae26d59caa3e6e227f35c61f470cbde98"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae26d59caa3e6e227f35c61f470cbde98">block_operator</a> (const BlockMatrixType &amp;matrix)</td></tr>
<tr class="separator:gae26d59caa3e6e227f35c61f470cbde98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga07b64c23c5ff0b8aa7d84bf41b102e92"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga07b64c23c5ff0b8aa7d84bf41b102e92"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga07b64c23c5ff0b8aa7d84bf41b102e92">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;)</td></tr>
<tr class="separator:ga07b64c23c5ff0b8aa7d84bf41b102e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d663a86353a5666fec7dd9746084ccd"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga1d663a86353a5666fec7dd9746084ccd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1d663a86353a5666fec7dd9746084ccd">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;)</td></tr>
<tr class="separator:ga1d663a86353a5666fec7dd9746084ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">block_diagonal_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename BlockPayload , typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gad48a267ed219e65f5316204a8e9c87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3b78c08372b54dc7bc9a2cf6b497baba">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga4f98cbf0ce0df665a068394a306fd0b7">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">block_diagonal_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
对一个BlockLinearOperator的操纵</h2></td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2e93f2424bc70a566a1a46ee8c0b1c31">block_forward_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga8b2bf4fd828e4ee7539bcc16c8b19777">block_back_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2e93f2424bc70a566a1a46ee8c0b1c31">block_forward_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga8b2bf4fd828e4ee7539bcc16c8b19777">block_back_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
矢量空间操作</h2></td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
LinearOperator的组成和操作</h2></td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplParams" colspan="2">template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
创建一个LinearOperator</h2></td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50e510550627aa8892168f313d18d86"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:gad50e510550627aa8892168f313d18d86"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad50e510550627aa8892168f313d18d86">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;)</td></tr>
<tr class="separator:gad50e510550627aa8892168f313d18d86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga592c1896d2eab9faca22a852384f0079"><td class="memTemplParams" colspan="2">template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga592c1896d2eab9faca22a852384f0079"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga592c1896d2eab9faca22a852384f0079">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;)</td></tr>
<tr class="separator:ga592c1896d2eab9faca22a852384f0079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf7fafc02e3d9690336d00b033e2d4351"><td class="memTemplParams" colspan="2">template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename Matrix &gt; </td></tr>
<tr class="memitem:gaf7fafc02e3d9690336d00b033e2d4351"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaf7fafc02e3d9690336d00b033e2d4351">linear_operator</a> (const Matrix &amp;)</td></tr>
<tr class="separator:gaf7fafc02e3d9690336d00b033e2d4351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52a70111839180da28ccfebb4c588eca"><td class="memTemplParams" colspan="2">template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename OperatorExemplar , typename Matrix &gt; </td></tr>
<tr class="memitem:ga52a70111839180da28ccfebb4c588eca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga52a70111839180da28ccfebb4c588eca">linear_operator</a> (const OperatorExemplar &amp;, const Matrix &amp;)</td></tr>
<tr class="separator:ga52a70111839180da28ccfebb4c588eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga373310de5b48d5a70b9cdd47834da48f">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga373310de5b48d5a70b9cdd47834da48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2043a16b6855670766f46780a39f03f3">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga2043a16b6855670766f46780a39f03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a> (const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename OperatorExemplar , typename Matrix &gt; </td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga14dbc8c2c27ea3fd45576528a891c6e2">linear_operator</a> (const OperatorExemplar &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
矢量空间操作</h2></td></tr>
<tr class="memitem:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gafa632ef2b50c80c96ed831ac7cfcb018">operator+</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;first_comp, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;second_comp)</td></tr>
<tr class="separator:gafa632ef2b50c80c96ed831ac7cfcb018"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab5209738cb7a57b293ee76a5f822429"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaab5209738cb7a57b293ee76a5f822429"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaab5209738cb7a57b293ee76a5f822429">operator-</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;first_comp, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;second_comp)</td></tr>
<tr class="separator:gaab5209738cb7a57b293ee76a5f822429"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae64fff253a63070b2662a17edcfe4a44"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gae64fff253a63070b2662a17edcfe4a44"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae64fff253a63070b2662a17edcfe4a44">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, typename Range::value_type number)</td></tr>
<tr class="separator:gae64fff253a63070b2662a17edcfe4a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaefd932f9b2760c5d21a8d6af4af2c22d">operator*</a> (typename Range::value_type number, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaefd932f9b2760c5d21a8d6af4af2c22d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab4c6466be816b7aa10ef2ed2e9cab80c">operator+</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const Range &amp;offset)</td></tr>
<tr class="separator:gab4c6466be816b7aa10ef2ed2e9cab80c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga81c3ca2764ebc61b5820cdc51602b9d1">operator+</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:ga81c3ca2764ebc61b5820cdc51602b9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga052b4292d8beeea5fe2eeafd8f925884">operator-</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const Range &amp;offset)</td></tr>
<tr class="separator:ga052b4292d8beeea5fe2eeafd8f925884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa5b434083f131cddd947fc2ac8a16774">operator-</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaa5b434083f131cddd947fc2ac8a16774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplParams" colspan="2">template&lt;typename Range &gt; </td></tr>
<tr class="memitem:gaa5b434083f131cddd947fc2ac8a16774"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa5b434083f131cddd947fc2ac8a16774">operator-</a> (const Range &amp;offset, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp)</td></tr>
<tr class="separator:gaa5b434083f131cddd947fc2ac8a16774"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
创建一个PackagedOperation对象</h2></td></tr>
<tr class="memitem:gae329832e88340f453852ca1c19464c27"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:gae329832e88340f453852ca1c19464c27"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gae329832e88340f453852ca1c19464c27">operator+</a> (const Range &amp;u, const Range &amp;v)</td></tr>
<tr class="separator:gae329832e88340f453852ca1c19464c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga31f822e8264ec476eb33d256a02789ce"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga31f822e8264ec476eb33d256a02789ce"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga31f822e8264ec476eb33d256a02789ce">operator-</a> (const Range &amp;u, const Range &amp;v)</td></tr>
<tr class="separator:ga31f822e8264ec476eb33d256a02789ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaf4e1b30b9e1cea48976ca1ae4c81a92e">operator*</a> (const Range &amp;u, typename Range::value_type number)</td></tr>
<tr class="separator:gaf4e1b30b9e1cea48976ca1ae4c81a92e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9e1a013ccd3864453868b21771d08cdc"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </td></tr>
<tr class="memitem:ga9e1a013ccd3864453868b21771d08cdc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga9e1a013ccd3864453868b21771d08cdc">operator*</a> (typename Range::value_type number, const Range &amp;u)</td></tr>
<tr class="separator:ga9e1a013ccd3864453868b21771d08cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga643bfc3ac1e993293b9bb1ddb2b83618">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const Domain &amp;u)</td></tr>
<tr class="separator:ga643bfc3ac1e993293b9bb1ddb2b83618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6a7163ca5e3375fae50b17a0e4a35253">operator*</a> (const Range &amp;u, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga6a7163ca5e3375fae50b17a0e4a35253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga0082d09d3a4bac88dbacea1ffbbf78e5">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;comp)</td></tr>
<tr class="separator:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1ddbda7644b9b62e30e4b45d8ed0ec09">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga0082d09d3a4bac88dbacea1ffbbf78e5">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op, const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;comp)</td></tr>
<tr class="separator:ga0082d09d3a4bac88dbacea1ffbbf78e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename Payload &gt; </td></tr>
<tr class="memitem:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1ddbda7644b9b62e30e4b45d8ed0ec09">operator*</a> (const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;comp, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;op)</td></tr>
<tr class="separator:ga1ddbda7644b9b62e30e4b45d8ed0ec09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
创建一个与舒尔补码有关的LinearOperator</h2></td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
创建与舒尔补数有关的打包操作对象</h2></td></tr>
<tr class="memitem:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Payload &gt; </td></tr>
<tr class="memitem:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range_2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;C, const Range_1 &amp;f, const Range_2 &amp;g)</td></tr>
<tr class="separator:ga2c071b6555ac9e2eb543b7da5100889b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const Domain_2 &amp;y, const Range_1 &amp;f)</td></tr>
<tr class="separator:gab965c40b54990bbcbc129a1cd218ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplParams" colspan="2">template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </td></tr>
<tr class="memitem:gab965c40b54990bbcbc129a1cd218ee21"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;B, const Domain_2 &amp;y, const Range_1 &amp;f)</td></tr>
<tr class="separator:gab965c40b54990bbcbc129a1cd218ee21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>deal.II包括支持以一种非常普遍的方式来描述线性变换。这是用LinearOperator类来完成的，就像 <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType概念 </a> 一样，它为<em>applying</em>向量上的线性操作定义了一个最小的接口。</p>
<div class="fragment"><div class="line">std::function&lt;void(Range &amp;, const Domain &amp;)&gt; vmult;</div><div class="line">std::function&lt;void(Range &amp;, const Domain &amp;)&gt; vmult_add;</div><div class="line">std::function&lt;void(Domain &amp;, const Range &amp;)&gt; Tvmult;</div><div class="line">std::function&lt;void(Domain &amp;, const Range &amp;)&gt; Tvmult_add;</div></div><!-- fragment --><p>LinearOperator类的最大优势在于它为复杂的矩阵-向量操作提供了语法糖。作为一个例子，考虑操作 \((A+k\,B)\,C\) ，其中 \(A\) 、 \(B\) 和 \(C\) 表示（可能不同的）稀疏矩阵对象。为了构造一个LinearOperator <code>op</code> ，当应用于一个向量时执行上述计算，我们可以写道。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrix.html">::SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>, B, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>;</div><div class="line"><span class="keywordtype">double</span> k;</div><div class="line"><span class="comment">// Setup and assembly...</span></div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_b = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(B);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_c = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(C);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op = (op_a + k op_b) op_c;</div></div><!-- fragment --><p> 现在， <code>op</code> 可以作为一个矩阵对象用于进一步的计算。 <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator()</a>函数可以用来将一个普通的矩阵或预处理对象包装成一个LinearOperator。线性算子可以用transpose_operator()进行转置，或者通过使用inverse_operator()与迭代求解器一起进行反转。 对于LinearOperator类型的对象，所有的向量空间操作，即加减法、标量乘法和组合（兼容的线性算子）都被实现。 </p><div class="fragment"><div class="line"><a class="code" href="classLinearOperator.html">::LinearOperator&lt;&gt;</a> op_a, op_b;</div><div class="line"><span class="keywordtype">double</span> k;</div><div class="line"></div><div class="line"><span class="comment">// vector space addition, subtraction and scalar multiplication</span></div><div class="line">op_a + op_b;</div><div class="line">op_a</div><div class="line"></div><div class="line">- op_b;</div><div class="line">k op_a;</div><div class="line">op_a k;</div><div class="line"></div><div class="line"><span class="comment">// in-place variants</span></div><div class="line">op_a += op_b;</div><div class="line">op_a</div><div class="line"></div><div class="line">-= op_b;</div><div class="line">op_a= k;</div><div class="line"></div><div class="line"><span class="comment">// operator composition</span></div><div class="line">op_a op_b;</div><div class="line">op_a= op_b; <span class="comment">// If op_b is an endomorphism of the domain space of op_a</span></div></div><!-- fragment --><p><a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator()</a>和block_diagonal_operator()提供了对单个线性算子的进一步封装，使其成为封锁的线性算子变体。 <a class="el" href="step_20.html">step-20</a> 教程中有一个关于LinearOperator类的详细使用例子。</p>
<dl class="section note"><dt>Note</dt><dd>如下所述，当使用LinearOperator作为 <code>res = op_a*x</code> 时，会在幕后生成PackagedOperation类实例。因此，用户程序必须包括这两个类的头文件才能编译成功。为了更容易决定在什么情况下包含哪些头文件，并防止隐藏的与模板相关的编译器错误，所有与LinearOperator相关的头文件都被归入了<code>&lt;deal.II/lac/linear_operator_tools.h&gt;</code>头文件。 <h3>Packaged Operation</h3>
</dd></dl>
<p>通过 <code>operator*</code> 将LinearOperator对象应用于一个向量，会产生一个PackagedOperation对象来存储这个计算。 PackagedOperation类允许对涉及向量和线性运算符的表达式进行懒惰的评估。这是通过存储计算表达式来实现的，只有当对象被隐含地转换为向量对象，或者 <a class="el" href="classPackagedOperation.html#a5738d078d44dcc7cf3efb5e09e1af51a">PackagedOperation::apply()</a> （或 <a class="el" href="classPackagedOperation.html#a9ce32616ad171364d0567c38444d52ee">PackagedOperation::apply_add()</a>) 被手动调用时才执行计算。这就避免了不必要的中间结果的临时存储。 作为一个例子，考虑多个向量的相加。 </p><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div><div class="line"></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> a, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>, c, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div><div class="line"><span class="comment">// ..</span></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> result = a + b</div><div class="line"></div><div class="line">- c + <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div></div><!-- fragment --><p> 转换PackagedOperation <code>a + b</code></p>
<p><code></p><ul>
<li>c + d到一个向量的结果是，代码相当于以下代码 <div class="fragment"><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> a, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>, c, <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div><div class="line"><span class="comment">// ..</span></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> result = a;</div><div class="line">result += <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>;</div><div class="line">result</div><div class="line"></div><div class="line">-= c;</div><div class="line">result += <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>;</div></div><!-- fragment --> 这避免了任何中间存储。作为第二个例子（涉及一个LinearOperator对象），考虑计算一个残差 \(b-Ax\) 。</li>
</ul>
<p></code></p>
<p><code></p><div class="fragment"><div class="line"><a class="code" href="classSparseMatrix.html">::SparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>;</div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#ae880749870e5b45fbb6a441fd96c1a07">b</a>, x;</div><div class="line"><span class="comment">// ..</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> op_a = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(A);</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">::Vector&lt;double&gt;</a> residual =  b</div><div class="line"></div><div class="line">- op_a x;</div></div><!-- fragment --><p> 这里，表达式<code>b</code></code></p>
<p><code><code></p><ul>
<li>op_a x的结果又是一个PackagedOperation类型的对象，它存储了应该使用两个向量和线性运算符执行的<em>sequence of operations</em>。将表达式转换为矢量（就像这里发生的对矢量 <code>residual</code> 的赋值一样），执行计算（见下面的注释）。</li>
</ul>
<p></code></code></p>
<p><code><code></p><dl class="section note"><dt>Note</dt><dd>计算表达式的懒惰评估必然涉及对底层向量和矩阵对象的引用。例如，创建一个 <code>residual_expr</code> 对象 <div class="fragment"><div class="line"><span class="keyword">auto</span> residual_expr =  b</div><div class="line"></div><div class="line">- op_a x;</div></div><!-- fragment --> 存储残差的计算表达式，引用向量 <code>b</code> and matrix <code>A</code> 。在这一点上，它不进行任何计算。特别是，如果 <code>b</code> 或 <code>A</code> 被改变<b>after</b>， <code>residual_expr</code> 的创建，每一个后续的表达式的评估都用新的值进行。 <div class="fragment"><div class="line"><span class="keyword">auto</span> residual_expr =  b</div><div class="line"></div><div class="line">- op_a x;</div><div class="line">residual_expr.apply(tmp);  <span class="comment">// tmp is a Vector&lt;double&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// modify b, or A</span></div><div class="line"></div><div class="line">residual_expr.apply(tmp2); <span class="comment">// tmp2 is a Vector&lt;double&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// tmp and tmp2 are different</span></div></div><!-- fragment --> 因此，作为一种保障，如果你想马上计算一个表达式的结果，总是明确地在左边使用一个向量类型（而不是 <code>auto</code> ）。 <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> residual =  b</div><div class="line"></div><div class="line">- op_a x; <span class="comment">// computes the residual at this point</span></div></div><!-- fragment --></dd>
<dd>
<a class="el" href="step_20.html">step-20</a> 教程中有一个PackagedOperation类的详细使用例子。</dd>
<dd>
LinearOperator的许多用例导致中间表达式需要一个PackagedOperation。为了一次性包含所有必要的头文件，可以考虑使用 <div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="linear__operator__tools_8h.html">deal.II/lac/linear_operator_tools.h</a>&gt;</span></div></div><!-- fragment --> </dd></dl>
<p></code></code></p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gae26d59caa3e6e227f35c61f470cbde98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae26d59caa3e6e227f35c61f470cbde98">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个将 <code>block_matrix</code> 封装为BlockLinearOperator的函数。 在BlockLinearOperator对象创建后，对 <code>block_matrix的块结构和单个块所做的所有改变都会被操作者对象所反映。</code> </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00593">593</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga07b64c23c5ff0b8aa7d84bf41b102e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga07b64c23c5ff0b8aa7d84bf41b102e92">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的一个变体，它将一个给定的LinearOperator集合 <code>ops</code> 封装成一个块结构。这里假定Range和Domain是块状向量，即从 <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> 中导出。 <code>ops</code> 中的各个线性运算符必须作用于块向量的底层向量类型，即在 Domain::BlockType 中产生一个 Range::BlockType. 的结果。 列表 <code>ops</code> 最好作为初始化器列表传递。例如，考虑一个线性运算块（作用于Vector&lt;double&gt;）。</p>
<div class="fragment"><div class="line">op_a00 | op_a01</div><div class="line">      |</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">---------------</div><div class="line">      |</div><div class="line">op_a10 | op_a11</div></div><!-- fragment --><p> 相应的block_operator调用的形式是</p>
<div class="fragment"><div class="line">block_operator&lt;2, 2, BlockVector&lt;double&gt;&gt;({op_a00, op_a01, op_a10, op_a11});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00672">672</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaa37c982a2dd7106e7efc1b380b501bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37c982a2dd7106e7efc1b380b501bd5">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数提取 <code>block_matrix</code> 的对角线块（可以是块状矩阵类型，也可以是BlockLinearOperator），并创建一个具有对角线的BlockLinearOperator。对角线外的元素被初始化为null_operator（有正确的 reinit_range_vector 和 reinit_domain_vector 方法）。 在创建BlockLinearOperator对象后，在 <code>block_matrix</code> 的各个对角线块上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00723">723</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1d663a86353a5666fec7dd9746084ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d663a86353a5666fec7dd9746084ccd">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的一个变体，它从对角线元素的数组 <code>ops</code> 中建立起一个块状对角线线性运算器（非对角线块被假定为0）。 列表 <code>ops</code> 最好作为一个初始化器列表传递。例如考虑一个线性操作块（作用于Vector&lt;double&gt;） <code>diag(op_a0, op_a1, ..., op_am)</code>。相应的block_operator调用的形式是</p>
<div class="fragment"><div class="line">block_diagonal_operator&lt;m, BlockVector&lt;double&gt;&gt;({op_00, op_a1, ..., op_am});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00779">779</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaaaedcd8e4d6ed8ff7c6340f05deda5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的一个变体，它只接受一个LinearOperator参数 <code>op</code> ，并创建一个带有 <code>m</code> 副本的块对角线性算子。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00829">829</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2e93f2424bc70a566a1a46ee8c0b1c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e93f2424bc70a566a1a46ee8c0b1c31">&#9670;&nbsp;</a></span>block_forward_substitution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数实现了正向替换，以反转一个低级块状三角形矩阵。作为参数，它需要一个BlockLinearOperator <code>block_operator，代表一个块状下三角矩阵，以及一个BlockLinearOperator</code> <code>diagonal_inverse</code> ，代表 <code>block_operator</code>. 对角线块的反转。 让我们假设我们有一个线性系统，其块结构如下。</p>
<div class="fragment"><div class="line">A00 x0 + ...                   = y0</div><div class="line">A01 x0 + A11 x1 + ...          = y1</div><div class="line">...        ...</div><div class="line">A0n x0 + A1n x1 + ... + Ann xn = yn</div></div><!-- fragment --><p>首先， <code>x0 = A00^-1 y0</code> 。然后，我们可以用x0来恢复x1。</p>
<div class="fragment"><div class="line"> x1 = A11^-1 ( y1</div><div class="line"></div><div class="line">- A01 x0 )</div></div><!-- fragment --><p> 并因此。 </p><div class="fragment"><div class="line"> xn = Ann^-1 ( yn</div><div class="line"></div><div class="line">- A0n x0</div><div class="line"></div><div class="line">- ...</div><div class="line"></div><div class="line">- <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>我们没有使用BlockLinearOperator参数的所有块。只是使用了 <code>block_operator</code> 的下三角块矩阵以及 <code>diagonal_inverse</code>. 的对角线。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00906">906</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga8b2bf4fd828e4ee7539bcc16c8b19777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2bf4fd828e4ee7539bcc16c8b19777">&#9670;&nbsp;</a></span>block_back_substitution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_back_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数实现了反置，以反转一个上块三角矩阵。作为参数，它需要一个BlockLinearOperator <code>block_operator，代表一个上块三角矩阵，以及一个BlockLinearOperator</code> <code>diagonal_inverse</code> ，代表 <code>block_operator</code>. 的对角块的反转。 让我们假设我们有一个线性系统，其块结构如下。</p>
<div class="fragment"><div class="line">A00 x0 + A01 x1 + ... + A0n xn = yn</div><div class="line">       A11 x1 + ...          = y1</div><div class="line">                       ...     ..</div><div class="line">                      Ann xn = yn</div></div><!-- fragment --><p> 首先， <code>xn = Ann^-1 yn</code> 。然后，我们可以用xn来恢复x(n-1)。</p>
<div class="fragment"><div class="line"> x(n-1) = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)(n-1)^-1 ( y(n-1)</div><div class="line"></div><div class="line">- <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><p> 并因此。</p>
<div class="fragment"><div class="line"> x0 = A00^-1 ( y0</div><div class="line"></div><div class="line">- A0n xn</div><div class="line"></div><div class="line">- ...</div><div class="line"></div><div class="line">- A01 x1 )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>我们没有使用BlockLinearOperator参数的所有块。只是使用了 <code>block_operator</code> 的上三角块矩阵以及 <code>diagonal_inverse</code>. 的对角线。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l01035">1035</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gad5b7eee8927ffd58475199d70e445b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7eee8927ffd58475199d70e445b16">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的相加，由 \((\mathrm{first\_op}+\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) + \mathrm{second\_op}(x)\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00379">379</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga19125a34d76f661b3da533c97afda332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19125a34d76f661b3da533c97afda332">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的减法，由 \((\mathrm{first\_op}-\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) - \mathrm{second\_op}(x)\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00441">441</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87b07e6da906c2a1a5ec6a45be2d5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b07e6da906c2a1a5ec6a45be2d5d7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ScalarOperator对象 <code>op</code> 与 <code>number</code> 的标量乘法，从左边开始。 <code>Domain</code> 和 <code>Range</code> 类型必须实现以下 <code>operator*=</code> 成员函数，接受适当的标量Number类型进行重新缩放。</p>
<div class="fragment"><div class="line">Domain &amp; operator=(Domain::value_type);</div><div class="line">Range &amp; operator=(Range::value_type);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00478">478</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga88637d015b1e6962c60305e7e739ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88637d015b1e6962c60305e7e739ffa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从右边开始对一个ScalarOperator对象进行标量乘法。 <code>Domain</code> 和 <code>Range</code> 类型必须实现以下 <code>operator*=</code> 成员函数，用于重新缩放。</p>
<div class="fragment"><div class="line">Domain &amp; operator=(Domain::value_type);</div><div class="line">Range &amp; operator=(Range::value_type);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00548">548</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga148e5775d722a0e051f1b4a815650431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e5775d722a0e051f1b4a815650431">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的组合，由 \((\mathrm{first\_op}*\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(\mathrm{second\_op}(x))\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00584">584</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6bdc65fb2db56230e6bc7d545e81295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdc65fb2db56230e6bc7d545e81295d">&#9670;&nbsp;</a></span>transpose_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; transpose_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <code>op</code>. 的转置线性运算。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00656">656</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87e38fbde431397c069a88692bd24ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e38fbde431397c069a88692bd24ae7">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个代表LinearOperator的逆运算的对象 <code>op</code>. 。 该函数需要引用 <code>solver</code> 和 <code>preconditioner</code> 一个迭代求解器和一个预处理器，这些都是LinearOperator对象的 <code>vmult</code> and <code>Tvmult</code> 实现中使用的。 创建的 <a class="el" href="classLinearOperator.html">LinearOperator</a> 对象存储了对 <code>solver</code> 和 <code>preconditioner</code>. 的引用。因此，这两个对象必须在 <a class="el" href="classLinearOperator.html">LinearOperator</a> 对象的整个生命周期内保持有效引用。 <code>solver</code> 对象的内部数据结构将在调用 <code>vmult</code> or <code>Tvmult</code> 时被修改。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00695">695</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga484b23159d208db5fc2706b470bf3863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484b23159d208db5fc2706b470bf3863">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的变体，接受 <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>preconditioner</code> 作为预处理参数。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00752">752</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga058953c3b4cfae4a9cd6fa75509960a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058953c3b4cfae4a9cd6fa75509960a2">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的变体，没有预处理参数。在这种情况下， <code>op</code> 参数的ident_operator()被用作预处理。这等同于使用PreconditionIdentity。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00810">810</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3deff1665b4dad59643251895e7f5239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deff1665b4dad59643251895e7f5239">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的特殊重载，需要一个PreconditionIdentity参数。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00831">831</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1a0a3fb15266869710e63e78658cfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0a3fb15266869710e63e78658cfaed">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个LinearOperator，它是向量空间的标识 <code>Range</code>. 。 该函数需要一个 <code>std::function</code> 对象 <code>reinit_vector</code> 作为参数，以初始化LinearOperator对象的 <code>reinit_range_vector</code> 和 <code>reinit_domain_vector</code> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00865">865</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gad50e510550627aa8892168f313d18d86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad50e510550627aa8892168f313d18d86">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个LinearOperator，它是向量空间的标识 <code>Range</code>. 。 该函数接收一个LinearOperator <code>op</code> 并使用其范围初始化器来创建一个身份算子。与上面的函数不同，这个函数还确保底层的Payload与输入的Payload相匹配 <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00898">898</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga592c1896d2eab9faca22a852384f0079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga592c1896d2eab9faca22a852384f0079">&#9670;&nbsp;</a></span>null_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; null_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回LinearOperator <code>op</code>, 的空变体，即具有优化的 <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">LinearOperator::vmult</a>, <a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">LinearOperator::vmult_add</a>, 等函数，并将 <a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">LinearOperator::is_null_operator</a> 设置为真。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00920">920</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gacad49906c99b700ca6cafdef67977d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad49906c99b700ca6cafdef67977d0c">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个LinearOperator，作为一个均值过滤器。这个矩阵的vmult()函数减去向量的均值。 该函数需要一个 <code>std::function</code> 对象 <code>reinit_vector</code> 作为参数来初始化LinearOperator对象的 <code>reinit_range_vector</code> 和 <code>reinit_domain_vector</code> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00957">957</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6cedb0a75c51801a6052bf7343b90685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cedb0a75c51801a6052bf7343b90685">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个LinearOperator，作为一个均值过滤器。这个矩阵的vmult()函数减去向量的均值。 该函数接收一个LinearOperator <code>op</code> 并使用其范围初始化器来创建一个均值过滤器运算器。该函数还确保底层的Payload与输入的Payload相匹配 <code>op</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00998">998</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaf7fafc02e3d9690336d00b033e2d4351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf7fafc02e3d9690336d00b033e2d4351">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个将作用于兼容矢量类型的通用 <code>matrix</code> 对象封装为LinearOperator的函数。被创建的LinearOperator对象存储了一个对矩阵对象的引用。因此， <code>matrix</code> 必须在LinearOperator对象的整个生命周期内保持有效引用。 在创建LinearOperator对象之后，对 <code>matrix</code> 所做的所有更改都会被操作者对象所反映。例如，首先创建一个LinearOperator，然后调整大小，以后再重新组合矩阵，这是一个有效的程序。 有关的矩阵类必须提供以下最小接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// (type specific) information how to create a Range and Domain vector</span></div><div class="line"><span class="comment">// with appropriate size and internal layout</span></div><div class="line"></div><div class="line"><span class="comment">// Application of matrix to vector src, writes the result into dst.</span></div><div class="line">vmult(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line"><span class="comment">// Application of the transpose of matrix to vector src, writes the</span></div><div class="line"><span class="comment">// result into dst. (Depending on the usage of the linear operator</span></div><div class="line"><span class="comment">// class this can be a dummy implementation throwing an error.)</span></div><div class="line">Tvmult(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>如果有以下（可选）接口，则使用该接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// Application of matrix to vector src, adds the result to dst.</span></div><div class="line">vmult_add(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line"><span class="comment">// Application of the transpose of matrix to vector src, adds the</span></div><div class="line"><span class="comment">// result to dst.</span></div><div class="line">Tvmult_add(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>如果矩阵不提供 <code>vmult_add</code> 和 <code>Tvmult_add</code> ，则以 <code>vmult</code> and <code>Tvmult</code> 的方式实现（需要中间存储）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01359">1359</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga52a70111839180da28ccfebb4c588eca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52a70111839180da28ccfebb4c588eca">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = Vector&lt;double&gt;, typename Domain  = Range, typename Payload  = internal::LinearOperatorImplementation::EmptyPayload, typename OperatorExemplar , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const OperatorExemplar &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的变体，需要一个操作者对象 <code>operator_exemplar作为额外参考。这个对象被用来填充</code> reinit_domain_vector 和 reinit_range_vector 函数对象。引用 <code>matrix</code> 用于构造vmult、Tvmult等。 这个变体可以，例如，用于封装预处理程序（通常不暴露任何关于底层矩阵的信息）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01386">1386</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaac20bebeb1b53fd00f838b63baac0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac20bebeb1b53fd00f838b63baac0456">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>上述函数的变体，将LinearOperator <code>operator_exemplar作为一个额外的引用。reinit_domain_vector</code> 和 reinit_range_vector 函数是从 <code>operator_exemplar</code> 对象中复制的。 参考 <code>matrix</code> 用于构造vmult、Tvmult等。 这个变体可以，例如，用于封装预处理程序（通常不暴露任何关于底层矩阵的信息）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01436">1436</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gafa632ef2b50c80c96ed831ac7cfcb018"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafa632ef2b50c80c96ed831ac7cfcb018">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>两个PackagedOperation对象 <code>first_comp</code> 和 <code>second_comp</code> 的加法，通过向量空间加法给出相应结果。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00314">314</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaab5209738cb7a57b293ee76a5f822429"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaab5209738cb7a57b293ee76a5f822429">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>两个PackagedOperation对象 <code>first_comp</code> 和 <code>second_comp的减法，由相应结果的向量空间相加给出。</code> </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00349">349</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gae64fff253a63070b2662a17edcfe4a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae64fff253a63070b2662a17edcfe4a44">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个PackagedOperation对象 <code>comp</code> 与一个标量 <code>number</code> 的标量乘法，这个标量是由PackagedOperation的结果与 <code>number</code>. 的标量给出的。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00387">387</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaefd932f9b2760c5d21a8d6af4af2c22d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefd932f9b2760c5d21a8d6af4af2c22d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个PackagedOperation对象 <code>comp</code> 与一个标量 <code>number</code> 的标量乘法，这个标量是由PackagedOperation的结果与 <code>number</code>. 的标量给定的。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00430">430</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gab4c6466be816b7aa10ef2ed2e9cab80c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab4c6466be816b7aa10ef2ed2e9cab80c">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在PackagedOperation的结果中添加一个常数 <code>offset</code> （属于 <code>Range</code> 空间）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00448">448</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga81c3ca2764ebc61b5820cdc51602b9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga81c3ca2764ebc61b5820cdc51602b9d1">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在PackagedOperation的结果中添加一个常数 <code>offset</code> （属于 <code>Range</code> 空间）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00464">464</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga052b4292d8beeea5fe2eeafd8f925884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga052b4292d8beeea5fe2eeafd8f925884">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个PackagedOperation的结果中减去一个常数 <code>offset</code> （属于 <code>Range</code> 空间）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00481">481</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaa5b434083f131cddd947fc2ac8a16774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b434083f131cddd947fc2ac8a16774">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个常数 <code>offset</code> （属于 <code>Range</code> 空间）减去一个计算结果。其结果是一个PackagedOperation对象，应用这个计算。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00498">498</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gae329832e88340f453852ca1c19464c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae329832e88340f453852ca1c19464c27">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个PackagedOperation对象，存储两个向量的相加。 创建的PackagedOperation对象存储了对 <code>u</code> 和 <code>v</code>. 的引用。因此，向量必须在PackagedOperation对象的整个生命周期内保持有效引用。在创建PackagedOperation对象后，在 <code>u</code> 或 <code>v</code> 上所做的所有更改都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00562">562</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga31f822e8264ec476eb33d256a02789ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga31f822e8264ec476eb33d256a02789ce">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个PackagedOperation对象，存储两个向量的减法。 创建的PackagedOperation对象存储了对 <code>u</code> 和 <code>v</code>. 的引用。因此，这些向量必须在PackagedOperation对象的整个生命周期内保持有效的引用。在创建PackagedOperation对象后，在 <code>u</code> 或 <code>v</code> 上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00605">605</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="gaf4e1b30b9e1cea48976ca1ae4c81a92e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4e1b30b9e1cea48976ca1ae4c81a92e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个PackagedOperation对象，该对象存储一个具有 <code>number</code>. 的向量的缩放比例。 创建的PackagedOperation对象存储了对 <code>u</code>. 的引用。因此，向量必须在PackagedOperation对象的整个生命周期内保持有效的引用。在创建PackagedOperation对象后，在 <code>u</code> 或 <code>v</code> 上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00647">647</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga9e1a013ccd3864453868b21771d08cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9e1a013ccd3864453868b21771d08cdc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename  = typename std::enable_if&lt;            internal::PackagedOperationImplementation::has_vector_interface&lt;              Range&gt;::type::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个PackagedOperation对象，该对象存储了对一个具有 <code>number</code>. 的向量的缩放。 创建的PackagedOperation对象存储了对 <code>u</code>. 的引用。因此，向量必须在PackagedOperation对象的整个生命周期内保持有效的引用。在创建PackagedOperation对象后，在 <code>u</code> 或 <code>v</code> 上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00671">671</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga643bfc3ac1e993293b9bb1ddb2b83618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga643bfc3ac1e993293b9bb1ddb2b83618">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个LinearOperator和对域空间的向量 <code>u</code> 的引用中创建一个PackagedOperation对象。该对象存储PackagedOperation \(\text{op} \,u\) （用矩阵表示）。 <code>return</code> ( <code>return_add</code>) are implemented with <code>vmult(__1,u)</code> ( <code>vmult_add(__1,u)</code> ) 。 创建的PackagedOperation对象存储了对 <code>u</code>. 的引用。因此，在PackagedOperation对象的整个生命周期中，该向量必须保持有效的引用。在创建PackagedOperation对象后，在 <code>u</code> 上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00695">695</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga6a7163ca5e3375fae50b17a0e4a35253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a7163ca5e3375fae50b17a0e4a35253">&#9670;&nbsp;</a></span>operator*() <span class="overload">[9/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个LinearOperator和一个对Range空间的向量 <code>u</code> 的引用创建一个PackagedOperation对象。该对象存储PackagedOperation \(\text{op}^T \,u\) （用矩阵符号表示）。 <code>return</code> ( <code>return_add</code>) are implemented with <code>Tvmult(__1,u)</code> ( <code>Tvmult_add(__1,u)</code> ) 。 创建的PackagedOperation对象存储了对 <code>u</code>. 的引用。因此，在PackagedOperation对象的整个生命周期内，该向量必须保持有效引用。在创建PackagedOperation对象后，在 <code>u</code> 上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00729">729</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga0082d09d3a4bac88dbacea1ffbbf78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0082d09d3a4bac88dbacea1ffbbf78e5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[10/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(<a class="el" href="classPackagedOperation.html">PackagedOperation</a>) 一个PackagedOperation对象与一个LinearOperator的组合。该对象存储了计算 \(\text{op} \,comp\) （用矩阵符号表示）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00757">757</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga1ddbda7644b9b62e30e4b45d8ed0ec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ddbda7644b9b62e30e4b45d8ed0ec09">&#9670;&nbsp;</a></span>operator*() <span class="overload">[11/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>(<a class="el" href="classPackagedOperation.html">PackagedOperation</a>) 一个PackagedOperation对象与一个LinearOperator的组合。该对象存储了计算 \(\text{op}^T \,comp\) （用矩阵符号表示）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00803">803</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga76acca911f21089cd3bb385d20ccc995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76acca911f21089cd3bb385d20ccc995">&#9670;&nbsp;</a></span>schur_complement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; schur_complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个LinearOperator，执行与Schur补数相关的操作。有两个额外的辅助函数，condense_schur_rhs()和postprocess_schur_solution()，为了用这个操作符在线性代数中执行任何有用的任务，很可能需要使用这些函数。 我们以如下方式构建Schur补码的定义。 考虑一个一般的线性方程组，它可以被分解成两个主要的方程组。 </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{K}\mathbf{d} = \mathbf{f} \quad \Rightarrow\quad \left(\begin{array}{cc} A &amp; B \\ C &amp; D \end{array}\right) \left(\begin{array}{cc} x \\ y \end{array}\right) = \left(\begin{array}{cc} f \\ g \end{array}\right), \end{eqnarray*}
</p>
<p> 其中 \( A,B,C,D \) 代表矩阵 \( \mathbf{K} \) 的一般子块，同样地， \( \mathbf{d},\mathbf{f} \) 的一般子向量由 \( x,y,f,g \) 给出。 这等同于以下两个声明。 </p><p class="formulaDsp">
\begin{eqnarray*} (1) \quad Ax + By &amp;=&amp; f \\ (2) \quad Cx + Dy &amp;=&amp; g \quad . \end{eqnarray*}
</p>
<p>假设 \( A,D \) 既是正方形又是可倒置的，那么我们可以进行两种可能的替换， </p><p class="formulaDsp">
\begin{eqnarray*} (3) \quad x &amp;=&amp; A^{-1}(f - By) \quad \text{from} \quad (1) \\ (4) \quad y &amp;=&amp; D^{-1}(g - Cx) \quad \text{from} \quad (2) , \end{eqnarray*}
</p>
<p> 。 这相当于对这个方程组进行块状高斯消除。 就目前的实现而言，我们选择将（3）代入（2） </p><p class="formulaDsp">
\begin{eqnarray*} C \: A^{-1}(f - By) + Dy &amp;=&amp; g \\ -C \: A^{-1} \: By + Dy &amp;=&amp; g - C \: A^{-1} \: f \quad . \end{eqnarray*}
</p>
<p>。 这导致了结果 </p><p class="formulaDsp">
\[ (5) \quad (D - C\: A^{-1} \:B)y = g - C \: A^{-1} f \quad \Rightarrow \quad Sy = g&#39; \]
</p>
<p>，其中 \( S = (D - C\: A^{-1} \:B) \) 是舒尔补数，而修改后的右手边矢量 \( g&#39; = g - C \: A^{-1} f \) 则来自凝结步骤。请注意，对于 \( S \) 的这种选择，子矩阵 \( D \) 不需要是可逆的，因此可能是空矩阵。理想情况下 \( A \) 应该是条件良好的。 所以对于任何任意矢量 \( a \) ，舒尔补码进行以下操作。 </p><p class="formulaDsp">
\[ (6) \quad Sa = (D - C \: A^{-1} \: B)a \]
</p>
<p> 一个典型的解决线性系统(1),(2)所需的步骤集是。1. 定义逆矩阵 <code>A_inv</code> （使用inverse_operator()）。2. 2. 定义舒尔补码 \( S \) （使用schur_complement()）。3. 定义迭代逆矩阵 \( S^{-1} \) ，使(6)成立。有必要使用带有预处理程序的求解器来计算 \( S \) 的近似逆运算，因为我们从未直接计算 \( S \) ，而是计算其运算的结果。为了实现这一点，可以再次使用inverse_operator()与我们刚刚构建的Schur补码结合起来。请注意， \( S \) 和它的预处理程序都是在与 \( D \) 相同的空间内运行的。4. 4. 使用 <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a> 对(5)的RHS进行预处理步骤。 </p><p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
<p> 5. 求解（5）中的 \( y \) 。 </p><p class="formulaDsp">
\[ y = S^{-1} g&#39; \]
</p>
<p> 6. 使用postprocess_schur_solution()执行（3）中的后处理步骤。 </p><p class="formulaDsp">
\[ x = A^{-1} (f - By) \]
</p>
<p> 下面给出了该算子在全耦合系统中的典型用法说明。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="schur__complement_8h.html">deal.II/lac/schur_complement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Given BlockMatrix K and BlockVectors d,F</span></div><div class="line"></div><div class="line"><span class="comment">// Decomposition of tangent matrix</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> B = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,1));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> C = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> D = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,1));</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of solution vector</span></div><div class="line"><span class="keyword">auto</span> x = d.block(0);</div><div class="line"><span class="keyword">auto</span> y = d.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of RHS vector</span></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(0);</div><div class="line"><span class="keyword">auto</span> g = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Construction of inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> prec_A = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,prec_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(S,...,prec_S);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="comment">// PackagedOperation that represents the condensed form of g</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv rhs;</div><div class="line"></div><div class="line"><span class="comment">// Compute x using resolved solution y</span></div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p>在上面的例子中， \( S \) 的预处理器被定义为 \( D \) 的预处理器，这是有效的，因为它们在同一空间内运行。然而，如果 \( D \) 和 \( S \) 太不相似，那么这可能导致大量的求解器迭代，因为 \( \text{prec}(D) \) 不是 \( S^{-1} \) 的良好近似。 在这种情况下，更好的预处理程序是为 \( S^{-1} \) 提供更具代表性的近似。一种方法显示在 <a class="el" href="step_22.html">step-22</a> 中，其中 \( D \) 是空矩阵， \( S^{-1} \) 的预处理器是由这个空间的质量矩阵导出的。 从另一个角度来看，类似的结果可以通过首先构造一个代表 \( S \) 的近似对象来实现，其中昂贵的操作，即 \( A^{-1} \) ，被近似。此后，我们构建近似的反算子 \( \tilde{S}^{-1} \) ，然后将其作为计算 \( S^{-1} \) 的前提条件。</p>
<div class="fragment"><div class="line"><span class="comment">// Construction of approximate inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv_approx = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(preconditioner_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv_approx,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S_approx operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"></div><div class="line"><span class="comment">// Inner solver: Typically limited to few iterations</span></div><div class="line"><span class="comment">//               using IterationNumberControl</span></div><div class="line"><span class="keyword">auto</span> S_inv_approx = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S_approx,...,S_approx_prec);</div><div class="line"></div><div class="line"><span class="comment">// Construction of exact inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// Outer solver</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S,...,S_inv_approx);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv rhs;</div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p> 请注意，由于构建 <code>S_inv_approx和随后的</code> <code>S_inv，有一对嵌套的迭代求解器，可能会共同消耗大量的资源。因此，在构建迭代逆运算器的过程中，应该注意选择。我们可以考虑使用IterationNumberControl（或类似的机制）来限制内部求解器的迭代次数。这可以控制近似逆运算</code> \( \tilde{S}^{-1} \) 的精度，该运算仅作为 \( S^{-1} \) 的预处理程序发挥作用。此外， \( \tilde{S}^{-1} \) 的先决条件，在本例中是 \( \text{prec}(D) \) ，理想情况下应该是计算成本低的。 然而，如果使用基于IterationNumberControl的迭代求解器作为预处理器，那么预处理操作就不是线性操作了。这里最好采用SolverFGMRES（灵活的GMRES）这样的灵活求解器作为外部求解器，以处理预处理器的可变行为。否则，迭代求解器可能会在预处理器的容忍度附近停滞不前，或者普遍表现得不稳定。另外，使用ReductionControl可以确保前置条件器总是以相同的容差进行求解，从而使其行为恒定。 这种功能的更多例子可以在测试套件中找到，如 <code>tests/lac/schur_complement_01.cc</code> 。使用schur_complement解决一个多组件问题（即 <a class="el" href="step_22.html">step-22</a> ），可以在 <code>tests/lac/schur_complement_03.cc</code> 中找到。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00229">229</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="ga2c071b6555ac9e2eb543b7da5100889b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c071b6555ac9e2eb543b7da5100889b">&#9670;&nbsp;</a></span>condense_schur_rhs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range_2 &gt; condense_schur_rhs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_2 &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于方程组 </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p>来说 该操作对RHS子向量 <code>g</code> 进行预处理（凝结）步骤，以便舒尔补码可以用来解决这个方程组。更具体地说，它产生一个对象，代表子向量 <code>g</code>, 的浓缩形式，即 </p><p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
<p> 。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00276">276</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="gab965c40b54990bbcbc129a1cd218ee21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab965c40b54990bbcbc129a1cd218ee21">&#9670;&nbsp;</a></span>postprocess_schur_solution() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt; postprocess_schur_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain_2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于方程组 </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p>来说 *该操作执行舒尔补码的后处理步骤，在已知子向量 <code>y</code> 的情况下求解第二个子向量 <code>x</code> ，其结果是 </p><p class="formulaDsp">
\[ x = A^{-1}(f - By) \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00311">311</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="gad48a267ed219e65f5316204a8e9c87a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad48a267ed219e65f5316204a8e9c87a0">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename BlockPayload , typename BlockMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个将 <code>block_matrix</code> 封装为BlockLinearOperator的函数。 在BlockLinearOperator对象创建后，对 <code>block_matrix的块结构和单个块所做的所有改变都会被操作者对象所反映。</code> </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00593">593</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3b78c08372b54dc7bc9a2cf6b497baba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3b78c08372b54dc7bc9a2cf6b497baba">&#9670;&nbsp;</a></span>block_operator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n, typename Range , typename Domain , typename BlockPayload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的一个变体，它将一个给定的LinearOperator集合 <code>ops</code> 封装成一个块结构。这里假定Range和Domain是块状向量，即从 <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> 中导出。 <code>ops</code> 中的各个线性运算符必须作用于块向量的底层向量类型，即在 Domain::BlockType 中产生一个 Range::BlockType. 的结果。 列表 <code>ops</code> 最好作为初始化器列表传递。例如，考虑一个线性运算块（作用于Vector&lt;double&gt;）。</p>
<div class="fragment"><div class="line">op_a00 | op_a01</div><div class="line">      |</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">---------------</div><div class="line">      |</div><div class="line">op_a10 | op_a11</div></div><!-- fragment --><p> 相应的block_operator调用的形式是</p>
<div class="fragment"><div class="line">block_operator&lt;2, 2, BlockVector&lt;double&gt;&gt;({op_a00, op_a01, op_a10, op_a11});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00672">672</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaa37c982a2dd7106e7efc1b380b501bd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa37c982a2dd7106e7efc1b380b501bd5">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>block_matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数提取 <code>block_matrix</code> 的对角线块（可以是块状矩阵类型，也可以是BlockLinearOperator），并创建一个具有对角线的BlockLinearOperator。对角线外的元素被初始化为null_operator（有正确的 reinit_range_vector 和 reinit_domain_vector 方法）。 在创建BlockLinearOperator对象后，在 <code>block_matrix</code> 的各个对角线块上所做的所有改变都会被操作者对象所反映。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00723">723</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga4f98cbf0ce0df665a068394a306fd0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4f98cbf0ce0df665a068394a306fd0b7">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的一个变体，它从对角线元素的数组 <code>ops</code> 中建立起一个块状对角线线性运算器（非对角线块被假定为0）。 列表 <code>ops</code> 最好作为一个初始化器列表传递。例如考虑一个线性操作块（作用于Vector&lt;double&gt;） <code>diag(op_a0, op_a1, ..., op_am)</code>。相应的block_operator调用的形式是</p>
<div class="fragment"><div class="line">block_diagonal_operator&lt;m, BlockVector&lt;double&gt;&gt;({op_00, op_a1, ..., op_am});</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00779">779</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gaaaedcd8e4d6ed8ff7c6340f05deda5c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">&#9670;&nbsp;</a></span>block_diagonal_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; block_diagonal_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的一个变体，它只接受一个LinearOperator参数 <code>op</code> ，并创建一个带有 <code>m</code> 副本的块对角线性算子。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00829">829</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2e93f2424bc70a566a1a46ee8c0b1c31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2e93f2424bc70a566a1a46ee8c0b1c31">&#9670;&nbsp;</a></span>block_forward_substitution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_forward_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数实现了正向替换，以反转一个低级块状三角形矩阵。作为参数，它需要一个BlockLinearOperator <code>block_operator，代表一个块状下三角矩阵，以及一个BlockLinearOperator</code> <code>diagonal_inverse</code> ，代表 <code>block_operator</code>. 对角线块的反转。 让我们假设我们有一个线性系统，其块结构如下。</p>
<div class="fragment"><div class="line">A00 x0 + ...                   = y0</div><div class="line">A01 x0 + A11 x1 + ...          = y1</div><div class="line">...        ...</div><div class="line">A0n x0 + A1n x1 + ... + Ann xn = yn</div></div><!-- fragment --><p>首先， <code>x0 = A00^-1 y0</code> 。然后，我们可以用x0来恢复x1。</p>
<div class="fragment"><div class="line"> x1 = A11^-1 ( y1</div><div class="line"></div><div class="line">- A01 x0 )</div></div><!-- fragment --><p> 并因此。 </p><div class="fragment"><div class="line"> xn = Ann^-1 ( yn</div><div class="line"></div><div class="line">- A0n x0</div><div class="line"></div><div class="line">- ...</div><div class="line"></div><div class="line">- <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>我们没有使用BlockLinearOperator参数的所有块。只是使用了 <code>block_operator</code> 的下三角块矩阵以及 <code>diagonal_inverse</code>. 的对角线。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00906">906</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga8b2bf4fd828e4ee7539bcc16c8b19777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8b2bf4fd828e4ee7539bcc16c8b19777">&#9670;&nbsp;</a></span>block_back_substitution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt; block_back_substitution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_operator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"><em>diagonal_inverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数实现了反置，以反转一个上块三角矩阵。作为参数，它需要一个BlockLinearOperator <code>block_operator，代表一个上块三角矩阵，以及一个BlockLinearOperator</code> <code>diagonal_inverse</code> ，代表 <code>block_operator</code>. 的对角块的反转。 让我们假设我们有一个线性系统，其块结构如下。</p>
<div class="fragment"><div class="line">A00 x0 + A01 x1 + ... + A0n xn = yn</div><div class="line">       A11 x1 + ...          = y1</div><div class="line">                       ...     ..</div><div class="line">                      Ann xn = yn</div></div><!-- fragment --><p> 首先， <code>xn = Ann^-1 yn</code> 。然后，我们可以用xn来恢复x(n-1)。</p>
<div class="fragment"><div class="line"> x(n-1) = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)(n-1)^-1 ( y(n-1)</div><div class="line"></div><div class="line">- <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(n-1)n x(n-1) )</div></div><!-- fragment --><p> 并因此。</p>
<div class="fragment"><div class="line"> x0 = A00^-1 ( y0</div><div class="line"></div><div class="line">- A0n xn</div><div class="line"></div><div class="line">- ...</div><div class="line"></div><div class="line">- A01 x1 )</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>我们没有使用BlockLinearOperator参数的所有块。只是使用了 <code>block_operator</code> 的上三角块矩阵以及 <code>diagonal_inverse</code>. 的对角线。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l01035">1035</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="gad5b7eee8927ffd58475199d70e445b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7eee8927ffd58475199d70e445b16">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的相加，由 \((\mathrm{first\_op}+\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) + \mathrm{second\_op}(x)\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00379">379</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga19125a34d76f661b3da533c97afda332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19125a34d76f661b3da533c97afda332">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的减法，由 \((\mathrm{first\_op}-\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) - \mathrm{second\_op}(x)\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00441">441</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87b07e6da906c2a1a5ec6a45be2d5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b07e6da906c2a1a5ec6a45be2d5d7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[12/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ScalarOperator对象 <code>op</code> 与 <code>number</code> 的标量乘法，从左边开始。 <code>Domain</code> 和 <code>Range</code> 类型必须实现以下 <code>operator*=</code> 成员函数，接受适当的标量Number类型进行重新缩放。</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classLinearOperator.html#adce51f284d093109562cad98df31209a">operator=</a>(Domain::value_type);</div><div class="line">Range &amp; <a class="code" href="classLinearOperator.html#adce51f284d093109562cad98df31209a">operator=</a>(Range::value_type);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00478">478</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga88637d015b1e6962c60305e7e739ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88637d015b1e6962c60305e7e739ffa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[13/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从右边开始对一个ScalarOperator对象进行标量乘法。 <code>Domain</code> 和 <code>Range</code> 类型必须实现以下 <code>operator*=</code> 成员函数，用于重新缩放。</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classLinearOperator.html#adce51f284d093109562cad98df31209a">operator=</a>(Domain::value_type);</div><div class="line">Range &amp; <a class="code" href="classLinearOperator.html#adce51f284d093109562cad98df31209a">operator=</a>(Range::value_type);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00548">548</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga148e5775d722a0e051f1b4a815650431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e5775d722a0e051f1b4a815650431">&#9670;&nbsp;</a></span>operator*() <span class="overload">[14/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Intermediate , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的组合，由 \((\mathrm{first\_op}*\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(\mathrm{second\_op}(x))\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00584">584</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6bdc65fb2db56230e6bc7d545e81295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdc65fb2db56230e6bc7d545e81295d">&#9670;&nbsp;</a></span>transpose_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; transpose_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>op</code>. 的转置线性运算。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00656">656</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87e38fbde431397c069a88692bd24ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e38fbde431397c069a88692bd24ae7">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Preconditioner , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个代表LinearOperator的逆运算的对象 <code>op</code>. 。 该函数需要引用 <code>solver</code> 和 <code>preconditioner</code> 一个迭代求解器和一个预处理器，这些都是LinearOperator对象的 <code>vmult</code> and <code>Tvmult</code> 实现中使用的。 创建的 <a class="el" href="classLinearOperator.html">LinearOperator</a> 对象存储了对 <code>solver</code> 和 <code>preconditioner</code>. 的引用。因此，这两个对象必须在 <a class="el" href="classLinearOperator.html">LinearOperator</a> 对象的整个生命周期内保持有效引用。 <code>solver</code> 对象的内部数据结构将在调用 <code>vmult</code> or <code>Tvmult</code> 时被修改。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00695">695</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga484b23159d208db5fc2706b470bf3863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484b23159d208db5fc2706b470bf3863">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，接受 <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>preconditioner</code> 作为预处理参数。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00752">752</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga058953c3b4cfae4a9cd6fa75509960a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058953c3b4cfae4a9cd6fa75509960a2">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，没有预处理参数。在这种情况下， <code>op</code> 参数的ident_operator()被用作预处理。这等同于使用PreconditionIdentity。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00810">810</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3deff1665b4dad59643251895e7f5239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deff1665b4dad59643251895e7f5239">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Payload , typename Solver , typename Range  = typename Solver::vector_type, typename Domain  = Range&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, <a class="el" href="classPayload.html">Payload</a> &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的特殊重载，需要一个PreconditionIdentity参数。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00831">831</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1a0a3fb15266869710e63e78658cfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0a3fb15266869710e63e78658cfaed">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，它是向量空间的标识 <code>Range</code>. 。 该函数需要一个 <code>std::function</code> 对象 <code>reinit_vector</code> 作为参数，以初始化LinearOperator对象的 <code>reinit_range_vector</code> 和 <code>reinit_domain_vector</code> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00865">865</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga373310de5b48d5a70b9cdd47834da48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373310de5b48d5a70b9cdd47834da48f">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，它是向量空间的标识 <code>Range</code>. 。 该函数接收一个LinearOperator <code>op</code> 并使用其范围初始化器来创建一个身份算子。与上面的函数不同，这个函数还确保底层的Payload与输入的Payload相匹配 <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00898">898</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2043a16b6855670766f46780a39f03f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2043a16b6855670766f46780a39f03f3">&#9670;&nbsp;</a></span>null_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; null_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回LinearOperator <code>op</code>, 的空变体，即具有优化的 <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">LinearOperator::vmult</a>, <a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">LinearOperator::vmult_add</a>, 等函数，并将 <a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">LinearOperator::is_null_operator</a> 设置为真。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00920">920</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gacad49906c99b700ca6cafdef67977d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad49906c99b700ca6cafdef67977d0c">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Payload  = internal::LinearOperatorImplementation::EmptyPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，作为一个均值过滤器。这个矩阵的vmult()函数减去向量的均值。 该函数需要一个 <code>std::function</code> 对象 <code>reinit_vector</code> 作为参数来初始化LinearOperator对象的 <code>reinit_range_vector</code> 和 <code>reinit_domain_vector</code> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00957">957</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6cedb0a75c51801a6052bf7343b90685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cedb0a75c51801a6052bf7343b90685">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，作为一个均值过滤器。这个矩阵的vmult()函数减去向量的均值。 该函数接收一个LinearOperator <code>op</code> 并使用其范围初始化器来创建一个均值过滤器运算器。该函数还确保底层的Payload与输入的Payload相匹配 <code>op</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00998">998</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6b74b7ed76e4aeea2c67c0bbb03e3e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个将作用于兼容矢量类型的通用 <code>matrix</code> 对象封装为LinearOperator的函数。被创建的LinearOperator对象存储了一个对矩阵对象的引用。因此， <code>matrix</code> 必须在LinearOperator对象的整个生命周期内保持有效引用。 在创建LinearOperator对象之后，对 <code>matrix</code> 所做的所有更改都会被操作者对象所反映。例如，首先创建一个LinearOperator，然后调整大小，以后再重新组合矩阵，这是一个有效的程序。 有关的矩阵类必须提供以下最小接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// (type specific) information how to create a Range and Domain vector</span></div><div class="line"><span class="comment">// with appropriate size and internal layout</span></div><div class="line"></div><div class="line"><span class="comment">// Application of matrix to vector src, writes the result into dst.</span></div><div class="line"><a class="code" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line"><span class="comment">// Application of the transpose of matrix to vector src, writes the</span></div><div class="line"><span class="comment">// result into dst. (Depending on the usage of the linear operator</span></div><div class="line"><span class="comment">// class this can be a dummy implementation throwing an error.)</span></div><div class="line"><a class="code" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>如果有以下（可选）接口，则使用该接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// Application of matrix to vector src, adds the result to dst.</span></div><div class="line"><a class="code" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line"><span class="comment">// Application of the transpose of matrix to vector src, adds the</span></div><div class="line"><span class="comment">// result to dst.</span></div><div class="line"><a class="code" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>如果矩阵不提供 <code>vmult_add</code> 和 <code>Tvmult_add</code> ，则以 <code>vmult</code> and <code>Tvmult</code> 的方式实现（需要中间存储）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01359">1359</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga14dbc8c2c27ea3fd45576528a891c6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14dbc8c2c27ea3fd45576528a891c6e2">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename OperatorExemplar , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const OperatorExemplar &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，需要一个操作者对象 <code>operator_exemplar作为额外参考。这个对象被用来填充</code> reinit_domain_vector 和 reinit_range_vector 函数对象。引用 <code>matrix</code> 用于构造vmult、Tvmult等。 这个变体可以，例如，用于封装预处理程序（通常不暴露任何关于底层矩阵的信息）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01386">1386</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaac20bebeb1b53fd00f838b63baac0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac20bebeb1b53fd00f838b63baac0456">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload , typename Matrix &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，将LinearOperator <code>operator_exemplar作为一个额外的引用。reinit_domain_vector</code> 和 reinit_range_vector 函数是从 <code>operator_exemplar</code> 对象中复制的。 参考 <code>matrix</code> 用于构造vmult、Tvmult等。 这个变体可以，例如，用于封装预处理程序（通常不暴露任何关于底层矩阵的信息）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01436">1436</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaa5b434083f131cddd947fc2ac8a16774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5b434083f131cddd947fc2ac8a16774">&#9670;&nbsp;</a></span>operator-() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个常数 <code>offset</code> （属于 <code>Range</code> 空间）减去一个计算结果。其结果是一个PackagedOperation对象，应用这个计算。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00498">498</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga0082d09d3a4bac88dbacea1ffbbf78e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0082d09d3a4bac88dbacea1ffbbf78e5">&#9670;&nbsp;</a></span>operator*() <span class="overload">[15/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(<a class="el" href="classPackagedOperation.html">PackagedOperation</a>) 一个PackagedOperation对象与一个LinearOperator的组合。该对象存储了计算 \(\text{op} \,comp\) （用矩阵符号表示）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00757">757</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga1ddbda7644b9b62e30e4b45d8ed0ec09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ddbda7644b9b62e30e4b45d8ed0ec09">&#9670;&nbsp;</a></span>operator*() <span class="overload">[16/16]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range , typename Domain , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; &amp;&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>(<a class="el" href="classPackagedOperation.html">PackagedOperation</a>) 一个PackagedOperation对象与一个LinearOperator的组合。该对象存储了计算 \(\text{op}^T \,comp\) （用矩阵符号表示）。 </p>

<p class="definition">Definition at line <a class="el" href="packaged__operation_8h_source.html#l00803">803</a> of file <a class="el" href="packaged__operation_8h_source.html">packaged_operation.h</a>.</p>

</div>
</div>
<a id="ga76acca911f21089cd3bb385d20ccc995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76acca911f21089cd3bb385d20ccc995">&#9670;&nbsp;</a></span>schur_complement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Range_2 , typename Domain_2 , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; schur_complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，执行与Schur补数相关的操作。有两个额外的辅助函数，condense_schur_rhs()和postprocess_schur_solution()，为了用这个操作符在线性代数中执行任何有用的任务，很可能需要使用这些函数。 我们以如下方式构建Schur补码的定义。 考虑一个一般的线性方程组，它可以被分解成两个主要的方程组。 </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{K}\mathbf{d} = \mathbf{f} \quad \Rightarrow\quad \left(\begin{array}{cc} A &amp; B \\ C &amp; D \end{array}\right) \left(\begin{array}{cc} x \\ y \end{array}\right) = \left(\begin{array}{cc} f \\ g \end{array}\right), \end{eqnarray*}
</p>
<p> 其中 \( A,B,C,D \) 代表矩阵 \( \mathbf{K} \) 的一般子块，同样地， \( \mathbf{d},\mathbf{f} \) 的一般子向量由 \( x,y,f,g \) 给出。 这等同于以下两个声明。 </p><p class="formulaDsp">
\begin{eqnarray*} (1) \quad Ax + By &amp;=&amp; f \\ (2) \quad Cx + Dy &amp;=&amp; g \quad . \end{eqnarray*}
</p>
<p>假设 \( A,D \) 既是正方形又是可倒置的，那么我们可以进行两种可能的替换， </p><p class="formulaDsp">
\begin{eqnarray*} (3) \quad x &amp;=&amp; A^{-1}(f - By) \quad \text{from} \quad (1) \\ (4) \quad y &amp;=&amp; D^{-1}(g - Cx) \quad \text{from} \quad (2) , \end{eqnarray*}
</p>
<p> 。 这相当于对这个方程组进行块状高斯消除。 就目前的实现而言，我们选择将（3）代入（2） </p><p class="formulaDsp">
\begin{eqnarray*} C \: A^{-1}(f - By) + Dy &amp;=&amp; g \\ -C \: A^{-1} \: By + Dy &amp;=&amp; g - C \: A^{-1} \: f \quad . \end{eqnarray*}
</p>
<p>。 这导致了结果 </p><p class="formulaDsp">
\[ (5) \quad (D - C\: A^{-1} \:B)y = g - C \: A^{-1} f \quad \Rightarrow \quad Sy = g&#39; \]
</p>
<p>，其中 \( S = (D - C\: A^{-1} \:B) \) 是舒尔补数，而修改后的右手边矢量 \( g&#39; = g - C \: A^{-1} f \) 则来自凝结步骤。请注意，对于 \( S \) 的这种选择，子矩阵 \( D \) 不需要是可逆的，因此可能是空矩阵。理想情况下 \( A \) 应该是条件良好的。 所以对于任何任意矢量 \( a \) ，舒尔补码进行以下操作。 </p><p class="formulaDsp">
\[ (6) \quad Sa = (D - C \: A^{-1} \: B)a \]
</p>
<p> 一个典型的解决线性系统(1),(2)所需的步骤集是。1. 定义逆矩阵 <code>A_inv</code> （使用inverse_operator()）。2. 2. 定义舒尔补码 \( S \) （使用schur_complement()）。3. 定义迭代逆矩阵 \( S^{-1} \) ，使(6)成立。有必要使用带有预处理程序的求解器来计算 \( S \) 的近似逆运算，因为我们从未直接计算 \( S \) ，而是计算其运算的结果。为了实现这一点，可以再次使用inverse_operator()与我们刚刚构建的Schur补码结合起来。请注意， \( S \) 和它的预处理程序都是在与 \( D \) 相同的空间内运行的。4. 4. 使用 <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a> 对(5)的RHS进行预处理步骤。 </p><p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
<p> 5. 求解（5）中的 \( y \) 。 </p><p class="formulaDsp">
\[ y = S^{-1} g&#39; \]
</p>
<p> 6. 使用postprocess_schur_solution()执行（3）中的后处理步骤。 </p><p class="formulaDsp">
\[ x = A^{-1} (f - By) \]
</p>
<p> 下面给出了该算子在全耦合系统中的典型用法说明。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="schur__complement_8h.html">deal.II/lac/schur_complement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Given BlockMatrix K and BlockVectors d,F</span></div><div class="line"></div><div class="line"><span class="comment">// Decomposition of tangent matrix</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> B = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,1));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> C = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> D = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,1));</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of solution vector</span></div><div class="line"><span class="keyword">auto</span> x = d.block(0);</div><div class="line"><span class="keyword">auto</span> y = d.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of RHS vector</span></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(0);</div><div class="line"><span class="keyword">auto</span> g = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Construction of inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> prec_A = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,prec_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(S,...,prec_S);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="comment">// PackagedOperation that represents the condensed form of g</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv rhs;</div><div class="line"></div><div class="line"><span class="comment">// Compute x using resolved solution y</span></div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p>在上面的例子中， \( S \) 的预处理器被定义为 \( D \) 的预处理器，这是有效的，因为它们在同一空间内运行。然而，如果 \( D \) 和 \( S \) 太不相似，那么这可能导致大量的求解器迭代，因为 \( \text{prec}(D) \) 不是 \( S^{-1} \) 的良好近似。 在这种情况下，更好的预处理程序是为 \( S^{-1} \) 提供更具代表性的近似。一种方法显示在 <a class="el" href="step_22.html">step-22</a> 中，其中 \( D \) 是空矩阵， \( S^{-1} \) 的预处理器是由这个空间的质量矩阵导出的。 从另一个角度来看，类似的结果可以通过首先构造一个代表 \( S \) 的近似对象来实现，其中昂贵的操作，即 \( A^{-1} \) ，被近似。此后，我们构建近似的反算子 \( \tilde{S}^{-1} \) ，然后将其作为计算 \( S^{-1} \) 的前提条件。</p>
<div class="fragment"><div class="line"><span class="comment">// Construction of approximate inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv_approx = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(preconditioner_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv_approx,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S_approx operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"></div><div class="line"><span class="comment">// Inner solver: Typically limited to few iterations</span></div><div class="line"><span class="comment">//               using IterationNumberControl</span></div><div class="line"><span class="keyword">auto</span> S_inv_approx = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S_approx,...,S_approx_prec);</div><div class="line"></div><div class="line"><span class="comment">// Construction of exact inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// Outer solver</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S,...,S_inv_approx);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv rhs;</div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p> 请注意，由于构建 <code>S_inv_approx和随后的</code> <code>S_inv，有一对嵌套的迭代求解器，可能会共同消耗大量的资源。因此，在构建迭代逆运算器的过程中，应该注意选择。我们可以考虑使用IterationNumberControl（或类似的机制）来限制内部求解器的迭代次数。这可以控制近似逆运算</code> \( \tilde{S}^{-1} \) 的精度，该运算仅作为 \( S^{-1} \) 的预处理程序发挥作用。此外， \( \tilde{S}^{-1} \) 的先决条件，在本例中是 \( \text{prec}(D) \) ，理想情况下应该是计算成本低的。 然而，如果使用基于IterationNumberControl的迭代求解器作为预处理器，那么预处理操作就不是线性操作了。这里最好采用SolverFGMRES（灵活的GMRES）这样的灵活求解器作为外部求解器，以处理预处理器的可变行为。否则，迭代求解器可能会在预处理器的容忍度附近停滞不前，或者普遍表现得不稳定。另外，使用ReductionControl可以确保前置条件器总是以相同的容差进行求解，从而使其行为恒定。 这种功能的更多例子可以在测试套件中找到，如 <code>tests/lac/schur_complement_01.cc</code> 。使用schur_complement解决一个多组件问题（即 <a class="el" href="step_22.html">step-22</a> ），可以在 <code>tests/lac/schur_complement_03.cc</code> 中找到。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00229">229</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<a id="gab965c40b54990bbcbc129a1cd218ee21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab965c40b54990bbcbc129a1cd218ee21">&#9670;&nbsp;</a></span>postprocess_schur_solution() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range_1 , typename Domain_1 , typename Domain_2 , typename Payload &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Domain_1 &gt; postprocess_schur_solution </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_1, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, <a class="el" href="classPayload.html">Payload</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Domain_2 &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range_1 &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于方程组 </p><p class="formulaDsp">
\begin{eqnarray*} Ax + By &amp;=&amp; f \\ Cx + Dy &amp;=&amp; g \quad , \end{eqnarray*}
</p>
<p>来说 *该操作执行舒尔补码的后处理步骤，在已知子向量 <code>y</code> 的情况下求解第二个子向量 <code>x</code> ，其结果是 </p><p class="formulaDsp">
\[ x = A^{-1}(f - By) \]
</p>
 <dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00311">311</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
