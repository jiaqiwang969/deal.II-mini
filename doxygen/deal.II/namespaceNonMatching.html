<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceNonMatching.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: NonMatching Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">NonMatching Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceNonMatching_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceNonMatching_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structNonMatching_1_1AdditionalQGeneratorData.html">AdditionalQGeneratorData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNonMatching_1_1FaceQuadratureGenerator.html">FaceQuadratureGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNonMatching_1_1ImmersedSurfaceQuadrature.html">ImmersedSurfaceQuadrature</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classNonMatching_1_1QuadratureGenerator.html">QuadratureGenerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a8829bfa8e55c21b8eeaafd086c53680d"><td class="memTemplParams" colspan="2">template&lt;int dim0, int dim1, int spacedim, typename Sparsity , typename number  = double&gt; </td></tr>
<tr class="memitem:a8829bfa8e55c21b8eeaafd086c53680d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">create_coupling_sparsity_pattern</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;space_dh, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;immersed_dh, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;quad, Sparsity &amp;sparsity, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;space_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;immersed_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classMapping.html">Mapping</a>&lt; dim0, spacedim &gt; &amp;space_mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim0, spacedim &gt;::mapping, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;immersed_mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim1, spacedim &gt;::mapping)</td></tr>
<tr class="separator:a8829bfa8e55c21b8eeaafd086c53680d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a75bda48830793be89ef84020d8d27"><td class="memTemplParams" colspan="2">template&lt;int dim0, int dim1, int spacedim, typename Sparsity , typename number  = double&gt; </td></tr>
<tr class="memitem:ad9a75bda48830793be89ef84020d8d27"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceNonMatching.html#ad9a75bda48830793be89ef84020d8d27">create_coupling_sparsity_pattern</a> (const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;cache, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;space_dh, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;immersed_dh, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;quad, Sparsity &amp;sparsity, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;space_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;immersed_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;immersed_mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim1, spacedim &gt;::mapping)</td></tr>
<tr class="separator:ad9a75bda48830793be89ef84020d8d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3821491559b8a76af0be66736fe4c6f"><td class="memTemplParams" colspan="2">template&lt;int dim0, int dim1, int spacedim, typename Matrix &gt; </td></tr>
<tr class="memitem:ac3821491559b8a76af0be66736fe4c6f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceNonMatching.html#ac3821491559b8a76af0be66736fe4c6f">create_coupling_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;space_dh, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;immersed_dh, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;quad, Matrix &amp;matrix, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt;(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;space_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;immersed_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classMapping.html">Mapping</a>&lt; dim0, spacedim &gt; &amp;space_mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim0, spacedim &gt;::mapping, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;immersed_mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim1, spacedim &gt;::mapping)</td></tr>
<tr class="separator:ac3821491559b8a76af0be66736fe4c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009cf4da137d69c3bd0e00a2f89ba513"><td class="memTemplParams" colspan="2">template&lt;int dim0, int dim1, int spacedim, typename Matrix &gt; </td></tr>
<tr class="memitem:a009cf4da137d69c3bd0e00a2f89ba513"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceNonMatching.html#a009cf4da137d69c3bd0e00a2f89ba513">create_coupling_mass_matrix</a> (const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;cache, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;space_dh, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;immersed_dh, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;quad, Matrix &amp;matrix, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt;(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;space_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;immersed_comps=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;immersed_mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; dim1, spacedim &gt;::mapping)</td></tr>
<tr class="separator:a009cf4da137d69c3bd0e00a2f89ba513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7f345fdc3634974cfeeea99d084d7a"><td class="memTemplParams" colspan="2">template&lt;int dim0, int dim1, int spacedim, typename Sparsity , typename Number  = double&gt; </td></tr>
<tr class="memitem:a6e7f345fdc3634974cfeeea99d084d7a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceNonMatching.html#a6e7f345fdc3634974cfeeea99d084d7a">create_coupling_sparsity_pattern</a> (const <a class="el" href="classdouble.html">double</a> &amp;epsilon, const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;cache0, const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim1, spacedim &gt; &amp;cache1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;dh0, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;dh1, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;quad, Sparsity &amp;sparsity, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; Number &gt; &amp;constraints0=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; Number &gt;(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;comps0=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;comps1=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a6e7f345fdc3634974cfeeea99d084d7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cdb0c9f16edb5531e3087e48ce7b862"><td class="memTemplParams" colspan="2">template&lt;int dim0, int dim1, int spacedim, typename Matrix &gt; </td></tr>
<tr class="memitem:a8cdb0c9f16edb5531e3087e48ce7b862"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceNonMatching.html#a8cdb0c9f16edb5531e3087e48ce7b862">create_coupling_mass_matrix</a> (<a class="el" href="classFunctions_1_1CutOffFunctionBase.html">Functions::CutOffFunctionBase</a>&lt; spacedim &gt; &amp;kernel, const <a class="el" href="classdouble.html">double</a> &amp;epsilon, const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;cache0, const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim1, spacedim &gt; &amp;cache1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;dh0, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;dh1, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim0 &gt; &amp;quadrature0, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;quadrature1, Matrix &amp;matrix, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt; &amp;constraints0=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt;(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;comps0=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;comps1=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a8cdb0c9f16edb5531e3087e48ce7b862"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace for functions offering tools to handle two meshes with no alignment requirements.</p>
<p>Typically these functions allow for computations on the real-space intersection between the two meshes e.g. surface integrals and construction of coupling matrices. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a8829bfa8e55c21b8eeaafd086c53680d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8829bfa8e55c21b8eeaafd086c53680d">&#9670;&nbsp;</a></span>create_coupling_sparsity_pattern() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim0, int dim1, int spacedim, typename Sparsity , typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NonMatching::create_coupling_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sparsity &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>space_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>immersed_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim0,&#160;spacedim&#160;&gt;::mapping</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim1,&#160;spacedim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coupling sparsity pattern for non-matching, overlapping grids.</p>
<p>Given two non-matching triangulations, representing the domains \(\Omega\) and \(B\), with \(B \subseteq \Omega\), and two finite element spaces \(V(\Omega) = \text{span}\{v_i\}_{i=0}^n\) and \(Q(B) = \text{span}\{w_j\}_{j=0}^m\), compute the sparsity pattern that would be necessary to assemble the matrix </p><p class="formulaDsp">
\[ M_{ij} \dealcoloneq \int_{B} v_i(x) w_j(x) dx, \quad i \in [0,n), j \in [0,m), \]
</p>
<p> where \(V(\Omega)\) is the finite element space associated with the <code>space_dh</code> passed to this function (or part of it, if specified in <code>space_comps</code>), while \(Q(B)\) is the finite element space associated with the <code>immersed_dh</code> passed to this function (or part of it, if specified in <code>immersed_comps</code>).</p>
<p>The <code>sparsity</code> is filled by locating the position of quadrature points (obtained by the reference quadrature <code>quad</code>) defined on elements of \(B\) with respect to the embedding triangulation \(\Omega\). For each overlapping cell, the entries corresponding to <code>space_comps</code> in <code>space_dh</code> and <code>immersed_comps</code> in <code>immersed_dh</code> are added to the sparsity pattern.</p>
<p>The <code>space_comps</code> and <code>immersed_comps</code> masks are assumed to be ordered in the same way: the first component of <code>space_comps</code> will couple with the first component of <code>immersed_comps</code>, the second with the second, and so on. If one of the two masks has more non-zero than the other, then the excess components will be ignored.</p>
<p>If the domain \(B\) does not fall within \(\Omega\), an exception will be thrown by the algorithm that computes the quadrature point locations. In particular, notice that this function only makes sens for <code>dim1</code> lower or equal than <code>dim0</code>. A static assert guards that this is actually the case.</p>
<p>For both spaces, it is possible to specify a custom <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a>, which defaults to <a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a> for both.</p>
<p>This function will also work in parallel, provided that the immersed triangulation is of type parallel::shared::Triangulation&lt;dim1,spacedim&gt;. An exception is thrown if you use an immersed parallel::distributed::Triangulation&lt;dim1,spacedim&gt;.</p>
<p>See the tutorial program step-60 for an example on how to use this function. </p>

</div>
</div>
<a id="ad9a75bda48830793be89ef84020d8d27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a75bda48830793be89ef84020d8d27">&#9670;&nbsp;</a></span>create_coupling_sparsity_pattern() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim0, int dim1, int spacedim, typename Sparsity , typename number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NonMatching::create_coupling_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sparsity &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>space_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>immersed_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim1,&#160;spacedim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but takes an additional <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object, instead of creating one internally. In this version of the function, the parameter <code>space_mapping</code> cannot be specified, since it is taken from the <code>cache</code> parameter. </p>

</div>
</div>
<a id="ac3821491559b8a76af0be66736fe4c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3821491559b8a76af0be66736fe4c6f">&#9670;&nbsp;</a></span>create_coupling_mass_matrix() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim0, int dim1, int spacedim, typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NonMatching::create_coupling_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;Matrix::value_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>space_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>immersed_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim0,&#160;spacedim&#160;&gt;::mapping</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim1,&#160;spacedim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coupling mass matrix for non-matching, overlapping grids.</p>
<p>Given two non-matching triangulations, representing the domains \(\Omega\) and \(B\), with \(B \subseteq \Omega\), and two finite element spaces \(V(\Omega) = \text{span}\{v_i\}_{i=0}^n\) and \(Q(B) = \text{span}\{w_j\}_{j=0}^m\), compute the coupling matrix </p><p class="formulaDsp">
\[ M_{ij} \dealcoloneq \int_{B} v_i(x) w_j(x) dx, \quad i \in [0,n), j \in [0,m), \]
</p>
<p> where \(V(\Omega)\) is the finite element space associated with the <code>space_dh</code> passed to this function (or part of it, if specified in <code>space_comps</code>), while \(Q(B)\) is the finite element space associated with the <code>immersed_dh</code> passed to this function (or part of it, if specified in <code>immersed_comps</code>).</p>
<p>The corresponding sparsity patterns can be computed by calling the make_coupling_sparsity_pattern function. The elements of the matrix are computed by locating the position of quadrature points defined on elements of \(B\) with respect to the embedding triangulation \(\Omega\).</p>
<p>The <code>space_comps</code> and <code>immersed_comps</code> masks are assumed to be ordered in the same way: the first component of <code>space_comps</code> will couple with the first component of <code>immersed_comps</code>, the second with the second, and so on. If one of the two masks has more non-zero entries non-zero than the other, then the excess components will be ignored.</p>
<p>If the domain \(B\) does not fall within \(\Omega\), an exception will be thrown by the algorithm that computes the quadrature point locations. In particular, notice that this function only makes sense for <code>dim1</code> lower or equal than <code>dim0</code>. A static assert guards that this is actually the case.</p>
<p>For both spaces, it is possible to specify a custom <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a>, which defaults to <a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a> for both.</p>
<p>This function will also work in parallel, provided that the immersed triangulation is of type parallel::shared::Triangulation&lt;dim1,spacedim&gt;. An exception is thrown if you use an immersed parallel::distributed::Triangulation&lt;dim1,spacedim&gt;.</p>
<p>See the tutorial program step-60 for an example on how to use this function. </p>

</div>
</div>
<a id="a009cf4da137d69c3bd0e00a2f89ba513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009cf4da137d69c3bd0e00a2f89ba513">&#9670;&nbsp;</a></span>create_coupling_mass_matrix() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim0, int dim1, int spacedim, typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NonMatching::create_coupling_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>space_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;Matrix::value_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>space_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>immersed_comps</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>immersed_mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;&#160;dim1,&#160;spacedim&#160;&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but takes an additional <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a> object, instead of creating one internally. In this version of the function, the parameter <code>space_mapping</code> cannot specified, since it is taken from the <code>cache</code> parameter. </p>

</div>
</div>
<a id="a6e7f345fdc3634974cfeeea99d084d7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7f345fdc3634974cfeeea99d084d7a">&#9670;&nbsp;</a></span>create_coupling_sparsity_pattern() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim0, int dim1, int spacedim, typename Sparsity , typename Number  = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NonMatching::create_coupling_sparsity_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quad</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Sparsity &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints0</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;Number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>comps0</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>comps1</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coupling sparsity pattern for non-matching independent grids, using a convolution kernel with compact support of radius epsilon.</p>
<p>Given two non-matching triangulations, representing the domains \(\Omega^0\) and \(\Omega^1\), both embedded in \(\mathbb{R}^d\), and two finite element spaces \(V^0(\Omega^0) = \text{span}\{v_i\}_{i=0}^n\) and \(V^1(\Omega^1) = \text{span}\{w_\alpha\}_{\alpha=0}^m\), compute the sparsity pattern that would be necessary to assemble the matrix</p>
<p class="formulaDsp">
\[ M_{i\alpha} \dealcoloneq \int_{\Omega^0} \int_{\Omega^1} v_i(x) K^{\epsilon}(x-y) w_\alpha(y) dx \ dy, \quad i \in [0,n), \alpha \in [0,m), \]
</p>
<p>where \(V^0(\Omega^0)\) is the finite element space associated with the <code>dh0</code> passed to this function (or part of it, if specified in <code>comps0</code>), while \(V^1(\Omega^1)\) is the finite element space associated with the <code>dh1</code> passed to this function (or part of it, if specified in <code>comps1</code>), and \(K^\epsilon\) is a function derived from CutOffFunctionBase with compact support included in a ball of radius \(\epsilon\).</p>
<p>The <code>comps0</code> and <code>comps1</code> masks are assumed to be ordered in the same way: the first component of <code>comps0</code> will couple with the first component of <code>comps1</code>, the second with the second, and so on. If one of the two masks has more active components than the other, then the excess components will be ignored.</p>
<p>For both spaces, it is possible to specify a custom <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a>, which defaults to <a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a> for both.</p>
<p>This function will also work in parallel, provided that at least one of the triangulations is of type parallel::shared::Triangulation&lt;dim1,spacedim&gt;. An exception is thrown if both triagnulations are of type parallel::distributed::Triangulation&lt;dim1,spacedim&gt;.</p>
<p>This function assumes that the convolution has support contained in a box of radius <code>epsilon</code>. If epsilon is set to zero, then we assume that the kernel is the Dirac delta distribution, and the call is forwarded to the method in this namespace with the same name, that does not take an epsilon as input (but a quadrature formula <code>quad</code> is required). In this case, more restrictive conditions are required on the two spaces. See the documentation of the other <a class="el" href="namespaceNonMatching.html#a8829bfa8e55c21b8eeaafd086c53680d">create_coupling_sparsity_pattern()</a> function. </p>

</div>
</div>
<a id="a8cdb0c9f16edb5531e3087e48ce7b862"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cdb0c9f16edb5531e3087e48ce7b862">&#9670;&nbsp;</a></span>create_coupling_mass_matrix() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim0, int dim1, int spacedim, typename Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void NonMatching::create_coupling_mass_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFunctions_1_1CutOffFunctionBase.html">Functions::CutOffFunctionBase</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>kernel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td>
          <td class="paramname"><em>epsilon</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classGridTools_1_1Cache.html">GridTools::Cache</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim0, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim0 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Matrix::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints0</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;Matrix::value_type&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>comps0</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>comps1</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a coupling mass matrix for non-matching independent grids, using a convolution kernel with compact support.</p>
<p>Given two non-matching triangulations, representing the domains \(\Omega^0\) and \(\Omega^1\), both embedded in \(\mathbb{R}^d\), and two finite element spaces \(V^0(\Omega^0) = \text{span}\{v_i\}_{i=0}^n\) and \(V^1(\Omega^1) = \text{span}\{w_\alpha\}_{\alpha=0}^m\), compute the matrix</p>
<p class="formulaDsp">
\[ M_{i\alpha} \dealcoloneq \int_{\Omega^0} \int_{\Omega^1} v_i(x) K^{\epsilon}(x-y) w_\alpha(y) dx \ dy, \quad i \in [0,n), \alpha \in [0,m), \]
</p>
<p>where \(V^0(\Omega^0)\) is the finite element space associated with the <code>dh0</code> passed to this function (or part of it, if specified in <code>comps0</code>), while \(V^1(\Omega^1)\) is the finite element space associated with the <code>dh1</code> passed to this function (or part of it, if specified in <code>comps1</code>), and \(K^\epsilon\) is a function derived from CutOffFunctionBase with compact support included in a ball of radius \(\epsilon\).</p>
<p>The corresponding sparsity patterns can be computed by calling the make_coupling_sparsity_pattern() function.</p>
<p>The <code>comps0</code> and <code>comps1</code> masks are assumed to be ordered in the same way: the first component of <code>comps0</code> will couple with the first component of <code>comps1</code>, the second with the second, and so on. If one of the two masks has more active components than the other, then the excess components will be ignored.</p>
<p>For both spaces, it is possible to specify a custom <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a>, which defaults to <a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a> for both.</p>
<p>This function will also work in parallel, provided that one of the two triangulations is of type parallel::shared::Triangulation&lt;dim1,spacedim&gt;. An exception is thrown if both triangulations are of type parallel::distributed::Triangulation&lt;dim1,spacedim&gt;.</p>
<p>The parameter <code>epsilon</code> is used to set the size of the cut-off function used to compute the convolution. If epsilon is set to zero, then we assume that the kernel is the Dirac delta distribution, and the call is forwarded to the method in this namespace with the same name, that does not take an epsilon as input. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
