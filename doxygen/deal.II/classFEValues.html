<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFEValues.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FEValues&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFEValues-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEValues&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">deal.II/fe/fe.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FEValues&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFEValues__inherit__graph.svg" width="218" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a051be8559fb1a35dff1ba230864d94b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a051be8559fb1a35dff1ba230864d94b3">FEValues</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a5502d4cd55c37491d1f89e41285fc7e5">mapping</a>, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a051be8559fb1a35dff1ba230864d94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e29a8987e36c016fa9e5c5ad68f0fda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a6e29a8987e36c016fa9e5c5ad68f0fda">FEValues</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a5502d4cd55c37491d1f89e41285fc7e5">mapping</a>, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a6e29a8987e36c016fa9e5c5ad68f0fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f982108aa0d834923a57fa328d1c7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a80f982108aa0d834923a57fa328d1c7e">FEValues</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a80f982108aa0d834923a57fa328d1c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb7498746ed379c23466e9de536c319"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a5eb7498746ed379c23466e9de536c319">FEValues</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a5eb7498746ed379c23466e9de536c319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f914e63d588e2652a9514620653d77"><td class="memTemplParams" colspan="2">template&lt;bool level_dof_access&gt; </td></tr>
<tr class="memitem:a21f914e63d588e2652a9514620653d77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;cell)</td></tr>
<tr class="separator:a21f914e63d588e2652a9514620653d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5f1445edcf7964ad66554b804dfa4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a8a5f1445edcf7964ad66554b804dfa4c">reinit</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a8a5f1445edcf7964ad66554b804dfa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae053b49309f1dce22268c6bc8fe50cb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a> () const</td></tr>
<tr class="separator:ae053b49309f1dce22268c6bc8fe50cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af649ad9baf7e58a6d43e266dec5523d9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#af649ad9baf7e58a6d43e266dec5523d9">memory_consumption</a> () const</td></tr>
<tr class="separator:af649ad9baf7e58a6d43e266dec5523d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902429920d32c81c9c279d9a15faa263"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a> () const</td></tr>
<tr class="separator:a902429920d32c81c9c279d9a15faa263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d2970cb77d5947ea056d8a6ed6a971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55d2970cb77d5947ea056d8a6ed6a971">DeclException1</a> (ExcAccessToUninitializedField, std::string,&lt;&lt; &quot;You are requesting information from an <a class="el" href="classFEValues.html">FEValues</a>/<a class="el" href="classFEFaceValues.html">FEFaceValues</a>/<a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> &quot;&lt;&lt; &quot;object for which this kind of information has not been computed. What &quot;&lt;&lt; &quot;information these objects compute is determined by the update_* flags you &quot;&lt;&lt; &quot;pass to the constructor. Here, the operation you are attempting requires &quot;&lt;&lt; &quot;the &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; flag to be set, but it was apparently not specified &quot;&lt;&lt; &quot;upon construction.&quot;)</td></tr>
<tr class="separator:ga55d2970cb77d5947ea056d8a6ed6a971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4ee91a4333e56c9c3251aa676663ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3c4ee91a4333e56c9c3251aa676663ca">DeclException1</a> (ExcShapeFunctionNotPrimitive, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The shape function with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not primitive, i.e. it is vector-valued and &quot;&lt;&lt; &quot;has more than one non-zero vector component. This &quot;&lt;&lt; &quot;function cannot be called for these shape functions. &quot;&lt;&lt; &quot;Maybe you want to use the same function with the &quot;&lt;&lt; &quot;_component suffix?&quot;)</td></tr>
<tr class="separator:ga3c4ee91a4333e56c9c3251aa676663ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87028ad3b58f711faf692703612ac20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf87028ad3b58f711faf692703612ac20">DeclExceptionMsg</a> (ExcFEDontMatch, &quot;The <a class="el" href="classFiniteElement.html">FiniteElement</a> you provided to <a class="el" href="classFEValues.html">FEValues</a> and the <a class="el" href="classFiniteElement.html">FiniteElement</a> that belongs &quot; &quot;to the <a class="el" href="classDoFHandler.html">DoFHandler</a> that provided the cell iterator do not match.&quot;)</td></tr>
<tr class="separator:gaf87028ad3b58f711faf692703612ac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b64d2082d3b7f42c537ca121098066d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0b64d2082d3b7f42c537ca121098066d">DeclExceptionMsg</a> (ExcFENotPrimitive, &quot;The given <a class="el" href="classFiniteElement.html">FiniteElement</a> is not a primitive element but the requested operation &quot; &quot;only works for those. See <a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">FiniteElement::is_primitive</a>() for more information.&quot;)</td></tr>
<tr class="separator:ga0b64d2082d3b7f42c537ca121098066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to shape function values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These fields are filled by the finite element. </p>
</div></td></tr>
<tr class="memitem:a1dd48cb744013c448d57f8f77640c08d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const</td></tr>
<tr class="separator:a1dd48cb744013c448d57f8f77640c08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57a7e777b0798ec009b4ce888ad9574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:aa57a7e777b0798ec009b4ce888ad9574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aefdb527125dafb59dcba92a0f256e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a46aefdb527125dafb59dcba92a0f256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e93aa182f3acd34abd020538f3bc39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a71e93aa182f3acd34abd020538f3bc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a37e5067b9fd879752048bc2d77d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a83a37e5067b9fd879752048bc2d77d42">shape_hessian</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const</td></tr>
<tr class="separator:a83a37e5067b9fd879752048bc2d77d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847929f632ae57b4305e9dca7270389a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a847929f632ae57b4305e9dca7270389a">shape_hessian_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a847929f632ae57b4305e9dca7270389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99ebb836476c7b72c0cd2ca3594827b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad99ebb836476c7b72c0cd2ca3594827b">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const</td></tr>
<tr class="separator:ad99ebb836476c7b72c0cd2ca3594827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77234bc51dd64a24880bb50c834bb210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a77234bc51dd64a24880bb50c834bb210">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a77234bc51dd64a24880bb50c834bb210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to values of global finite element fields</div></td></tr>
<tr class="memitem:a357b422e374f2f2207af3512093f3907"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a357b422e374f2f2207af3512093f3907"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; typename InputVector::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:a357b422e374f2f2207af3512093f3907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8756b2e6e63977f37a3f26fdf83a7be"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ac8756b2e6e63977f37a3f26fdf83a7be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac8756b2e6e63977f37a3f26fdf83a7be">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:ac8756b2e6e63977f37a3f26fdf83a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378b552c1b8ca9f23f89677910e7a5cd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a378b552c1b8ca9f23f89677910e7a5cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a378b552c1b8ca9f23f89677910e7a5cd">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; typename InputVector::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:a378b552c1b8ca9f23f89677910e7a5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cee3d4c01d14d74be02a797650f561f"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a5cee3d4c01d14d74be02a797650f561f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5cee3d4c01d14d74be02a797650f561f">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a5cee3d4c01d14d74be02a797650f561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f91fd23806e90bfe74b7446b835210"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ad0f91fd23806e90bfe74b7446b835210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad0f91fd23806e90bfe74b7446b835210">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; typename InputVector::value_type &gt;&gt; values, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest) const</td></tr>
<tr class="separator:ad0f91fd23806e90bfe74b7446b835210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to derivatives of global finite element fields</div></td></tr>
<tr class="memitem:ad1f4e0deb5d982e8172d82141c634a67"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ad1f4e0deb5d982e8172d82141c634a67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:ad1f4e0deb5d982e8172d82141c634a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae991c7d48b60b228897a91a00bd6900d"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae991c7d48b60b228897a91a00bd6900d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae991c7d48b60b228897a91a00bd6900d">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:ae991c7d48b60b228897a91a00bd6900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ed70ad8baff761b1232bc111a00ffd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aa9ed70ad8baff761b1232bc111a00ffd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa9ed70ad8baff761b1232bc111a00ffd">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:aa9ed70ad8baff761b1232bc111a00ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4213cb7edc4788d42a923af0d5a563"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aef4213cb7edc4788d42a923af0d5a563"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aef4213cb7edc4788d42a923af0d5a563">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt; gradients, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:aef4213cb7edc4788d42a923af0d5a563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to second derivatives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Hessian matrices and Laplacians of global finite element fields </p>
</div></td></tr>
<tr class="memitem:ae8f183c9d6da0c7daf9d345e0bc91b0a"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae8f183c9d6da0c7daf9d345e0bc91b0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;hessians) const</td></tr>
<tr class="separator:ae8f183c9d6da0c7daf9d345e0bc91b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d80068005cd1283597e2e3f092864b3"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a4d80068005cd1283597e2e3f092864b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a4d80068005cd1283597e2e3f092864b3">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;hessians, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a4d80068005cd1283597e2e3f092864b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac081e64d8a7f72f36bc87ee100f623dc"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ac081e64d8a7f72f36bc87ee100f623dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac081e64d8a7f72f36bc87ee100f623dc">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;hessians) const</td></tr>
<tr class="separator:ac081e64d8a7f72f36bc87ee100f623dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0090df9b494c98f66c6db4cacc27502b"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a0090df9b494c98f66c6db4cacc27502b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a0090df9b494c98f66c6db4cacc27502b">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt; hessians, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a0090df9b494c98f66c6db4cacc27502b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; typename InputVector::value_type &gt; &amp;laplacians) const</td></tr>
<tr class="separator:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fb3cd3ffccb0f0a7b2454601428f0c"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a08fb3cd3ffccb0f0a7b2454601428f0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a08fb3cd3ffccb0f0a7b2454601428f0c">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;laplacians) const</td></tr>
<tr class="separator:a08fb3cd3ffccb0f0a7b2454601428f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062e419bf95dc7e6f83dcf1e0eeeedd7"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a062e419bf95dc7e6f83dcf1e0eeeedd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a062e419bf95dc7e6f83dcf1e0eeeedd7">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; typename InputVector::value_type &gt; &amp;laplacians) const</td></tr>
<tr class="separator:a062e419bf95dc7e6f83dcf1e0eeeedd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad192d491d4dad2bdea26c8e1c0a9ab1"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aad192d491d4dad2bdea26c8e1c0a9ab1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aad192d491d4dad2bdea26c8e1c0a9ab1">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;laplacians) const</td></tr>
<tr class="separator:aad192d491d4dad2bdea26c8e1c0a9ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced6912ea4c1324431f504b407cc2745"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aced6912ea4c1324431f504b407cc2745"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aced6912ea4c1324431f504b407cc2745">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; std::vector&lt; typename InputVector::value_type &gt;&gt; &amp;laplacians, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:aced6912ea4c1324431f504b407cc2745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to third derivatives of global finite element fields</div></td></tr>
<tr class="memitem:a07414796ef13160769987e6e252f3d1f"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a07414796ef13160769987e6e252f3d1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a07414796ef13160769987e6e252f3d1f">get_function_third_derivatives</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;third_derivatives) const</td></tr>
<tr class="separator:a07414796ef13160769987e6e252f3d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa181bd794cd9e423b70f87b41309bd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:abaa181bd794cd9e423b70f87b41309bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abaa181bd794cd9e423b70f87b41309bd">get_function_third_derivatives</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;third_derivatives, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:abaa181bd794cd9e423b70f87b41309bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9220827b037d7b44fba1e36e56f2e810"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9220827b037d7b44fba1e36e56f2e810"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9220827b037d7b44fba1e36e56f2e810">get_function_third_derivatives</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;third_derivatives) const</td></tr>
<tr class="separator:a9220827b037d7b44fba1e36e56f2e810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7fe4012e770f17e192ae4ded255cb7"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a3c7fe4012e770f17e192ae4ded255cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3c7fe4012e770f17e192ae4ded255cb7">get_function_third_derivatives</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt; third_derivatives, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a3c7fe4012e770f17e192ae4ded255cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell degrees of freedom</div></td></tr>
<tr class="memitem:a93872d888911cda7e2e716168afc1b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a> () const</td></tr>
<tr class="separator:a93872d888911cda7e2e716168afc1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe8baa6858e3edb5a1f0190fc3f85e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7dfe8baa6858e3edb5a1f0190fc3f85e">dof_indices_starting_at</a> (const unsigned <a class="el" href="classint.html">int</a> start_dof_index) const</td></tr>
<tr class="separator:a7dfe8baa6858e3edb5a1f0190fc3f85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4ca7b33a291c07d9c155ccbf314d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3a4ca7b33a291c07d9c155ccbf314d5f">dof_indices_ending_at</a> (const unsigned <a class="el" href="classint.html">int</a> end_dof_index) const</td></tr>
<tr class="separator:a3a4ca7b33a291c07d9c155ccbf314d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry of the cell</div></td></tr>
<tr class="memitem:aada8380792b5e6a1f91dcba94b558cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a> () const</td></tr>
<tr class="separator:aada8380792b5e6a1f91dcba94b558cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123e5da03736be4977c76fbcb6a2e37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (const unsigned <a class="el" href="classint.html">int</a> q) const</td></tr>
<tr class="separator:ab123e5da03736be4977c76fbcb6a2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b67cfd48e02f6035e39c84f0fb47a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a> () const</td></tr>
<tr class="separator:ae41b67cfd48e02f6035e39c84f0fb47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abade89efb068b71b7ced7082012a2441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:abade89efb068b71b7ced7082012a2441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371618d5977d28dfe82c81fbac29c0f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> () const</td></tr>
<tr class="separator:a7371618d5977d28dfe82c81fbac29c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abe3ffe1b14b2472093b4d95b09b76f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6abe3ffe1b14b2472093b4d95b09b76f">jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a6abe3ffe1b14b2472093b4d95b09b76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb95b09ced1230e1f29ce993eedb1ccf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acb95b09ced1230e1f29ce993eedb1ccf">get_jacobians</a> () const</td></tr>
<tr class="separator:acb95b09ced1230e1f29ce993eedb1ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b8b21f05fe45701ce5d71e8952d893"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a24b8b21f05fe45701ce5d71e8952d893">jacobian_grad</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a24b8b21f05fe45701ce5d71e8952d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d228651f45f5e9a8d787d2137e71e86"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9d228651f45f5e9a8d787d2137e71e86">get_jacobian_grads</a> () const</td></tr>
<tr class="separator:a9d228651f45f5e9a8d787d2137e71e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d9388afa7d9ee1266d824b37fbff27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab7d9388afa7d9ee1266d824b37fbff27">jacobian_pushed_forward_grad</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:ab7d9388afa7d9ee1266d824b37fbff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5819f15c0e821762a0abc60fc77ddd54"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5819f15c0e821762a0abc60fc77ddd54">get_jacobian_pushed_forward_grads</a> () const</td></tr>
<tr class="separator:a5819f15c0e821762a0abc60fc77ddd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aed77844d697d26e19cf0e9e6891351"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 3, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5aed77844d697d26e19cf0e9e6891351">jacobian_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a5aed77844d697d26e19cf0e9e6891351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa784c826743ed3a66e178a9260b040be"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 3, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa784c826743ed3a66e178a9260b040be">get_jacobian_2nd_derivatives</a> () const</td></tr>
<tr class="separator:aa784c826743ed3a66e178a9260b040be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c0f9a8b40a506ef6746da258f93c32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 4, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad3c0f9a8b40a506ef6746da258f93c32">jacobian_pushed_forward_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:ad3c0f9a8b40a506ef6746da258f93c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9be9ddf679019e37e9d3474d893f3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abb9be9ddf679019e37e9d3474d893f3a">get_jacobian_pushed_forward_2nd_derivatives</a> () const</td></tr>
<tr class="separator:abb9be9ddf679019e37e9d3474d893f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747bbb82f8bf29b762253778d2c0839"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 4, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2747bbb82f8bf29b762253778d2c0839">jacobian_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a2747bbb82f8bf29b762253778d2c0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae391823baf3ecd0792a867c0b031aa62"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 4, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae391823baf3ecd0792a867c0b031aa62">get_jacobian_3rd_derivatives</a> () const</td></tr>
<tr class="separator:ae391823baf3ecd0792a867c0b031aa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6683da072e8135a4e423894457f2782"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 5, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac6683da072e8135a4e423894457f2782">jacobian_pushed_forward_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:ac6683da072e8135a4e423894457f2782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf9ada77adee2b864e57dda00e25339"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 5, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#adcf9ada77adee2b864e57dda00e25339">get_jacobian_pushed_forward_3rd_derivatives</a> () const</td></tr>
<tr class="separator:adcf9ada77adee2b864e57dda00e25339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539d494cab9b9f2a9d6fd8e78c9666e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:aa539d494cab9b9f2a9d6fd8e78c9666e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bfab60e48072979414b34bbbce4418"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a52bfab60e48072979414b34bbbce4418">get_inverse_jacobians</a> () const</td></tr>
<tr class="separator:a52bfab60e48072979414b34bbbce4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25ec6835799c3b6c7c842f8acb05eb3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ac25ec6835799c3b6c7c842f8acb05eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80d39b9aea51af573ded84342b8b330d"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a80d39b9aea51af573ded84342b8b330d">get_normal_vectors</a> () const</td></tr>
<tr class="separator:a80d39b9aea51af573ded84342b8b330d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extractors Methods to extract individual components</div></td></tr>
<tr class="memitem:a7670d68d12957e0ca99569a17c63efb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7670d68d12957e0ca99569a17c63efb2">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7670d68d12957e0ca99569a17c63efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb48e1d06471efe7835f827f3c315a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3bb48e1d06471efe7835f827f3c315a3">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a3bb48e1d06471efe7835f827f3c315a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfcef98b4371fe0ccc2e5da644cef1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1SymmetricTensor.html">FEValuesViews::SymmetricTensor</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8bfcef98b4371fe0ccc2e5da644cef1f">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;tensor) const</td></tr>
<tr class="separator:a8bfcef98b4371fe0ccc2e5da644cef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af092b17057ebfeeba90ac58f9205bc86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Tensor.html">FEValuesViews::Tensor</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af092b17057ebfeeba90ac58f9205bc86">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;tensor) const</td></tr>
<tr class="separator:af092b17057ebfeeba90ac58f9205bc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to the raw data</div></td></tr>
<tr class="memitem:adcc1b936b41b758dad7ddae21c71f14c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#adcc1b936b41b758dad7ddae21c71f14c">get_mapping</a> () const</td></tr>
<tr class="separator:adcc1b936b41b758dad7ddae21c71f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22ffd9fb5b07842daa504929244aa7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a> () const</td></tr>
<tr class="separator:ade22ffd9fb5b07842daa504929244aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b258a1619829f7ec03a184ffb8e556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a55b258a1619829f7ec03a184ffb8e556">get_update_flags</a> () const</td></tr>
<tr class="separator:a55b258a1619829f7ec03a184ffb8e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d3a1c53c139e2553b672de682d6233e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9d3a1c53c139e2553b672de682d6233e">get_cell</a> () const</td></tr>
<tr class="separator:a9d3a1c53c139e2553b672de682d6233e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808af56bde1d82893b88875dc651e749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a808af56bde1d82893b88875dc651e749">get_cell_similarity</a> () const</td></tr>
<tr class="separator:a808af56bde1d82893b88875dc651e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a></td></tr>
<tr class="separator:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f8b164f3fa6f25982c8a52fefe0995"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af4f8b164f3fa6f25982c8a52fefe0995">max_n_quadrature_points</a></td></tr>
<tr class="separator:af4f8b164f3fa6f25982c8a52fefe0995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a></td></tr>
<tr class="separator:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a627033acd32f5d22a4bb82444267a240"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a627033acd32f5d22a4bb82444267a240">integral_dimension</a> = dim</td></tr>
<tr class="separator:a627033acd32f5d22a4bb82444267a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd889a38bbce8ea33d46d152f14abdd3"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afd889a38bbce8ea33d46d152f14abdd3">dimension</a> = dim</td></tr>
<tr class="separator:afd889a38bbce8ea33d46d152f14abdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541820cb52f78a4d43de18be0352002"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6541820cb52f78a4d43de18be0352002">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a6541820cb52f78a4d43de18be0352002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaf01126d2e3b926fecbaf122357add53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aaf01126d2e3b926fecbaf122357add53">invalidate_present_cell</a> ()</td></tr>
<tr class="separator:aaf01126d2e3b926fecbaf122357add53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed652da6ec16e368e27da4085b4281bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aed652da6ec16e368e27da4085b4281bb">maybe_invalidate_previous_present_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:aed652da6ec16e368e27da4085b4281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1352ba7f04525e175d2c6fa552a1c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa1352ba7f04525e175d2c6fa552a1c6a">compute_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>) const</td></tr>
<tr class="separator:aa1352ba7f04525e175d2c6fa552a1c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5c38a7d7c3a6b384ad5b46f38248524d">check_cell_similarity</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acf87f79b7e82e60650bc9227deb6aeb9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const <a class="el" href="classFEValuesBase_1_1CellIteratorBase.html">CellIteratorBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acf87f79b7e82e60650bc9227deb6aeb9">present_cell</a></td></tr>
<tr class="separator:acf87f79b7e82e60650bc9227deb6aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7274f2ea9bbe0ea61bd983c5746ffef"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa7274f2ea9bbe0ea61bd983c5746ffef">tria_listener_refinement</a></td></tr>
<tr class="separator:aa7274f2ea9bbe0ea61bd983c5746ffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f853782c9ba1f6c4093f64ede145253"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2f853782c9ba1f6c4093f64ede145253">tria_listener_mesh_transform</a></td></tr>
<tr class="separator:a2f853782c9ba1f6c4093f64ede145253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502d4cd55c37491d1f89e41285fc7e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5502d4cd55c37491d1f89e41285fc7e5">mapping</a></td></tr>
<tr class="separator:a5502d4cd55c37491d1f89e41285fc7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2786d839ac016cd2181c1a2acf7b755"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa2786d839ac016cd2181c1a2acf7b755">mapping_data</a></td></tr>
<tr class="separator:aa2786d839ac016cd2181c1a2acf7b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa26fda7aba97298344ab95b4753ac"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9faa26fda7aba97298344ab95b4753ac">mapping_output</a></td></tr>
<tr class="separator:a9faa26fda7aba97298344ab95b4753ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67500f1f0d3d40e014e562d375f911f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a></td></tr>
<tr class="separator:a67500f1f0d3d40e014e562d375f911f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73456971913b569cfb5d79dc827e9bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae73456971913b569cfb5d79dc827e9bc">fe_data</a></td></tr>
<tr class="separator:ae73456971913b569cfb5d79dc827e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8644fa994116af02667ddd6517ae3"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acfc8644fa994116af02667ddd6517ae3">finite_element_output</a></td></tr>
<tr class="separator:acfc8644fa994116af02667ddd6517ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ed91bcc8004390e372704d63177162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a></td></tr>
<tr class="separator:a63ed91bcc8004390e372704d63177162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096d4ea9edea6618e23f5f13ab40784c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a096d4ea9edea6618e23f5f13ab40784c">cell_similarity</a></td></tr>
<tr class="separator:a096d4ea9edea6618e23f5f13ab40784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a887641164e5e42d1c2300e552b6edcbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a887641164e5e42d1c2300e552b6edcbd">initialize</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a887641164e5e42d1c2300e552b6edcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244db200d87403103119e3d62872745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a1244db200d87403103119e3d62872745">do_reinit</a> ()</td></tr>
<tr class="separator:a1244db200d87403103119e3d62872745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a50edb536baf30f637a51203f0e73d15e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a></td></tr>
<tr class="separator:a50edb536baf30f637a51203f0e73d15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class FEValues&lt; dim, spacedim &gt;</h3>

<p>在单元格的正交点上评估的有限元。 这个函数实现了FEValuesBase的初始化程序，如果需要以单元格的正交点为单位的值。更多的文件请看这个类。 </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00039">39</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a051be8559fb1a35dff1ba230864d94b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051be8559fb1a35dff1ba230864d94b3">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。从映射和有限元对象中获取单元独立数据，匹配正交规则和更新标志。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04342">4342</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a6e29a8987e36c016fa9e5c5ad68f0fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e29a8987e36c016fa9e5c5ad68f0fda">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但取一个正交规则的集合。 </p><dl class="section note"><dt>Note</dt><dd>与FEFaceValues相反，我们要求集合中正交规则的数量为1。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04359">4359</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a80f982108aa0d834923a57fa328d1c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f982108aa0d834923a57fa328d1c7e">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。这个构造函数除了使对象隐含地使用 \(Q_1\) 映射（即MappingQGeneric(1)类型的对象）外，与其他构造函数是等价的。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04371">4371</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a5eb7498746ed379c23466e9de536c319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb7498746ed379c23466e9de536c319">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但取一个正交规则的集合。 </p><dl class="section note"><dt>Note</dt><dd>与FEFaceValues相反，我们要求集合中的正交规则的数量为1。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04388">4388</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a21f914e63d588e2652a9514620653d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f914e63d588e2652a9514620653d77">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;bool lda&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dim, spacedim, lda &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>重新初始化类型为 "iterator into a DoFHandler object
"的给定单元的梯度、雅各比行列式等，以及与此对象相关的有限元。假设给定单元所使用的有限元也是这个FEValues对象所使用的有限元。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04515">4515</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a8a5f1445edcf7964ad66554b804dfa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5f1445edcf7964ad66554b804dfa4c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>重新初始化梯度、雅可比行列式等，用于给定类型为 "进入三角测量对象的迭代器
"的单元和给定的有限元。由于进入三角剖分的迭代器只传递单元的几何信息，而不传递可能与此单元相关的自由度的信息，所以如果需要自由度的信息，你将无法调用这一类的一些函数。这些函数首先是<code>get_function_value/gradients/hessians/laplacians/third_derivatives</code>函数。如果你想调用这些函数，你必须调用 <code>reinit变体，将迭代器带入DoFHandler或其他DoF处理程序类型对象。</code> </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04485">4485</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ae053b49309f1dce22268c6bc8fe50cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae053b49309f1dce22268c6bc8fe50cb2">&#9670;&nbsp;</a></span>get_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt;&amp; <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::get_quadrature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对该对象所存储的正交公式副本的引用。 </p>

</div>
</div>
<a id="af649ad9baf7e58a6d43e266dec5523d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af649ad9baf7e58a6d43e266dec5523d9">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定此对象的内存消耗（以字节为单位）的估计值。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04583">4583</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a902429920d32c81c9c279d9a15faa263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902429920d32c81c9c279d9a15faa263">&#9670;&nbsp;</a></span>get_present_fe_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValues.html">FEValues</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::get_present_fe_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对这个非常对象的引用。 虽然看起来不是很有用，但是这个函数的存在是为了给 <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> 类提供能力，在这种情况下，它提供了当前单元的FEValues对象（记住，对于hp-finite元素，实际使用的FE对象可能会在不同的单元之间变化，所以我们也需要不同的FEValues对象用于不同的单元；一旦你重新初始化了 <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> ]对象，它就会为该单元格的FE检索FEValues对象，并通过与此相同的函数返回；因此，这里的这个函数只提供相同的接口，以便人们可以对FEValues和 <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a>). 进行模板化。 </p>

</div>
</div>
<a id="a887641164e5e42d1c2300e552b6edcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887641164e5e42d1c2300e552b6edcbd">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>做两个构造函数的共同工作。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04400">4400</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a1244db200d87403103119e3d62872745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1244db200d87403103119e3d62872745">&#9670;&nbsp;</a></span>do_reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a>函数只做需要了解迭代器类型的那部分工作。在设置完present_cell()后，它们会传递给这个函数，这个函数做真正的工作，而且与单元格迭代器的实际类型无关。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04549">4549</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a1dd48cb744013c448d57f8f77640c08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd48cb744013c448d57f8f77640c08d">&#9670;&nbsp;</a></span>shape_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdouble.html">double</a>&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>派生类的<code>reinit</code>函数最后一次被调用时选择的单元格、面或子面的正交点上的形状函数的值。 如果形状函数是矢量值，那么这将返回唯一的非零分量。如果形状函数有一个以上的非零分量（也就是说，它不是原始的），那么抛出一个ExcShapeFunctionNotPrimitive类型的异常。在这种情况下，使用 <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> 函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>要被评估的形状函数的数字。请注意，这个数字从零到dofs_per_cell，即使是在FEFaceValues或FESubfaceValues对象的情况下。 </td></tr>
    <tr><td class="paramname">point_no</td><td>要评估函数的正交点的数目 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. 。 </dd></dl>

</div>
</div>
<a id="aa57a7e777b0798ec009b4ce888ad9574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57a7e777b0798ec009b4ce888ad9574">&#9670;&nbsp;</a></span>shape_value_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个正交点的形状函数值的一个向量分量。如果有限元是标量的，那么只允许零分量，返回值等于shape_value()函数的值。如果有限元是矢量值的，但所有形状函数都是原始的（即它们只有一个分量是非零的），那么shape_value()返回的值正好等于这个函数的一个分量。因此，只有在形状函数不是基元的情况下，这个函数才更有意义，但此时它是必要的，因为其他函数不能被使用。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>要评估的形状函数的编号。 </td></tr>
    <tr><td class="paramname">point_no</td><td>要评估函数的正交点的编号。 </td></tr>
    <tr><td class="paramname">component</td><td>要评估的向量分量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a46aefdb527125dafb59dcba92a0f256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aefdb527125dafb59dcba92a0f256e">&#9670;&nbsp;</a></span>shape_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算<code>function_no</code>第1个形状函数在<code>quadrature_point</code>第1个正交点的梯度，相对于实际单元坐标。 如果你想得到其中一个坐标方向的导数，使用张量类的适当函数来提取这个函数返回的张量的一个分量。因为只返回对梯度值的引用，所以应该不会有大的性能缺陷。 如果形状函数是矢量值的，那么它返回唯一的非零分量。如果形状函数有一个以上的非零分量（即它不是原始的），那么它将抛出一个ExcShapeFunctionNotPrimitive类型的异常。在这种情况下，请使用 <a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">shape_grad_component()</a> 函数。 这个函数的参数与shape_value()函数的参数相同。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>要被评估的形状函数的编号。 </td></tr>
    <tr><td class="paramname">quadrature_point</td><td>要评估函数的正交点的数量。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a71e93aa182f3acd34abd020538f3bc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e93aa182f3acd34abd020538f3bc39">&#9670;&nbsp;</a></span>shape_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回形状函数在正交点的梯度的一个向量分量。如果有限元是标量的，那么只允许零分量，返回值等于shape_grad()函数的值。如果有限元是矢量值的，但所有形状函数都是原始的（即它们只有一个分量是非零的），那么shape_grad()返回的值就等于这个函数的一个分量。因此，只有在形状函数不是基元的情况下，这个函数才更有意义，但此时它是必要的，因为其他函数不能使用。 这个函数的参数与shape_value_component()函数的参数同样成立。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a83a37e5067b9fd879752048bc2d77d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a37e5067b9fd879752048bc2d77d42">&#9670;&nbsp;</a></span>shape_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>function_no</code>第1个形状函数在<code>point_no</code>第1个正交点相对于实际单元坐标的二次导数。如果你想得到其中一个坐标方向的导数，使用张量类的适当函数来提取一个分量。由于只返回对Hessian值的引用，应该不会有大的性能缺陷。 如果形状函数是矢量值的，那么这将返回唯一的非零分量。如果形状函数有一个以上的非零分量（即它不是原始的），那么抛出一个ExcShapeFunctionNotPrimitive类型的异常。在这种情况下，使用shape_hessian_component()函数。 这个函数的参数与shape_value()函数的参数相同。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a847929f632ae57b4305e9dca7270389a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847929f632ae57b4305e9dca7270389a">&#9670;&nbsp;</a></span>shape_hessian_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个正交点上的形状函数的 hessian 的一个向量分量。如果有限元是标量的，那么只允许零分量，返回值等于shape_hessian()函数的值。如果有限元是矢量的，但是所有的形状函数都是原始的（即它们只有一个分量是不为零的），那么shape_hessian()返回的值就等于这个函数的一个分量。因此，只有在形状函数不是原始函数的情况下，这个函数才更有意义，但此时它是必要的，因为其他函数不能使用。 这个函数的参数与shape_value_component()函数的参数同样成立。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ad99ebb836476c7b72c0cd2ca3594827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99ebb836476c7b72c0cd2ca3594827b">&#9670;&nbsp;</a></span>shape_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>function_no</code>第1个形状函数在<code>point_no</code>第1个正交点相对于实际单元坐标的3次导数。如果你想得到其中一个坐标方向的3阶导数，请使用张量类的适当函数来提取一个分量。由于只返回对三阶导数值的引用，应该不会有大的性能缺陷。 如果形状函数是矢量值的，那么这将返回唯一的非零分量。如果形状函数有一个以上的非零分量（即它不是原始的），那么抛出一个ExcShapeFunctionNotPrimitive类型的异常。在这种情况下，使用 shape_3rdderivative_component() 函数。 这个函数的参数与shape_value()函数的参数相同。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a77234bc51dd64a24880bb50c834bb210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77234bc51dd64a24880bb50c834bb210">&#9670;&nbsp;</a></span>shape_3rd_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个正交点的形状函数的三次导数的一个向量分量。如果有限元是标量的，那么只允许零分量，返回值等于shape_3rdderivative()函数的值。如果有限元是矢量值的，但所有形状函数都是原始的（即它们只有一个分量是非零的），那么shape_3rdderivative()返回的值就等于这个函数的一个分量。因此，只有在形状函数不是原始函数的情况下，这个函数才更有意义，但此时它是必要的，因为其他函数不能使用。 这个函数的参数与 <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> 函数的参数相同。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a357b422e374f2f2207af3512093f3907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b422e374f2f2207af3512093f3907">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回限制在当前单元、面或子面的有限元函数的值，这些单元、面或子面是在最后一次调用派生类的<code>reinit</code>函数时选择的正交点。 如果当前的单元没有被激活，那么数值将被内插到当前的单元，并从中计算出点值。 这个函数只能在使用的有限元是标量的情况下使用，即只有一个矢量分量。 为了获得多分量元素的值，下面有另一个get_function_values()，返回结果的向量的向量。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>一个值向量，描述（全局）该函数应在当前单元的正交点评估的有限元函数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>由fe_function指定的函数在当前单元的正交点的值。 假设该对象已经具有正确的大小。这个输出向量所存储的数据类型必须是当你将形状函数的值乘以用于存储你的有限元向量 \(U\) （由 <code>fe_function</code> 参数表示）的未知数的值的类型时得到的。这恰好等于解向量元素的类型。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> 将包含fe_function描述的场在 \(q\) 第三个正交点的值。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>输入矢量的实际数据类型可以是Vector&lt;T&gt;、BlockVector&lt;T&gt;或PETSc或Trilinos矢量包装类之一。它代表了与DoFHandler对象相关的全局DoF值的向量，这个FEValues对象最后被初始化。 </dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03523">3523</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ac8756b2e6e63977f37a3f26fdf83a7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8756b2e6e63977f37a3f26fdf83a7be">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与其他get_function_values()的作用相同，但应用于多分量（矢量值）元素。参数的含义如那里所解释。 </p><dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> 是fe_function描述的场在 \(q\) 个正交点的值的向量。由 <code>values[q]</code> 访问的矢量的大小等于有限元的分量数，即 <code>values[q](c)</code> 返回 \(q\) 个正交点的 \(c\) 个矢量的值。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03572">3572</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a378b552c1b8ca9f23f89677910e7a5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378b552c1b8ca9f23f89677910e7a5cd">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<h1>从一个任意的矢量生成函数值。这个函数与上面这个名字的第一个函数本质上是一样的，只是它没有假设输入矢量对应于描述有限元场的未知数的DoFHandler（然后我们会假设`fe_function.size() </h1>
<p>dof_handler.n_dofs()<code>）。相反，对应于当前单元的节点值是一个任意矢量的元素，这些元素由这个函数的第二个参数来索引。</code>fe_function<code>输入参数的其余部分对应于什么，对这个函数没有影响。 鉴于此，上面的函数相当于将</code>fe_function<code>作为第一个参数传给当前函数，并将以下调用产生的</code>local_dof_indices`数组作为当前函数的第二个参数。 </p><div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p> (更多信息见 <a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">DoFCellAccessor::get_dof_indices()</a> 。)同样地，上面的函数也相当于调用 </p><div class="fragment"><div class="line">cell-&gt;get_dof_values (fe_function, local_dof_values);</div></div><!-- fragment --><p> 然后调用当前函数，将<code>local_dof_values</code>作为第一个参数，并将一个索引为`{0,...,fe.dofs_per_cell-1}的数组作为第二个参数。 当前函数的意义在于，人们有时希望在正交点评估有限元函数，其节点值没有存储在全局矢量中</p>
<p>例如，可以先修改这些局部值，例如应用限制器或确保所有节点值为正值，然后再评估当前单元上与这些局部值对应的有限元场。另一种应用是，人们希望将一个单元上的解后处理为每个单元上的不同有限元空间，而不需要实际创建一个相应的DoFHandler</p>
<p>在这种情况下，我们所要计算的是该后处理函数的局部表示，其特征是节点值；然后该函数允许在正交点评估该表示。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>一个结点值的向量。这个向量可以有一个任意的大小，只要所有由 "indices "索引的元素可以被实际访问。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>进入<code>fe_function</code>的索引的一个向量。这个向量的长度必须等于当前单元上的自由度数量，并且必须按照参考单元上自由度的索引顺序识别<code>fe_function</code>中的元素。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>给定的有限元场的数值向量，在当前对象上的正交点。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03548">3548</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a5cee3d4c01d14d74be02a797650f561f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cee3d4c01d14d74be02a797650f561f">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个任意的矢量生成矢量函数值。 这个函数与前一个函数相对应，只是针对矢量值的情况。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03600">3600</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ad0f91fd23806e90bfe74b7446b835210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f91fd23806e90bfe74b7446b835210">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; typename InputVector::value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个任意的向量生成向量函数值。这个函数与前一个函数类似，但<code>indices</code>向量也可以是每个单元格的dofs数量的倍数。然后，<code>value</code>中的向量应该允许有限元的分量的相同倍数。 </p><h1>根据最后一个参数的值，<code>values</code>的外向量要么有正交规则的长度（<code>quadrature_points_fastest </code></h1>
<p><code> </p><h1>false），要么有要填充的元件的长度<code>quadrature_points_fastest </code></h1>
<p></code></p>
<p><code><code> </p><h1>true。如果<code>p</code>是当前的正交点编号，<code>i</code>是所需解决方案的矢量分量，如果<code>quadrature_points_fastest </code></h1>
<p></code></code></p>
<p><code><code><code> false</code>，对<code>values[p][i]</code>的访问是<code>values[i][p]</code>，否则是<code>values</code>。 由于这个函数允许相当普遍的参数大小组合，所以要注意对参数的检查可能不会发现错误。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>
<p></code></code></p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03631">3631</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ad1f4e0deb5d982e8172d82141c634a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4e0deb5d982e8172d82141c634a67">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个单元的正交点上的有限元梯度。这个函数等同于相应的get_function_values()函数（更多信息见那里），但评估的是有限元场的梯度而不是它的值。 这个函数只能在使用的有限元是标量的情况下使用，即只有一个矢量成分。对于矢量值的有限元，有一个相同名称的相应函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>一个值的向量，描述（全局）该函数应在当前单元的正交点评估的有限元函数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradients</td><td>由fe_function指定的函数在当前单元的正交点的梯度。 梯度是在实空间计算的（而不是在单元格上）。 假设该对象已经有了正确的尺寸。这个输出向量所存储的数据类型必须是当你将形状函数的梯度乘以用于存储有限元向量 \(U_j\) 的未知数 \(U\) （由 <code>fe_function参数表示）的类型时所得到的。</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> 将包含fe_function描述的场在 \(q\) 第三个正交点的梯度。 <code>gradients[q][d]</code> 代表坐标方向 \(d\) 在正交点 \(q\) 的导数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>输入矢量的实际数据类型可以是Vector&lt;T&gt;、BlockVector&lt;T&gt;或PETSc或Trilinos矢量包装类之一。它代表了与DoFHandler对象相关的全局DoF值的向量，而这个FEValues对象最后被初始化。 </dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03664">3664</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ae991c7d48b60b228897a91a00bd6900d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae991c7d48b60b228897a91a00bd6900d">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与其他get_function_gradients()的作用相同，但应用于多分量（矢量值）元素。参数的含义与那里解释的一样。 </p><dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> 是fe_function描述的场在 \(q\) 第1个正交点的梯度的矢量。由 <code>gradients[q]</code> 访问的矢量的大小等于有限元的分量数，即 <code>gradients[q][c]</code> 返回 \(c\) 个矢量分量在 \(q\) 个正交点的梯度。因此， <code>gradients[q][c][d]</code> 是当前单元的 \(c\) 矢量场的第1个矢量分量在坐标方向 \(d\) 上的导数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03715">3715</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aa9ed70ad8baff761b1232bc111a00ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ed70ad8baff761b1232bc111a00ffd">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_gradients()函数中的第一个函数的关系，与带有类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03690">3690</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aef4213cb7edc4788d42a923af0d5a563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4213cb7edc4788d42a923af0d5a563">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_gradients()函数中的第一个函数的关系，与带有类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03744">3744</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ae8f183c9d6da0c7daf9d345e0bc91b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f183c9d6da0c7daf9d345e0bc91b0a">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算单元格正交点上的有限元二阶导数的张量。这个函数等同于相应的get_function_values()函数（更多信息见那里），但评估有限元场的二阶导数而不是其值。 这个函数只能在使用的有限元是标量的情况下使用，即只有一个矢量成分。对于矢量值的有限元有一个相同名称的相应函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>一个值的向量，描述（全局）该函数应在当前单元的正交点评估的有限元函数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessians</td><td>由fe_function指定的函数在当前单元的正交点上的Hessians。 Hessians是在实空间计算的（而不是在单元格上）。 假设该对象已经有了正确的尺寸。这个输出向量所存储的数据类型必须是你将形状函数的Hessians乘以用于存储你的有限元向量 \(U_j\) （由 <code>fe_function参数表示）的未知数值的类型时得到的。</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> 将包含fe_function描述的场在 \(q\) 第三个正交点的Hessian。 <code>hessians[q][i][j]</code> 代表正交点 \(q\) 的第二导数矩阵的 \((i,j)\) 分量。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>输入矢量的实际数据类型可以是Vector&lt;T&gt;、BlockVector&lt;T&gt;或PETSc或Trilinos矢量封装类之一。它代表了与DoFHandler对象相关的全局DoF值的向量，这个FEValues对象最后被初始化。 </dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03777">3777</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a4d80068005cd1283597e2e3f092864b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d80068005cd1283597e2e3f092864b3">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与其他get_function_hessians()的作用相同，但应用于多分量（矢量值）元素。参数的含义与那里解释的一样。 </p><dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> 是fe_function描述的场在 \(q\) 第1个正交点的Hessians的向量。由 <code>hessians[q]</code> 访问的矢量的大小等于有限元的分量数，即 <code>hessians[q][c]</code> 返回 \(c\) 第1个正交点的 \(q\) 矢量分量的Hessian。因此， <code>hessians[q][c][i][j]</code> 是当前单元格的正交点 \(q\) 处向量场的 \(c\) 个向量分量的第二导数矩阵的 \((i,j)\) 个分量。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03828">3828</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="ac081e64d8a7f72f36bc87ee100f623dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac081e64d8a7f72f36bc87ee100f623dc">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_hessians()函数中的第一个函数的关系，与带有类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03803">3803</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a0090df9b494c98f66c6db4cacc27502b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0090df9b494c98f66c6db4cacc27502b">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_hessians()函数中的第一个函数的关系，与带类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03859">3859</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a9e058f0caf1c888010bfc2c616ab4ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e058f0caf1c888010bfc2c616ab4ebd">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算单元格正交点上的有限元的（标量）拉普拉斯（即二阶导数张量的迹）。这个函数等同于相应的get_function_values()函数（更多信息见那里），但评估的是有限元场的二阶导数而不是其值。 这个函数只能在使用的有限元是标量的情况下使用，即只有一个矢量成分。对于矢量值的有限元有一个相同名称的相应函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>一个值的向量，描述（全局）该函数应在当前单元的正交点评估的有限元函数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">laplacians</td><td>由fe_function指定的函数在当前单元的正交点上的拉普拉斯方程。 拉普拉斯是在实空间计算的（而不是在单元格上）。 假设该对象已经有了正确的尺寸。这个输出向量所存储的数据类型必须是当你将形状函数的拉普拉斯系数乘以用于存储有限元向量 \(U_j\) 的未知数 \(U\) （由 <code>fe_function参数表示）的类型时所得到的。这恰好等于输入向量元素的类型。</code> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> 将包含fe_function描述的场在 \(q\) 第三个正交点的拉普拉斯。 </dd>
<dd>
对于输出向量的每个分量，都有 <code>laplacians[q]=trace(hessians[q])</code> ，其中<code>hessians</code>将是get_function_hessians()函数的输出。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>输入向量的实际数据类型可以是Vector&lt;T&gt;、BlockVector&lt;T&gt;或PETSc或Trilinos向量封装类之一。它代表了与DoFHandler对象相关的全局DoF值的向量，而这个FEValues对象最后被初始化。 </dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03890">3890</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a08fb3cd3ffccb0f0a7b2454601428f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fb3cd3ffccb0f0a7b2454601428f0c">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与其他get_function_laplacians()的作用相同，但应用于多分量（矢量值）元素。参数的含义与那里解释的一样。 </p><dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> 是fe_function描述的场在 \(q\) 个正交点的拉普拉斯矢量。由 <code>laplacians[q]</code> 访问的矢量的大小等于有限元的分量数，即 <code>laplacians[q][c]</code> 返回 \(c\) 第1个正交点的 \(q\) 矢量的拉普拉斯。 </dd>
<dd>
对于输出向量的每个分量，持有 <code>laplacians[q][c]=trace(hessians[q][c])</code> ，其中<code>hessians</code>将是get_function_hessians() 函数的输出。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03939">3939</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a062e419bf95dc7e6f83dcf1e0eeeedd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062e419bf95dc7e6f83dcf1e0eeeedd7">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_laplacians()函数中的第一个函数的关系，与带有类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03915">3915</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aad192d491d4dad2bdea26c8e1c0a9ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad192d491d4dad2bdea26c8e1c0a9ab1">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_laplacians()函数中的第一个函数的关系，与带类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03966">3966</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aced6912ea4c1324431f504b407cc2745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced6912ea4c1324431f504b407cc2745">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_laplacians()函数中的第一个函数的关系，与带类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l03997">3997</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a07414796ef13160769987e6e252f3d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07414796ef13160769987e6e252f3d1f">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个单元的正交点上的有限元的三阶导数张量。这个函数等同于相应的get_function_values()函数（更多信息见那里），但评估的是有限元场的第三导数而不是它的值。 这个函数只能在使用的有限元是标量的情况下使用，即只有一个矢量成分。对于矢量值的有限元有一个相同名称的相应函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>一个值的向量，描述（全局）该函数应在当前单元的正交点评估的有限元函数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">third_derivatives</td><td>由fe_function指定的函数在当前单元的正交点上的第三导数。 三次导数是在实空间计算的（而不是在单元格上）。 假设该对象已经有了正确的尺寸。这个输出向量所存储的数据类型必须是当你将形状函数的三次导数乘以用于存储你的有限元向量 \(U_j\) 的未知数值的类型 \(U\) （由 <code>fe_function</code> 参数表示）时所得到的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>third_derivatives[q]</code> 将包含fe_function描述的场在 \(q\) 第1个正交点的第三导数。 <code>third_derivatives[q][i][j][k]</code> 代表在正交点 \(q\) 的三阶张量的 \((i,j,k)\) 的第三导数的第三部分。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>输入矢量的实际数据类型可以是Vector&lt;T&gt;、BlockVector&lt;T&gt;或PETSc或Trilinos矢量封装类之一。它代表了与DoFHandler对象相关的全局DoF值的向量，而这个FEValues对象最后被初始化。 </dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04027">4027</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="abaa181bd794cd9e423b70f87b41309bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa181bd794cd9e423b70f87b41309bd">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数的作用与其他get_function_third_derivatives()相同，但应用于多分量（矢量值）元素。参数的含义与那里的解释相同。 </p><dl class="section post"><dt>Postcondition</dt><dd><code>third_derivatives[q]</code> 是fe_function描述的场在 \(q\) 第1个正交点上的第三导数的向量。由 <code>third_derivatives[q]</code> 访问的矢量的大小等于有限元的分量数，即 <code>third_derivatives[q][c]</code> 返回 \(c\) 在 \(q\) 第1个正交点的第1个矢量分量的三次导数。因此， <code>third_derivatives[q][c][i][j][k]</code> 是当前单元的正交点 \(q\) 处向量场的 \(c\) 第3个向量分量的张量的 \((i,j,k)\) 。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04080">4080</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a9220827b037d7b44fba1e36e56f2e810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9220827b037d7b44fba1e36e56f2e810">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_third_derivatives()函数中的第一个函数的关系，与带有类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04054">4054</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a3c7fe4012e770f17e192ae4ded255cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7fe4012e770f17e192ae4ded255cb7">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数与上述get_function_third_derivatives()函数中的第一个函数的关系，与带有类似参数的get_function_values()函数与get_function_values()函数中的第一个函数的关系相同。更多信息见那里。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04111">4111</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a93872d888911cda7e2e716168afc1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93872d888911cda7e2e716168afc1b3f">&#9670;&nbsp;</a></span>dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dof_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零（包括）到<code>dofs_per_cell</code>（不包括）所有索引的数组。这允许人们使用基于范围的 "for "循环来编写代码，如以下类型。 </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values (...);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q : fe_values.quadrature_point_indices())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.dof_indices())</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += ...; <span class="comment">// Do something for DoF indices (i,j)</span></div><div class="line">                                   <span class="comment">// at quadrature point q</span></div><div class="line">  }</div></div><!-- fragment --><p> 这里，我们在所有单元上的所有自由度上循环，<code>i'和</code>j'代表所有单元自由度的有效指数，由传递给`fe_values'的有限元定义。 </p>

</div>
</div>
<a id="a7dfe8baa6858e3edb5a1f0190fc3f85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfe8baa6858e3edb5a1f0190fc3f85e">&#9670;&nbsp;</a></span>dof_indices_starting_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dof_indices_starting_at </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，可以认为是一个数组，包含从 <code>start_dof_index</code> （包括）到<code>dofs_per_cell</code>（包括）的所有索引。 这允许人们使用基于范围的 "for
"循环来编写以下类型的代码。 </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values (...);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q : fe_values.quadrature_point_indices())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.dof_indices_starting_at(i))</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += ...; <span class="comment">// Do something for DoF indices (i,j)</span></div><div class="line">                                   <span class="comment">// at quadrature point q</span></div><div class="line">  }</div></div><!-- fragment --><p> 这里，我们在所有单元上的所有局部自由度上循环，<code>i</code>取所有单元自由度的有效指数，由传递给<code>fe_values</code>的有限元定义，而<code>j</code>取<code>i</code>范围的指定子集，从<code>i</code>本身开始，到单元自由度的数量为止。通过这种方式，我们可以构建刚度矩阵贡献的上半部分和对角线（假设它是对称的，并且只需要计算它的一半），例如。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>start_dof_index</code> 等于单元格中的DoF数量，则返回的索引范围为空。 </dd></dl>

</div>
</div>
<a id="a3a4ca7b33a291c07d9c155ccbf314d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4ca7b33a291c07d9c155ccbf314d5f">&#9670;&nbsp;</a></span>dof_indices_ending_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dof_indices_ending_at </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从0（包括）到 <code>end_dof_index</code> （包括）所有索引的数组。这允许人们使用基于范围的 "for "循环来编写以下类型的代码。 </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values (...);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q : fe_values.quadrature_point_indices())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.dof_indices_ending_at(i))</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += ...; <span class="comment">// Do something for DoF indices (i,j)</span></div><div class="line">                                   <span class="comment">// at quadrature point q</span></div><div class="line">  }</div></div><!-- fragment --><p> 这里，我们在所有单元上的所有局部自由度上循环，<code>i'代表所有单元自由度的有效指数，由传递给</code>fe_values'的有限元定义，而<code>j'代表</code>i'范围的指定子集，从零开始，到`i'本身结束。这样，我们可以构建刚度矩阵贡献的下半部分和对角线（假设它是对称的，并且只需要计算它的一半），例如。 </p><dl class="section note"><dt>Note</dt><dd>如果 <code>end_dof_index</code> 等于零，则返回的索引范围为空。 </dd></dl>

</div>
</div>
<a id="aada8380792b5e6a1f91dcba94b558cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada8380792b5e6a1f91dcba94b558cb8">&#9670;&nbsp;</a></span>quadrature_point_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::quadrature_point_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，可以认为是一个包含从零到<code>n_quadrature_points</code>所有索引的数组。这允许使用基于范围的`for'循环来编写以下类型的代码。 </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.quadrature_point_indices())</div><div class="line">      ... <span class="keywordflow">do</span> something at the <a class="code" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> ...</div><div class="line">  }</div></div><!-- fragment --><p> 这里，我们正在循环所有单元格上的所有正交点，<code>q_point</code>采用所有有效的正交点索引，由传递给<code>fe_values</code>的正交规则定义。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> </dd></dl>

</div>
</div>
<a id="ab123e5da03736be4977c76fbcb6a2e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab123e5da03736be4977c76fbcb6a2e37">&#9670;&nbsp;</a></span>quadrature_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::quadrature_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>q</code>第1个正交点在实空间的位置。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_quadrature_points</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ae41b67cfd48e02f6035e39c84f0fb47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b67cfd48e02f6035e39c84f0fb47a">&#9670;&nbsp;</a></span>get_quadrature_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_quadrature_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回实空间中正交点向量的参考。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_quadrature_points</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="abade89efb068b71b7ced7082012a2441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abade89efb068b71b7ced7082012a2441">&#9670;&nbsp;</a></span>JxW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::JxW </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>映射的正交点权重。如果这个对象指的是体积评价（即派生类是FEValues类型），那么这就是雅可比行列式乘以<code>i</code>第1个单位正交点的权重。 对于表面评估（即类FEFaceValues或FESubfaceValues），它是映射的表面元素乘以正交点的权重。 你可以把这个函数返回的数量看作是我们在这里通过正交实现的积分中的体积或表面元素 \(dx, ds\) 。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_JxW_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a7371618d5977d28dfe82c81fbac29c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7371618d5977d28dfe82c81fbac29c0f">&#9670;&nbsp;</a></span>get_JxW_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_JxW_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对存放JxW()返回值的数组的引用。 </p>

</div>
</div>
<a id="a6abe3ffe1b14b2472093b4d95b09b76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abe3ffe1b14b2472093b4d95b09b76f">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定正交点上的变换的雅各布系数，即 \(J_{ij}=dx_i/d\hat x_j\) </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. 。 </dd></dl>

</div>
</div>
<a id="acb95b09ced1230e1f29ce993eedb1ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb95b09ced1230e1f29ce993eedb1ccf">&#9670;&nbsp;</a></span>get_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对存放jacobian()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a24b8b21f05fe45701ce5d71e8952d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b8b21f05fe45701ce5d71e8952d893">&#9670;&nbsp;</a></span>jacobian_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回在指定的正交点，即 \(G_{ijk}=dJ_{jk}/d\hat x_i\) ，从单位到实数单元转换的二阶导数，即雅各布式的一阶导数。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a9d228651f45f5e9a8d787d2137e71e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d228651f45f5e9a8d787d2137e71e86">&#9670;&nbsp;</a></span>get_jacobian_grads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对存放jacobian_grads()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ab7d9388afa7d9ee1266d824b37fbff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d9388afa7d9ee1266d824b37fbff27">&#9670;&nbsp;</a></span>jacobian_pushed_forward_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从单位单元到实数单元转换的二阶导数，即雅各布式的一阶导数，在指定的正交点，向前推到实数单元坐标，即 \(G_{ijk}=dJ_{iJ}/d\hat x_K (J_{jJ})^{-1} (J_{kK})^{-1}\) 。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a5819f15c0e821762a0abc60fc77ddd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5819f15c0e821762a0abc60fc77ddd54">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_grads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回持有jacobian_pushed_forward_grads()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a5aed77844d697d26e19cf0e9e6891351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aed77844d697d26e19cf0e9e6891351">&#9670;&nbsp;</a></span>jacobian_2nd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;3, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回在指定的正交点上，即 \(G_{ijkl}=\frac{d^2J_{ij}}{d\hat x_k d\hat x_l}\) ，从单位到实数单元转换的第三导数，即雅各布的第二导数。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="aa784c826743ed3a66e178a9260b040be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa784c826743ed3a66e178a9260b040be">&#9670;&nbsp;</a></span>get_jacobian_2nd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;3, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_2nd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对存放jacobian_2nd_derivatives()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ad3c0f9a8b40a506ef6746da258f93c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c0f9a8b40a506ef6746da258f93c32">&#9670;&nbsp;</a></span>jacobian_pushed_forward_2nd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;4, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从单位到实心单元转换的第三导数，即雅各布的第二导数，在指定的正交点，向前推到实心单元坐标，即 \(G_{ijkl}=\frac{d^2J_{iJ}}{d\hat x_K d\hat x_L} (J_{jJ})^{-1} (J_{kK})^{-1}(J_{lL})^{-1}\) 。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="abb9be9ddf679019e37e9d3474d893f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9be9ddf679019e37e9d3474d893f3a">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_2nd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;4, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_2nd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回持有jacobian_pushed_forward_2nd_derivatives()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="a2747bbb82f8bf29b762253778d2c0839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2747bbb82f8bf29b762253778d2c0839">&#9670;&nbsp;</a></span>jacobian_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;4, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回在指定的正交点，即 \(G_{ijklm}=\frac{d^2J_{ij}}{d\hat x_k d\hat x_l d\hat x_m}\) ，从单位到实数单元转换的第四导数，即雅各布式的第三导数 。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ae391823baf3ecd0792a867c0b031aa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae391823baf3ecd0792a867c0b031aa62">&#9670;&nbsp;</a></span>get_jacobian_3rd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;4, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_3rd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对存放jacobian_3rd_derivatives()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ac6683da072e8135a4e423894457f2782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6683da072e8135a4e423894457f2782">&#9670;&nbsp;</a></span>jacobian_pushed_forward_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;5, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回从单位到实心单元转换的第四导数，即雅各布的第三导数，在指定的正交点，向前推到实心单元坐标，即 \(G_{ijklm}=\frac{d^3J_{iJ}}{d\hat x_K d\hat x_L d\hat x_M} (J_{jJ})^{-1} (J_{kK})^{-1} (J_{lL})^{-1} (J_{mM})^{-1}\) 。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="adcf9ada77adee2b864e57dda00e25339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf9ada77adee2b864e57dda00e25339">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_3rd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;5, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_3rd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回持有jacobian_pushed_forward_3rd_derivatives()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="aa539d494cab9b9f2a9d6fd8e78c9666e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa539d494cab9b9f2a9d6fd8e78c9666e">&#9670;&nbsp;</a></span>inverse_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, spacedim, dim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定正交点上的变换的逆雅各布系数，即 \(J_{ij}=d\hat x_i/dx_j\) </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_inverse_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. 。 </dd></dl>

</div>
</div>
<a id="a52bfab60e48072979414b34bbbce4418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bfab60e48072979414b34bbbce4418">&#9670;&nbsp;</a></span>get_inverse_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, spacedim, dim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_inverse_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对存放inverse_jacobian()返回值的数组的引用。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_inverse_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

</div>
</div>
<a id="ac25ec6835799c3b6c7c842f8acb05eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25ec6835799c3b6c7c842f8acb05eb3">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个正交点的法向量。如果你为一个面调用这个函数（即，当使用FEFaceValues或FESubfaceValues对象时），那么这个函数返回面的<code>i</code>第1个正交点处的单元格的外向法向量。 相反，如果你为一个一维的单元格调用这个函数（即，当使用<code><a class="el" href="classFEValues.html">FEValues</a>&lt;dim,spacedim&gt;</code>对象时，<code>spacedim&gt;dim</code>），那么这个函数返回单元格的法向量</p>
<ul>
<li>换句话说，是对嵌入三角形的流形的法向量的一个近似值。在这种情况下，流形的法线方向当然有两个，这个函数返回由顶点编号引起的 "向上 "方向。 矢量的长度被规范化为1。 <dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a80d39b9aea51af573ded84342b8b330d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80d39b9aea51af573ded84342b8b330d">&#9670;&nbsp;</a></span>get_normal_vectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_normal_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此对象所代表的所有正交点的法向量。关于法向量所代表的内容，请参见normal_vector()函数。 </p><dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and</a> for more information. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04150">4150</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a7670d68d12957e0ca99569a17c63efb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670d68d12957e0ca99569a17c63efb2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建当前FEValues对象的一个视图，该视图代表可能是矢量值的有限元的特定标量分量。视图的概念在命名空间FEValuesViews的文档中解释，特别是在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中。 </p>

</div>
</div>
<a id="a3bb48e1d06471efe7835f827f3c315a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb48e1d06471efe7835f827f3c315a3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个当前FEValues对象的视图，该视图代表了一组 <code>dim</code> 矢量值有限元的标量分量（即矢量）。视图的概念在命名空间FEValuesViews的文档中解释，特别是在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中。 </p>

</div>
</div>
<a id="a8bfcef98b4371fe0ccc2e5da644cef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfcef98b4371fe0ccc2e5da644cef1f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1SymmetricTensor.html">FEValuesViews::SymmetricTensor</a>&lt;2, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建当前FEValues对象的视图，该视图代表了一组 <code>(dim*dim</p><ul>
<li>dim)/2 矢量值有限元的标量分量（即对称的二阶张量）。视图的概念在命名空间FEValuesViews的文档中解释，特别是在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中。 </li>
</ul>
<p></code></p>

</div>
</div>
<a id="af092b17057ebfeeba90ac58f9205bc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af092b17057ebfeeba90ac58f9205bc86">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Tensor.html">FEValuesViews::Tensor</a>&lt;2, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个当前FEValues对象的视图，该视图表示一组 <code>(dim*dim)</code> 矢量值有限元的标量分量（即二阶张量）。视图的概念在命名空间FEValuesViews的文档中解释，特别是在 <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> 模块中。 </p>

</div>
</div>
<a id="adcc1b936b41b758dad7ddae21c71f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc1b936b41b758dad7ddae21c71f14c">&#9670;&nbsp;</a></span>get_mapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对所选映射对象的常量引用。 </p>

</div>
</div>
<a id="ade22ffd9fb5b07842daa504929244aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22ffd9fb5b07842daa504929244aa7">&#9670;&nbsp;</a></span>get_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对所选有限元对象的常数参考。 </p>

</div>
</div>
<a id="a55b258a1619829f7ec03a184ffb8e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b258a1619829f7ec03a184ffb8e556">&#9670;&nbsp;</a></span>get_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回为该对象设置的更新标志。 </p>

</div>
</div>
<a id="a9d3a1c53c139e2553b672de682d6233e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d3a1c53c139e2553b672de682d6233e">&#9670;&nbsp;</a></span>get_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回到当前单元的三角形迭代器。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04141">4141</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a808af56bde1d82893b88875dc651e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808af56bde1d82893b88875dc651e749">&#9670;&nbsp;</a></span>get_cell_similarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell_similarity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前单元格与前一个单元格的关系。如果结果是 <code><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13a4f8507015c458575753e0a45e0c3544a">CellSimilarity::translation</a></code>. ，这允许重新使用一些单元格数据（如具有常数系数的方程的局部矩阵）。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04319">4319</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aaf01126d2e3b926fecbaf122357add53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf01126d2e3b926fecbaf122357add53">&#9670;&nbsp;</a></span>invalidate_present_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::invalidate_present_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个与三角结构相连的函数，以便在三角结构发生变化，迭代器随之失效时，将存储的'present_cell'迭代器重置为一个无效的迭代器。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04203">4203</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aed652da6ec16e368e27da4085b4281bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed652da6ec16e368e27da4085b4281bb">&#9670;&nbsp;</a></span>maybe_invalidate_previous_present_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::maybe_invalidate_previous_present_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数被派生类中的各种 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a> 函数调用。给定参数所指示的单元格，测试我们是否必须丢弃之前存储的present_cell参数，因为这需要我们比较不同三角形的单元格。在检查这一切的时候，还要确保我们有tria_listener连接到我们将在调用此函数后立即设置present_cell的三角结构。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04221">4221</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="aa1352ba7f04525e175d2c6fa552a1c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1352ba7f04525e175d2c6fa552a1c6a">&#9670;&nbsp;</a></span>compute_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::compute_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>初始化一些更新标志。从派生类的 <code>initialize</code> 函数中调用，这些函数又从它们的构造函数中调用。 基本上，这个函数使用已经存储的有限元和映射对象找出需要设置的标志来计算用户想要的一切，正如通过作为参数传递的标志所表达的那样。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04184">4184</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a5c38a7d7c3a6b384ad5b46f38248524d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c38a7d7c3a6b384ad5b46f38248524d">&#9670;&nbsp;</a></span>check_cell_similarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::check_cell_similarity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个检查新单元是否与之前使用的单元相似的函数。然后，大量的数据可以被重新使用，例如实空间中的基函数导数，shape_grad。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8cc_source.html#l04264">4264</a> of file <a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a627033acd32f5d22a4bb82444267a240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627033acd32f5d22a4bb82444267a240">&#9670;&nbsp;</a></span>integral_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::integral_dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>我们对其进行积分的对象的尺寸。对于本类，这等于 <code>dim</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03240">3240</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a50edb536baf30f637a51203f0e73d15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50edb536baf30f637a51203f0e73d15e">&#9670;&nbsp;</a></span>quadrature</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt; <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::quadrature</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在这里存储一份正交公式的副本。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03334">3334</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="afd889a38bbce8ea33d46d152f14abdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd889a38bbce8ea33d46d152f14abdd3">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该对象所处的尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02013">2013</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a6541820cb52f78a4d43de18be0352002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541820cb52f78a4d43de18be0352002">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该对象所处空间的尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02019">2019</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a807c3049bfe81743fc0f237dfc2fbdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807c3049bfe81743fc0f237dfc2fbdea">&#9670;&nbsp;</a></span>n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::n_quadrature_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前对象的正交点的数量。它的值由max_n_quadrature_points的值初始化并被更新，例如，如果为一个新的单元/面调用 <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a> 。 </p><dl class="section note"><dt>Note</dt><dd>默认值等于max_n_quadrature_points的值。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02027">2027</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="af4f8b164f3fa6f25982c8a52fefe0995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f8b164f3fa6f25982c8a52fefe0995">&#9670;&nbsp;</a></span>max_n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::max_n_quadrature_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>正交点的最大数量。这个值可能与n_quadrature_points不同，例如，如果一个具有不同面孔正交规则的QCollection被传递给初始化FEFaceValues。 这对于初始化数组，分配最大的内存量是非常有用的，在以后重新调整大小的时候，可能会用到n_quadrature_points给出的当前正交点的数量。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02034">2034</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a5b264d5b2fb6615f5dea7a21135ed1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b264d5b2fb6615f5dea7a21135ed1a5">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>每个单元的形状函数的数量。如果我们使用这个基类来评估单元面的有限元，这仍然是每个单元的自由度数量，而不是每个面的自由度。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02040">2040</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="acf87f79b7e82e60650bc9227deb6aeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf87f79b7e82e60650bc9227deb6aeb9">&#9670;&nbsp;</a></span>present_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const <a class="el" href="classFEValuesBase_1_1CellIteratorBase.html">CellIteratorBase</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::present_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储上次调用reinit()函数时选择的单元格。 这对<code>get_function_*</code>函数以及提取器类中的同名函数是必要的。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03084">3084</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aa7274f2ea9bbe0ea61bd983c5746ffef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7274f2ea9bbe0ea61bd983c5746ffef">&#9670;&nbsp;</a></span>tria_listener_refinement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个信号连接，我们用来确保每当三角结构因细化而发生变化时，我们会得到通知。我们需要知道这一点，因为它使所有的单元格迭代器失效，作为其中的一部分，我们在随后调用reinit()时保留了'present_cell'迭代器，以便计算单元格相似度。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03097">3097</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a2f853782c9ba1f6c4093f64ede145253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f853782c9ba1f6c4093f64ede145253">&#9670;&nbsp;</a></span>tria_listener_mesh_transform</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener_mesh_transform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个信号连接，我们用它来确保每当三角结构因网格转换而发生变化时，我们都能得到通知。我们需要知道这一点，因为它使所有的单元格迭代器失效，作为其中的一部分，我们在后续调用reinit()时保留了'present_cell'迭代器，以便计算单元格的相似度。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03103">3103</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a5502d4cd55c37491d1f89e41285fc7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5502d4cd55c37491d1f89e41285fc7e5">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向与该FEValues对象相关的映射对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03126">3126</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aa2786d839ac016cd2181c1a2acf7b755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2786d839ac016cd2181c1a2acf7b755">&#9670;&nbsp;</a></span>mapping_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向映射内部数据对象的指针，从 <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>, <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping::get_face_data()</a>, 或 <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping::get_subface_data()</a>. 获得。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03134">3134</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a9faa26fda7aba97298344ab95b4753ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faa26fda7aba97298344ab95b4753ac">&#9670;&nbsp;</a></span>mapping_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt;dim, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个对象， <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> 和类似的函数将其输出放入其中。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03142">3142</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a67500f1f0d3d40e014e562d375f911f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67500f1f0d3d40e014e562d375f911f8">&#9670;&nbsp;</a></span>fe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个指向与此FEValues对象相关的有限元对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03151">3151</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="ae73456971913b569cfb5d79dc827e9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73456971913b569cfb5d79dc827e9bc">&#9670;&nbsp;</a></span>fe_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向有限元内部数据对象的指针，从 <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a>, <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping::get_face_data()</a>, 或 <a class="el" href="classFiniteElement.html#af8d025c0e209ea71e8247eadb5f78b38">FiniteElement::get_subface_data()</a>. 获得。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03160">3160</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="acfc8644fa994116af02667ddd6517ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc8644fa994116af02667ddd6517ae3">&#9670;&nbsp;</a></span>finite_element_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt;dim, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::finite_element_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个对象， <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 和类似的函数将其输出放入其中。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03169">3169</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a63ed91bcc8004390e372704d63177162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ed91bcc8004390e372704d63177162">&#9670;&nbsp;</a></span>update_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>交给FEValues构造器的原始更新标志。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03176">3176</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a096d4ea9edea6618e23f5f13ab40784c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096d4ea9edea6618e23f5f13ab40784c">&#9670;&nbsp;</a></span>cell_similarity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::cell_similarity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个枚举变量，可以存储当前单元与之前访问的单元的不同状态。如果需要，可以在这里检查额外的状态，并在重新启动时使用其中一个方法。 </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03191">3191</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a></li>
<li>include/deal.II/fe/<a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a></li>
<li>source/fe/<a class="el" href="fe_2fe__values_8cc_source.html">fe_values.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
