<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFEValues.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FEValues&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classFEValues-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FEValues&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">deal.II/fe/fe.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FEValues&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFEValues__inherit__graph.svg" width="199" height="294"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a051be8559fb1a35dff1ba230864d94b3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a051be8559fb1a35dff1ba230864d94b3">FEValues</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a5502d4cd55c37491d1f89e41285fc7e5">mapping</a>, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a051be8559fb1a35dff1ba230864d94b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e29a8987e36c016fa9e5c5ad68f0fda"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a6e29a8987e36c016fa9e5c5ad68f0fda">FEValues</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a5502d4cd55c37491d1f89e41285fc7e5">mapping</a>, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a6e29a8987e36c016fa9e5c5ad68f0fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f982108aa0d834923a57fa328d1c7e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a80f982108aa0d834923a57fa328d1c7e">FEValues</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a80f982108aa0d834923a57fa328d1c7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb7498746ed379c23466e9de536c319"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a5eb7498746ed379c23466e9de536c319">FEValues</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a>, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;<a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a>, const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a5eb7498746ed379c23466e9de536c319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f914e63d588e2652a9514620653d77"><td class="memTemplParams" colspan="2">template&lt;bool level_dof_access&gt; </td></tr>
<tr class="memitem:a21f914e63d588e2652a9514620653d77"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;cell)</td></tr>
<tr class="separator:a21f914e63d588e2652a9514620653d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5f1445edcf7964ad66554b804dfa4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a8a5f1445edcf7964ad66554b804dfa4c">reinit</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a8a5f1445edcf7964ad66554b804dfa4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae053b49309f1dce22268c6bc8fe50cb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#ae053b49309f1dce22268c6bc8fe50cb2">get_quadrature</a> () const</td></tr>
<tr class="separator:ae053b49309f1dce22268c6bc8fe50cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af649ad9baf7e58a6d43e266dec5523d9"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#af649ad9baf7e58a6d43e266dec5523d9">memory_consumption</a> () const</td></tr>
<tr class="separator:af649ad9baf7e58a6d43e266dec5523d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902429920d32c81c9c279d9a15faa263"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a902429920d32c81c9c279d9a15faa263">get_present_fe_values</a> () const</td></tr>
<tr class="separator:a902429920d32c81c9c279d9a15faa263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga55d2970cb77d5947ea056d8a6ed6a971"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga55d2970cb77d5947ea056d8a6ed6a971">DeclException1</a> (ExcAccessToUninitializedField, std::string,&lt;&lt; &quot;You are requesting information from an <a class="el" href="classFEValues.html">FEValues</a>/<a class="el" href="classFEFaceValues.html">FEFaceValues</a>/<a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> &quot;&lt;&lt; &quot;object for which this kind of information has not been computed. What &quot;&lt;&lt; &quot;information these objects compute is determined by the update_* flags you &quot;&lt;&lt; &quot;pass to the constructor. Here, the operation you are attempting requires &quot;&lt;&lt; &quot;the &lt;&quot;&lt;&lt; arg1&lt;&lt; &quot;&gt; flag to be set, but it was apparently not specified &quot;&lt;&lt; &quot;upon construction.&quot;)</td></tr>
<tr class="separator:ga55d2970cb77d5947ea056d8a6ed6a971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c4ee91a4333e56c9c3251aa676663ca"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3c4ee91a4333e56c9c3251aa676663ca">DeclException1</a> (ExcShapeFunctionNotPrimitive, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The shape function with index &quot;&lt;&lt; arg1&lt;&lt; &quot; is not primitive, i.e. it is vector-valued and &quot;&lt;&lt; &quot;has more than one non-zero vector component. This &quot;&lt;&lt; &quot;function cannot be called for these shape functions. &quot;&lt;&lt; &quot;Maybe you want to use the same function with the &quot;&lt;&lt; &quot;_component suffix?&quot;)</td></tr>
<tr class="separator:ga3c4ee91a4333e56c9c3251aa676663ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf87028ad3b58f711faf692703612ac20"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf87028ad3b58f711faf692703612ac20">DeclExceptionMsg</a> (ExcFEDontMatch, &quot;The <a class="el" href="classFiniteElement.html">FiniteElement</a> you provided to <a class="el" href="classFEValues.html">FEValues</a> and the <a class="el" href="classFiniteElement.html">FiniteElement</a> that belongs &quot; &quot;to the <a class="el" href="classDoFHandler.html">DoFHandler</a> that provided the cell iterator do not match.&quot;)</td></tr>
<tr class="separator:gaf87028ad3b58f711faf692703612ac20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0b64d2082d3b7f42c537ca121098066d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0b64d2082d3b7f42c537ca121098066d">DeclExceptionMsg</a> (ExcFENotPrimitive, &quot;The given <a class="el" href="classFiniteElement.html">FiniteElement</a> is not a primitive element but the requested operation &quot; &quot;only works for those. See <a class="el" href="classFiniteElement.html#a626abd282a25193db7f61b4ec53e7385">FiniteElement::is_primitive</a>() for more information.&quot;)</td></tr>
<tr class="separator:ga0b64d2082d3b7f42c537ca121098066d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to shape function values</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These fields are filled by the finite element. </p>
</div></td></tr>
<tr class="memitem:a1dd48cb744013c448d57f8f77640c08d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classdouble.html">double</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const</td></tr>
<tr class="separator:a1dd48cb744013c448d57f8f77640c08d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa57a7e777b0798ec009b4ce888ad9574"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:aa57a7e777b0798ec009b4ce888ad9574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46aefdb527125dafb59dcba92a0f256e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a46aefdb527125dafb59dcba92a0f256e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e93aa182f3acd34abd020538f3bc39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">shape_grad_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a71e93aa182f3acd34abd020538f3bc39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83a37e5067b9fd879752048bc2d77d42"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a83a37e5067b9fd879752048bc2d77d42">shape_hessian</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const</td></tr>
<tr class="separator:a83a37e5067b9fd879752048bc2d77d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a847929f632ae57b4305e9dca7270389a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a847929f632ae57b4305e9dca7270389a">shape_hessian_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a847929f632ae57b4305e9dca7270389a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad99ebb836476c7b72c0cd2ca3594827b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad99ebb836476c7b72c0cd2ca3594827b">shape_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no) const</td></tr>
<tr class="separator:ad99ebb836476c7b72c0cd2ca3594827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77234bc51dd64a24880bb50c834bb210"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a77234bc51dd64a24880bb50c834bb210">shape_3rd_derivative_component</a> (const unsigned <a class="el" href="classint.html">int</a> function_no, const unsigned <a class="el" href="classint.html">int</a> point_no, const unsigned <a class="el" href="classint.html">int</a> component) const</td></tr>
<tr class="separator:a77234bc51dd64a24880bb50c834bb210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to values of global finite element fields</div></td></tr>
<tr class="memitem:a357b422e374f2f2207af3512093f3907"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a357b422e374f2f2207af3512093f3907"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; typename InputVector::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:a357b422e374f2f2207af3512093f3907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8756b2e6e63977f37a3f26fdf83a7be"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ac8756b2e6e63977f37a3f26fdf83a7be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac8756b2e6e63977f37a3f26fdf83a7be">get_function_values</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:ac8756b2e6e63977f37a3f26fdf83a7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378b552c1b8ca9f23f89677910e7a5cd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a378b552c1b8ca9f23f89677910e7a5cd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a378b552c1b8ca9f23f89677910e7a5cd">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; typename InputVector::value_type &gt; &amp;values) const</td></tr>
<tr class="separator:a378b552c1b8ca9f23f89677910e7a5cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cee3d4c01d14d74be02a797650f561f"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a5cee3d4c01d14d74be02a797650f561f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5cee3d4c01d14d74be02a797650f561f">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;values) const</td></tr>
<tr class="separator:a5cee3d4c01d14d74be02a797650f561f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f91fd23806e90bfe74b7446b835210"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ad0f91fd23806e90bfe74b7446b835210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad0f91fd23806e90bfe74b7446b835210">get_function_values</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; typename InputVector::value_type &gt;&gt; values, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest) const</td></tr>
<tr class="separator:ad0f91fd23806e90bfe74b7446b835210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to derivatives of global finite element fields</div></td></tr>
<tr class="memitem:ad1f4e0deb5d982e8172d82141c634a67"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ad1f4e0deb5d982e8172d82141c634a67"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:ad1f4e0deb5d982e8172d82141c634a67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae991c7d48b60b228897a91a00bd6900d"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae991c7d48b60b228897a91a00bd6900d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae991c7d48b60b228897a91a00bd6900d">get_function_gradients</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:ae991c7d48b60b228897a91a00bd6900d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ed70ad8baff761b1232bc111a00ffd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aa9ed70ad8baff761b1232bc111a00ffd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa9ed70ad8baff761b1232bc111a00ffd">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;gradients) const</td></tr>
<tr class="separator:aa9ed70ad8baff761b1232bc111a00ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4213cb7edc4788d42a923af0d5a563"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aef4213cb7edc4788d42a923af0d5a563"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aef4213cb7edc4788d42a923af0d5a563">get_function_gradients</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt; gradients, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:aef4213cb7edc4788d42a923af0d5a563"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to second derivatives</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Hessian matrices and Laplacians of global finite element fields </p>
</div></td></tr>
<tr class="memitem:ae8f183c9d6da0c7daf9d345e0bc91b0a"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ae8f183c9d6da0c7daf9d345e0bc91b0a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;hessians) const</td></tr>
<tr class="separator:ae8f183c9d6da0c7daf9d345e0bc91b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d80068005cd1283597e2e3f092864b3"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a4d80068005cd1283597e2e3f092864b3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a4d80068005cd1283597e2e3f092864b3">get_function_hessians</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;hessians, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a4d80068005cd1283597e2e3f092864b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac081e64d8a7f72f36bc87ee100f623dc"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:ac081e64d8a7f72f36bc87ee100f623dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac081e64d8a7f72f36bc87ee100f623dc">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;hessians) const</td></tr>
<tr class="separator:ac081e64d8a7f72f36bc87ee100f623dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0090df9b494c98f66c6db4cacc27502b"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a0090df9b494c98f66c6db4cacc27502b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a0090df9b494c98f66c6db4cacc27502b">get_function_hessians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt; hessians, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a0090df9b494c98f66c6db4cacc27502b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; typename InputVector::value_type &gt; &amp;laplacians) const</td></tr>
<tr class="separator:a9e058f0caf1c888010bfc2c616ab4ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08fb3cd3ffccb0f0a7b2454601428f0c"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a08fb3cd3ffccb0f0a7b2454601428f0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a08fb3cd3ffccb0f0a7b2454601428f0c">get_function_laplacians</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;laplacians) const</td></tr>
<tr class="separator:a08fb3cd3ffccb0f0a7b2454601428f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062e419bf95dc7e6f83dcf1e0eeeedd7"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a062e419bf95dc7e6f83dcf1e0eeeedd7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a062e419bf95dc7e6f83dcf1e0eeeedd7">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; typename InputVector::value_type &gt; &amp;laplacians) const</td></tr>
<tr class="separator:a062e419bf95dc7e6f83dcf1e0eeeedd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad192d491d4dad2bdea26c8e1c0a9ab1"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aad192d491d4dad2bdea26c8e1c0a9ab1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aad192d491d4dad2bdea26c8e1c0a9ab1">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;laplacians) const</td></tr>
<tr class="separator:aad192d491d4dad2bdea26c8e1c0a9ab1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aced6912ea4c1324431f504b407cc2745"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:aced6912ea4c1324431f504b407cc2745"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aced6912ea4c1324431f504b407cc2745">get_function_laplacians</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; std::vector&lt; typename InputVector::value_type &gt;&gt; &amp;laplacians, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:aced6912ea4c1324431f504b407cc2745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to third derivatives of global finite element fields</div></td></tr>
<tr class="memitem:a07414796ef13160769987e6e252f3d1f"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a07414796ef13160769987e6e252f3d1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a07414796ef13160769987e6e252f3d1f">get_function_third_derivatives</a> (const InputVector &amp;fe_function, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;third_derivatives) const</td></tr>
<tr class="separator:a07414796ef13160769987e6e252f3d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa181bd794cd9e423b70f87b41309bd"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:abaa181bd794cd9e423b70f87b41309bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abaa181bd794cd9e423b70f87b41309bd">get_function_third_derivatives</a> (const InputVector &amp;fe_function, std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;third_derivatives, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:abaa181bd794cd9e423b70f87b41309bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9220827b037d7b44fba1e36e56f2e810"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a9220827b037d7b44fba1e36e56f2e810"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9220827b037d7b44fba1e36e56f2e810">get_function_third_derivatives</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;third_derivatives) const</td></tr>
<tr class="separator:a9220827b037d7b44fba1e36e56f2e810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7fe4012e770f17e192ae4ded255cb7"><td class="memTemplParams" colspan="2">template&lt;class InputVector &gt; </td></tr>
<tr class="memitem:a3c7fe4012e770f17e192ae4ded255cb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3c7fe4012e770f17e192ae4ded255cb7">get_function_third_derivatives</a> (const InputVector &amp;fe_function, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices, <a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt; third_derivatives, const <a class="el" href="classbool.html">bool</a> quadrature_points_fastest=false) const</td></tr>
<tr class="separator:a3c7fe4012e770f17e192ae4ded255cb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cell degrees of freedom</div></td></tr>
<tr class="memitem:a93872d888911cda7e2e716168afc1b3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a> () const</td></tr>
<tr class="separator:a93872d888911cda7e2e716168afc1b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dfe8baa6858e3edb5a1f0190fc3f85e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7dfe8baa6858e3edb5a1f0190fc3f85e">dof_indices_starting_at</a> (const unsigned <a class="el" href="classint.html">int</a> start_dof_index) const</td></tr>
<tr class="separator:a7dfe8baa6858e3edb5a1f0190fc3f85e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a4ca7b33a291c07d9c155ccbf314d5f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3a4ca7b33a291c07d9c155ccbf314d5f">dof_indices_ending_at</a> (const unsigned <a class="el" href="classint.html">int</a> end_dof_index) const</td></tr>
<tr class="separator:a3a4ca7b33a291c07d9c155ccbf314d5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometry of the cell</div></td></tr>
<tr class="memitem:aada8380792b5e6a1f91dcba94b558cb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a> () const</td></tr>
<tr class="separator:aada8380792b5e6a1f91dcba94b558cb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab123e5da03736be4977c76fbcb6a2e37"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a> (const unsigned <a class="el" href="classint.html">int</a> q) const</td></tr>
<tr class="separator:ab123e5da03736be4977c76fbcb6a2e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae41b67cfd48e02f6035e39c84f0fb47a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a> () const</td></tr>
<tr class="separator:ae41b67cfd48e02f6035e39c84f0fb47a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abade89efb068b71b7ced7082012a2441"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:abade89efb068b71b7ced7082012a2441"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7371618d5977d28dfe82c81fbac29c0f"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7371618d5977d28dfe82c81fbac29c0f">get_JxW_values</a> () const</td></tr>
<tr class="separator:a7371618d5977d28dfe82c81fbac29c0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6abe3ffe1b14b2472093b4d95b09b76f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6abe3ffe1b14b2472093b4d95b09b76f">jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a6abe3ffe1b14b2472093b4d95b09b76f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb95b09ced1230e1f29ce993eedb1ccf"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acb95b09ced1230e1f29ce993eedb1ccf">get_jacobians</a> () const</td></tr>
<tr class="separator:acb95b09ced1230e1f29ce993eedb1ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24b8b21f05fe45701ce5d71e8952d893"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a24b8b21f05fe45701ce5d71e8952d893">jacobian_grad</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a24b8b21f05fe45701ce5d71e8952d893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d228651f45f5e9a8d787d2137e71e86"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9d228651f45f5e9a8d787d2137e71e86">get_jacobian_grads</a> () const</td></tr>
<tr class="separator:a9d228651f45f5e9a8d787d2137e71e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d9388afa7d9ee1266d824b37fbff27"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ab7d9388afa7d9ee1266d824b37fbff27">jacobian_pushed_forward_grad</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:ab7d9388afa7d9ee1266d824b37fbff27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5819f15c0e821762a0abc60fc77ddd54"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5819f15c0e821762a0abc60fc77ddd54">get_jacobian_pushed_forward_grads</a> () const</td></tr>
<tr class="separator:a5819f15c0e821762a0abc60fc77ddd54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aed77844d697d26e19cf0e9e6891351"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 3, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5aed77844d697d26e19cf0e9e6891351">jacobian_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a5aed77844d697d26e19cf0e9e6891351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa784c826743ed3a66e178a9260b040be"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 3, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa784c826743ed3a66e178a9260b040be">get_jacobian_2nd_derivatives</a> () const</td></tr>
<tr class="separator:aa784c826743ed3a66e178a9260b040be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c0f9a8b40a506ef6746da258f93c32"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 4, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ad3c0f9a8b40a506ef6746da258f93c32">jacobian_pushed_forward_2nd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:ad3c0f9a8b40a506ef6746da258f93c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb9be9ddf679019e37e9d3474d893f3a"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 4, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#abb9be9ddf679019e37e9d3474d893f3a">get_jacobian_pushed_forward_2nd_derivatives</a> () const</td></tr>
<tr class="separator:abb9be9ddf679019e37e9d3474d893f3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2747bbb82f8bf29b762253778d2c0839"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 4, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2747bbb82f8bf29b762253778d2c0839">jacobian_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:a2747bbb82f8bf29b762253778d2c0839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae391823baf3ecd0792a867c0b031aa62"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 4, dim, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae391823baf3ecd0792a867c0b031aa62">get_jacobian_3rd_derivatives</a> () const</td></tr>
<tr class="separator:ae391823baf3ecd0792a867c0b031aa62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6683da072e8135a4e423894457f2782"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 5, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac6683da072e8135a4e423894457f2782">jacobian_pushed_forward_3rd_derivative</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:ac6683da072e8135a4e423894457f2782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf9ada77adee2b864e57dda00e25339"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 5, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#adcf9ada77adee2b864e57dda00e25339">get_jacobian_pushed_forward_3rd_derivatives</a> () const</td></tr>
<tr class="separator:adcf9ada77adee2b864e57dda00e25339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539d494cab9b9f2a9d6fd8e78c9666e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, dim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html#ab123e5da03736be4977c76fbcb6a2e37">quadrature_point</a>) const</td></tr>
<tr class="separator:aa539d494cab9b9f2a9d6fd8e78c9666e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52bfab60e48072979414b34bbbce4418"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, spacedim, dim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a52bfab60e48072979414b34bbbce4418">get_inverse_jacobians</a> () const</td></tr>
<tr class="separator:a52bfab60e48072979414b34bbbce4418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac25ec6835799c3b6c7c842f8acb05eb3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ac25ec6835799c3b6c7c842f8acb05eb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a7ca22ff683ad2feeea0c579681a6ed"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2a7ca22ff683ad2feeea0c579681a6ed">get_normal_vectors</a> () const</td></tr>
<tr class="separator:a2a7ca22ff683ad2feeea0c579681a6ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extractors Methods to extract individual components</div></td></tr>
<tr class="memitem:a7670d68d12957e0ca99569a17c63efb2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a7670d68d12957e0ca99569a17c63efb2">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;scalar) const</td></tr>
<tr class="separator:a7670d68d12957e0ca99569a17c63efb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bb48e1d06471efe7835f827f3c315a3"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a3bb48e1d06471efe7835f827f3c315a3">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;vector) const</td></tr>
<tr class="separator:a3bb48e1d06471efe7835f827f3c315a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfcef98b4371fe0ccc2e5da644cef1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1SymmetricTensor.html">FEValuesViews::SymmetricTensor</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a8bfcef98b4371fe0ccc2e5da644cef1f">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;tensor) const</td></tr>
<tr class="separator:a8bfcef98b4371fe0ccc2e5da644cef1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af092b17057ebfeeba90ac58f9205bc86"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFEValuesViews_1_1Tensor.html">FEValuesViews::Tensor</a>&lt; 2, dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af092b17057ebfeeba90ac58f9205bc86">operator[]</a> (const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;tensor) const</td></tr>
<tr class="separator:af092b17057ebfeeba90ac58f9205bc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Access to the raw data</div></td></tr>
<tr class="memitem:adcc1b936b41b758dad7ddae21c71f14c"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#adcc1b936b41b758dad7ddae21c71f14c">get_mapping</a> () const</td></tr>
<tr class="separator:adcc1b936b41b758dad7ddae21c71f14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade22ffd9fb5b07842daa504929244aa7"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a> () const</td></tr>
<tr class="separator:ade22ffd9fb5b07842daa504929244aa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b258a1619829f7ec03a184ffb8e556"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a55b258a1619829f7ec03a184ffb8e556">get_update_flags</a> () const</td></tr>
<tr class="separator:a55b258a1619829f7ec03a184ffb8e556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7cc3af52cb9ce98d5562592901f4fb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aaf7cc3af52cb9ce98d5562592901f4fb">get_cell</a> () const</td></tr>
<tr class="separator:aaf7cc3af52cb9ce98d5562592901f4fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808af56bde1d82893b88875dc651e749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a808af56bde1d82893b88875dc651e749">get_cell_similarity</a> () const</td></tr>
<tr class="separator:a808af56bde1d82893b88875dc651e749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a></td></tr>
<tr class="separator:a807c3049bfe81743fc0f237dfc2fbdea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4f8b164f3fa6f25982c8a52fefe0995"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#af4f8b164f3fa6f25982c8a52fefe0995">max_n_quadrature_points</a></td></tr>
<tr class="separator:af4f8b164f3fa6f25982c8a52fefe0995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memItemLeft" align="right" valign="top">const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5b264d5b2fb6615f5dea7a21135ed1a5">dofs_per_cell</a></td></tr>
<tr class="separator:a5b264d5b2fb6615f5dea7a21135ed1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a627033acd32f5d22a4bb82444267a240"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a627033acd32f5d22a4bb82444267a240">integral_dimension</a> = dim</td></tr>
<tr class="separator:a627033acd32f5d22a4bb82444267a240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd889a38bbce8ea33d46d152f14abdd3"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#afd889a38bbce8ea33d46d152f14abdd3">dimension</a> = dim</td></tr>
<tr class="separator:afd889a38bbce8ea33d46d152f14abdd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541820cb52f78a4d43de18be0352002"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a6541820cb52f78a4d43de18be0352002">space_dimension</a> = spacedim</td></tr>
<tr class="separator:a6541820cb52f78a4d43de18be0352002"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aaf01126d2e3b926fecbaf122357add53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aaf01126d2e3b926fecbaf122357add53">invalidate_present_cell</a> ()</td></tr>
<tr class="separator:aaf01126d2e3b926fecbaf122357add53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed652da6ec16e368e27da4085b4281bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aed652da6ec16e368e27da4085b4281bb">maybe_invalidate_previous_present_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:aed652da6ec16e368e27da4085b4281bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1352ba7f04525e175d2c6fa552a1c6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa1352ba7f04525e175d2c6fa552a1c6a">compute_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>) const</td></tr>
<tr class="separator:aa1352ba7f04525e175d2c6fa552a1c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5c38a7d7c3a6b384ad5b46f38248524d">check_cell_similarity</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell)</td></tr>
<tr class="separator:a5c38a7d7c3a6b384ad5b46f38248524d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:acf87f79b7e82e60650bc9227deb6aeb9"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; const CellIteratorBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acf87f79b7e82e60650bc9227deb6aeb9">present_cell</a></td></tr>
<tr class="separator:acf87f79b7e82e60650bc9227deb6aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7274f2ea9bbe0ea61bd983c5746ffef"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa7274f2ea9bbe0ea61bd983c5746ffef">tria_listener_refinement</a></td></tr>
<tr class="separator:aa7274f2ea9bbe0ea61bd983c5746ffef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f853782c9ba1f6c4093f64ede145253"><td class="memItemLeft" align="right" valign="top">boost::signals2::connection&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a2f853782c9ba1f6c4093f64ede145253">tria_listener_mesh_transform</a></td></tr>
<tr class="separator:a2f853782c9ba1f6c4093f64ede145253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5502d4cd55c37491d1f89e41285fc7e5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a5502d4cd55c37491d1f89e41285fc7e5">mapping</a></td></tr>
<tr class="separator:a5502d4cd55c37491d1f89e41285fc7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2786d839ac016cd2181c1a2acf7b755"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#aa2786d839ac016cd2181c1a2acf7b755">mapping_data</a></td></tr>
<tr class="separator:aa2786d839ac016cd2181c1a2acf7b755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faa26fda7aba97298344ab95b4753ac"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a9faa26fda7aba97298344ab95b4753ac">mapping_output</a></td></tr>
<tr class="separator:a9faa26fda7aba97298344ab95b4753ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67500f1f0d3d40e014e562d375f911f8"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a67500f1f0d3d40e014e562d375f911f8">fe</a></td></tr>
<tr class="separator:a67500f1f0d3d40e014e562d375f911f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae73456971913b569cfb5d79dc827e9bc"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;::InternalDataBase &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#ae73456971913b569cfb5d79dc827e9bc">fe_data</a></td></tr>
<tr class="separator:ae73456971913b569cfb5d79dc827e9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfc8644fa994116af02667ddd6517ae3"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#acfc8644fa994116af02667ddd6517ae3">finite_element_output</a></td></tr>
<tr class="separator:acfc8644fa994116af02667ddd6517ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63ed91bcc8004390e372704d63177162"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a></td></tr>
<tr class="separator:a63ed91bcc8004390e372704d63177162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a096d4ea9edea6618e23f5f13ab40784c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesBase.html#a096d4ea9edea6618e23f5f13ab40784c">cell_similarity</a></td></tr>
<tr class="separator:a096d4ea9edea6618e23f5f13ab40784c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a887641164e5e42d1c2300e552b6edcbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a887641164e5e42d1c2300e552b6edcbd">initialize</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html#a63ed91bcc8004390e372704d63177162">update_flags</a>)</td></tr>
<tr class="separator:a887641164e5e42d1c2300e552b6edcbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1244db200d87403103119e3d62872745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a1244db200d87403103119e3d62872745">do_reinit</a> ()</td></tr>
<tr class="separator:a1244db200d87403103119e3d62872745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a50edb536baf30f637a51203f0e73d15e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a></td></tr>
<tr class="separator:a50edb536baf30f637a51203f0e73d15e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class FEValues&lt; dim, spacedim &gt;</h3>

<p>Finite element evaluated in quadrature points of a cell.</p>
<p>This function implements the initialization routines for <a class="el" href="classFEValuesBase.html">FEValuesBase</a>, if values in quadrature points of a cell are needed. For further documentation see this class. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html#l00038">38</a> of file <a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a051be8559fb1a35dff1ba230864d94b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051be8559fb1a35dff1ba230864d94b3">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Gets cell independent data from mapping and finite element objects, matching the quadrature rule and update flags. </p>

</div>
</div>
<a id="a6e29a8987e36c016fa9e5c5ad68f0fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e29a8987e36c016fa9e5c5ad68f0fda">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but taking a collection of quadrature rules.</p>
<dl class="section note"><dt>Note</dt><dd>We require, in contrast to <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, that the number of quadrature rules in the collection is one. </dd></dl>

</div>
</div>
<a id="a80f982108aa0d834923a57fa328d1c7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80f982108aa0d834923a57fa328d1c7e">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. This constructor is equivalent to the other one except that it makes the object use a \(Q_1\) mapping (i.e., an object of type <a class="el" href="classMappingQGeneric.html">MappingQGeneric(1)</a>) implicitly. </p>

</div>
</div>
<a id="a5eb7498746ed379c23466e9de536c319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb7498746ed379c23466e9de536c319">&#9670;&nbsp;</a></span>FEValues() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::<a class="el" href="classFEValues.html">FEValues</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the function above, but taking a collection of quadrature rules.</p>
<dl class="section note"><dt>Note</dt><dd>We require, in contrast to <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, that the number of quadrature rules in the collection is one. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a21f914e63d588e2652a9514620653d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f914e63d588e2652a9514620653d77">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dim, spacedim, level_dof_access &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the gradients, Jacobi determinants, etc for the given cell of type "iterator into a DoFHandler object", and the finite element associated with this object. It is assumed that the finite element used by the given cell is also the one used by this <a class="el" href="classFEValues.html">FEValues</a> object. </p>

</div>
</div>
<a id="a8a5f1445edcf7964ad66554b804dfa4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5f1445edcf7964ad66554b804dfa4c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the gradients, Jacobi determinants, etc for the given cell of type "iterator into a Triangulation object", and the given finite element. Since iterators into triangulation alone only convey information about the geometry of a cell, but not about degrees of freedom possibly associated with this cell, you will not be able to call some functions of this class if they need information about degrees of freedom. These functions are, above all, the <code>get_function_value/gradients/hessians/laplacians/third_derivatives</code> functions. If you want to call these functions, you have to call the <code>reinit</code> variants that take iterators into <a class="el" href="classDoFHandler.html">DoFHandler</a> or other DoF handler type objects. </p>

</div>
</div>
<a id="ae053b49309f1dce22268c6bc8fe50cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae053b49309f1dce22268c6bc8fe50cb2">&#9670;&nbsp;</a></span>get_quadrature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt;&amp; <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::get_quadrature </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the copy of the quadrature formula stored by this object. </p>

</div>
</div>
<a id="af649ad9baf7e58a6d43e266dec5523d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af649ad9baf7e58a6d43e266dec5523d9">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a902429920d32c81c9c279d9a15faa263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902429920d32c81c9c279d9a15faa263">&#9670;&nbsp;</a></span>get_present_fe_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValues.html">FEValues</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::get_present_fe_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to this very object.</p>
<p>Though it seems that it is not very useful, this function is there to provide capability to the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> class, in which case it provides the <a class="el" href="classFEValues.html">FEValues</a> object for the present cell (remember that for hp-finite elements, the actual FE object used may change from cell to cell, so we also need different <a class="el" href="classFEValues.html">FEValues</a> objects for different cells; once you reinitialize the <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a> object for a specific cell, it retrieves the <a class="el" href="classFEValues.html">FEValues</a> object for the FE on that cell and returns it through a function of the same name as this one; this function here therefore only provides the same interface so that one can templatize on <a class="el" href="classFEValues.html">FEValues</a> and <a class="el" href="classhp_1_1FEValues.html">hp::FEValues</a>). </p>

</div>
</div>
<a id="a887641164e5e42d1c2300e552b6edcbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887641164e5e42d1c2300e552b6edcbd">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do work common to the two constructors. </p>

</div>
</div>
<a id="a1244db200d87403103119e3d62872745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1244db200d87403103119e3d62872745">&#9670;&nbsp;</a></span>do_reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a> functions do only that part of the work that requires knowledge of the type of iterator. After setting <a class="el" href="classFEValuesBase.html#acf87f79b7e82e60650bc9227deb6aeb9">present_cell()</a>, they pass on to this function, which does the real work, and which is independent of the actual type of the cell iterator. </p>

</div>
</div>
<a id="a1dd48cb744013c448d57f8f77640c08d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd48cb744013c448d57f8f77640c08d">&#9670;&nbsp;</a></span>shape_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classdouble.html">double</a>&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Value of a shape function at a quadrature point on the cell, face or subface selected the last time the <code>reinit</code> function of the derived class was called.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated. Note that this number runs from zero to dofs_per_cell, even in the case of an <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object.</td></tr>
    <tr><td class="paramname">point_no</td><td>Number of the quadrature point at which function is to be evaluated</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aa57a7e777b0798ec009b4ce888ad9574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57a7e777b0798ec009b4ce888ad9574">&#9670;&nbsp;</a></span>shape_value_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_value_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute one vector component of the value of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated.</td></tr>
    <tr><td class="paramname">point_no</td><td>Number of the quadrature point at which function is to be evaluated.</td></tr>
    <tr><td class="paramname">component</td><td>vector component to be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a46aefdb527125dafb59dcba92a0f256e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46aefdb527125dafb59dcba92a0f256e">&#9670;&nbsp;</a></span>shape_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the gradient of the <code>function_no</code>th shape function at the <code>quadrature_point</code>th quadrature point with respect to real cell coordinates. If you want to get the derivative in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component of the <a class="el" href="classTensor.html">Tensor</a> returned by this function. Since only a reference to the gradient's value is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then it will throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#a71e93aa182f3acd34abd020538f3bc39">shape_grad_component()</a> function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">function_no</td><td>Number of the shape function to be evaluated.</td></tr>
    <tr><td class="paramname">quadrature_point</td><td>Number of the quadrature point at which function is to be evaluated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a71e93aa182f3acd34abd020538f3bc39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e93aa182f3acd34abd020538f3bc39">&#9670;&nbsp;</a></span>shape_grad_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_grad_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return one vector component of the gradient of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a83a37e5067b9fd879752048bc2d77d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83a37e5067b9fd879752048bc2d77d42">&#9670;&nbsp;</a></span>shape_hessian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;2, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Second derivatives of the <code>function_no</code>th shape function at the <code>point_no</code>th quadrature point with respect to real cell coordinates. If you want to get the derivatives in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component. Since only a reference to the hessian values is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the <a class="el" href="classFEValuesBase.html#a847929f632ae57b4305e9dca7270389a">shape_hessian_component()</a> function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a847929f632ae57b4305e9dca7270389a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a847929f632ae57b4305e9dca7270389a">&#9670;&nbsp;</a></span>shape_hessian_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;2, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_hessian_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return one vector component of the hessian of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the <a class="el" href="classFEValuesBase.html#a83a37e5067b9fd879752048bc2d77d42">shape_hessian()</a> function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by <a class="el" href="classFEValuesBase.html#a83a37e5067b9fd879752048bc2d77d42">shape_hessian()</a> equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ad99ebb836476c7b72c0cd2ca3594827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad99ebb836476c7b72c0cd2ca3594827b">&#9670;&nbsp;</a></span>shape_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Third derivatives of the <code>function_no</code>th shape function at the <code>point_no</code>th quadrature point with respect to real cell coordinates. If you want to get the 3rd derivatives in one of the coordinate directions, use the appropriate function of the <a class="el" href="classTensor.html">Tensor</a> class to extract one component. Since only a reference to the 3rd derivative values is returned, there should be no major performance drawback.</p>
<p>If the shape function is vector-valued, then this returns the only non- zero component. If the shape function has more than one non-zero component (i.e. it is not primitive), then throw an exception of type ExcShapeFunctionNotPrimitive. In that case, use the shape_3rdderivative_component() function.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#a1dd48cb744013c448d57f8f77640c08d">shape_value()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a77234bc51dd64a24880bb50c834bb210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77234bc51dd64a24880bb50c834bb210">&#9670;&nbsp;</a></span>shape_3rd_derivative_component()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::shape_3rd_derivative_component </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>function_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>point_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return one vector component of the third derivative of a shape function at a quadrature point. If the finite element is scalar, then only component zero is allowed and the return value equals that of the shape_3rdderivative() function. If the finite element is vector valued but all shape functions are primitive (i.e. they are non-zero in only one component), then the value returned by shape_3rdderivative() equals that of this function for exactly one component. This function is therefore only of greater interest if the shape function is not primitive, but then it is necessary since the other function cannot be used.</p>
<p>The same holds for the arguments of this function as for the <a class="el" href="classFEValuesBase.html#aa57a7e777b0798ec009b4ce888ad9574">shape_value_component()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a357b422e374f2f2207af3512093f3907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a357b422e374f2f2207af3512093f3907">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the values of a finite element function restricted to the current cell, face or subface selected the last time the <code>reinit</code> function of the derived class was called, at the quadrature points.</p>
<p>If the present cell is not active then values are interpolated to the current cell and point values are computed from that.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. To get values of multi- component elements, there is another <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> below, returning a vector of vectors of results.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>The values of the function specified by fe_function at the quadrature points of the current cell. The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the values of shape function times the type used to store the values of the unknowns \(U_j\) of your finite element vector \(U\) (represented by the <code>fe_function</code> argument). This happens to be equal to the type of the elements of the solution vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> will contain the value of the field described by fe_function at the \(q\)th quadrature point.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ac8756b2e6e63977f37a3f26fdf83a7be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8756b2e6e63977f37a3f26fdf83a7be">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>values[q]</code> is a vector of values of the field described by fe_function at the \(q\)th quadrature point. The size of the vector accessed by <code>values[q]</code> equals the number of components of the finite element, i.e. <code>values[q](c)</code> returns the value of the \(c\)th vector component at the \(q\)th quadrature point.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a378b552c1b8ca9f23f89677910e7a5cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378b552c1b8ca9f23f89677910e7a5cd">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate function values from an arbitrary vector. This function does in essence the same as the first function of this name above, except that it does not make the assumption that the input vector corresponds to a <a class="el" href="classDoFHandler.html">DoFHandler</a> that describes the unknowns of a finite element field (and for which we would then assume that <code>fe_function.size() == dof_handler.n_dofs()</code>). Rather, the nodal values corresponding to the current cell are elements of an otherwise arbitrary vector, and these elements are indexed by the second argument to this function. What the rest of the <code>fe_function</code> input argument corresponds to is of no consequence to this function.</p>
<p>Given this, the function above corresponds to passing <code>fe_function</code> as first argument to the current function, and using the <code>local_dof_indices</code> array that results from the following call as second argument to the current function: </p><div class="fragment"><div class="line">cell-&gt;get_dof_indices (local_dof_indices);</div></div><!-- fragment --><p> (See <a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">DoFCellAccessor::get_dof_indices()</a> for more information.)</p>
<p>Likewise, the function above is equivalent to calling </p><div class="fragment"><div class="line">cell-&gt;get_dof_values (fe_function, local_dof_values);</div></div><!-- fragment --><p> and then calling the current function with <code>local_dof_values</code> as first argument, and an array with indices <code>{0,...,fe.dofs_per_cell-1}</code> as second argument.</p>
<p>The point of the current function is that one sometimes wants to evaluate finite element functions at quadrature points with nodal values that are not stored in a global vector &ndash; for example, one could modify these local values first, such as by applying a limiter or by ensuring that all nodal values are positive, before evaluating the finite element field that corresponds to these local values on the current cell. Another application is where one wants to postprocess the solution on a cell into a different finite element space on every cell, without actually creating a corresponding <a class="el" href="classDoFHandler.html">DoFHandler</a> &ndash; in that case, all one would compute is a local representation of that postprocessed function, characterized by its nodal values; this function then allows the evaluation of that representation at quadrature points.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of nodal values. This vector can have an arbitrary size, as long as all elements index by <code>indices</code> can actually be accessed.</td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices</td><td>A vector of indices into <code>fe_function</code>. This vector must have length equal to the number of degrees of freedom on the current cell, and must identify elements in <code>fe_function</code> in the order in which degrees of freedom are indexed on the reference cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">values</td><td>A vector of values of the given finite element field, at the quadrature points on the current object.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a5cee3d4c01d14d74be02a797650f561f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cee3d4c01d14d74be02a797650f561f">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate vector function values from an arbitrary vector.</p>
<p>This function corresponds to the previous one, just for the vector-valued case.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ad0f91fd23806e90bfe74b7446b835210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0f91fd23806e90bfe74b7446b835210">&#9670;&nbsp;</a></span>get_function_values() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; typename InputVector::value_type &gt;&gt;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate vector function values from an arbitrary vector. This function is similar to the previous one, but the <code>indices</code> vector may also be a multiple of the number of dofs per cell. Then, the vectors in <code>value</code> should allow for the same multiple of the components of the finite element.</p>
<p>Depending on the value of the last argument, the outer vector of <code>values</code> has either the length of the quadrature rule (<code>quadrature_points_fastest == false</code>) or the length of components to be filled <code>quadrature_points_fastest == true</code>. If <code>p</code> is the current quadrature point number and <code>i</code> is the vector component of the solution desired, the access to <code>values</code> is <code>values[p][i]</code> if <code>quadrature_points_fastest == false</code>, and <code>values[i][p]</code> otherwise.</p>
<p>Since this function allows for fairly general combinations of argument sizes, be aware that the checks on the arguments may not detect errors.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ad1f4e0deb5d982e8172d82141c634a67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1f4e0deb5d982e8172d82141c634a67">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the gradients of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's gradient instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">gradients</td><td>The gradients of the function specified by fe_function at the quadrature points of the current cell. The gradients are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the gradients of shape function times the type used to store the values of the unknowns \(U_j\) of your finite element vector \(U\) (represented by the <code>fe_function</code> argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> will contain the gradient of the field described by fe_function at the \(q\)th quadrature point. <code>gradients[q][d]</code> represents the derivative in coordinate direction \(d\) at quadrature point \(q\).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ae991c7d48b60b228897a91a00bd6900d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae991c7d48b60b228897a91a00bd6900d">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>gradients[q]</code> is a vector of gradients of the field described by fe_function at the \(q\)th quadrature point. The size of the vector accessed by <code>gradients[q]</code> equals the number of components of the finite element, i.e. <code>gradients[q][c]</code> returns the gradient of the \(c\)th vector component at the \(q\)th quadrature point. Consequently, <code>gradients[q][c][d]</code> is the derivative in coordinate direction \(d\) of the \(c\)th vector component of the vector field at quadrature point \(q\) of the current cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aa9ed70ad8baff761b1232bc111a00ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ed70ad8baff761b1232bc111a00ffd">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>gradients</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aef4213cb7edc4788d42a923af0d5a563"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4213cb7edc4788d42a923af0d5a563">&#9670;&nbsp;</a></span>get_function_gradients() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_gradients </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename InputVector::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>gradients</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_gradients</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ae8f183c9d6da0c7daf9d345e0bc91b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8f183c9d6da0c7daf9d345e0bc91b0a">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the tensor of second derivatives of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's second derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">hessians</td><td>The Hessians of the function specified by fe_function at the quadrature points of the current cell. The Hessians are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the Hessians of shape function times the type used to store the values of the unknowns \(U_j\) of your finite element vector \(U\) (represented by the <code>fe_function</code> argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> will contain the Hessian of the field described by fe_function at the \(q\)th quadrature point. <code>hessians[q][i][j]</code> represents the \((i,j)\)th component of the matrix of second derivatives at quadrature point \(q\).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a4d80068005cd1283597e2e3f092864b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d80068005cd1283597e2e3f092864b3">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>hessians[q]</code> is a vector of Hessians of the field described by fe_function at the \(q\)th quadrature point. The size of the vector accessed by <code>hessians[q]</code> equals the number of components of the finite element, i.e. <code>hessians[q][c]</code> returns the Hessian of the \(c\)th vector component at the \(q\)th quadrature point. Consequently, <code>hessians[q][c][i][j]</code> is the \((i,j)\)th component of the matrix of second derivatives of the \(c\)th vector component of the vector field at quadrature point \(q\) of the current cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ac081e64d8a7f72f36bc87ee100f623dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac081e64d8a7f72f36bc87ee100f623dc">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>hessians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a0090df9b494c98f66c6db4cacc27502b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0090df9b494c98f66c6db4cacc27502b">&#9670;&nbsp;</a></span>get_function_hessians() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_hessians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim, typename InputVector::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>hessians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a9e058f0caf1c888010bfc2c616ab4ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e058f0caf1c888010bfc2c616ab4ebd">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the (scalar) Laplacian (i.e. the trace of the tensor of second derivatives) of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's second derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">laplacians</td><td>The Laplacians of the function specified by fe_function at the quadrature points of the current cell. The Laplacians are computed in real space (as opposed to on the unit cell). The object is assume to already have the correct size. The data type stored by this output vector must be what you get when you multiply the Laplacians of shape function times the type used to store the values of the unknowns \(U_j\) of your finite element vector \(U\) (represented by the <code>fe_function</code> argument). This happens to be equal to the type of the elements of the input vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> will contain the Laplacian of the field described by fe_function at the \(q\)th quadrature point.</dd>
<dd>
For each component of the output vector, there holds <code>laplacians[q]=trace(hessians[q])</code>, where <code>hessians</code> would be the output of the <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians()</a> function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a08fb3cd3ffccb0f0a7b2454601428f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08fb3cd3ffccb0f0a7b2454601428f0c">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians()</a>, but applied to multi-component (vector-valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>laplacians[q]</code> is a vector of Laplacians of the field described by fe_function at the \(q\)th quadrature point. The size of the vector accessed by <code>laplacians[q]</code> equals the number of components of the finite element, i.e. <code>laplacians[q][c]</code> returns the Laplacian of the \(c\)th vector component at the \(q\)th quadrature point.</dd>
<dd>
For each component of the output vector, there holds <code>laplacians[q][c]=trace(hessians[q][c])</code>, where <code>hessians</code> would be the output of the <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">get_function_hessians()</a> function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a062e419bf95dc7e6f83dcf1e0eeeedd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062e419bf95dc7e6f83dcf1e0eeeedd7">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aad192d491d4dad2bdea26c8e1c0a9ab1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad192d491d4dad2bdea26c8e1c0a9ab1">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aced6912ea4c1324431f504b407cc2745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced6912ea4c1324431f504b407cc2745">&#9670;&nbsp;</a></span>get_function_laplacians() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_laplacians </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>laplacians</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#a9e058f0caf1c888010bfc2c616ab4ebd">get_function_laplacians()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_hessians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a07414796ef13160769987e6e252f3d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07414796ef13160769987e6e252f3d1f">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the tensor of third derivatives of a finite element at the quadrature points of a cell. This function is the equivalent of the corresponding <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> function (see there for more information) but evaluates the finite element field's third derivatives instead of its value.</p>
<p>This function may only be used if the finite element in use is a scalar one, i.e. has only one vector component. There is a corresponding function of the same name for vector-valued finite elements.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector of values that describes (globally) the finite element function that this function should evaluate at the quadrature points of the current cell.</td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">third_derivatives</td><td>The third derivatives of the function specified by fe_function at the quadrature points of the current cell. The third derivatives are computed in real space (as opposed to on the unit cell). The object is assumed to already have the correct size. The data type stored by this output vector must be what you get when you multiply the third derivatives of shape function times the type used to store the values of the unknowns \(U_j\) of your finite element vector \(U\) (represented by the <code>fe_function</code> argument).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section post"><dt>Postcondition</dt><dd><code>third_derivatives[q]</code> will contain the third derivatives of the field described by fe_function at the \(q\)th quadrature point. <code>third_derivatives[q][i][j][k]</code> represents the \((i,j,k)\)th component of the 3rd order tensor of third derivatives at quadrature point \(q\).</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The actual data type of the input vector may be either a <a class="el" href="classVector.html">Vector</a>&lt;T&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;T&gt;, or one of the PETSc or Trilinos vector wrapper classes. It represents a global vector of DoF values associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> object with which this <a class="el" href="classFEValues.html">FEValues</a> object was last initialized.</dd>
<dd>
For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="abaa181bd794cd9e423b70f87b41309bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa181bd794cd9e423b70f87b41309bd">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does the same as the other <a class="el" href="classFEValuesBase.html#a07414796ef13160769987e6e252f3d1f">get_function_third_derivatives()</a>, but applied to multi-component (vector- valued) elements. The meaning of the arguments is as explained there.</p>
<dl class="section post"><dt>Postcondition</dt><dd><code>third_derivatives[q]</code> is a vector of third derivatives of the field described by fe_function at the \(q\)th quadrature point. The size of the vector accessed by <code>third_derivatives[q]</code> equals the number of components of the finite element, i.e. <code>third_derivatives[q][c]</code> returns the third derivative of the \(c\)th vector component at the \(q\)th quadrature point. Consequently, <code>third_derivatives[q][c][i][j][k]</code> is the \((i,j,k)\)th component of the tensor of third derivatives of the \(c\)th vector component of the vector field at quadrature point \(q\) of the current cell.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a9220827b037d7b44fba1e36e56f2e810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9220827b037d7b44fba1e36e56f2e810">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#a07414796ef13160769987e6e252f3d1f">get_function_third_derivatives()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a3c7fe4012e770f17e192ae4ded255cb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7fe4012e770f17e192ae4ded255cb7">&#9670;&nbsp;</a></span>get_function_third_derivatives() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;class InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_function_third_derivatives </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim, typename InputVector::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>third_derivatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>quadrature_points_fastest</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function relates to the first of the <a class="el" href="classFEValuesBase.html#a07414796ef13160769987e6e252f3d1f">get_function_third_derivatives()</a> function above in the same way as the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> with similar arguments relates to the first of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">get_function_values()</a> functions. See there for more information.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a93872d888911cda7e2e716168afc1b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93872d888911cda7e2e716168afc1b3f">&#9670;&nbsp;</a></span>dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dof_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero (inclusive) to <code>dofs_per_cell</code> (exclusive). This allows one to write code using range-based <code>for</code> loops of the following kind: </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values (...);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q : fe_values.quadrature_point_indices())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.dof_indices())</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += ...; <span class="comment">// Do something for DoF indices (i,j)</span></div><div class="line">                                   <span class="comment">// at quadrature point q</span></div><div class="line">  }</div></div><!-- fragment --><p> Here, we are looping over all degrees of freedom on all cells, with <code>i</code> and <code>j</code> taking on all valid indices for cell degrees of freedom, as defined by the finite element passed to <code>fe_values</code>. </p>

</div>
</div>
<a id="a7dfe8baa6858e3edb5a1f0190fc3f85e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dfe8baa6858e3edb5a1f0190fc3f85e">&#9670;&nbsp;</a></span>dof_indices_starting_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dof_indices_starting_at </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>start_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from <code>start_dof_index</code> (inclusive) to <code>dofs_per_cell</code> (exclusive). This allows one to write code using range-based <code>for</code> loops of the following kind: </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values (...);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q : fe_values.quadrature_point_indices())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.dof_indices_starting_at(i))</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += ...; <span class="comment">// Do something for DoF indices (i,j)</span></div><div class="line">                                   <span class="comment">// at quadrature point q</span></div><div class="line">  }</div></div><!-- fragment --><p> Here, we are looping over all local degrees of freedom on all cells, with <code>i</code> taking on all valid indices for cell degrees of freedom, as defined by the finite element passed to <code>fe_values</code>, and <code>j</code> taking on a specified subset of <code>i</code>'s range, starting at <code>i</code> itself and ending at the number of cell degrees of freedom. In this way, we can construct the upper half and the diagonal of a stiffness matrix contribution (assuming it is symmetric, and that only one half of it needs to be computed), for example.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>start_dof_index</code> is equal to the number of DoFs in the cell, then the returned index range is empty. </dd></dl>

</div>
</div>
<a id="a3a4ca7b33a291c07d9c155ccbf314d5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a4ca7b33a291c07d9c155ccbf314d5f">&#9670;&nbsp;</a></span>dof_indices_ending_at()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dof_indices_ending_at </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_dof_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero (inclusive) to <code>end_dof_index</code> (inclusive). This allows one to write code using range-based <code>for</code> loops of the following kind: </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values (...);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a> = 0;</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q : fe_values.quadrature_point_indices())</div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> i : fe_values.dof_indices())</div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> j : fe_values.dof_indices_ending_at(i))</div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j) += ...; <span class="comment">// Do something for DoF indices (i,j)</span></div><div class="line">                                   <span class="comment">// at quadrature point q</span></div><div class="line">  }</div></div><!-- fragment --><p> Here, we are looping over all local degrees of freedom on all cells, with <code>i</code> taking on all valid indices for cell degrees of freedom, as defined by the finite element passed to <code>fe_values</code>, and <code>j</code> taking on a specified subset of <code>i</code>'s range, starting at zero and ending at <code>i</code> itself. In this way, we can construct the lower half and the diagonal of a stiffness matrix contribution (assuming it is symmetric, and that only one half of it needs to be computed), for example.</p>
<dl class="section note"><dt>Note</dt><dd>If the <code>end_dof_index</code> is equal to zero, then the returned index range is empty. </dd></dl>

</div>
</div>
<a id="aada8380792b5e6a1f91dcba94b558cb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada8380792b5e6a1f91dcba94b558cb8">&#9670;&nbsp;</a></span>quadrature_point_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::quadrature_point_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <code>n_quadrature_points</code>. This allows to write code using range-based <code>for</code> loops of the following kind: </p><div class="fragment"><div class="line"><a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a> fe_values (...);</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : dof_handler.active_cell_iterators())</div><div class="line">  {</div><div class="line">    fe_values.reinit(cell);</div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> q_point : fe_values.quadrature_point_indices())</div><div class="line">      ... <span class="keywordflow">do</span> something at the <a class="code" href="classFEValues.html#a50edb536baf30f637a51203f0e73d15e">quadrature</a> <a class="code" href="namespaceOpenCASCADE.html#a041fdfae3d9ed8c073c54277acdd0b96">point</a> ...</div><div class="line">  }</div></div><!-- fragment --><p> Here, we are looping over all quadrature points on all cells, with <code>q_point</code> taking on all valid indices for quadrature points, as defined by the quadrature rule passed to <code>fe_values</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__CPP11.html">deal.II and the C++11 standard</a> </dd></dl>

</div>
</div>
<a id="ab123e5da03736be4977c76fbcb6a2e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab123e5da03736be4977c76fbcb6a2e37">&#9670;&nbsp;</a></span>quadrature_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::quadrature_point </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>q</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Position of the <code>q</code>th quadrature point in real space.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_quadrature_points</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ae41b67cfd48e02f6035e39c84f0fb47a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae41b67cfd48e02f6035e39c84f0fb47a">&#9670;&nbsp;</a></span>get_quadrature_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_quadrature_points </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the vector of quadrature points in real space.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_quadrature_points</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="abade89efb068b71b7ced7082012a2441"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abade89efb068b71b7ced7082012a2441">&#9670;&nbsp;</a></span>JxW()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::JxW </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mapped quadrature weight. If this object refers to a volume evaluation (i.e. the derived class is of type <a class="el" href="classFEValues.html">FEValues</a>), then this is the Jacobi determinant times the weight of the *<code>i</code>th unit quadrature point.</p>
<p>For surface evaluations (i.e. classes <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>), it is the mapped surface element times the weight of the quadrature point.</p>
<p>You can think of the quantity returned by this function as the volume or surface element \(dx, ds\) in the integral that we implement here by quadrature.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_JxW_values</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a7371618d5977d28dfe82c81fbac29c0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7371618d5977d28dfe82c81fbac29c0f">&#9670;&nbsp;</a></span>get_JxW_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_JxW_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW()</a>. </p>

</div>
</div>
<a id="a6abe3ffe1b14b2472093b4d95b09b76f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6abe3ffe1b14b2472093b4d95b09b76f">&#9670;&nbsp;</a></span>jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the Jacobian of the transformation at the specified quadrature point, i.e. \(J_{ij}=dx_i/d\hat x_j\)</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="acb95b09ced1230e1f29ce993eedb1ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb95b09ced1230e1f29ce993eedb1ccf">&#9670;&nbsp;</a></span>get_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by <a class="el" href="classFEValuesBase.html#a6abe3ffe1b14b2472093b4d95b09b76f">jacobian()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a24b8b21f05fe45701ce5d71e8952d893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24b8b21f05fe45701ce5d71e8952d893">&#9670;&nbsp;</a></span>jacobian_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the second derivative of the transformation from unit to real cell, i.e. the first derivative of the Jacobian, at the specified quadrature point, i.e. \(G_{ijk}=dJ_{jk}/d\hat x_i\).</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a9d228651f45f5e9a8d787d2137e71e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d228651f45f5e9a8d787d2137e71e86">&#9670;&nbsp;</a></span>get_jacobian_grads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;2, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_grads().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ab7d9388afa7d9ee1266d824b37fbff27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d9388afa7d9ee1266d824b37fbff27">&#9670;&nbsp;</a></span>jacobian_pushed_forward_grad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_grad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the second derivative of the transformation from unit to real cell, i.e. the first derivative of the Jacobian, at the specified quadrature point, pushed forward to the real cell coordinates, i.e. \(G_{ijk}=dJ_{iJ}/d\hat x_K (J_{jJ})^{-1} (J_{kK})^{-1}\).</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a5819f15c0e821762a0abc60fc77ddd54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5819f15c0e821762a0abc60fc77ddd54">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_grads()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;3, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_grads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_pushed_forward_grads().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_grads</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a5aed77844d697d26e19cf0e9e6891351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aed77844d697d26e19cf0e9e6891351">&#9670;&nbsp;</a></span>jacobian_2nd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;3, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the third derivative of the transformation from unit to real cell, i.e. the second derivative of the Jacobian, at the specified quadrature point, i.e. \(G_{ijkl}=\frac{d^2J_{ij}}{d\hat x_k d\hat x_l}\).</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aa784c826743ed3a66e178a9260b040be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa784c826743ed3a66e178a9260b040be">&#9670;&nbsp;</a></span>get_jacobian_2nd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;3, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_2nd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_2nd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ad3c0f9a8b40a506ef6746da258f93c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c0f9a8b40a506ef6746da258f93c32">&#9670;&nbsp;</a></span>jacobian_pushed_forward_2nd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;4, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_2nd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the third derivative of the transformation from unit to real cell, i.e. the second derivative of the Jacobian, at the specified quadrature point, pushed forward to the real cell coordinates, i.e. \(G_{ijkl}=\frac{d^2J_{iJ}}{d\hat x_K d\hat x_L} (J_{jJ})^{-1} (J_{kK})^{-1}(J_{lL})^{-1}\).</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="abb9be9ddf679019e37e9d3474d893f3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb9be9ddf679019e37e9d3474d893f3a">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_2nd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;4, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_2nd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_pushed_forward_2nd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a2747bbb82f8bf29b762253778d2c0839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2747bbb82f8bf29b762253778d2c0839">&#9670;&nbsp;</a></span>jacobian_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;4, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth derivative of the transformation from unit to real cell, i.e. the third derivative of the Jacobian, at the specified quadrature point, i.e. \(G_{ijklm}=\frac{d^2J_{ij}}{d\hat x_k d\hat x_l d\hat x_m}\).</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ae391823baf3ecd0792a867c0b031aa62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae391823baf3ecd0792a867c0b031aa62">&#9670;&nbsp;</a></span>get_jacobian_3rd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;4, dim, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_3rd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_3rd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ac6683da072e8135a4e423894457f2782"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6683da072e8135a4e423894457f2782">&#9670;&nbsp;</a></span>jacobian_pushed_forward_3rd_derivative()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;5, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::jacobian_pushed_forward_3rd_derivative </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth derivative of the transformation from unit to real cell, i.e. the third derivative of the Jacobian, at the specified quadrature point, pushed forward to the real cell coordinates, i.e. \(G_{ijklm}=\frac{d^3J_{iJ}}{d\hat x_K d\hat x_L d\hat x_M} (J_{jJ})^{-1} (J_{kK})^{-1} (J_{lL})^{-1} (J_{mM})^{-1}\).</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_3rd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="adcf9ada77adee2b864e57dda00e25339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf9ada77adee2b864e57dda00e25339">&#9670;&nbsp;</a></span>get_jacobian_pushed_forward_3rd_derivatives()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;5, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_jacobian_pushed_forward_3rd_derivatives </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by jacobian_pushed_forward_3rd_derivatives().</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_jacobian_pushed_forward_2nd_derivatives</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="aa539d494cab9b9f2a9d6fd8e78c9666e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa539d494cab9b9f2a9d6fd8e78c9666e">&#9670;&nbsp;</a></span>inverse_jacobian()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, spacedim, dim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::inverse_jacobian </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>quadrature_point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the inverse Jacobian of the transformation at the specified quadrature point, i.e. \(J_{ij}=d\hat x_i/dx_j\)</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_inverse_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a52bfab60e48072979414b34bbbce4418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52bfab60e48072979414b34bbbce4418">&#9670;&nbsp;</a></span>get_inverse_jacobians()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, spacedim, dim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_inverse_jacobians </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the array holding the values returned by <a class="el" href="classFEValuesBase.html#aa539d494cab9b9f2a9d6fd8e78c9666e">inverse_jacobian()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_inverse_jacobians</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="ac25ec6835799c3b6c7c842f8acb05eb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac25ec6835799c3b6c7c842f8acb05eb3">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector at a quadrature point. If you call this function for a face (i.e., when using a <a class="el" href="classFEFaceValues.html">FEFaceValues</a> or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object), then this function returns the outward normal vector to the cell at the <code>i</code>th quadrature point of the face.</p>
<p>In contrast, if you call this function for a cell of codimension one (i.e., when using a <code><a class="el" href="classFEValues.html">FEValues</a>&lt;dim,spacedim&gt;</code> object with <code>spacedim&gt;dim</code>), then this function returns the normal vector to the cell &ndash; in other words, an approximation to the normal vector to the manifold in which the triangulation is embedded. There are of course two normal directions to a manifold in that case, and this function returns the "up" direction as induced by the numbering of the vertices.</p>
<p>The length of the vector is normalized to one.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a2a7ca22ff683ad2feeea0c579681a6ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a7ca22ff683ad2feeea0c579681a6ed">&#9670;&nbsp;</a></span>get_normal_vectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; &gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_normal_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vectors at all quadrature points represented by this object. See the <a class="el" href="classFEValuesBase.html#ac25ec6835799c3b6c7c842f8acb05eb3">normal_vector()</a> function for what the normal vectors represent.</p>
<dl class="section note"><dt>Note</dt><dd>For this function to work properly, the underlying <a class="el" href="classFEValues.html">FEValues</a>, <a class="el" href="classFEFaceValues.html">FEFaceValues</a>, or <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> object on which you call it must have computed the information you are requesting. To do so, the <code>update_normal_vectors</code> flag must be an element of the list of UpdateFlags that you passed to the constructor of this object. See <a class="el" href="group__UpdateFlags.html">The interplay of UpdateFlags, Mapping, and FiniteElement in FEValues</a> for more information. </dd></dl>

</div>
</div>
<a id="a7670d68d12957e0ca99569a17c63efb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7670d68d12957e0ca99569a17c63efb2">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a particular scalar component of the possibly vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="a3bb48e1d06471efe7835f827f3c315a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bb48e1d06471efe7835f827f3c315a3">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>dim</code> scalar components (i.e. a vector) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="a8bfcef98b4371fe0ccc2e5da644cef1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bfcef98b4371fe0ccc2e5da644cef1f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1SymmetricTensor.html">FEValuesViews::SymmetricTensor</a>&lt;2, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>(dim*dim + dim)/2</code> scalar components (i.e. a symmetric 2nd order tensor) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="af092b17057ebfeeba90ac58f9205bc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af092b17057ebfeeba90ac58f9205bc86">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFEValuesViews_1_1Tensor.html">FEValuesViews::Tensor</a>&lt;2, dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tensor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a view of the current <a class="el" href="classFEValues.html">FEValues</a> object that represents a set of <code>(dim*dim)</code> scalar components (i.e. a 2nd order tensor) of the vector-valued finite element. The concept of views is explained in the documentation of the namespace <a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a> and in particular in the <a class="el" href="group__vector__valued.html">Handling vector valued problems</a> module. </p>

</div>
</div>
<a id="adcc1b936b41b758dad7ddae21c71f14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcc1b936b41b758dad7ddae21c71f14c">&#9670;&nbsp;</a></span>get_mapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_mapping </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constant reference to the selected mapping object. </p>

</div>
</div>
<a id="ade22ffd9fb5b07842daa504929244aa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade22ffd9fb5b07842daa504929244aa7">&#9670;&nbsp;</a></span>get_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constant reference to the selected finite element object. </p>

</div>
</div>
<a id="a55b258a1619829f7ec03a184ffb8e556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b258a1619829f7ec03a184ffb8e556">&#9670;&nbsp;</a></span>get_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the update flags set for this object. </p>

</div>
</div>
<a id="aaf7cc3af52cb9ce98d5562592901f4fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7cc3af52cb9ce98d5562592901f4fb">&#9670;&nbsp;</a></span>get_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;::cell_iterator <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a triangulation iterator to the current cell. </p>

</div>
</div>
<a id="a808af56bde1d82893b88875dc651e749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808af56bde1d82893b88875dc651e749">&#9670;&nbsp;</a></span>get_cell_similarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::get_cell_similarity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the relation of the current cell to the previous cell. This allows re-use of some cell data (like local matrices for equations with constant coefficients) if the result is <code><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13a4f8507015c458575753e0a45e0c3544a">CellSimilarity::translation</a></code>. </p>

</div>
</div>
<a id="aaf01126d2e3b926fecbaf122357add53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf01126d2e3b926fecbaf122357add53">&#9670;&nbsp;</a></span>invalidate_present_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::invalidate_present_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that is connected to the triangulation in order to reset the stored 'present_cell' iterator to an invalid one whenever the triangulation is changed and the iterator consequently becomes invalid. </p>

</div>
</div>
<a id="aed652da6ec16e368e27da4085b4281bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed652da6ec16e368e27da4085b4281bb">&#9670;&nbsp;</a></span>maybe_invalidate_previous_present_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::maybe_invalidate_previous_present_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is called by the various <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a> functions in derived classes. Given the cell indicated by the argument, test whether we have to throw away the previously stored present_cell argument because it would require us to compare cells from different triangulations. In checking all this, also make sure that we have tria_listener connected to the triangulation to which we will set present_cell right after calling this function. </p>

</div>
</div>
<a id="aa1352ba7f04525e175d2c6fa552a1c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1352ba7f04525e175d2c6fa552a1c6a">&#9670;&nbsp;</a></span>compute_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::compute_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initialize some update flags. Called from the <code>initialize</code> functions of derived classes, which are in turn called from their constructors.</p>
<p>Basically, this function finds out using the finite element and mapping object already stored which flags need to be set to compute everything the user wants, as expressed through the flags passed as argument. </p>

</div>
</div>
<a id="a5c38a7d7c3a6b384ad5b46f38248524d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c38a7d7c3a6b384ad5b46f38248524d">&#9670;&nbsp;</a></span>check_cell_similarity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::check_cell_similarity </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that checks whether the new cell is similar to the one previously used. Then, a significant amount of the data can be reused, e.g. the derivatives of the basis functions in real space, shape_grad. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a627033acd32f5d22a4bb82444267a240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627033acd32f5d22a4bb82444267a240">&#9670;&nbsp;</a></span>integral_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::integral_dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension of the object over which we integrate. For the present class, this is equal to <code>dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l04000">4000</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a50edb536baf30f637a51203f0e73d15e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50edb536baf30f637a51203f0e73d15e">&#9670;&nbsp;</a></span>quadrature</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim&gt; <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;::quadrature</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store a copy of the quadrature formula here. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l04103">4103</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="afd889a38bbce8ea33d46d152f14abdd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd889a38bbce8ea33d46d152f14abdd3">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension in which this object operates. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02418">2418</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a6541820cb52f78a4d43de18be0352002"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541820cb52f78a4d43de18be0352002">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension of the space in which this object operates. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02423">2423</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a807c3049bfe81743fc0f237dfc2fbdea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807c3049bfe81743fc0f237dfc2fbdea">&#9670;&nbsp;</a></span>n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::n_quadrature_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of quadrature points of the current object. Its value is initialized by the value of max_n_quadrature_points and is updated, e.g., if <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a> is called for a new cell/face.</p>
<dl class="section note"><dt>Note</dt><dd>The default value equals to the value of max_n_quadrature_points. </dd></dl>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02432">2432</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="af4f8b164f3fa6f25982c8a52fefe0995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4f8b164f3fa6f25982c8a52fefe0995">&#9670;&nbsp;</a></span>max_n_quadrature_points</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::max_n_quadrature_points</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of quadrature points. This value might be different from n_quadrature_points, e.g., if a QCollection with different face quadrature rules has been passed to initialize <a class="el" href="classFEFaceValues.html">FEFaceValues</a>.</p>
<p>This is mostly useful to initialize arrays to allocate the maximum amount of memory that may be used when re-sizing later on to a the current number of quadrature points given by n_quadrature_points. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02443">2443</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a5b264d5b2fb6615f5dea7a21135ed1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b264d5b2fb6615f5dea7a21135ed1a5">&#9670;&nbsp;</a></span>dofs_per_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::dofs_per_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of shape functions per cell. If we use this base class to evaluate a finite element on faces of cells, this is still the number of degrees of freedom per cell, not per face. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l02450">2450</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="acf87f79b7e82e60650bc9227deb6aeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf87f79b7e82e60650bc9227deb6aeb9">&#9670;&nbsp;</a></span>present_cell</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;const CellIteratorBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::present_cell</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the cell selected last time the <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a> function was called. This is necessary for the <code>get_function_*</code> functions as well as the functions of same name in the extractor classes. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03836">3836</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aa7274f2ea9bbe0ea61bd983c5746ffef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7274f2ea9bbe0ea61bd983c5746ffef">&#9670;&nbsp;</a></span>tria_listener_refinement</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener_refinement</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal connection we use to ensure we get informed whenever the triangulation changes by refinement. We need to know about that because it invalidates all cell iterators and, as part of that, the 'present_cell' iterator we keep around between subsequent calls to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a> in order to compute the cell similarity. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03852">3852</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a2f853782c9ba1f6c4093f64ede145253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f853782c9ba1f6c4093f64ede145253">&#9670;&nbsp;</a></span>tria_listener_mesh_transform</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::signals2::connection <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::tria_listener_mesh_transform</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A signal connection we use to ensure we get informed whenever the triangulation changes by mesh transformations. We need to know about that because it invalidates all cell iterators and, as part of that, the 'present_cell' iterator we keep around between subsequent calls to <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit()</a> in order to compute the cell similarity. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03861">3861</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a5502d4cd55c37491d1f89e41285fc7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5502d4cd55c37491d1f89e41285fc7e5">&#9670;&nbsp;</a></span>mapping</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the mapping object associated with this <a class="el" href="classFEValues.html">FEValues</a> object. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03888">3888</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="aa2786d839ac016cd2181c1a2acf7b755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2786d839ac016cd2181c1a2acf7b755">&#9670;&nbsp;</a></span>mapping_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the internal data object of mapping, obtained from <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping::get_data()</a>, <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping::get_face_data()</a>, or <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping::get_subface_data()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03896">3896</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a9faa26fda7aba97298344ab95b4753ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faa26fda7aba97298344ab95b4753ac">&#9670;&nbsp;</a></span>mapping_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt;dim, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::mapping_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An object into which the <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a> and similar functions place their output. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03903">3903</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a67500f1f0d3d40e014e562d375f911f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67500f1f0d3d40e014e562d375f911f8">&#9670;&nbsp;</a></span>fe</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;, <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the finite element object associated with this <a class="el" href="classFEValues.html">FEValues</a> object. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03912">3912</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="ae73456971913b569cfb5d79dc827e9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73456971913b569cfb5d79dc827e9bc">&#9670;&nbsp;</a></span>fe_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;typename <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt;::InternalDataBase&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::fe_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A pointer to the internal data object of finite element, obtained from <a class="el" href="classFiniteElement.html#a83c2e3851e02752d6b241fd402cc0bcd">FiniteElement::get_data()</a>, <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping::get_face_data()</a>, or <a class="el" href="classFiniteElement.html#a450e656fc6a48e7a6f1a9546713fcbf5">FiniteElement::get_subface_data()</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03920">3920</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="acfc8644fa994116af02667ddd6517ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfc8644fa994116af02667ddd6517ae3">&#9670;&nbsp;</a></span>finite_element_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1FiniteElementRelatedData.html">internal::FEValuesImplementation::FiniteElementRelatedData</a>&lt;dim, spacedim&gt; <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::finite_element_output</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An object into which the <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> and similar functions place their output. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03928">3928</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a63ed91bcc8004390e372704d63177162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63ed91bcc8004390e372704d63177162">&#9670;&nbsp;</a></span>update_flags</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::update_flags</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Original update flags handed to the constructor of <a class="el" href="classFEValues.html">FEValues</a>. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03934">3934</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<a id="a096d4ea9edea6618e23f5f13ab40784c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a096d4ea9edea6618e23f5f13ab40784c">&#9670;&nbsp;</a></span>cell_similarity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;::cell_similarity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An enum variable that can store different states of the current cell in comparison to the previously visited cell. If wanted, additional states can be checked here and used in one of the methods used during reinit. </p>

<p class="definition">Definition at line <a class="el" href="fe_2fe__values_8h_source.html#l03952">3952</a> of file <a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="include_2deal_8II_2fe_2fe_8h_source.html">fe.h</a></li>
<li>include/deal.II/fe/<a class="el" href="fe_2fe__values_8h_source.html">fe_values.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
