<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classCellAccessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: CellAccessor&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classCellAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CellAccessor&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grids and Triangulations</a><a class="el" href="group__grid.html">Grids and Triangulations</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo;  &#124; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">deal.II/grid/tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CellAccessor&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCellAccessor__inherit__graph.svg" width="1018" height="87"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e1e1f35643e735193d89e70c5a28b54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9e1e1f35643e735193d89e70c5a28b54">AccessorData</a> = typename <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td></tr>
<tr class="separator:a9e1e1f35643e735193d89e70c5a28b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e473b08fe4f390e918059d85b1afe60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0e473b08fe4f390e918059d85b1afe60">Container</a> = <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:a0e473b08fe4f390e918059d85b1afe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf7670cf3c4571fe55e051d2503190"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> = void *</td></tr>
<tr class="separator:a90bf7670cf3c4571fe55e051d2503190"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e7c4a89332133d5ce71a1a5aa8f64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a13e7c4a89332133d5ce71a1a5aa8f64f">global_active_cell_index</a> () const</td></tr>
<tr class="separator:a13e7c4a89332133d5ce71a1a5aa8f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e84609c2c6afbeefdaa9096ff50dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae8e84609c2c6afbeefdaa9096ff50dae">global_level_cell_index</a> () const</td></tr>
<tr class="separator:ae8e84609c2c6afbeefdaa9096ff50dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbda6466751b42b9660eccc8b8fe4a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cbda6466751b42b9660eccc8b8fe4a3">DeclException0</a> (ExcRefineCellNotActive)</td></tr>
<tr class="separator:ga7cbda6466751b42b9660eccc8b8fe4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1d6d2729d5ab7580aeddad59b29e19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9b1d6d2729d5ab7580aeddad59b29e19">DeclException0</a> (ExcCellFlaggedForRefinement)</td></tr>
<tr class="separator:ga9b1d6d2729d5ab7580aeddad59b29e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797a1f7e7783e76abc85581a4577dc75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga797a1f7e7783e76abc85581a4577dc75">DeclException0</a> (ExcCellFlaggedForCoarsening)</td></tr>
<tr class="separator:ga797a1f7e7783e76abc85581a4577dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81b4fd965bfe879d1d5819575158ce11"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a81b4fd965bfe879d1d5819575158ce11"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a81b4fd965bfe879d1d5819575158ce11">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;p) const</td></tr>
<tr class="separator:a81b4fd965bfe879d1d5819575158ce11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb389f7d1c4b94812ba55e6e37ee2e2d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:afb389f7d1c4b94812ba55e6e37ee2e2d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afb389f7d1c4b94812ba55e6e37ee2e2d">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p) const</td></tr>
<tr class="separator:afb389f7d1c4b94812ba55e6e37ee2e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17249a985a005be6e933aa76eb55023d"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a17249a985a005be6e933aa76eb55023d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a17249a985a005be6e933aa76eb55023d">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:a17249a985a005be6e933aa76eb55023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5ed157476c1275a351bf0338d6d14b"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a9f5ed157476c1275a351bf0338d6d14b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9f5ed157476c1275a351bf0338d6d14b">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p) const</td></tr>
<tr class="separator:a9f5ed157476c1275a351bf0338d6d14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab82811b7ba2e50923fd77820ad9c7838"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:ab82811b7ba2e50923fd77820ad9c7838"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab82811b7ba2e50923fd77820ad9c7838">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:ab82811b7ba2e50923fd77820ad9c7838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852120f4858e21deb555981eb5203b90"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a852120f4858e21deb555981eb5203b90"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a852120f4858e21deb555981eb5203b90">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p) const</td></tr>
<tr class="separator:a852120f4858e21deb555981eb5203b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeb0b77c3f3c1de1f604d456d0718efc0">used</a> () const</td></tr>
<tr class="separator:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b007b674b316f793f72b8ddc31e1cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8b007b674b316f793f72b8ddc31e1cf9">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_ind) const</td></tr>
<tr class="separator:a8b007b674b316f793f72b8ddc31e1cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab467082583c8bce60bd9dd669b939ae9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab467082583c8bce60bd9dd669b939ae9">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:ab467082583c8bce60bd9dd669b939ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0264eafc337e3596b9f895a091b18a44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0264eafc337e3596b9f895a091b18a44">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a0264eafc337e3596b9f895a091b18a44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1b363d9cf3b6911d41223c9ed5d82daa">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a1b363d9cf3b6911d41223c9ed5d82daa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09623959e21c50be31d6e40b508c39b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a09623959e21c50be31d6e40b508c39b4">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a09623959e21c50be31d6e40b508c39b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7f33cb96e76ff07eaf0052427907aeb3">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a7f33cb96e76ff07eaf0052427907aeb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造函数</div></td></tr>
<tr class="memitem:a026b9553c7d56c103147d3e9a6d9a0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a026b9553c7d56c103147d3e9a6d9a0ed">CellAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *<a class="el" href="classCellAccessor.html#a027532e7f473fac2812a92e4066e29f5">parent</a>=nullptr, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:a026b9553c7d56c103147d3e9a6d9a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3fbe765bc2a08b056175f8f52da568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#acb3fbe765bc2a08b056175f8f52da568">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;cell_accessor)</td></tr>
<tr class="separator:acb3fbe765bc2a08b056175f8f52da568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab34931ab97b3e7c7da47388b30c36707">CellAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:ab34931ab97b3e7c7da47388b30c36707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aecdfe299bf81ce75210d54e3f47684fb">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aecdfe299bf81ce75210d54e3f47684fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95e342f30144f3e5b9fedb5a7ae814"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6a95e342f30144f3e5b9fedb5a7ae814">CellAccessor</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;)=default</td></tr>
<tr class="separator:a6a95e342f30144f3e5b9fedb5a7ae814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac0b773c7d711afd21d70651a749f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a96ac0b773c7d711afd21d70651a749f4">CellAccessor</a> (<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a96ac0b773c7d711afd21d70651a749f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf6ed208744e1c068bbac1f4fed9b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a68bf6ed208744e1c068bbac1f4fed9b9">~CellAccessor</a> ()=default</td></tr>
<tr class="separator:a68bf6ed208744e1c068bbac1f4fed9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe479b764e417ae5caa2dff2c3a0c733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afe479b764e417ae5caa2dff2c3a0c733">operator=</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;)=delete</td></tr>
<tr class="separator:afe479b764e417ae5caa2dff2c3a0c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd380c25f52e90e2638e6fbf52c193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a56fd380c25f52e90e2638e6fbf52c193">operator=</a> (<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a56fd380c25f52e90e2638e6fbf52c193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理周期性邻居的问题</div></td></tr>
<tr class="memitem:a5b60dfb7926e4a9d39c2208b0f86b256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5b60dfb7926e4a9d39c2208b0f86b256">has_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a5b60dfb7926e4a9d39c2208b0f86b256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12b7281609d7b0b1a5f436515c385964"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a12b7281609d7b0b1a5f436515c385964">periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a12b7281609d7b0b1a5f436515c385964"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cbc0468b12ad483b1cb395bc625a61"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af2cbc0468b12ad483b1cb395bc625a61">neighbor_or_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:af2cbc0468b12ad483b1cb395bc625a61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3395f4ebb63aa30e1a0aac7fdbb5953"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa3395f4ebb63aa30e1a0aac7fdbb5953">periodic_neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:aa3395f4ebb63aa30e1a0aac7fdbb5953"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98496895de96d67cea5392c3aade826"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ac98496895de96d67cea5392c3aade826">periodic_neighbor_of_coarser_periodic_neighbor</a> (const unsigned face_no) const</td></tr>
<tr class="separator:ac98496895de96d67cea5392c3aade826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c3888e028fcfafd86b1eef59e73505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab1c3888e028fcfafd86b1eef59e73505">periodic_neighbor_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab1c3888e028fcfafd86b1eef59e73505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fa397b3b27f4cda613208d127f0a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a64fa397b3b27f4cda613208d127f0a98">periodic_neighbor_level</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a64fa397b3b27f4cda613208d127f0a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92a480d8d1b269b21d95c7cc3c0a033"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af92a480d8d1b269b21d95c7cc3c0a033">periodic_neighbor_of_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:af92a480d8d1b269b21d95c7cc3c0a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdf47567f70bac8826dcd7e5782f968"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afbdf47567f70bac8826dcd7e5782f968">periodic_neighbor_face_no</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:afbdf47567f70bac8826dcd7e5782f968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab737948031be71ea02495126a177ed8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab737948031be71ea02495126a177ed8a">periodic_neighbor_is_coarser</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab737948031be71ea02495126a177ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理边界指标的问题</div></td></tr>
<tr class="memitem:a4b683043741a1167de1ab9dbda0e54f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a4b683043741a1167de1ab9dbda0e54f7">at_boundary</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a4b683043741a1167de1ab9dbda0e54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c08cb6a4ced3f610d9789d02ad202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ace4c08cb6a4ced3f610d9789d02ad202">at_boundary</a> () const</td></tr>
<tr class="separator:ace4c08cb6a4ced3f610d9789d02ad202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fee6d28c03cd3ba90263ecb0e268b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9fee6d28c03cd3ba90263ecb0e268b3a">has_boundary_lines</a> () const</td></tr>
<tr class="separator:a9fee6d28c03cd3ba90263ecb0e268b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理细化指标的问题</div></td></tr>
<tr class="memitem:a902048fc67583f356fd3278a7d2aa8de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a902048fc67583f356fd3278a7d2aa8de">refine_flag_set</a> () const</td></tr>
<tr class="separator:a902048fc67583f356fd3278a7d2aa8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8359d5342b4ae7ae8b74fc3f4a1558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">set_refine_flag</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; ref_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a8c8359d5342b4ae7ae8b74fc3f4a1558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ccb325d746a81fa4a8542d698b89c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad5ccb325d746a81fa4a8542d698b89c7">clear_refine_flag</a> () const</td></tr>
<tr class="separator:ad5ccb325d746a81fa4a8542d698b89c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a3010dcf7bd365a6d43429d64dcc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a375a3010dcf7bd365a6d43429d64dcc1">flag_for_face_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;face_refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a375a3010dcf7bd365a6d43429d64dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3fa84168f193c7877ff90b70bcee83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aeb3fa84168f193c7877ff90b70bcee83">flag_for_line_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> line_no) const</td></tr>
<tr class="separator:aeb3fa84168f193c7877ff90b70bcee83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d8dc9bdecab5a250ed5ecb899ded9"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a448d8dc9bdecab5a250ed5ecb899ded9">subface_case</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a448d8dc9bdecab5a250ed5ecb899ded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4910a26c4458ce0dd444e6b7bec2564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae4910a26c4458ce0dd444e6b7bec2564">coarsen_flag_set</a> () const</td></tr>
<tr class="separator:ae4910a26c4458ce0dd444e6b7bec2564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de037c4860dcaceb4f9429b981b715e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6de037c4860dcaceb4f9429b981b715e">set_coarsen_flag</a> () const</td></tr>
<tr class="separator:a6de037c4860dcaceb4f9429b981b715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd137b13ff401f168ea0433cb18e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab9fd137b13ff401f168ea0433cb18e49">clear_coarsen_flag</a> () const</td></tr>
<tr class="separator:ab9fd137b13ff401f168ea0433cb18e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理材料指标</div></td></tr>
<tr class="memitem:ae4769702cd7ab67a61b25778ea3021b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae4769702cd7ab67a61b25778ea3021b2">material_id</a> () const</td></tr>
<tr class="separator:ae4769702cd7ab67a61b25778ea3021b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861d3679d23d3f4365f724c9cfe5fd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a861d3679d23d3f4365f724c9cfe5fd77">set_material_id</a> (const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> new_material_id) const</td></tr>
<tr class="separator:a861d3679d23d3f4365f724c9cfe5fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b49d85f8793f5a95d6c50797c07be2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2b49d85f8793f5a95d6c50797c07be2b">recursively_set_material_id</a> (const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> new_material_id) const</td></tr>
<tr class="separator:a2b49d85f8793f5a95d6c50797c07be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理子域指标的问题</div></td></tr>
<tr class="memitem:ae06835414c3c3f3359974f2c75a88033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae06835414c3c3f3359974f2c75a88033">subdomain_id</a> () const</td></tr>
<tr class="separator:ae06835414c3c3f3359974f2c75a88033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56098dab68574f96b42779d68c54269d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a56098dab68574f96b42779d68c54269d">set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> new_subdomain_id) const</td></tr>
<tr class="separator:a56098dab68574f96b42779d68c54269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84842b2847744da6e48fbcabf777ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id</a> () const</td></tr>
<tr class="separator:a2c84842b2847744da6e48fbcabf777ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfad9f24d9ddbc86883614639d4886d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2bfad9f24d9ddbc86883614639d4886d">set_level_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> new_level_subdomain_id) const</td></tr>
<tr class="separator:a2bfad9f24d9ddbc86883614639d4886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108d0f1a0710c1e6d9b98f7cb2768fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0108d0f1a0710c1e6d9b98f7cb2768fa">recursively_set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> new_subdomain_id) const</td></tr>
<tr class="separator:a0108d0f1a0710c1e6d9b98f7cb2768fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理codim 1单元的方位问题。</div></td></tr>
<tr class="memitem:ae146ea059e9c27cb3e040b92d5c4e152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae146ea059e9c27cb3e040b92d5c4e152">direction_flag</a> () const</td></tr>
<tr class="separator:ae146ea059e9c27cb3e040b92d5c4e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8ec35236bea8ee91a72bbd19762fe"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index</a> () const</td></tr>
<tr class="separator:ad4b8ec35236bea8ee91a72bbd19762fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a594e870d1b725fed0c5231596709b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af7a594e870d1b725fed0c5231596709b">parent_index</a> () const</td></tr>
<tr class="separator:af7a594e870d1b725fed0c5231596709b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a027532e7f473fac2812a92e4066e29f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a027532e7f473fac2812a92e4066e29f5">parent</a> () const</td></tr>
<tr class="separator:a027532e7f473fac2812a92e4066e29f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">其他函数</div></td></tr>
<tr class="memitem:a5096c47dd02a264799a1b7b18fd45b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5096c47dd02a264799a1b7b18fd45b3c">is_active</a> () const</td></tr>
<tr class="separator:a5096c47dd02a264799a1b7b18fd45b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3ff6217f3b5b4537f6a101560f493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a87a3ff6217f3b5b4537f6a101560f493">is_locally_owned</a> () const</td></tr>
<tr class="separator:a87a3ff6217f3b5b4537f6a101560f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b3c485d88ed58114d1b470bb3693f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9e6b3c485d88ed58114d1b470bb3693f">is_locally_owned_on_level</a> () const</td></tr>
<tr class="separator:a9e6b3c485d88ed58114d1b470bb3693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54375bf8f17e51501a4da7a2fac852ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a54375bf8f17e51501a4da7a2fac852ae">is_ghost</a> () const</td></tr>
<tr class="separator:a54375bf8f17e51501a4da7a2fac852ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef398493764dee787a796b436826847b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aef398493764dee787a796b436826847b">is_artificial</a> () const</td></tr>
<tr class="separator:aef398493764dee787a796b436826847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8a0465d3d7145513463b6a4a215fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#adb8a0465d3d7145513463b6a4a215fbc">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:adb8a0465d3d7145513463b6a4a215fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd998ef06bbaa081316d1f41ed5d6f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abd998ef06bbaa081316d1f41ed5d6f49">set_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;&gt; &amp;pointer) const</td></tr>
<tr class="separator:abd998ef06bbaa081316d1f41ed5d6f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d5ec9cac8af95a136554501ea4f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellId.html">CellId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aee7d5ec9cac8af95a136554501ea4f0a">id</a> () const</td></tr>
<tr class="separator:aee7d5ec9cac8af95a136554501ea4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb9bed9b28bc791489cea0c867c476d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a3cb9bed9b28bc791489cea0c867c476d">diameter</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping) const</td></tr>
<tr class="separator:a3cb9bed9b28bc791489cea0c867c476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问子对象</div></td></tr>
<tr class="memitem:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a76b3fb7b9d5de13f797e3c04d4dd03a5">vertex_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81afd26d765a4cec094b25767b8dd42a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a81afd26d765a4cec094b25767b8dd42a">vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a81afd26d765a4cec094b25767b8dd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6518eb0cf5fccc5926470128415d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3dd6518eb0cf5fccc5926470128415d9">vertex</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a3dd6518eb0cf5fccc5926470128415d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f0e6e00b9711650f59143e2085d95"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450f0e6e00b9711650f59143e2085d95">line_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a450f0e6e00b9711650f59143e2085d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc361f8b3fb30c60a9e248c2108979"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a04dc361f8b3fb30c60a9e248c2108979">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a04dc361f8b3fb30c60a9e248c2108979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3f77d56ddde728b892e3c736a28cd0c">quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">子对象的方向</div></td></tr>
<tr class="memitem:a452389bb368ba37c9c5542ef956526ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:a452389bb368ba37c9c5542ef956526ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f831f5ca8626677089f94af9be43a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:a2f831f5ca8626677089f94af9be43a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a>) const</td></tr>
<tr class="separator:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问儿童</div></td></tr>
<tr class="memitem:a4ce77fc45536beea670a0b5c1d91539c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4ce77fc45536beea670a0b5c1d91539c">has_children</a> () const</td></tr>
<tr class="separator:a4ce77fc45536beea670a0b5c1d91539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a634bf3e1c46e9ba87dfafa8c869e8972">n_children</a> () const</td></tr>
<tr class="separator:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0c1e25935669a4b310671a26e9dcbd2">number_of_children</a> () const</td></tr>
<tr class="separator:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb24948b4e177f8e4eb737ec057397"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a24fb24948b4e177f8e4eb737ec057397">n_active_descendants</a> () const</td></tr>
<tr class="separator:a24fb24948b4e177f8e4eb737ec057397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa39e613fd2e2c22bdc8ba340068e5713">max_refinement_depth</a> () const</td></tr>
<tr class="separator:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237132d2e5161b34a05291e10f3d6feb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a237132d2e5161b34a05291e10f3d6feb">child_iterator_to_index</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;<a class="el" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">child</a>) const</td></tr>
<tr class="separator:a237132d2e5161b34a05291e10f3d6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa035549b0c8b7eb7fcd33654bc73da29">isotropic_child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case</a> () const</td></tr>
<tr class="separator:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd7551fc85831a3fd4d5cd339b81d8c6">child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8adec5f5b7786cf43e6011d03cc7903a">isotropic_child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理边界指标</div></td></tr>
<tr class="memitem:af2b4887416074f2ecdcd06512e864e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id</a> () const</td></tr>
<tr class="separator:af2b4887416074f2ecdcd06512e864e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654de9ccd776b524a27cd64bded48e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:a654de9ccd776b524a27cd64bded48e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0304fb253839c45e64b60460ab040ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:aa0304fb253839c45e64b60460ab040ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae4d63b9ebf9b5c31aa702e49c664e59d">get_manifold</a> () const</td></tr>
<tr class="separator:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理流形指标的问题</div></td></tr>
<tr class="memitem:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id</a> () const</td></tr>
<tr class="separator:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">用户数据</div></td></tr>
<tr class="memitem:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6aa91f3e086777b02a2f6eef7ac19ebb">user_flag_set</a> () const</td></tr>
<tr class="separator:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6dda85b6637fefd5db3d37ad7729fcb1">set_user_flag</a> () const</td></tr>
<tr class="separator:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">clear_user_flag</a> () const</td></tr>
<tr class="separator:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a63d791b3769c77bcfd1c56748a6c56fa">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a50b22f28a2baf2dd90b5309c3f0136af">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3965091ec2c6ba6ed838a2479dd8110f">clear_user_data</a> () const</td></tr>
<tr class="separator:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaa0940be75dd7436769b55538aaac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:aceaaa0940be75dd7436769b55538aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd20837028286220f0b2ba9b0d4b219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1fd20837028286220f0b2ba9b0d4b219">clear_user_pointer</a> () const</td></tr>
<tr class="separator:a1fd20837028286220f0b2ba9b0d4b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer</a> () const</td></tr>
<tr class="separator:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e590959847d514d42814efa3e25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a484e590959847d514d42814efa3e25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad04d1802d9b1e8923dcfef41ea624edc">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0cca979ccf43e19af78dcb91d19cfd87">set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1e59ae7328b4c75c69720826736c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a97a1e59ae7328b4c75c69720826736c0">clear_user_index</a> () const</td></tr>
<tr class="separator:a97a1e59ae7328b4c75c69720826736c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a24da10289811179abbfb57253e9d3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">user_index</a> () const</td></tr>
<tr class="separator:ac7a24da10289811179abbfb57253e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e559fb261a631942d54c897243abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a429e559fb261a631942d54c897243abb">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:a429e559fb261a631942d54c897243abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">关于一个物体的几何信息</div></td></tr>
<tr class="memitem:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">diameter</a> () const</td></tr>
<tr class="separator:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7af8bab7e9ad732b6f3fa6a120ed5208">enclosing_ball</a> () const</td></tr>
<tr class="separator:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57453302997d9df8d1e242bf663dc11b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a57453302997d9df8d1e242bf663dc11b">bounding_box</a> () const</td></tr>
<tr class="separator:a57453302997d9df8d1e242bf663dc11b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a088728d7acb727fdc13bb6664d91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49a088728d7acb727fdc13bb6664d91a">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a49a088728d7acb727fdc13bb6664d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b268c743742c3c9ab159ff916d9236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a99b268c743742c3c9ab159ff916d9236">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a99b268c743742c3c9ab159ff916d9236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49df04630565a833e168e9cab074305e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49df04630565a833e168e9cab074305e">intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;coordinates) const</td></tr>
<tr class="separator:a49df04630565a833e168e9cab074305e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eb24d5074a9a7bf216bd82f5d0dc618"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3eb24d5074a9a7bf216bd82f5d0dc618">real_to_unit_cell_affine_approximation</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point) const</td></tr>
<tr class="separator:a3eb24d5074a9a7bf216bd82f5d0dc618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b045bcae58de112897824f4f08d1713"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">center</a> (const <a class="el" href="classbool.html">bool</a> respect_manifold=false, const <a class="el" href="classbool.html">bool</a> interpolate_from_surrounding=false) const</td></tr>
<tr class="separator:a8b045bcae58de112897824f4f08d1713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56cc737f4b28f8d28a576d2e3d32ef9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a56cc737f4b28f8d28a576d2e3d32ef9f">barycenter</a> () const</td></tr>
<tr class="separator:a56cc737f4b28f8d28a576d2e3d32ef9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9cecb2b7c9a1644fb5fd44bbba40ab0c">measure</a> () const</td></tr>
<tr class="separator:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21eeac18f82c9689857c225ca6be7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab21eeac18f82c9689857c225ca6be7e4">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;o) const</td></tr>
<tr class="separator:ab21eeac18f82c9689857c225ca6be7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCell.html">ReferenceCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad2f79864c20e5ee8283e9ddb6f7c0415">reference_cell</a> () const</td></tr>
<tr class="separator:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4a5ed83117e0ff9276abeb9a4fbaac61">n_vertices</a> () const</td></tr>
<tr class="separator:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e25f9720160ac96bc7f4eea0977784"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a48e25f9720160ac96bc7f4eea0977784">n_lines</a> () const</td></tr>
<tr class="separator:a48e25f9720160ac96bc7f4eea0977784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330fe95fe8d30a99884797f61236913"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces</a> () const</td></tr>
<tr class="separator:af330fe95fe8d30a99884797f61236913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40947cf863ecef1ee08ec93f411baaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae40947cf863ecef1ee08ec93f411baaa">vertex_indices</a> () const</td></tr>
<tr class="separator:ae40947cf863ecef1ee08ec93f411baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44268b67d46418c49a0a5e47f404adcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a44268b67d46418c49a0a5e47f404adcc">line_indices</a> () const</td></tr>
<tr class="separator:a44268b67d46418c49a0a5e47f404adcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4cabec41161961ab25d91b6cdc2425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5b4cabec41161961ab25d91b6cdc2425">face_indices</a> () const</td></tr>
<tr class="separator:a5b4cabec41161961ab25d91b6cdc2425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器地址和状态</div></td></tr>
<tr class="memitem:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a> () const</td></tr>
<tr class="separator:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebfc1e42324fbf595487e1bf668a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a> () const</td></tr>
<tr class="separator:a6bebfc1e42324fbf595487e1bf668a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5f75f0d6c68a1a67ea03bd4727c29529">state</a> () const</td></tr>
<tr class="separator:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af822c24c013e7b677f45ec2a8a41386a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af822c24c013e7b677f45ec2a8a41386a">get_triangulation</a> () const</td></tr>
<tr class="separator:af822c24c013e7b677f45ec2a8a41386a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac97bc3b07691e1a0ba9f32074642ae66">space_dimension</a> = spacedim</td></tr>
<tr class="separator:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed55a8362723639a14d083d9e745c"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a> = dim</td></tr>
<tr class="separator:a125ed55a8362723639a14d083d9e745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e42860babc727fc028adfb9a3200b7"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> = structdim</td></tr>
<tr class="separator:a35e42860babc727fc028adfb9a3200b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dd9ea78cda7d19b9997bae1bf1d5fe0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0dd9ea78cda7d19b9997bae1bf1d5fe0">neighbor_of_neighbor_internal</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a>) const</td></tr>
<tr class="separator:a0dd9ea78cda7d19b9997bae1bf1d5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c380d489670714b30a3812801a1a53"><td class="memTemplParams" colspan="2">template&lt;int dim_, int spacedim_&gt; </td></tr>
<tr class="memitem:a96c380d489670714b30a3812801a1a53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a96c380d489670714b30a3812801a1a53">point_inside_codim</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;p) const</td></tr>
<tr class="separator:a96c380d489670714b30a3812801a1a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436333e85278d0d4f3feb80abc2db97c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a436333e85278d0d4f3feb80abc2db97c">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a436333e85278d0d4f3feb80abc2db97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4644115f0c10a4e07462029211274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7cd4644115f0c10a4e07462029211274">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a7cd4644115f0c10a4e07462029211274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce14be63f6000f7b5d70618dc14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af88fce14be63f6000f7b5d70618dc14b">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:af88fce14be63f6000f7b5d70618dc14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a044710b90a02f1d4e6c2e39c00f51ee7">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d5a6b58e60a06216665e31c26704bd"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae6d5a6b58e60a06216665e31c26704bd">objects</a> () const</td></tr>
<tr class="separator:ae6d5a6b58e60a06216665e31c26704bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器的推进</div></td></tr>
<tr class="memitem:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5a24bd66635320e66d1dff07e3cb26e1">operator++</a> ()</td></tr>
<tr class="separator:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a85d4f1dc476691cf77e88f2c3ed15afe">operator--</a> ()</td></tr>
<tr class="separator:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3ad5efb039ed878a124c9577acd92256"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriaAccessorImplementation_1_1PresentLevelType.html">internal::TriaAccessorImplementation::PresentLevelType</a>&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3ad5efb039ed878a124c9577acd92256">present_level</a></td></tr>
<tr class="separator:a3ad5efb039ed878a124c9577acd92256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf2d985abdb2c9a43ab97722305f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a11cf2d985abdb2c9a43ab97722305f34">present_index</a></td></tr>
<tr class="separator:a11cf2d985abdb2c9a43ab97722305f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af02486bbb2ee4b94d1b51f03ba47257f">tria</a></td></tr>
<tr class="separator:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0d7efb46efc1d5dfe714e3d0689c1700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0d7efb46efc1d5dfe714e3d0689c1700">set_active_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index</a>) const</td></tr>
<tr class="separator:a0d7efb46efc1d5dfe714e3d0689c1700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8122005ec0257e87cc6475a841790c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab8122005ec0257e87cc6475a841790c3">set_global_active_cell_index</a> (const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:ab8122005ec0257e87cc6475a841790c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a11e0fd6f847735bfbbf9543511bc5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5a11e0fd6f847735bfbbf9543511bc5b">set_global_level_cell_index</a> (const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:a5a11e0fd6f847735bfbbf9543511bc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f559666292ef3769b136e0a1516dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ac7f559666292ef3769b136e0a1516dfd">set_parent</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#af7a594e870d1b725fed0c5231596709b">parent_index</a>)</td></tr>
<tr class="separator:ac7f559666292ef3769b136e0a1516dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab75196e96aafda94a0a96d833fdc84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2ab75196e96aafda94a0a96d833fdc84">set_direction_flag</a> (const <a class="el" href="classbool.html">bool</a> new_direction_flag) const</td></tr>
<tr class="separator:a2ab75196e96aafda94a0a96d833fdc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abe9e690d5d7904f804316e15362a2191">Triangulation</a></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06609bdb8db3c02e2988fe92796820a"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:aa06609bdb8db3c02e2988fe92796820a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa06609bdb8db3c02e2988fe92796820a">parallel::TriangulationBase</a></td></tr>
<tr class="separator:aa06609bdb8db3c02e2988fe92796820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173edf91a9d914373821b6117f32a8f"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a1173edf91a9d914373821b6117f32a8f">::internal::TriangulationImplementation::Implementation</a></td></tr>
<tr class="separator:a1173edf91a9d914373821b6117f32a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8b5f94c07c2ca904c27c04ca38eac0e1">::internal::TriangulationImplementation::ImplementationMixedMesh</a></td></tr>
<tr class="separator:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
访问子对象和相邻对象</h2></td></tr>
<tr class="memitem:abacf4d5819d5f9e96d0e597cd92ce41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:abacf4d5819d5f9e96d0e597cd92ce41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9f633c95c8309133588ae7970a4083"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2d9f633c95c8309133588ae7970a4083">child_iterators</a> () const</td></tr>
<tr class="separator:a2d9f633c95c8309133588ae7970a4083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731df8f0245670b477495d804b60f4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a731df8f0245670b477495d804b60f4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ca7ccf82126f4c791dbf361b143b60"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a09ca7ccf82126f4c791dbf361b143b60">face_iterator_to_index</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt;&gt; &amp;<a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:a09ca7ccf82126f4c791dbf361b143b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed34bf314b75f184a848b72759d917cb"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::faces_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aed34bf314b75f184a848b72759d917cb">face_iterators</a> () const</td></tr>
<tr class="separator:aed34bf314b75f184a848b72759d917cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393ecccb4d12de31be253b60740befe9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a393ecccb4d12de31be253b60740befe9">face_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a393ecccb4d12de31be253b60740befe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54844a9be3a35e62aaabc8d43ad1f8b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a54844a9be3a35e62aaabc8d43ad1f8b8">neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:a54844a9be3a35e62aaabc8d43ad1f8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e47f00c82296ea941b41c0e0201f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a87e47f00c82296ea941b41c0e0201f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c3e14735a8d0dc265e4436e69706ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad9c3e14735a8d0dc265e4436e69706ab">neighbor_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:ad9c3e14735a8d0dc265e4436e69706ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0f773bc457f562f34a49fa841db9e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aae0f773bc457f562f34a49fa841db9e3">neighbor_level</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:aae0f773bc457f562f34a49fa841db9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5dc97427e571da846e1fb0545aeb9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a81e5dc97427e571da846e1fb0545aeb9">neighbor_of_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a81e5dc97427e571da846e1fb0545aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570b9c4837247169156ae7c9d59ade33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a570b9c4837247169156ae7c9d59ade33">neighbor_is_coarser</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a570b9c4837247169156ae7c9d59ade33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653454d4633329469aaea5a27d61e2de"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a653454d4633329469aaea5a27d61e2de">neighbor_of_coarser_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a>) const</td></tr>
<tr class="separator:a653454d4633329469aaea5a27d61e2de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e8dae65320c8d718b6fc88394293d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a036e8dae65320c8d718b6fc88394293d">neighbor_face_no</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a>) const</td></tr>
<tr class="separator:a036e8dae65320c8d718b6fc88394293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a20051ef5a6874f0ed22ce76706fcb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad5a20051ef5a6874f0ed22ce76706fcb">is_level_cell</a> ()</td></tr>
<tr class="separator:ad5a20051ef5a6874f0ed22ce76706fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class CellAccessor&lt; dim, spacedim &gt;</h3>

<p>这个类允许访问一个单元：一维的线，二维的四边形，等等。 以下指的是任何维度。 该类允许访问一个<code>单元格</code>，在一维中是一条线，在二维中是一个四角形。单元比线或四边形本身有更多的功能，例如，它们可以被标记为细化，它们有邻居，它们有可能检查它们是否在边界上等等。该类提供了对所有这些数据的访问。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02596">2596</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9e1e1f35643e735193d89e70c5a28b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1e1f35643e735193d89e70c5a28b54">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> =  typename <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim, dim, spacedim&gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将AccessorData类型传播到本类中。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02603">2603</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a0e473b08fe4f390e918059d85b1afe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e473b08fe4f390e918059d85b1afe60">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html#a0e473b08fe4f390e918059d85b1afe60">Container</a> =  <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>定义这个容器的类型，是它的一部分。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02609">2609</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a90bf7670cf3c4571fe55e051d2503190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf7670cf3c4571fe55e051d2503190">&#9670;&nbsp;</a></span>LocalData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> =  void *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用来从迭代器向访问器类传递参数的数据类型，无论这些参数的数量类型是什么，都是统一的。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00435">435</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a026b9553c7d56c103147d3e9a6d9a0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026b9553c7d56c103147d3e9a6d9a0ed">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构建器。 </p>

</div>
</div>
<a id="acb3fbe765bc2a08b056175f8f52da568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3fbe765bc2a08b056175f8f52da568">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造器。 </p>

</div>
</div>
<a id="ab34931ab97b3e7c7da47388b30c36707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34931ab97b3e7c7da47388b30c36707">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>转换构造器。这个构造器的存在是为了使某些构造在独立于维度的代码中写得更简单。例如，它允许将一个面的迭代器分配给一个线的迭代器，这个操作在2D中很有用，但在3D中没有任何意义。这里的构造函数是为了使代码符合C++的要求而存在的，但它会无条件地中止；换句话说，将面迭代器赋值给线迭代器最好放在一个if语句中，检查维度是否为2，并在3D中赋值给一个四维迭代器（如果没有这个构造函数，如果我们碰巧为2d编译，这个操作是非法的）。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03503">3503</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="aecdfe299bf81ce75210d54e3f47684fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdfe299bf81ce75210d54e3f47684fb">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>另一个对象之间的转换操作符，就像之前的那个一样，没有意义。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03533">3533</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a6a95e342f30144f3e5b9fedb5a7ae814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a95e342f30144f3e5b9fedb5a7ae814">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造器。 </p>

</div>
</div>
<a id="a96ac0b773c7d711afd21d70651a749f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ac0b773c7d711afd21d70651a749f4">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。 </p>

</div>
</div>
<a id="a68bf6ed208744e1c068bbac1f4fed9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf6ed208744e1c068bbac1f4fed9b9">&#9670;&nbsp;</a></span>~CellAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::~<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解除构造器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe479b764e417ae5caa2dff2c3a0c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe479b764e417ae5caa2dff2c3a0c733">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制操作符。这些操作符通常在类似<code>iterator a,b;a=*b;</code>的情况下使用。据推测，这里的意图是将 <code>b</code> 所指向的对象复制到 <code>a</code>. 所指向的对象。然而，取消引用迭代器的结果不是一个对象，而是一个存取器；因此，这个操作对三角形的迭代器没有用。 因此，这个操作被声明为删除，不能使用。 </p>

</div>
</div>
<a id="a56fd380c25f52e90e2638e6fbf52c193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fd380c25f52e90e2638e6fbf52c193">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符。 </p>

</div>
</div>
<a id="abacf4d5819d5f9e96d0e597cd92ce41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacf4d5819d5f9e96d0e597cd92ce41e">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向 <code>ith</code> 子对象的指针。重载版本，返回一个更合理的迭代器类。 </p>

</div>
</div>
<a id="a2d9f633c95c8309133588ae7970a4083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9f633c95c8309133588ae7970a4083">&#9670;&nbsp;</a></span>child_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;<a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::max_children_per_cell&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::child_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元格所有子代的迭代器的数组。 </p>

</div>
</div>
<a id="a731df8f0245670b477495d804b60f4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731df8f0245670b477495d804b60f4e7">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此单元格的 <code>ith</code> 面的一个迭代器。 </p>

</div>
</div>
<a id="a09ca7ccf82126f4c791dbf361b143b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ca7ccf82126f4c791dbf361b143b60">&#9670;&nbsp;</a></span>face_iterator_to_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_iterator_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前单元格上 <code>face</code> 的面数。这是 TriaAccessor::face(). 的反函数。 </p>

</div>
</div>
<a id="aed34bf314b75f184a848b72759d917cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed34bf314b75f184a848b72759d917cb">&#9670;&nbsp;</a></span>face_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元格所有面的迭代器阵列。 </p>

</div>
</div>
<a id="a393ecccb4d12de31be253b60740befe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393ecccb4d12de31be253b60740befe9">&#9670;&nbsp;</a></span>face_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此单元格的 <code>ith</code> 面的（全局）索引。 </p><dl class="section note"><dt>Note</dt><dd>尽管有这个名字，这里返回的索引只是全局的，即它是特定于一个特定的三角形对象的，或者，在三角形实际上是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型的情况下，特定于存储在当前处理器上的分布式三角形的那一部分。 </dd></dl>

</div>
</div>
<a id="a54844a9be3a35e62aaabc8d43ad1f8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54844a9be3a35e62aaabc8d43ad1f8b8">&#9670;&nbsp;</a></span>neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个单元格的迭代器，该单元格与给定面和子面编号上的当前单元格相邻。 为了成功，目前的单元必须没有被进一步细化，而在给定面的邻居必须被进一步细化一次；然后返回的单元是该邻居的一个子单元。 这个函数不能在1d中调用，因为在那里我们没有子面。 这个函数在2d中的实现相当直接，首先确定当前单元格与邻居单元格的哪个面接壤（这就是 <code>neighbor_of_neighbor</code> 函数的作用），然后向 <code>GeometryInfo::child_cell_on_subface</code> 询问子单元的索引。 然而，在3D中情况更为复杂，因为面可能有不止一个方向，我们必须对这个单元和邻近的单元使用 <code>face_orientation</code>, <code>face_flip</code> 和 <code>face_rotation</code> ，以弄清我们想拥有哪个单元。 这可能会导致令人惊讶的结果：如果我们坐在一个单元格上，并要求得到子面<code>sf</code>后面的单元格，那么这意味着我们考虑的是本单元格自然方向上的脸的子面。然而，如果从这个单元格看到的面有<code><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation()</a>==false</code>，那么将本单元格与邻近单元格的子面分开的子面不一定是本单元格的 <code>sf-th</code> 子面。之所以如此，是因为单元格上的 <code>subface_no</code> 对应于相对于本单元格的内在排序的子面，而面的迭代器的子女是相对于面的内在排序来计算的；这两个排序只有在面的方向是 <code>true</code>, 时才是相同的，否则就会颠倒。 同样，<code><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip()</a>==true</code>和<code><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation()</a>==true()</code>的影响也要考虑，这两种情况都表示非标准的脸。 幸运的是，这只是非常少的关注，因为通常我们只希望在一个活动单元的给定面的所有更细的邻居上进行循环。只有在细化三角图的过程中，我们才希望为我们的子单元和邻居的子单元设置邻居信息。因为在这种情况下，我们可以尊重当前单元格的面的方向，在这个函数中，我们不尊重当前单元格的面的方向、面的翻转和面的旋转，即返回的邻居的孩子在关于给定面的内在排序的子面 <code>subface</code> 后面。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02865">2865</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a87e47f00c82296ea941b41c0e0201f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e47f00c82296ea941b41c0e0201f47">&#9670;&nbsp;</a></span>neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回编号为 <code>face_no</code>. 的面的另一侧的邻接单元的迭代器 如果邻接单元不存在，即如果当前对象的编号为 <code>face_no</code> 的面处于边界，那么将返回一个无效的迭代器。 因此，索引 <code>face_no</code> 必须小于n_faces（）。 一个单元格的邻居最多具有与这个单元格相同的级别。例如，考虑以下情况。 </p><div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p> 在这里，如果你在右上角的单元格上，并要求得到它的左邻（根据GeometryInfo类中阐明的惯例，就是它的<em>zeroth</em>邻），那么你将得到左上角四个小单元格的母格。换句话说，你作为邻居得到的单元格与你现在所在的单元格（右上角的那个）具有相同的细化级别，而且它可能有子代。 另一方面，如果你在左上角四个小单元格中的右上角，并且你要求获得右邻（与索引 <code>face_no=1</code> 相关），那么你会得到右上角的大单元格，在这种情况下，它的细化级别较低，并且没有自己的孩子。 </p>

</div>
</div>
<a id="ad9c3e14735a8d0dc265e4436e69706ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c3e14735a8d0dc265e4436e69706ab">&#9670;&nbsp;</a></span>neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回索引为 <code>face_no</code>. 的面的另一侧的相邻单元格的单元格索引 如果相邻单元格不存在，该函数返回</p>
<ul>
<li>. 这个函数等同于<code>cell-&gt;neighbor(face_no)-&gt;<a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index()</a></code>。 更多细节请参见 <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor()</a>。 </li>
</ul>

</div>
</div>
<a id="aae0f773bc457f562f34a49fa841db9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0f773bc457f562f34a49fa841db9e3">&#9670;&nbsp;</a></span>neighbor_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回编号为 <code>face_no</code>. 的面的另一边的相邻单元的水平 如果相邻单元不存在，该函数返回</p>
<ul>
<li>. 这个函数等同于<code>cell-&gt;neighbor(face_no)-&gt;<a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level()</a></code>。 更多细节请参见 <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor()</a>。 </li>
</ul>

</div>
</div>
<a id="a81e5dc97427e571da846e1fb0545aeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5dc97427e571da846e1fb0545aeb9">&#9670;&nbsp;</a></span>neighbor_of_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个单元格是<code>cell-&gt;neighbor(face_no)</code>的第几个邻居，即返回 <code>other_face_no</code> ，使得<code>cell-&gt;neighbor(face_no)-&gt;neighbor(other_face_no)==cell</code>。如果你想知道如何从邻居回到现在的单元格，这个函数是正确的。 请注意，这个操作只有在邻居不比当前单元格粗的情况下才有用。如果邻居更粗，这个函数会抛出一个异常。在这种情况下，请使用 <code>neighbor_of_coarser_neighbor</code> 函数。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02333">2333</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a570b9c4837247169156ae7c9d59ade33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570b9c4837247169156ae7c9d59ade33">&#9670;&nbsp;</a></span>neighbor_is_coarser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回，邻居是否比现在的单元更粗大。这在各向异性的细化中很重要，因为这一信息并不取决于单元格的级别。 请注意，在各向异性的情况下，一个单元只能在给定的面比另一个单元更粗，而不是在一般的基础上。较细的单元的面包含在较粗的单元的相应面中，较细的面是较粗的面的子女或孙子。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02347">2347</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a653454d4633329469aaea5a27d61e2de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a653454d4633329469aaea5a27d61e2de">&#9670;&nbsp;</a></span>neighbor_of_coarser_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_coarser_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是 <code>neighbor_of_neighbor</code> 函数的泛化，适用于粗邻的情况。它返回一对数字，face_no和subface_no，如果邻居没有被细化，则具有以下属性。<code>cell-&gt;neighbor( neighbor)-&gt;neighbor_child_on_subface(face_no, subface_no)==cell</code>。在3D中，一个更粗的邻居仍然可以被细化。 在这种情况下，subface_no表示与我们的脸有关的邻居脸的子索引。 <code>cell-&gt;neighbor(neighbor)-&gt;face(face_no)-&gt;child(subface_no)==cell-&gt;face(neighbor)</code>。 在 <a class="el" href="step_30.html">step-30</a> 教程程序的介绍中讨论了3D中的这种情况以及它如何发生。 这个函数对于<code>dim==1</code>来说是不可能的。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02358">2358</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a036e8dae65320c8d718b6fc88394293d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e8dae65320c8d718b6fc88394293d">&#9670;&nbsp;</a></span>neighbor_face_no()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是 <code>neighbor_of_neighbor</code> 和 <code>neighbor_of_coarser_neighbor</code> 函数的一个概括。它检查邻居是否更粗，并调用相应的函数。在这两种情况下，只有face_no被返回。 </p>

</div>
</div>
<a id="ad5a20051ef5a6874f0ed22ce76706fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a20051ef5a6874f0ed22ce76706fcb">&#9670;&nbsp;</a></span>is_level_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_level_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与DoFCellAccessor兼容的接口。总是返回 <code>false</code>. 。 </p>

</div>
</div>
<a id="a5b60dfb7926e4a9d39c2208b0f86b256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b60dfb7926e4a9d39c2208b0f86b256">&#9670;&nbsp;</a></span>has_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果单元格在其 <code>第i个面有周期性邻居，该函数返回真，否则，返回值为假。</code> </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02534">2534</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a12b7281609d7b0b1a5f436515c385964"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12b7281609d7b0b1a5f436515c385964">&#9670;&nbsp;</a></span>periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于其 <code>第i个面位于周期性边界的单元格，见</code> <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">周期性边界的条目</a> ，该函数返回周期性边界另一侧的单元格的迭代器。如果在 <code>第i个面没有周期性边界，将抛出一个异常。</code> 为了避免遇到异常，在使用这个函数之前，请检查has_periodic_neighbor()对 <code>第i个面的结果。</code> <a class="el" href="classCellAccessor.html#a12b7281609d7b0b1a5f436515c385964">periodic_neighbor()</a>的行为与neighbor()类似，即返回的单元最多具有与当前单元相同的细化程度。在分布式网格上，通过调用 <a class="el" href="classTriangulation.html#adbf04756b28dae69194870812acaf941">Triangulation::add_periodicity()</a>, ，我们可以确保周期性边界另一侧的元素在这个等级中以幽灵单元或局部拥有的单元存在。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02562">2562</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af2cbc0468b12ad483b1cb395bc625a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cbc0468b12ad483b1cb395bc625a61">&#9670;&nbsp;</a></span>neighbor_or_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_or_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于 <code>第i个面不在边界上的单元格，这个函数返回的结果与邻接()相同。如果</code> <code>第i个面在一个周期性的边界上，这个函数返回与periodic_neighbor()相同的结果。如果上述两个条件都不满足，即</code> <code>第i个面在一个非周期性边界上，将抛出一个异常。</code> </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02589">2589</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="aa3395f4ebb63aa30e1a0aac7fdbb5953"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3395f4ebb63aa30e1a0aac7fdbb5953">&#9670;&nbsp;</a></span>periodic_neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回单元格在给定面和子面编号处的周期性邻居的一个迭代器。使用这个函数的一般准则类似于函数 <a class="el" href="classCellAccessor.html#a54844a9be3a35e62aaabc8d43ad1f8b8">neighbor_child_on_subface()</a>。这个函数的实现与periodic_neighbor_of_coarser_periodic_neighbor()一致。例如，假设我们坐在一个名为 <code>cell1的单元格上，其在</code> <code>第1个面后面的邻居是一个更粗的层次。让我们把这个更粗的邻居命名为</code> <code>cell2。然后，通过调用</code> <a class="el" href="classCellAccessor.html#ac98496895de96d67cea5392c3aade826">periodic_neighbor_of_coarser_periodic_neighbor()</a>，从 <code>cell1，我们得到一个</code> <code>face_num</code> 和一个 <code>subface_num。现在，如果我们从cell2调用periodic_neighbor_child_on_subface()，用上述face_num和subface_num，我们会得到一个前往</code> <code>cell1的迭代器。</code> </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02606">2606</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ac98496895de96d67cea5392c3aade826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98496895de96d67cea5392c3aade826">&#9670;&nbsp;</a></span>periodic_neighbor_of_coarser_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_of_coarser_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是periodic_neighbor_of_periodic_neighbor()的泛化，用于那些有较粗的周期性邻居的单元。返回的一对数字可以在period_neighbor_child_on_subface()中使用，以回到当前单元。换句话说，对于有较粗的周期性邻居的单元格，下面的断言应该是真的：cell-&gt;periodic_neighbor(i)-&gt;periodic_neighbor_child_on_subface(face_no, subface_no)==cell </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02658">2658</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab1c3888e028fcfafd86b1eef59e73505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c3888e028fcfafd86b1eef59e73505">&#9670;&nbsp;</a></span>periodic_neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数返回当前单元格的第 <code>个面的周期性邻居的索引。如果在给定的面没有周期性邻居，返回值为</code> </p>
<ul>
<li>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02719">2719</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a64fa397b3b27f4cda613208d127f0a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fa397b3b27f4cda613208d127f0a98">&#9670;&nbsp;</a></span>periodic_neighbor_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数返回当前单元格的 <code>第i个面的周期性邻居的水平。如果在给定的面没有周期性邻居，返回值为</code> </p>
<ul>
<li>. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02729">2729</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af92a480d8d1b269b21d95c7cc3c0a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92a480d8d1b269b21d95c7cc3c0a033">&#9670;&nbsp;</a></span>periodic_neighbor_of_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_of_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于在其 <code>第i个面有周期性邻居的单元格，该函数返回该周期性邻居的面数，以便当前单元格是该邻居的周期性邻居。换句话说，对于那些拥有与当前单元相同或更高细化程度的周期性邻居的单元，以下断言成立。</code> <code>{cell-&gt;periodic_neighbor(i)-&gt;</code> periodic_neighbor(cell-&gt;periodic_neighbor_of_periodic_neighbor(i))==cell}。 对于具有较粗的周期性邻居的单元格，应该使用periodic_neighbor_of_coarser_periodic_neighbor()和periodic_neighbor_child_on_subface()来回到当前单元格。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02739">2739</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="afbdf47567f70bac8826dcd7e5782f968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdf47567f70bac8826dcd7e5782f968">&#9670;&nbsp;</a></span>periodic_neighbor_face_no()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果一个单元格在其 <code>第i个面有一个周期性邻居，这个函数返回周期性邻居的面数，它与这个单元格的</code> <code>第i个面相连。</code> </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02749">2749</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab737948031be71ea02495126a177ed8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab737948031be71ea02495126a177ed8a">&#9670;&nbsp;</a></span>periodic_neighbor_is_coarser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果周期性边界另一侧的元素更粗，该函数返回真，否则返回假。该实现允许该函数在各向异性细化的情况下工作。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02780">2780</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a4b683043741a1167de1ab9dbda0e54f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b683043741a1167de1ab9dbda0e54f7">&#9670;&nbsp;</a></span>at_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 的顶点或面（取决于维度）是否是边界的一部分。如果 <code>ith</code> 的邻居不存在，这就是真的。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02835">2835</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ace4c08cb6a4ced3f610d9789d02ad202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4c08cb6a4ced3f610d9789d02ad202">&#9670;&nbsp;</a></span>at_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元格是否在边界上。在边界上的定义是有一个面在边界上。请注意，这并不包括四边形或六边形中只有一个顶点在边界上的情况，或者六边形中只有一条线在边界上，而所有面的内部都在域的内部。对于后一种情况， <code>has_boundary_lines函数才是正确的请求。</code> </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01952">1952</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a9fee6d28c03cd3ba90263ecb0e268b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fee6d28c03cd3ba90263ecb0e268b3a">&#9670;&nbsp;</a></span>has_boundary_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_boundary_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是对 <code>at_boundary</code> 函数的一个轻微变化：对于一维和二维，它是等价的，对于三维，它返回六面体的12条线中是否至少有一条位于边界。当然，这包括整个面处于边界的情况，但也包括其他一些情况。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02847">2847</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a902048fc67583f356fd3278a7d2aa8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902048fc67583f356fd3278a7d2aa8de">&#9670;&nbsp;</a></span>refine_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::refine_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此单元格被标记为细化的 <code>RefinementCase&lt;dim&gt;</code> 。 这个函数的返回值可以与一个bool进行比较，以检查这个单元格是否被标记为任何种类的细化。例如，如果你之前为一个单元格调用了cell-&gt;<a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">set_refine_flag()</a>，那么你将进入以下片段中的'if'块。 </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">{</div><div class="line"><span class="comment">// yes, this cell is marked for refinement.</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a8c8359d5342b4ae7ae8b74fc3f4a1558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8359d5342b4ae7ae8b74fc3f4a1558">&#9670;&nbsp;</a></span>set_refine_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_refine_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>ref_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对指向的单元格进行标记，以便进行细化。这个函数只允许用于活动单元。保持 <code>ref_case</code> 的默认值将标记该单元为各向同性的细化。 如果你选择各向异性的细化，例如通过传递一个标志 RefinementCase::cut_x, RefinementCase::cut_y, RefinementCase::cut_z, 或这些标志的组合作为参数，那么请记住，X、Y或Z方向的细化发生在该单元的 <em> 局部 </em> 坐标系。换句话说，这些标志决定了单元格的哪些边和面将被切割成新的边和面。另一方面，这个过程与单元在 <em> 全局 </em> 坐标系中的方向无关，你不应该假定单元的局部坐标系在它所处空间的全局坐标系中的任何特定方向。 </p>

</div>
</div>
<a id="ad5ccb325d746a81fa4a8542d698b89c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ccb325d746a81fa4a8542d698b89c7">&#9670;&nbsp;</a></span>clear_refine_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_refine_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除细化标志。 </p>

</div>
</div>
<a id="a375a3010dcf7bd365a6d43429d64dcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375a3010dcf7bd365a6d43429d64dcc1">&#9670;&nbsp;</a></span>flag_for_face_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_face_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>修改单元格的细化标志，以确保（至少）在面<code>face_no</code>的给定细化情况 <code>face_refinement_case</code> ，考虑到面的方向、翻转和旋转。返回，是否必须修改细化标志。这个函数只允许用于活动单元。 </p>

</div>
</div>
<a id="aeb3fa84168f193c7877ff90b70bcee83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3fa84168f193c7877ff90b70bcee83">&#9670;&nbsp;</a></span>flag_for_line_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_line_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>修改单元格的细化标志，确保行<code>面_no</code>将被细化。返回，是否必须修改细化标志。这个函数只允许用于活动单元。 </p>

</div>
</div>
<a id="a448d8dc9bdecab5a250ed5ecb899ded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d8dc9bdecab5a250ed5ecb899ded9">&#9670;&nbsp;</a></span>subface_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subface_case </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回面<code>face_no</code>的SubfaceCase。请注意，这与询问<code>cell-&gt;face(face_no)-&gt;<a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case()</a></code>不一样，因为后者返回一个RefinementCase&lt;dim-1&gt;，因此只考虑一个（各向异性的）细化，而这个函数考虑完整的细化情况，包括可能对面的孩子进行细化。这个函数只能在2D和3D的活动单元中调用。 </p>

</div>
</div>
<a id="ae4910a26c4458ce0dd444e6b7bec2564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4910a26c4458ce0dd444e6b7bec2564">&#9670;&nbsp;</a></span>coarsen_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::coarsen_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回粗化标志是否被设置。 </p>

</div>
</div>
<a id="a6de037c4860dcaceb4f9429b981b715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de037c4860dcaceb4f9429b981b715e">&#9670;&nbsp;</a></span>set_coarsen_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>指向粗化的单元格的标志。这个函数只允许用于活动单元。 </p>

</div>
</div>
<a id="ab9fd137b13ff401f168ea0433cb18e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fd137b13ff401f168ea0433cb18e49">&#9670;&nbsp;</a></span>clear_coarsen_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除粗化标志。 </p>

</div>
</div>
<a id="ae4769702cd7ab67a61b25778ea3021b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4769702cd7ab67a61b25778ea3021b2">&#9670;&nbsp;</a></span>material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::material_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01965">1965</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a861d3679d23d3f4365f724c9cfe5fd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861d3679d23d3f4365f724c9cfe5fd77">&#9670;&nbsp;</a></span>set_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01977">1977</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2b49d85f8793f5a95d6c50797c07be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b49d85f8793f5a95d6c50797c07be2b">&#9670;&nbsp;</a></span>recursively_set_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此单元格及其所有子单元格（以及孙子单元格，以此类推）的材质ID设置为给定值。 参见 <a class="el" href="DEALGlossary.html#GlossMaterialId">词汇表 </a> 以了解更多信息。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01991">1991</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ae06835414c3c3f3359974f2c75a88033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06835414c3c3f3359974f2c75a88033">&#9670;&nbsp;</a></span>subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个单元格的子域指标。 参见 词汇表  以了解更多信息。 </p><dl class="section note"><dt>Note</dt><dd>单元格的子域是一个只为活动单元格定义的属性，即没有被进一步细化的单元。因此，只有当它所指的单元格没有子域时，你才能调用这个函数。对于并行的多网格方法，知道哪个处理器拥有非活动单元也很重要，为此你可以调用level_subdomain_id()。 </dd></dl>

</div>
</div>
<a id="a56098dab68574f96b42779d68c54269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56098dab68574f96b42779d68c54269d">&#9670;&nbsp;</a></span>set_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置这个单元的子域id。 参见 词汇表  以了解更多信息。如果你使用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象，则不应调用此函数。 </p><dl class="section note"><dt>Note</dt><dd>单元的子域是一个只为活动单元定义的属性，即没有被进一步细化的单元。因此，只有当它所指的单元格没有子域时，你才能调用这个函数。对于并行的多网格方法，知道哪个处理器拥有非活动单元也很重要，为此你可以调用level_subdomain_id()。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02005">2005</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2c84842b2847744da6e48fbcabf777ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c84842b2847744da6e48fbcabf777ad">&#9670;&nbsp;</a></span>level_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::level_subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取该单元的水平子域ID。这用于并行多网格，其中不仅全局网格（由活动单元组成）被划分到处理器中，而且还包括构成网格的递归细化单元的各个层次。换句话说，如果使用多网格层次结构，层次子域id是一个也为非活动单元定义的属性。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02019">2019</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2bfad9f24d9ddbc86883614639d4886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfad9f24d9ddbc86883614639d4886d">&#9670;&nbsp;</a></span>set_level_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_level_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_level_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置此单元格的水平子域ID。这用于并行多网格。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02030">2030</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a0108d0f1a0710c1e6d9b98f7cb2768fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0108d0f1a0710c1e6d9b98f7cb2768fa">&#9670;&nbsp;</a></span>recursively_set_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置此单元的子域ID（如果它是活动的）或其所有终端子单元（和孙子单元，等等，只要它们没有自己的子单元）的给定值。由于子域id是一个只为活跃的单元格（即没有自己的孩子）定义的概念，这个函数只为这个单元格的所有实际活跃的子和孙子设置子域id，跳过中间的子单元格。 更多信息请参见 词汇表 。如果你使用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象，就不应该调用这个函数，因为在那里，子域id是由你所在的处理器隐式定义的。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02182">2182</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a13e7c4a89332133d5ce71a1a5aa8f64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e7c4a89332133d5ce71a1a5aa8f64f">&#9670;&nbsp;</a></span>global_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::global_active_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为当前单元格返回一个全局唯一的单元格索引，假设它不是人工的。如果该单元是串行三角形的一部分，其值与active_cell_index()相同。 在平行三角剖分的情况下，本地拥有的单元在网格的每个子域中被连续地列举出来。这就保证了这个函数返回的索引可以作为总条目数为 Triangulation::n_globally_active_cells() 的向量的索引，并且每个进程都存储一个连续的部分。 如果这样一个单元数据向量已经被设置为 <a class="el" href="classparallel_1_1TriangulationBase.html#abe6d84acdf8908f48fb236e2c2d47a17">parallel::TriangulationBase::global_active_cell_index_partitioner()</a>, ，那么这个函数返回的索引就可以用来访问正确的向量条目。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02132">2132</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ae8e84609c2c6afbeefdaa9096ff50dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e84609c2c6afbeefdaa9096ff50dae">&#9670;&nbsp;</a></span>global_level_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::global_level_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为非人工水平单元返回一个全局唯一的索引。 </p><dl class="section note"><dt>Note</dt><dd>与global_active_cell_index()类似。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02158">2158</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ae146ea059e9c27cb3e040b92d5c4e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae146ea059e9c27cb3e040b92d5c4e152">&#9670;&nbsp;</a></span>direction_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::direction_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此单元格的方向。 关于这个标志的含义，见 <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02041">2041</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ad4b8ec35236bea8ee91a72bbd19762fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b8ec35236bea8ee91a72bbd19762fe">&#9670;&nbsp;</a></span>active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::active_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前单元格是第几个活动单元格（假设当前单元格确实是活动的）。这很有用，例如，如果你要访问一个有多少个条目的向量的元素，就有多少个活动单元。这样的向量用于估计三角形的每个单元的误差，用于指定传递给GridRefinement中的函数的细化标准，以及用于生成单元的输出。 如果当前单元格没有被激活，该函数会抛出一个异常。 </p><dl class="section note"><dt>Note</dt><dd>如果这个函数被调用的三角形是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型，那么活动单元可能是本地拥有的、幽灵单元或人工的（见 <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a> 、 GlossGhostCell 和 GlossArtificialCell ）。 这个函数对所有这些单元进行计数，包括幽灵和人工活动单元。这意味着该函数返回的索引可以唯一地识别单个处理器上三角结构中的单元，但不能唯一地识别处理器之间共享的三角结构（部分）中的单元。如果你想识别跨处理器的活动单元，你需要考虑由 <a class="el" href="classCellAccessor.html#aee7d5ec9cac8af95a136554501ea4f0a">CellAccessor::id()</a>. 返回的单元的CellId。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02099">2099</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="af7a594e870d1b725fed0c5231596709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a594e870d1b725fed0c5231596709b">&#9670;&nbsp;</a></span>parent_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元格的父单元格在父单元格所属的三角结构层次中的索引。父单元的层次当然要比本单元的层次低一个。如果父单元不存在（即，如果该对象处于网格层次结构的最粗层），将产生一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02084">2084</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a027532e7f473fac2812a92e4066e29f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a027532e7f473fac2812a92e4066e29f5">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个到父对象的迭代器。如果父对象不存在（即，如果该对象处于网格层次结构的最粗层），将产生一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02168">2168</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a5096c47dd02a264799a1b7b18fd45b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096c47dd02a264799a1b7b18fd45b3c">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87a3ff6217f3b5b4537f6a101560f493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a3ff6217f3b5b4537f6a101560f493">&#9670;&nbsp;</a></span>is_locally_owned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元是否为当前处理器所拥有，或为其他处理器所拥有。如果应用于类型为 <a class="el" href="classTriangulation.html">Triangulation</a>, 的对象，该函数总是返回true，但如果三角形是类型为 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. ，则可能产生false。更多信息请参见 词汇表  和 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块。 </p><dl class="section post"><dt>Postcondition</dt><dd>返回值等于<code>!is_ghost() &amp;&amp; !is_artificial()/code&gt;。 </code></dd></dl>
<dl class="section note"><dt>Note</dt><dd><code> 一个细胞是否是幽灵细胞、人造的，或者是本地拥有的，或者是一个只与活动的细胞有关的属性。因此，只有当它所指的单元格没有孩子时，你才能调用这个函数。 </code></dd></dl>

</div>
</div>
<a id="a9e6b3c485d88ed58114d1b470bb3693f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b3c485d88ed58114d1b470bb3693f">&#9670;&nbsp;</a></span>is_locally_owned_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned_on_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果三角结构没有分布，或者level_subdomain_id()等于当前处理器的id，则返回true。 </p>

</div>
</div>
<a id="a54375bf8f17e51501a4da7a2fac852ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54375bf8f17e51501a4da7a2fac852ae">&#9670;&nbsp;</a></span>is_ghost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个单元在全局网格中是否存在，但是(i)被另一个处理器所拥有，也就是有一个不同于当前处理器所拥有的子域_id，以及(ii)与当前处理器拥有的单元相邻。 这个函数只有在使用的三角形是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. 的情况下才有意义，在所有其他情况下，返回值总是错误的。 更多信息请参见 词汇表  和 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块。 </p><dl class="section post"><dt>Postcondition</dt><dd>返回值等于<code>!is_locally_owned() &amp;&amp; !is_artificial()/code&gt;。 </code></dd></dl>
<dl class="section note"><dt>Note</dt><dd><code> 一个细胞是否是幽灵细胞、人造的，或者是本地拥有的，或者是一个只与活动的细胞有关的属性。因此，只有当它所指的单元格没有孩子时，你才能调用这个函数。 </code></dd></dl>

</div>
</div>
<a id="aef398493764dee787a796b436826847b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef398493764dee787a796b436826847b">&#9670;&nbsp;</a></span>is_artificial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_artificial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个单元格是否是人造的，即它不是当前处理器所拥有的单元格之一，而且也不在一个单元格的边界上。因此，它存在于网格中，以确保每个处理器拥有所有粗略的网格单元，并保持相邻单元的2：1比例，但它不是我们应该在当前处理器上工作的单元之一。特别是，不能保证这个单元实际上没有在其他处理器上进一步细化。 这个函数只有在使用的三角形是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. 的情况下才有意义，在所有其他情况下，返回值总是假的。 参见 词汇表  和 <a class="el" href="group__distributed.html">Parallel computing with multiple processors using</a> 模块以了解更多信息。 </p><dl class="section post"><dt>Postcondition</dt><dd>返回值等于<code>!is_ghost() &amp;&amp; !is_locally_owned()/code&gt;。 </code></dd></dl>
<dl class="section note"><dt>Note</dt><dd><code> 一个单元是否是幽灵单元、人造的或本地拥有的是一个只与活动的单元有关的属性。因此，你只能在它所指的单元格没有孩子的情况下调用这个函数。 </code></dd></dl>

</div>
</div>
<a id="adb8a0465d3d7145513463b6a4a215fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8a0465d3d7145513463b6a4a215fbc">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试点 <code>p</code> 是否在这个单元格内。边界上的点被算作是在单元格内。 请注意，这个函数假定单元格和实际单元格之间的映射是（双，三）线性的，也就是说，2D的面和3D的边都是直线。如果你有更高阶的变换，结果可能不同，因为一个点在实空间中是在单元内还是在单元外。 在codim&gt;0的情况下，首先将点投影到单元格所嵌入的流形上，然后检查这个投影是否在单元格内。 </p>

</div>
</div>
<a id="abd998ef06bbaa081316d1f41ed5d6f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd998ef06bbaa081316d1f41ed5d6f49">&#9670;&nbsp;</a></span>set_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此单元格的邻居 <code>i</code> 设置为 <code>pointer</code>. 所指向的单元格 这个函数其实不应该公开（但由于各种原因需要公开，以便不使一长串函数成为朋友）：它修改了内部数据结构，可能会留下一些东西。请不要从应用程序代码中使用它。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02196">2196</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="aee7d5ec9cac8af95a136554501ea4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7d5ec9cac8af95a136554501ea4f0a">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellId.html">CellId</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回当前单元格的唯一ID。这个ID是由层次结构中从粗父单元开始的路径构建的，并且在使用类型为 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. 的对象的并行计算中正确工作。因此，这个函数在为单元（活动或不活动）提供一个唯一的标识符方面非常有用，也适用于并行三角计算。更多信息请参见CellId类的文档。 </p><dl class="section note"><dt>Note</dt><dd>这个操作需要O(level)时间来计算。在大多数实际情况下，三角形的层数将取决于三角形中的单元格数量的对数。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02226">2226</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a3cb9bed9b28bc791489cea0c867c476d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb9bed9b28bc791489cea0c867c476d">&#9670;&nbsp;</a></span>diameter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与 <a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">TriaAccessor::diameter()</a> 相同，但也采取映射类。 </p>

</div>
</div>
<a id="a0dd9ea78cda7d19b9997bae1bf1d5fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd9ea78cda7d19b9997bae1bf1d5fe0">&#9670;&nbsp;</a></span>neighbor_of_neighbor_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor_internal </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数假设邻居不比当前单元格粗。在这种情况下，它返回 <a class="el" href="classCellAccessor.html#a81e5dc97427e571da846e1fb0545aeb9">neighbor_of_neighbor()</a>值。然而，如果邻居更粗，这个函数返回一个 <code>invalid_unsigned_int</code> 。 这个函数不供公众使用。请使用函数 <a class="el" href="classCellAccessor.html#a81e5dc97427e571da846e1fb0545aeb9">neighbor_of_neighbor()</a>来代替，如果对一个较粗的邻居进行调用，会抛出一个异常。如果邻居确实较粗（你可以通过neigher_is_coarser()函数知道这一点），那么应该调用neigher_of_coarser_neighbor()函数。如果你只想知道从邻居到现在的单元所需的 <code>face_no</code> ，那么只需使用 <a class="el" href="classCellAccessor.html#a036e8dae65320c8d718b6fc88394293d">neighbor_face_no()</a>函数，该函数可用于较粗的邻居和非较粗的邻居。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02267">2267</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a96c380d489670714b30a3812801a1a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c380d489670714b30a3812801a1a53">&#9670;&nbsp;</a></span>point_inside_codim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int dim_, int spacedim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside_codim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>至于任何codim&gt;0，我们可以使用类似的代码，C++不允许部分模板。我们使用这个辅助函数，然后从point_inside调用。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01913">1913</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a0d7efb46efc1d5dfe714e3d0689c1700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7efb46efc1d5dfe714e3d0689c1700">&#9670;&nbsp;</a></span>set_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_active_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>active_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置一个单元格的活动单元格索引。这是在细化结束时进行的。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02110">2110</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab8122005ec0257e87cc6475a841790c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8122005ec0257e87cc6475a841790c3">&#9670;&nbsp;</a></span>set_global_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_global_active_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置一个单元格的全局活动单元格索引。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02121">2121</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a5a11e0fd6f847735bfbbf9543511bc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a11e0fd6f847735bfbbf9543511bc5b">&#9670;&nbsp;</a></span>set_global_level_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_global_level_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为一个水平单元设置全局水平单元索引。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02147">2147</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ac7f559666292ef3769b136e0a1516dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f559666292ef3769b136e0a1516dfd">&#9670;&nbsp;</a></span>set_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_parent </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>parent_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置一个单元格的父级。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02072">2072</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a2ab75196e96aafda94a0a96d833fdc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab75196e96aafda94a0a96d833fdc84">&#9670;&nbsp;</a></span>set_direction_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_direction_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_direction_flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置该单元格的方向。 关于这个标志的含义，见 <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l02055">2055</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a81b4fd965bfe879d1d5819575158ce11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81b4fd965bfe879d1d5819575158ce11">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; 1 &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01778">1778</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="afb389f7d1c4b94812ba55e6e37ee2e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb389f7d1c4b94812ba55e6e37ee2e2d">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; 2 &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01791">1791</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a17249a985a005be6e933aa76eb55023d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17249a985a005be6e933aa76eb55023d">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; 3 &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01853">1853</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a9f5ed157476c1275a351bf0338d6d14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5ed157476c1275a351bf0338d6d14b">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; 1, 2 &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01927">1927</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab82811b7ba2e50923fd77820ad9c7838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab82811b7ba2e50923fd77820ad9c7838">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; 1, 3 &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01935">1935</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a852120f4858e21deb555981eb5203b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852120f4858e21deb555981eb5203b90">&#9670;&nbsp;</a></span>point_inside() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; 2, 3 &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01943">1943</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="aeb0b77c3f3c1de1f604d456d0718efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b77c3f3c1de1f604d456d0718efc0">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试元素是否被使用。 返回值是 <code>true</code> 对于所有的迭代器都是正常的迭代器或活动的迭代器，只有原始迭代器可以返回 <code>false</code>. 因为原始迭代器只在库的内部使用，你通常不需要这个函数。 </p>

</div>
</div>
<a id="a76b3fb7b9d5de13f797e3c04d4dd03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b3fb7b9d5de13f797e3c04d4dd03a5">&#9670;&nbsp;</a></span>vertex_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向与此对象相连接的 <code>ith</code> 顶点的指针。如果 <code>dim=1</code> ，则抛出一个异常。 </p>

</div>
</div>
<a id="a81afd26d765a4cec094b25767b8dd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81afd26d765a4cec094b25767b8dd42a">&#9670;&nbsp;</a></span>vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前对象的第i个顶点的全局索引。关于顶点编号的惯例在GeometryInfo类的文档中有所规定。 请注意，返回值只是几何顶点的索引。 它与可能与之相关的自由度无关。 关于这一点，请参阅 <code><a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">DoFAccessor::vertex_dof_index</a></code> 函数。 </p><dl class="section note"><dt>Note</dt><dd>尽管有这个名字，这里返回的索引只是全局的，即它是特定于一个特定的三角形对象，或者，在三角形实际上是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 类型的情况下，特定于存储在当前处理器上的分布式三角形的那一部分。 </dd></dl>

</div>
</div>
<a id="a3dd6518eb0cf5fccc5926470128415d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6518eb0cf5fccc5926470128415d9">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对 <code>ith</code> 顶点的引用。该引用不是常量，也就是说，可以在赋值的左侧调用该函数，从而在三角剖分中移动单元的顶点。 当然，这样做需要你确保顶点的新位置保持有用。</p>
<ul>
<li>例如，避免倒置或其他扭曲的情况（另见 <a class="el" href="DEALGlossary.html#GlossDistorted">本词汇表条目</a>）。 <dl class="section note"><dt>Note</dt><dd>当一个单元被细化时，它的子单元继承了它们与母单元共享的那些顶点的位置（加上为新的子单元创建的边、面和单元内部的新顶点的位置）。如果一个单元的顶点被移动，这意味着其子单元也将使用这些新的位置。 另一方面，想象一下2D的情况，你有一个被精化的单元（有四个子单元），然后你移动连接所有四个子单元的中心顶点。如果你再次将这四个子单元粗化到母单元，那么移动的顶点的位置就会丢失，如果在以后的步骤中，你再次细化母单元，那么新的顶点将再次被放置在与第一次相同的位置上。</dd></dl>
</li>
<li>即，不在你之前移动的位置。 <dl class="section note"><dt>Note</dt><dd>如果你有一个 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象，上述的行为是相关的。在那里，细化一个网格总是涉及到重新划分。换句话说，你可能在一个处理器上移动到不同位置的本地拥有的单元的顶点（见 <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">这个词汇表条目</a> ），在网格细化时可能被移动到不同的处理器上（即使这些特定的单元没有被细化），这将根据他们之前拥有的粗略单元的位置重新创建他们的位置，而不是根据这些顶点在之前拥有它们的处理器的位置。换句话说，在并行计算中，你可能必须在每次网格细化后明确地移动节点，因为顶点的位置可能会也可能不会在伴随着网格细化的重新划分中被保留下来。 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a54c8283c86c84e29f718cbfe4118b3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8283c86c84e29f718cbfe4118b3b2">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::line_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向与此物体相邻的 <code>ith</code> 线的指针。 </p>

</div>
</div>
<a id="a450f0e6e00b9711650f59143e2085d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450f0e6e00b9711650f59143e2085d95">&#9670;&nbsp;</a></span>line_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>围绕此对象的 <code>ith</code> 线的索引。 只对<code>structdim&gt;1</code>实现，否则会产生异常。 </p>

</div>
</div>
<a id="a04dc361f8b3fb30c60a9e248c2108979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc361f8b3fb30c60a9e248c2108979">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::quad_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向包围此对象的 <code>ith</code> 四边形的指针。 </p>

</div>
</div>
<a id="ab3f77d56ddde728b892e3c736a28cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f77d56ddde728b892e3c736a28cd0c">&#9670;&nbsp;</a></span>quad_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>绑定此对象的 <code>ith</code> 四边形的索引。 只对<code>structdim&gt;2</code>实现，否则产生异常。 </p>

</div>
</div>
<a id="a452389bb368ba37c9c5542ef956526ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452389bb368ba37c9c5542ef956526ee">&#9670;&nbsp;</a></span>face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回索引为 <code>face</code> 的面的法线是否指向标准方向（ <code>true</code>) ），或者是否相反（ <code>false</code>). 哪个是标准方向，用GeometryInfo类来记录。在1d和2d中，它总是 <code>true</code>, ，但在3d中它可能是不同的，见GeometryInfo类文档中的相应讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 </p>

</div>
</div>
<a id="ad90f5ff1a44cb8a6e08196dac6cdb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90f5ff1a44cb8a6e08196dac6cdb22e">&#9670;&nbsp;</a></span>face_flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回索引为 <code>face</code> 的面是否旋转了180度（ <code>为真）或不旋转（</code> <code>false</code>). 在1d和2d中，这总是 <code>false</code>, ，但在3d中可能不同，见GeometryInfo类文档中的相关讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 </p>

</div>
</div>
<a id="a2f831f5ca8626677089f94af9be43a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f831f5ca8626677089f94af9be43a5b">&#9670;&nbsp;</a></span>face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回索引为 <code>face</code> 的面是否旋转了90度（ <code>为真）或不旋转（</code> <code>false</code>). 在1d和2d中，这总是 <code>false</code>, ，但在3d中可能不同，见GeometryInfo类文档中的相关讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 </p>

</div>
</div>
<a id="a08aaa41d4d6e0942d888efc21ca5d6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aaa41d4d6e0942d888efc21ca5d6c7">&#9670;&nbsp;</a></span>line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回索引为 <code>line</code> 的线条是否朝向标准方向。 <code>true</code> 表示线的方向是从顶点0到顶点1，否则就是相反的方向。在1d和2d中，它总是 <code>true</code>, ，但在3d中它可能是不同的，见GeometryInfo类文档中的相应讨论。 这个函数实际上只在库的内部使用，除非你绝对知道这是怎么回事。 这个函数查询 <a class="el" href="classReferenceCell.html#a24db72fed8c0bf34ab1a1751ad2b1f38">ReferenceCell::standard_vs_true_line_orientation()</a>. 。 </p>

</div>
</div>
<a id="a4ce77fc45536beea670a0b5c1d91539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce77fc45536beea670a0b5c1d91539c">&#9670;&nbsp;</a></span>has_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::has_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试对象是否有子代。 </p>

</div>
</div>
<a id="a634bf3e1c46e9ba87dfafa8c869e8972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bf3e1c46e9ba87dfafa8c869e8972">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此对象的直系子女数。未精炼的单元格的子代数为零。 </p>

</div>
</div>
<a id="aa0c1e25935669a4b310671a26e9dcbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1e25935669a4b310671a26e9dcbd2">&#9670;&nbsp;</a></span>number_of_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::number_of_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000039">Deprecated:</a></b></dt><dd>使用n_active_descendants()代替。</dd></dl>

</div>
</div>
<a id="a24fb24948b4e177f8e4eb737ec057397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fb24948b4e177f8e4eb737ec057397">&#9670;&nbsp;</a></span>n_active_descendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_active_descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算并返回该对象的活动后裔的数量。例如，如果一个六边形的所有八个子单元都被进一步各向同性地精炼了一次，返回的数字将是64，而不是80。 如果目前的单元没有被细化，则返回一个。 如果把三角结构看成是一个森林，每棵树的根都是粗大的网格单元，节点都有后代（单元的子女），那么这个函数就会返回源自当前对象的子树中终端节点的数量；因此，如果当前对象没有被进一步细化，答案是1。 </p>

</div>
</div>
<a id="aa39e613fd2e2c22bdc8ba340068e5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39e613fd2e2c22bdc8ba340068e5713">&#9670;&nbsp;</a></span>max_refinement_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::max_refinement_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个对象被精炼的次数。请注意，并不是所有的子对象都被精炼了那么多次（这就是为什么我们要在前面加上 <code>max_</code>), 的原因，返回的数字是这个对象的任何分支中的最大精炼次数。 例如，如果这个对象被精炼了，并且它的一个子对象正好再被精炼一次，那么<code>max_refinement_depth</code>应该返回2。 如果这个对象没有被精炼（即它是活动的），那么返回值是0。 </p>

</div>
</div>
<a id="a237132d2e5161b34a05291e10f3d6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237132d2e5161b34a05291e10f3d6feb">&#9670;&nbsp;</a></span>child_iterator_to_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_iterator_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前单元格上 <code>child</code> 的子数。这是 <a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">TriaAccessor::child()</a>. 的反函数。 </p>

</div>
</div>
<a id="aa035549b0c8b7eb7fcd33654bc73da29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035549b0c8b7eb7fcd33654bc73da29">&#9670;&nbsp;</a></span>isotropic_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该对象的迭代器，该对象与各向同性细化的第i个孩子相同。如果当前对象是各向同性细化的，那么返回的对象就是第i个子对象。如果当前对象是各向异性精炼的，那么返回的子对象实际上可能是该对象的孙子，或者根本就不存在（在这种情况下会产生一个异常）。 </p>

</div>
</div>
<a id="ae6a4a753f2ef5b2615a7e2fec21e0dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a4a753f2ef5b2615a7e2fec21e0dec">&#9670;&nbsp;</a></span>refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个单元格的RefinementCase。 </p>

</div>
</div>
<a id="acd7551fc85831a3fd4d5cd339b81d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7551fc85831a3fd4d5cd339b81d8c6">&#9670;&nbsp;</a></span>child_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>ith</code> 子单元的索引。如果单元格的子代被访问，则子代的级别比本单元格的级别高一个。面的孩子没有级别。如果子单元不存在。</p>
<ul>
<li>被返回。 </li>
</ul>

</div>
</div>
<a id="a8adec5f5b7786cf43e6011d03cc7903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adec5f5b7786cf43e6011d03cc7903a">&#9670;&nbsp;</a></span>isotropic_child_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><code>ith</code> 各向同性的子女的索引。参见isotropic_child()函数对这个概念的定义。 如果该子集不存在。</p>
<ul>
<li>被返回。 </li>
</ul>

</div>
</div>
<a id="af2b4887416074f2ecdcd06512e864e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b4887416074f2ecdcd06512e864e48">&#9670;&nbsp;</a></span>boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::boundary_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此对象的边界指示器。 如果返回值是特殊值 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>, ，那么这个对象就在域的内部。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a654de9ccd776b524a27cd64bded48e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654de9ccd776b524a27cd64bded48e14">&#9670;&nbsp;</a></span>set_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置当前对象的边界指标。这与boundary_id()函数的情况相同。 这个函数只设置当前对象本身的边界对象，而不是绑定它的指标。例如，在3D中，如果这个函数被调用到一个面，那么绑定这个面的4条边的边界指标保持不变。如果你想同时设置面和边的边界指标，请使用set_all_boundary_ids()函数。你可以在 <a class="el" href="step_49.html">step-49</a> 的结果部分看到没有使用正确函数的结果。 </p><dl class="section warning"><dt>Warning</dt><dd>你不应该设置内部面（不在域的边界上的面）的边界指示器，也不应该将外部面的边界指示器设置为 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> （这个值是为其他目的保留的）。如果边界单元的边界指示器为 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> ，或者内部单元的边界指示器不是 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. ，算法可能无法工作或产生非常混乱的结果。 不幸的是，当前对象没有办法找出它是否真的处于域的边界，因此无法确定你试图设置的值在当前情况下是否有意义。 @ @ "" </dd></dl>

</div>
</div>
<a id="aa0304fb253839c45e64b60460ab040ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0304fb253839c45e64b60460ab040ae">&#9670;&nbsp;</a></span>set_all_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_boundary_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像set_boundary_id()那样做，但也要设置约束当前对象的边界指标。例如，在3D中，如果对一个面调用set_boundary_id()，那么绑定该面的4条边的边界指标保持不变。相反，如果你调用当前函数，面和边的边界指示器都被设置为给定值。 如果你在3D中设置面的边界指示器（在2D中，该函数的作用与set_boundary_id()相同），并且你这样做是因为你想用一个弯曲的边界对象来表示与当前面相对应的那部分边界，那么这个函数就很有用。在这种情况下，Triangulation类需要弄清楚在网格细化时将新的顶点放在哪里，高阶Mapping对象也需要弄清楚曲线边界近似的新插值点应该在哪里。在这两种情况下，这两个类首先要确定边界面边缘的插值点，询问边界对象，然后再向边界对象询问对应于边界面内部的插值点。为了使其正常工作，仅仅设置了面的边界指示器是不够的，还需要设置约束面的边缘的边界指示器。这个函数一次就完成了所有这些工作。你可以在 <a class="el" href="step_49.html">step-49</a> 的结果部分看到没有使用正确函数的结果。 @ @ "" </p>

</div>
</div>
<a id="ae4d63b9ebf9b5c31aa702e49c664e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d63b9ebf9b5c31aa702e49c664e59d">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该对象所使用的流形对象的常数引用。 正如 <a class="el" href="group__manifold.html">Manifold description for triangulations</a> 模块中所解释的，寻找合适的流形描述的过程涉及到查询流形或边界指标。更多信息见那里。 </p>

</div>
</div>
<a id="a6c28dbcfefe0ffe1e51fe315c3565f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28dbcfefe0ffe1e51fe315c3565f94">&#9670;&nbsp;</a></span>manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::manifold_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此对象的歧管指标。 如果返回值是特殊值 <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, ，那么这个对象就与一个标准的笛卡尔流形描述相关。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">关于流形指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="gafbeb21da36433dc2ec117b9694ca2557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb21da36433dc2ec117b9694ca2557">&#9670;&nbsp;</a></span>set_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_manifold_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置流形指示器。 与<code><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id()</a></code>函数同样适用。 注意，它只设置当前对象本身的流形对象，而不是绑定它的指标，也不是其子对象的指标。例如，在3D中，如果对一个面调用这个函数，那么绑定该面的4条边的流形指标就不会改变。如果你想同时设置面、边和所有子节点的流形指标，请使用set_all_manifold_ids()函数。 @ @ "" </p>

</div>
</div>
<a id="ga160a26ce22b36607556bcdcc20bc6d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160a26ce22b36607556bcdcc20bc6d61">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像set_manifold_id()那样做，但也要设置绑定当前对象的流形指标。例如，在3D中，如果对一个面调用了set_manifold_id()，那么绑定该面的4条边的流形指标就不会改变。另一方面，面和边的流形指标都是用当前函数同时设置的。 @ @ "" </p>

</div>
</div>
<a id="a8b007b674b316f793f72b8ddc31e1cf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b007b674b316f793f72b8ddc31e1cf9">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 3, 3, 3 &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>manifold_ind</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01693">1693</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a6aa91f3e086777b02a2f6eef7ac19ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa91f3e086777b02a2f6eef7ac19ebb">&#9670;&nbsp;</a></span>user_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>读取用户标志。更多信息见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 。 </p>

</div>
</div>
<a id="a6dda85b6637fefd5db3d37ad7729fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda85b6637fefd5db3d37ad7729fcb1">&#9670;&nbsp;</a></span>set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 了解更多信息。 </p>

</div>
</div>
<a id="a59ff7c1bc2b4fc8abcd9b3ef44b5f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">&#9670;&nbsp;</a></span>clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 了解更多信息。 </p>

</div>
</div>
<a id="a63d791b3769c77bcfd1c56748a6c56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d791b3769c77bcfd1c56748a6c56fa">&#9670;&nbsp;</a></span>recursively_set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为这个和所有的子代设置用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 以了解更多信息。 </p>

</div>
</div>
<a id="a50b22f28a2baf2dd90b5309c3f0136af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b22f28a2baf2dd90b5309c3f0136af">&#9670;&nbsp;</a></span>recursively_clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除此项目和所有子项目的用户标志。参见 <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> 以了解更多信息。 </p>

</div>
</div>
<a id="a3965091ec2c6ba6ed838a2479dd8110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965091ec2c6ba6ed838a2479dd8110f">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用户数据重置为零，与指针或索引无关。更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="aceaaa0940be75dd7436769b55538aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaaa0940be75dd7436769b55538aaac">&#9670;&nbsp;</a></span>set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用户指针设置为 <code>p</code>. 。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 参见 GlossUserData 以了解更多信息。 </dd></dl>

</div>
</div>
<a id="a1fd20837028286220f0b2ba9b0d4b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd20837028286220f0b2ba9b0d4b219">&#9670;&nbsp;</a></span>clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用户指针重置为 <code>nullptr</code> 指针。参见 GlossUserData 以了解更多信息。 </p>

</div>
</div>
<a id="ad3700f2ce7587b2fbcaf85753c79bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3700f2ce7587b2fbcaf85753c79bf40">&#9670;&nbsp;</a></span>user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问用户指针的值。用户有责任确保该指针指向有用的东西。你应该使用新式的cast操作符来保持最低限度的类型安全，例如。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是互斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。<code>A a=static_cast&lt;A*&gt;(cell-&gt;<a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer()</a>)；</code>。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a484e590959847d514d42814efa3e25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484e590959847d514d42814efa3e25c2">&#9670;&nbsp;</a></span>recursively_set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将此对象及其所有子对象的用户指针设置为给定值。例如，如果某个子域的所有单元格，或者边界的某个部分的所有面都应该有用户指针指向描述这部分域或边界的对象，这就很有用。 请注意，用户指针在网格细化过程中是不被继承的，所以在网格细化之后，可能会有单元格或面没有用户指针指向描述对象。在这种情况下，只需简单地循环所有具有此信息的最粗层次的元素，并使用此函数递归地设置三角形的所有更细层次的用户指针。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是互斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="ad04d1802d9b1e8923dcfef41ea624edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04d1802d9b1e8923dcfef41ea624edc">&#9670;&nbsp;</a></span>recursively_clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除这个对象的用户指针和它所有的子对象。这与recursively_set_user_pointer()函数的说法相同。更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="a0cca979ccf43e19af78dcb91d19cfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cca979ccf43e19af78dcb91d19cfd87">&#9670;&nbsp;</a></span>set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用户索引设置为 <code>p</code>. 。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a97a1e59ae7328b4c75c69720826736c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1e59ae7328b4c75c69720826736c0">&#9670;&nbsp;</a></span>clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将用户索引重置为0。更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="ac7a24da10289811179abbfb57253e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a24da10289811179abbfb57253e9d3">&#9670;&nbsp;</a></span>user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问用户索引的值。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a309ae29be30ad5a259b1cd942e7d9e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ae29be30ad5a259b1cd942e7d9e9d">&#9670;&nbsp;</a></span>recursively_set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置此对象及其所有子对象的用户索引。 请注意，用户索引在网格细化中是不被继承的，所以在网格细化后，可能会有单元格或面的用户索引不符合预期。在这种情况下，只需循环查看所有拥有该信息的最粗层次的元素，并使用该函数递归设置三角结构中所有更细层次的用户索引。 </p><dl class="section note"><dt>Note</dt><dd>用户指针和用户索引是相互排斥的。因此，你只能使用其中之一，除非你在中间调用 <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> 。 更多信息见 GlossUserData 。 </dd></dl>

</div>
</div>
<a id="a429e559fb261a631942d54c897243abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429e559fb261a631942d54c897243abb">&#9670;&nbsp;</a></span>recursively_clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>清除这个对象的用户索引和它的所有后代。这与recursively_set_user_index()函数的说法相同。 更多信息见 GlossUserData 。 </p>

</div>
</div>
<a id="af0e85725edb5d2bb43da61796f2fbbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e85725edb5d2bb43da61796f2fbbb9">&#9670;&nbsp;</a></span>diameter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>物体的直径。 一个物体的直径被计算为当前物体的最大对角线。如果这个物体是四边形，那么有两条这样的对角线，如果是六面体，那么有四条对角线连接 "对面
"的点。对于三角形和四面体，该函数只是返回最长边的长度。 楔形和金字塔的情况就比较困难了。对于楔形，我们返回三个四边形面的最长对角线的长度或两个三角形面的最长边的长度。对于金字塔，同样的原则也适用。 在所有这些情况下，这个 "直径
"的定义不一定是物体内部各点之间最大距离意义上的真正直径。事实上，我们经常可以构造出不是这样的物体，尽管这些物体与参考形状相比一般都有很大的变形。此外，对于可能使用高阶映射的物体，我们可能会有凸起的面，这也会给计算物体直径的精确表示带来麻烦。也就是说，上面使用的定义对于大多数计算来说是完全足够的。 </p>

</div>
</div>
<a id="a7af8bab7e9ad732b6f3fa6a120ed5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af8bab7e9ad732b6f3fa6a120ed5208">&#9670;&nbsp;</a></span>enclosing_ball()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::enclosing_ball </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一对Point和double，对应于物体的中心和合理的小包围球的半径。 该函数实现了Ritter的O(n)算法，以获得一个围绕对象顶点的合理的小包围球。 包围球的初始猜测是包含对象的最大对角线作为其直径的球。 从这样的初始猜测开始，算法测试对象的所有顶点（除了最大对角线的顶点）在几何上是否在球内。 如果发现任何顶点（v）在几何上不在球内，则通过移动球的中心和增加半径来构建一个新的球的迭代，以便在几何上包围先前的球和顶点（v）。当所有的顶点都在球的几何范围内时，该算法就结束了。 如果一个顶点（v）在几何上位于球的某个迭代中，那么它将在球的后续迭代中继续如此（这是真实的，通过/a结构）。 </p><dl class="section note"><dt>Note</dt><dd>这个函数假定从参考单元开始的d-线性映射。 <a href="http://geomalgorithms.com/a08-_containers.html">see this</a>和[Ritter 1990]。 </dd></dl>

</div>
</div>
<a id="a57453302997d9df8d1e242bf663dc11b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57453302997d9df8d1e242bf663dc11b">&#9670;&nbsp;</a></span>bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::bounding_box </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回包围该对象的最小边界框。 注意，这个方法不知道你可能用来做计算的任何映射。如果你使用的是修改顶点位置的映射对象，比如MappingQEulerian，或者MappingFEField，那么你应该调用函数 <a class="el" href="classMapping.html#a50d2861c7e444384240609ec53093a54">Mapping::get_bounding_box()</a> 代替。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01587">1587</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a49a088728d7acb727fdc13bb6664d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a088728d7acb727fdc13bb6664d91a">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对象在给定轴线方向的长度，在本地坐标系中指定。关于本地轴的含义和列举，请参见GeometryInfo的文档。 请注意，一个物体的 "长度
"可以有多种解释。在这里，我们选择它作为对象的任何一条边的最大长度，这些边与参考单元上选择的轴平行。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01609">1609</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab467082583c8bce60bd9dd669b939ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab467082583c8bce60bd9dd669b939ae9">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 1, 1, 1 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01620">1620</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a0264eafc337e3596b9f895a091b18a44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0264eafc337e3596b9f895a091b18a44">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 1, 1, 2 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01631">1631</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a1b363d9cf3b6911d41223c9ed5d82daa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b363d9cf3b6911d41223c9ed5d82daa">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 2, 2, 2 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01642">1642</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a09623959e21c50be31d6e40b508c39b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09623959e21c50be31d6e40b508c39b4">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 2, 2, 3 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01656">1656</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a7f33cb96e76ff07eaf0052427907aeb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f33cb96e76ff07eaf0052427907aeb3">&#9670;&nbsp;</a></span>extent_in_direction() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 3, 3, 3 &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Lines along x-axis, see <a class="el" href="structGeometryInfo.html">GeometryInfo</a></p>
<p>Lines along y-axis</p>
<p>Lines along z-axis </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01671">1671</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a99b268c743742c3c9ab159ff916d9236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b268c743742c3c9ab159ff916d9236">&#9670;&nbsp;</a></span>minimum_vertex_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::minimum_vertex_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回任何两个顶点之间的最小距离。 </p>

</div>
</div>
<a id="a49df04630565a833e168e9cab074305e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49df04630565a833e168e9cab074305e">&#9670;&nbsp;</a></span>intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个属于此对象所在的流形&lt;dim,spacedim&gt;的点，给定其在参考单元格 <code>structdim</code> 上的参数化坐标。该函数可查询底层流形对象，并可用于获得该对象上任意点的精确几何位置。 注意，参数 <code>coordinates</code> 是 <em> 参考单元 </em> 上的坐标，以参考坐标给出。换句话说，该参数提供了不同顶点之间的权重。例如，对于线，调用这个函数的参数是Point&lt;1&gt;(.5)，相当于要求线的中心。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01714">1714</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a3eb24d5074a9a7bf216bd82f5d0dc618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eb24d5074a9a7bf216bd82f5d0dc618">&#9670;&nbsp;</a></span>real_to_unit_cell_affine_approximation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::real_to_unit_cell_affine_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数通过从参考 \(d\) 维单元反转 \(d\) 线性函数的仿射近似，计算从实数到单元格的快速近似转换。 单位单元到实数单元映射的仿生近似是通过仿生函数与本对象的 \(2^d\) 顶点的最小二乘法拟合找到的。对于任何有效的网格单元，其几何形状不是退化的，这个操作的结果是一个唯一的仿生映射。因此，对于所有给定的输入点，这个函数将返回一个有限的结果，即使在实际的双/三线或高阶映射的实际转换可能是单数的情况下。除了仅从顶点近似映射外，该函数还忽略了附加的流形描述。只有在从单元格到实际单元格的转换确实是仿生的情况下，结果才是准确的，比如在一维或二维/三维的笛卡尔和仿生（平行四边形）网格。 对于单元格的精确变换，使用 <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>. 。 </p><dl class="section note"><dt>Note</dt><dd>如果dim&lt;spacedim，我们首先将p投影到平面上。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01736">1736</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a8b045bcae58de112897824f4f08d1713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b045bcae58de112897824f4f08d1713">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>respect_manifold</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interpolate_from_surrounding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>物体的中心。对象的中心被定义为顶点位置的平均值，这也是 \(Q_1\) 映射将映射参考单元的中心的地方。然而，你也可以要求这个函数返回与当前对象相关的底层流形对象所计算的顶点的平均值，方法是将可选参数 <code>respect_manifold</code>. 设置为 true 流形通常会将顶点的坐标拉回到参考域（不一定是参考单元），在那里计算平均值，然后再将平均值点的坐标推到物理空间；结果点保证位于流形内，即使流形是弯曲的。 当对象使用不同的流形描述作为其周围环境时，比如该TriaAccessor的部分边界对象使用非平面流形描述，但对象本身是平面的， <a class="el" href="classTriaAccessor.html#a8b045bcae58de112897824f4f08d1713">TriaAccessor::center()</a> 函数给出的结果可能不够准确，即使参数 <code>respect_manifold</code> 被设置为真。如果你发现这种情况，你可以通过将第二个附加参数 <code>interpolate_from_surrounding设置为真来进一步完善中心的计算。这将通过从所有边界对象的中心进行所谓的无限插值来计算中心的位置。对于一个二维物体，它在四条周围线中的每一条上加了</code> <code>1/2</code> 的权重，在四个顶点上加了 <code>-1/4</code> 的权重。这相当于四个面的描述之间的线性插值，减去顶点的贡献，当通过与顶点相邻的两条线时，顶点的贡献被加了两次。在三维中，面的权重是 <code>1/2</code> ，线的权重是 <code>-1/4</code> ，而顶点的权重是 <code>1/8</code> 。为了进一步了解情况，还可以赋予TransfiniteInterpolationManifold类，该类不仅能够将这种有益的描述应用于单个单元，而且能够应用于粗略单元的所有子女。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01755">1755</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a56cc737f4b28f8d28a576d2e3d32ef9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56cc737f4b28f8d28a576d2e3d32ef9f">&#9670;&nbsp;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::barycenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对象的arycenter（也叫中心点）。在 \(D\) 空间维度中，维度为 \(K\) 的对象的arycenter由 </p><p class="formulaDsp">
\[ \mathbf x_K = \frac{1}{|K|} \int_K \mathbf x \; \textrm{d}x \]
</p>
<p>定义的 \(\mathbf x_K\) -维向量给出，其中对象的度量由 </p><p class="formulaDsp">
\[ |K| = \int_K \mathbf 1 \; \textrm{d}x. \]
</p>
<p>给出。 这个函数假定 \(K\) 由 \(d\) -线性函数从参考 \(d\) -维单元映射出来。然后，上面的积分可以被拉回到参考单元，并准确地进行评估（如果通过冗长的，并且与Center()函数相比，昂贵的计算）。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01565">1565</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="a9cecb2b7c9a1644fb5fd44bbba40ab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cecb2b7c9a1644fb5fd44bbba40ab0c">&#9670;&nbsp;</a></span>measure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::measure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算对象的dim-dimensional度量。对于二维空间中的二维单元，这等于其体积。另一方面，对于三维空间中的二维单元，或者如果当前指向的对象是三维空间中的三维单元的二维面，那么该函数就会计算该对象所占的面积。对于一个一维的物体，返回其长度。 该函数只计算假定由（双/三）线性映射表示的单元、面或边的量度。换句话说，它只考虑绑定当前对象的顶点的位置，而不考虑对象的内部实际上如何被映射。在大多数简单的情况下，这正是你想要的。然而，对于不 "直
"的对象，例如，嵌入三维空间的二维单元作为弯曲域的三角化的一部分，三维单元的二维面不仅仅是平行四边形，或者位于域的边界的面不仅仅是由直线段或平面限定的，这个函数只计算由描述有关对象的真实几何的流形或边界对象定义的 "真实
"对象的（双/三）线性内插的二维度量。如果你想考虑 "真实
"几何，你将需要通过在物体上积分一个等于1的函数来计算这个度量，在应用正交之后，等于将你想用于积分的FEValues或FEFaceValues对象返回的JxW值相加。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8cc_source.html#l01576">1576</a> of file <a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a>.</p>

</div>
</div>
<a id="ab21eeac18f82c9689857c225ca6be7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21eeac18f82c9689857c225ca6be7e4">&#9670;&nbsp;</a></span>is_translation_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::is_translation_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果当前对象是给定参数的翻译，则返回真。 </p><dl class="section note"><dt>Note</dt><dd>为了三角测量的目的，单元格、面等只由其顶点来描述。因此，当前函数只对顶点的位置进行比较。然而，对于许多实际应用来说，决定一个单元是否是另一个单元的翻译的不仅仅是顶点，还有单元如何从参考单元映射到它在现实空间中的位置。例如，如果我们使用高阶映射，那么不仅顶点必须是彼此的平移，而且还必须是沿边缘的点。因此，在这些问题中，应该问映射，而不是当前的函数，两个对象是否是彼此的平移。 </dd></dl>

</div>
</div>
<a id="ad2f79864c20e5ee8283e9ddb6f7c0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f79864c20e5ee8283e9ddb6f7c0415">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCell.html">ReferenceCell</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::reference_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前对象的参考单元格类型。 </p>

</div>
</div>
<a id="a4a5ed83117e0ff9276abeb9a4fbaac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5ed83117e0ff9276abeb9a4fbaac61">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>顶点的数量。 </p>

</div>
</div>
<a id="a48e25f9720160ac96bc7f4eea0977784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e25f9720160ac96bc7f4eea0977784">&#9670;&nbsp;</a></span>n_lines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行的数量。 </p>

</div>
</div>
<a id="af330fe95fe8d30a99884797f61236913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330fe95fe8d30a99884797f61236913">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>面的数量。 </p><dl class="section note"><dt>Note</dt><dd>只对单元格实现（dim==spacedim）。 </dd></dl>

</div>
</div>
<a id="ae40947cf863ecef1ee08ec93f411baaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40947cf863ecef1ee08ec93f411baaa">&#9670;&nbsp;</a></span>vertex_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到n_vertices()所有索引的数组。 </p>

</div>
</div>
<a id="a44268b67d46418c49a0a5e47f404adcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44268b67d46418c49a0a5e47f404adcc">&#9670;&nbsp;</a></span>line_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到n_lines()所有索引的数组。 </p>

</div>
</div>
<a id="a5b4cabec41161961ab25d91b6cdc2425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4cabec41161961ab25d91b6cdc2425">&#9670;&nbsp;</a></span>face_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对象，它可以被认为是一个包含从零到n_faces()的所有索引的数组。 </p><dl class="section note"><dt>Note</dt><dd>只对单元格实现（dim==spacedim）。 </dd></dl>

</div>
</div>
<a id="a436333e85278d0d4f3feb80abc2db97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436333e85278d0d4f3feb80abc2db97c">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制操作符。因为这只是从迭代器中调用，所以不要返回任何东西，因为迭代器会返回自己。 这个方法是受保护的，因为它只能从迭代器类中调用。 </p>

</div>
</div>
<a id="a7cd4644115f0c10a4e07462029211274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd4644115f0c10a4e07462029211274">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问器的比较运算符。这个操作符在比较迭代器进入三角形的对象时使用，例如，当把它们放入一个 <code>std::map</code>. 如果::structure_dimension小于::dimension，我们只是比较这样一个对象的索引，因为面和边没有层次。如果::structure_dimension等于::dimension，我们首先比较层次，只有在层次相等时才比较索引。 </p>

</div>
</div>
<a id="af88fce14be63f6000f7b5d70618dc14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce14be63f6000f7b5d70618dc14b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较是否相等。 </p>

</div>
</div>
<a id="a044710b90a02f1d4e6c2e39c00f51ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044710b90a02f1d4e6c2e39c00f51ee7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较不平等。 </p>

</div>
</div>
<a id="a5a24bd66635320e66d1dff07e3cb26e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24bd66635320e66d1dff07e3cb26e1">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该操作符将迭代器推进到下一个元素。 仅适用于 <code>dim=1</code> 。如果有更多的元素，下一个元素就是这一层的下一个。如果现在的元素是这一层的最后一个，则访问下一层的第一个。 </p>

</div>
</div>
<a id="a85d4f1dc476691cf77e88f2c3ed15afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d4f1dc476691cf77e88f2c3ed15afe">&#9670;&nbsp;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个操作符将迭代器移动到前一个元素。 仅适用于 <code>dim=1</code> 。如果<code>index&gt;0</code>，前一个元素是本层的前一个。如果现在的元素是这一层的第一个，则访问前一层的最后一个。 </p>

</div>
</div>
<a id="ae6d5a6b58e60a06216665e31c26704bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d5a6b58e60a06216665e31c26704bd">&#9670;&nbsp;</a></span>objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a>&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问具有相同维度的Triangulation的其他对象。 </p>

</div>
</div>
<a id="ae826bd9e6c976638366d9993e6a6c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826bd9e6c976638366d9993e6a6c7c0">&#9670;&nbsp;</a></span>level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于单元格，该函数返回该单元格所处的网格层次。对于所有其他对象，该函数返回零。 </p><dl class="section note"><dt>Note</dt><dd>在一个三角形对象中，单元格由一对 <code>(level, index)</code> 唯一标识，前者是单元格的细化层次，后者是该细化层次中单元格的索引（前者是本函数的返回值）。 因此，可能有多个处于不同细化级别的单元格，但在其级别中具有相同的索引。与此相反，如果当前对象对应的是一个面或边，那么该对象就只能通过其索引来识别，因为面和边没有细化级别。对于这些对象，当前函数总是返回0作为级别。 </dd></dl>

</div>
</div>
<a id="a6bebfc1e42324fbf595487e1bf668a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bebfc1e42324fbf595487e1bf668a22">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前级别上指向的元素的索引。 在Triangulation对象中，单元格由一对 <code>(level, index)</code> 唯一标识，前者是单元格的细化级别，后者是该细化级别中单元格的索引（后者是本函数的返回值）。因此，可能有多个处于不同细化级别的单元格，但在其级别中具有相同的索引。与此相反，如果当前对象对应于一个面或边，那么该对象只能通过其索引来识别，因为面和边没有细化级别。 </p><dl class="section note"><dt>Note</dt><dd>这个函数返回的索引对象并不是每个层次上的连续数字集：从一个单元到另一个单元，一个层次中的一些索引可能没有使用。 </dd>
<dd>
如果三角图实际上是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类型的，那么指数就只相对于存储在当前处理器上的分布式三角图的那部分。换句话说，生活在不同处理器上的三角形分区中的单元可能具有相同的索引，即使它们指的是同一个单元，也可能具有不同的索引，即使它们指的是同一个单元（例如，如果一个单元被一个处理器拥有，但在另一个处理器上是一个幽灵单元）。 </dd></dl>

</div>
</div>
<a id="a5f75f0d6c68a1a67ea03bd4727c29529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75f0d6c68a1a67ea03bd4727c29529">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回迭代器的状态。 关于一个访问器可能处于的不同状态，请参考TriaRawIterator文档。 </p>

</div>
</div>
<a id="af822c24c013e7b677f45ec2a8a41386a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822c24c013e7b677f45ec2a8a41386a">&#9670;&nbsp;</a></span>get_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该类所指向的对象所属于的三角形的引用。 </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abe9e690d5d7904f804316e15362a2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e690d5d7904f804316e15362a2191">&#9670;&nbsp;</a></span>Triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriangulation.html">Triangulation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03456">3456</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="aa06609bdb8db3c02e2988fe92796820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06609bdb8db3c02e2988fe92796820a">&#9670;&nbsp;</a></span>parallel::TriangulationBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03459">3459</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a1173edf91a9d914373821b6117f32a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173edf91a9d914373821b6117f32a8f">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Implementation.html">internal::TriangulationImplementation::Implementation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03461">3461</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a8b5f94c07c2ca904c27c04ca38eac0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5f94c07c2ca904c27c04ca38eac0e1">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::ImplementationMixedMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation:: ImplementationMixedMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03463">3463</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac97bc3b07691e1a0ba9f32074642ae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bc3b07691e1a0ba9f32074642ae66">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个访问器所代表的对象所处空间的尺寸。 例如，如果这个访问器代表一个四边形，它是四维空间中一个二维表面的一部分，那么这个值就是四。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00306">306</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a125ed55a8362723639a14d083d9e745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ed55a8362723639a14d083d9e745c">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个访问器所代表的事物的尺寸，是这个访问器的一部分。例如，如果这个访问器代表一条线，是六面体的一部分，那么这个值就是三。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00312">312</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a35e42860babc727fc028adfb9a3200b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e42860babc727fc028adfb9a3200b7">&#9670;&nbsp;</a></span>structure_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::structure_dimension = structdim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该访问器所代表的当前对象的尺寸。例如，如果它是线（不管它是四面体还是六面体的一部分，也不管我们处于什么维度），那么这个值就等于1。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00318">318</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a3ad5efb039ed878a124c9577acd92256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5efb039ed878a124c9577acd92256">&#9670;&nbsp;</a></span>present_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriaAccessorImplementation:: PresentLevelType&lt;structdim, dim&gt;::type <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果这是一个单元格（<code>structdim==dim</code>），则是水平。否则，包含零。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00496">496</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a11cf2d985abdb2c9a43ab97722305f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf2d985abdb2c9a43ab97722305f34">&#9670;&nbsp;</a></span>present_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于存储目前所使用的级别上目前所指向的元素的索引。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00502">502</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="af02486bbb2ee4b94d1b51f03ba47257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02486bbb2ee4b94d1b51f03ba47257f">&#9670;&nbsp;</a></span>tria</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;* <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::tria</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向我们行动的三角图的指针。 </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00508">508</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
<li>source/grid/<a class="el" href="tria__accessor_8cc_source.html">tria_accessor.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
