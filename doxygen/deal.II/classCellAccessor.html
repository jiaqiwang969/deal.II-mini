<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classCellAccessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: CellAccessor&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classCellAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">CellAccessor&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo;  &#124; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tria__accessor_8h_source.html">deal.II/grid/tria_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for CellAccessor&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classCellAccessor__inherit__graph.svg" width="942" height="87"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a9e1e1f35643e735193d89e70c5a28b54"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9e1e1f35643e735193d89e70c5a28b54">AccessorData</a> = typename <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td></tr>
<tr class="separator:a9e1e1f35643e735193d89e70c5a28b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e473b08fe4f390e918059d85b1afe60"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0e473b08fe4f390e918059d85b1afe60">Container</a> = <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;</td></tr>
<tr class="separator:a0e473b08fe4f390e918059d85b1afe60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90bf7670cf3c4571fe55e051d2503190"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> = void *</td></tr>
<tr class="separator:a90bf7670cf3c4571fe55e051d2503190"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a13e7c4a89332133d5ce71a1a5aa8f64f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a13e7c4a89332133d5ce71a1a5aa8f64f">global_active_cell_index</a> () const</td></tr>
<tr class="separator:a13e7c4a89332133d5ce71a1a5aa8f64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e84609c2c6afbeefdaa9096ff50dae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae8e84609c2c6afbeefdaa9096ff50dae">global_level_cell_index</a> () const</td></tr>
<tr class="separator:ae8e84609c2c6afbeefdaa9096ff50dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7cbda6466751b42b9660eccc8b8fe4a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7cbda6466751b42b9660eccc8b8fe4a3">DeclException0</a> (ExcRefineCellNotActive)</td></tr>
<tr class="separator:ga7cbda6466751b42b9660eccc8b8fe4a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9b1d6d2729d5ab7580aeddad59b29e19"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9b1d6d2729d5ab7580aeddad59b29e19">DeclException0</a> (ExcCellFlaggedForRefinement)</td></tr>
<tr class="separator:ga9b1d6d2729d5ab7580aeddad59b29e19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga797a1f7e7783e76abc85581a4577dc75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga797a1f7e7783e76abc85581a4577dc75">DeclException0</a> (ExcCellFlaggedForCoarsening)</td></tr>
<tr class="separator:ga797a1f7e7783e76abc85581a4577dc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aeb0b77c3f3c1de1f604d456d0718efc0">used</a> () const</td></tr>
<tr class="separator:aeb0b77c3f3c1de1f604d456d0718efc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:a026b9553c7d56c103147d3e9a6d9a0ed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a026b9553c7d56c103147d3e9a6d9a0ed">CellAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *<a class="el" href="classCellAccessor.html#a174554a23387673fd516cc4efb1b739b">parent</a>=nullptr, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a>=-1, const <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>=-1, const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *local_data=nullptr)</td></tr>
<tr class="separator:a026b9553c7d56c103147d3e9a6d9a0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3fbe765bc2a08b056175f8f52da568"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#acb3fbe765bc2a08b056175f8f52da568">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;cell_accessor)</td></tr>
<tr class="separator:acb3fbe765bc2a08b056175f8f52da568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:ab34931ab97b3e7c7da47388b30c36707"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab34931ab97b3e7c7da47388b30c36707">CellAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:ab34931ab97b3e7c7da47388b30c36707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:aecdfe299bf81ce75210d54e3f47684fb"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aecdfe299bf81ce75210d54e3f47684fb">CellAccessor</a> (const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:aecdfe299bf81ce75210d54e3f47684fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a95e342f30144f3e5b9fedb5a7ae814"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6a95e342f30144f3e5b9fedb5a7ae814">CellAccessor</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;)=default</td></tr>
<tr class="separator:a6a95e342f30144f3e5b9fedb5a7ae814"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96ac0b773c7d711afd21d70651a749f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a96ac0b773c7d711afd21d70651a749f4">CellAccessor</a> (<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a96ac0b773c7d711afd21d70651a749f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bf6ed208744e1c068bbac1f4fed9b9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a68bf6ed208744e1c068bbac1f4fed9b9">~CellAccessor</a> ()=default</td></tr>
<tr class="separator:a68bf6ed208744e1c068bbac1f4fed9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe479b764e417ae5caa2dff2c3a0c733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afe479b764e417ae5caa2dff2c3a0c733">operator=</a> (const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;)=delete</td></tr>
<tr class="separator:afe479b764e417ae5caa2dff2c3a0c733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fd380c25f52e90e2638e6fbf52c193"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a56fd380c25f52e90e2638e6fbf52c193">operator=</a> (<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a56fd380c25f52e90e2638e6fbf52c193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with periodic neighbors</div></td></tr>
<tr class="memitem:a5b60dfb7926e4a9d39c2208b0f86b256"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5b60dfb7926e4a9d39c2208b0f86b256">has_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a5b60dfb7926e4a9d39c2208b0f86b256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcd6d202db6c4578fc2623521185ea6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8dcd6d202db6c4578fc2623521185ea6">periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8dcd6d202db6c4578fc2623521185ea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f18fcbae7e944c2e503905a266856e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a1f18fcbae7e944c2e503905a266856e2">neighbor_or_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a1f18fcbae7e944c2e503905a266856e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752021a2f53bfa00dfe547adc662ffd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a752021a2f53bfa00dfe547adc662ffd6">periodic_neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:a752021a2f53bfa00dfe547adc662ffd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae61a7da21d9fcd55206cd7042b34c5fb"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae61a7da21d9fcd55206cd7042b34c5fb">periodic_neighbor_of_coarser_periodic_neighbor</a> (const unsigned face_no) const</td></tr>
<tr class="separator:ae61a7da21d9fcd55206cd7042b34c5fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c3888e028fcfafd86b1eef59e73505"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab1c3888e028fcfafd86b1eef59e73505">periodic_neighbor_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab1c3888e028fcfafd86b1eef59e73505"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fa397b3b27f4cda613208d127f0a98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a64fa397b3b27f4cda613208d127f0a98">periodic_neighbor_level</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a64fa397b3b27f4cda613208d127f0a98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92a480d8d1b269b21d95c7cc3c0a033"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af92a480d8d1b269b21d95c7cc3c0a033">periodic_neighbor_of_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:af92a480d8d1b269b21d95c7cc3c0a033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbdf47567f70bac8826dcd7e5782f968"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#afbdf47567f70bac8826dcd7e5782f968">periodic_neighbor_face_no</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:afbdf47567f70bac8826dcd7e5782f968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab737948031be71ea02495126a177ed8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab737948031be71ea02495126a177ed8a">periodic_neighbor_is_coarser</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab737948031be71ea02495126a177ed8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary indicators</div></td></tr>
<tr class="memitem:a4b683043741a1167de1ab9dbda0e54f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a4b683043741a1167de1ab9dbda0e54f7">at_boundary</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a4b683043741a1167de1ab9dbda0e54f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace4c08cb6a4ced3f610d9789d02ad202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ace4c08cb6a4ced3f610d9789d02ad202">at_boundary</a> () const</td></tr>
<tr class="separator:ace4c08cb6a4ced3f610d9789d02ad202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fee6d28c03cd3ba90263ecb0e268b3a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9fee6d28c03cd3ba90263ecb0e268b3a">has_boundary_lines</a> () const</td></tr>
<tr class="separator:a9fee6d28c03cd3ba90263ecb0e268b3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with refinement indicators</div></td></tr>
<tr class="memitem:a902048fc67583f356fd3278a7d2aa8de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a902048fc67583f356fd3278a7d2aa8de">refine_flag_set</a> () const</td></tr>
<tr class="separator:a902048fc67583f356fd3278a7d2aa8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c8359d5342b4ae7ae8b74fc3f4a1558"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">set_refine_flag</a> (const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt; ref_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a8c8359d5342b4ae7ae8b74fc3f4a1558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ccb325d746a81fa4a8542d698b89c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad5ccb325d746a81fa4a8542d698b89c7">clear_refine_flag</a> () const</td></tr>
<tr class="separator:ad5ccb325d746a81fa4a8542d698b89c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375a3010dcf7bd365a6d43429d64dcc1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a375a3010dcf7bd365a6d43429d64dcc1">flag_for_face_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;face_refinement_case=<a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt;::isotropic_refinement) const</td></tr>
<tr class="separator:a375a3010dcf7bd365a6d43429d64dcc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb3fa84168f193c7877ff90b70bcee83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aeb3fa84168f193c7877ff90b70bcee83">flag_for_line_refinement</a> (const unsigned <a class="el" href="classint.html">int</a> line_no) const</td></tr>
<tr class="separator:aeb3fa84168f193c7877ff90b70bcee83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448d8dc9bdecab5a250ed5ecb899ded9"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a448d8dc9bdecab5a250ed5ecb899ded9">subface_case</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a448d8dc9bdecab5a250ed5ecb899ded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4910a26c4458ce0dd444e6b7bec2564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae4910a26c4458ce0dd444e6b7bec2564">coarsen_flag_set</a> () const</td></tr>
<tr class="separator:ae4910a26c4458ce0dd444e6b7bec2564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de037c4860dcaceb4f9429b981b715e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a6de037c4860dcaceb4f9429b981b715e">set_coarsen_flag</a> () const</td></tr>
<tr class="separator:a6de037c4860dcaceb4f9429b981b715e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9fd137b13ff401f168ea0433cb18e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab9fd137b13ff401f168ea0433cb18e49">clear_coarsen_flag</a> () const</td></tr>
<tr class="separator:ab9fd137b13ff401f168ea0433cb18e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with material indicators</div></td></tr>
<tr class="memitem:ae4769702cd7ab67a61b25778ea3021b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae4769702cd7ab67a61b25778ea3021b2">material_id</a> () const</td></tr>
<tr class="separator:ae4769702cd7ab67a61b25778ea3021b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861d3679d23d3f4365f724c9cfe5fd77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a861d3679d23d3f4365f724c9cfe5fd77">set_material_id</a> (const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> new_material_id) const</td></tr>
<tr class="separator:a861d3679d23d3f4365f724c9cfe5fd77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b49d85f8793f5a95d6c50797c07be2b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2b49d85f8793f5a95d6c50797c07be2b">recursively_set_material_id</a> (const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> new_material_id) const</td></tr>
<tr class="separator:a2b49d85f8793f5a95d6c50797c07be2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with subdomain indicators</div></td></tr>
<tr class="memitem:ae06835414c3c3f3359974f2c75a88033"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae06835414c3c3f3359974f2c75a88033">subdomain_id</a> () const</td></tr>
<tr class="separator:ae06835414c3c3f3359974f2c75a88033"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56098dab68574f96b42779d68c54269d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a56098dab68574f96b42779d68c54269d">set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> new_subdomain_id) const</td></tr>
<tr class="separator:a56098dab68574f96b42779d68c54269d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c84842b2847744da6e48fbcabf777ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id</a> () const</td></tr>
<tr class="separator:a2c84842b2847744da6e48fbcabf777ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bfad9f24d9ddbc86883614639d4886d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2bfad9f24d9ddbc86883614639d4886d">set_level_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> new_level_subdomain_id) const</td></tr>
<tr class="separator:a2bfad9f24d9ddbc86883614639d4886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0108d0f1a0710c1e6d9b98f7cb2768fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0108d0f1a0710c1e6d9b98f7cb2768fa">recursively_set_subdomain_id</a> (const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> new_subdomain_id) const</td></tr>
<tr class="separator:a0108d0f1a0710c1e6d9b98f7cb2768fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with codim 1 cell orientation</div></td></tr>
<tr class="memitem:ae146ea059e9c27cb3e040b92d5c4e152"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ae146ea059e9c27cb3e040b92d5c4e152">direction_flag</a> () const</td></tr>
<tr class="separator:ae146ea059e9c27cb3e040b92d5c4e152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8ec35236bea8ee91a72bbd19762fe"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index</a> () const</td></tr>
<tr class="separator:ad4b8ec35236bea8ee91a72bbd19762fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a594e870d1b725fed0c5231596709b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af7a594e870d1b725fed0c5231596709b">parent_index</a> () const</td></tr>
<tr class="separator:af7a594e870d1b725fed0c5231596709b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a174554a23387673fd516cc4efb1b739b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a174554a23387673fd516cc4efb1b739b">parent</a> () const</td></tr>
<tr class="separator:a174554a23387673fd516cc4efb1b739b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other functions</div></td></tr>
<tr class="memitem:a5096c47dd02a264799a1b7b18fd45b3c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5096c47dd02a264799a1b7b18fd45b3c">is_active</a> () const</td></tr>
<tr class="separator:a5096c47dd02a264799a1b7b18fd45b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87a3ff6217f3b5b4537f6a101560f493"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a87a3ff6217f3b5b4537f6a101560f493">is_locally_owned</a> () const</td></tr>
<tr class="separator:a87a3ff6217f3b5b4537f6a101560f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e6b3c485d88ed58114d1b470bb3693f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9e6b3c485d88ed58114d1b470bb3693f">is_locally_owned_on_level</a> () const</td></tr>
<tr class="separator:a9e6b3c485d88ed58114d1b470bb3693f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54375bf8f17e51501a4da7a2fac852ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a54375bf8f17e51501a4da7a2fac852ae">is_ghost</a> () const</td></tr>
<tr class="separator:a54375bf8f17e51501a4da7a2fac852ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e47e37784c9f513cdef3c09a53439a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#af0e47e37784c9f513cdef3c09a53439a">is_ghost_on_level</a> () const</td></tr>
<tr class="separator:af0e47e37784c9f513cdef3c09a53439a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef398493764dee787a796b436826847b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aef398493764dee787a796b436826847b">is_artificial</a> () const</td></tr>
<tr class="separator:aef398493764dee787a796b436826847b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8a0465d3d7145513463b6a4a215fbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#adb8a0465d3d7145513463b6a4a215fbc">point_inside</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:adb8a0465d3d7145513463b6a4a215fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd998ef06bbaa081316d1f41ed5d6f49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abd998ef06bbaa081316d1f41ed5d6f49">set_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;&gt; &amp;pointer) const</td></tr>
<tr class="separator:abd998ef06bbaa081316d1f41ed5d6f49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7d5ec9cac8af95a136554501ea4f0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classCellId.html">CellId</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aee7d5ec9cac8af95a136554501ea4f0a">id</a> () const</td></tr>
<tr class="separator:aee7d5ec9cac8af95a136554501ea4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cb9bed9b28bc791489cea0c867c476d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a3cb9bed9b28bc791489cea0c867c476d">diameter</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping) const</td></tr>
<tr class="separator:a3cb9bed9b28bc791489cea0c867c476d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects</div></td></tr>
<tr class="memitem:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a76b3fb7b9d5de13f797e3c04d4dd03a5">vertex_iterator</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a76b3fb7b9d5de13f797e3c04d4dd03a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81afd26d765a4cec094b25767b8dd42a"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a81afd26d765a4cec094b25767b8dd42a">vertex_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a81afd26d765a4cec094b25767b8dd42a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd6518eb0cf5fccc5926470128415d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3dd6518eb0cf5fccc5926470128415d9">vertex</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a3dd6518eb0cf5fccc5926470128415d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a54c8283c86c84e29f718cbfe4118b3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a450f0e6e00b9711650f59143e2085d95"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a450f0e6e00b9711650f59143e2085d95">line_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a450f0e6e00b9711650f59143e2085d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04dc361f8b3fb30c60a9e248c2108979"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriangulationImplementation_1_1Iterators.html">internal::TriangulationImplementation::Iterators</a>&lt; dim, spacedim &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a04dc361f8b3fb30c60a9e248c2108979">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a04dc361f8b3fb30c60a9e248c2108979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab3f77d56ddde728b892e3c736a28cd0c">quad_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab3f77d56ddde728b892e3c736a28cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Orientation of sub-objects</div></td></tr>
<tr class="memitem:a452389bb368ba37c9c5542ef956526ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:a452389bb368ba37c9c5542ef956526ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:ad90f5ff1a44cb8a6e08196dac6cdb22e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f831f5ca8626677089f94af9be43a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:a2f831f5ca8626677089f94af9be43a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a08aaa41d4d6e0942d888efc21ca5d6c7">line_orientation</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html#a54c8283c86c84e29f718cbfe4118b3b2">line</a>) const</td></tr>
<tr class="separator:a08aaa41d4d6e0942d888efc21ca5d6c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing children</div></td></tr>
<tr class="memitem:a4ce77fc45536beea670a0b5c1d91539c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4ce77fc45536beea670a0b5c1d91539c">has_children</a> () const</td></tr>
<tr class="separator:a4ce77fc45536beea670a0b5c1d91539c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a634bf3e1c46e9ba87dfafa8c869e8972">n_children</a> () const</td></tr>
<tr class="separator:a634bf3e1c46e9ba87dfafa8c869e8972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0c1e25935669a4b310671a26e9dcbd2">number_of_children</a> () const</td></tr>
<tr class="separator:aa0c1e25935669a4b310671a26e9dcbd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24fb24948b4e177f8e4eb737ec057397"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a24fb24948b4e177f8e4eb737ec057397">n_active_descendants</a> () const</td></tr>
<tr class="separator:a24fb24948b4e177f8e4eb737ec057397"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa39e613fd2e2c22bdc8ba340068e5713">max_refinement_depth</a> () const</td></tr>
<tr class="separator:aa39e613fd2e2c22bdc8ba340068e5713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a237132d2e5161b34a05291e10f3d6feb"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a237132d2e5161b34a05291e10f3d6feb">child_iterator_to_index</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;<a class="el" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">child</a>) const</td></tr>
<tr class="separator:a237132d2e5161b34a05291e10f3d6feb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa035549b0c8b7eb7fcd33654bc73da29">isotropic_child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aa035549b0c8b7eb7fcd33654bc73da29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case</a> () const</td></tr>
<tr class="separator:ae6a4a753f2ef5b2615a7e2fec21e0dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acd7551fc85831a3fd4d5cd339b81d8c6">child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acd7551fc85831a3fd4d5cd339b81d8c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a8adec5f5b7786cf43e6011d03cc7903a">isotropic_child_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8adec5f5b7786cf43e6011d03cc7903a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with boundary indicators</div></td></tr>
<tr class="memitem:af2b4887416074f2ecdcd06512e864e48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id</a> () const</td></tr>
<tr class="separator:af2b4887416074f2ecdcd06512e864e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654de9ccd776b524a27cd64bded48e14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:a654de9ccd776b524a27cd64bded48e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0304fb253839c45e64b60460ab040ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>) const</td></tr>
<tr class="separator:aa0304fb253839c45e64b60460ab040ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae4d63b9ebf9b5c31aa702e49c664e59d">get_manifold</a> () const</td></tr>
<tr class="separator:ae4d63b9ebf9b5c31aa702e49c664e59d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with manifold indicators</div></td></tr>
<tr class="memitem:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id</a> () const</td></tr>
<tr class="separator:a6c28dbcfefe0ffe1e51fe315c3565f94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">User data</div></td></tr>
<tr class="memitem:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6aa91f3e086777b02a2f6eef7ac19ebb">user_flag_set</a> () const</td></tr>
<tr class="separator:a6aa91f3e086777b02a2f6eef7ac19ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a6dda85b6637fefd5db3d37ad7729fcb1">set_user_flag</a> () const</td></tr>
<tr class="separator:a6dda85b6637fefd5db3d37ad7729fcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">clear_user_flag</a> () const</td></tr>
<tr class="separator:a59ff7c1bc2b4fc8abcd9b3ef44b5f485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a63d791b3769c77bcfd1c56748a6c56fa">recursively_set_user_flag</a> () const</td></tr>
<tr class="separator:a63d791b3769c77bcfd1c56748a6c56fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a50b22f28a2baf2dd90b5309c3f0136af">recursively_clear_user_flag</a> () const</td></tr>
<tr class="separator:a50b22f28a2baf2dd90b5309c3f0136af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3965091ec2c6ba6ed838a2479dd8110f">clear_user_data</a> () const</td></tr>
<tr class="separator:a3965091ec2c6ba6ed838a2479dd8110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceaaa0940be75dd7436769b55538aaac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#aceaaa0940be75dd7436769b55538aaac">set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:aceaaa0940be75dd7436769b55538aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd20837028286220f0b2ba9b0d4b219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a1fd20837028286220f0b2ba9b0d4b219">clear_user_pointer</a> () const</td></tr>
<tr class="separator:a1fd20837028286220f0b2ba9b0d4b219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer</a> () const</td></tr>
<tr class="separator:ad3700f2ce7587b2fbcaf85753c79bf40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a484e590959847d514d42814efa3e25c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer</a> (void *p) const</td></tr>
<tr class="separator:a484e590959847d514d42814efa3e25c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad04d1802d9b1e8923dcfef41ea624edc">recursively_clear_user_pointer</a> () const</td></tr>
<tr class="separator:ad04d1802d9b1e8923dcfef41ea624edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a0cca979ccf43e19af78dcb91d19cfd87">set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a0cca979ccf43e19af78dcb91d19cfd87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1e59ae7328b4c75c69720826736c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a97a1e59ae7328b4c75c69720826736c0">clear_user_index</a> () const</td></tr>
<tr class="separator:a97a1e59ae7328b4c75c69720826736c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7a24da10289811179abbfb57253e9d3"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ac7a24da10289811179abbfb57253e9d3">user_index</a> () const</td></tr>
<tr class="separator:ac7a24da10289811179abbfb57253e9d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index</a> (const unsigned <a class="el" href="classint.html">int</a> p) const</td></tr>
<tr class="separator:a309ae29be30ad5a259b1cd942e7d9e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a429e559fb261a631942d54c897243abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a429e559fb261a631942d54c897243abb">recursively_clear_user_index</a> () const</td></tr>
<tr class="separator:a429e559fb261a631942d54c897243abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Geometric information about an object</div></td></tr>
<tr class="memitem:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">diameter</a> () const</td></tr>
<tr class="separator:af0e85725edb5d2bb43da61796f2fbbb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a7af8bab7e9ad732b6f3fa6a120ed5208">enclosing_ball</a> () const</td></tr>
<tr class="separator:a7af8bab7e9ad732b6f3fa6a120ed5208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf87ae60fcf03c3eb4332ee6e634647f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#acf87ae60fcf03c3eb4332ee6e634647f">bounding_box</a> () const</td></tr>
<tr class="separator:acf87ae60fcf03c3eb4332ee6e634647f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49a088728d7acb727fdc13bb6664d91a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a49a088728d7acb727fdc13bb6664d91a">extent_in_direction</a> (const unsigned <a class="el" href="classint.html">int</a> axis) const</td></tr>
<tr class="separator:a49a088728d7acb727fdc13bb6664d91a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b268c743742c3c9ab159ff916d9236"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a99b268c743742c3c9ab159ff916d9236">minimum_vertex_distance</a> () const</td></tr>
<tr class="separator:a99b268c743742c3c9ab159ff916d9236"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68f07dabea75fdc6af95db7ed5ed394"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad68f07dabea75fdc6af95db7ed5ed394">intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;coordinates) const</td></tr>
<tr class="separator:ad68f07dabea75fdc6af95db7ed5ed394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3814b2ee53cd391e23dd4448a3d78abd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; structdim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a3814b2ee53cd391e23dd4448a3d78abd">real_to_unit_cell_affine_approximation</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;point) const</td></tr>
<tr class="separator:a3814b2ee53cd391e23dd4448a3d78abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a309aff7fc274a52af0d567b1533d5596"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a309aff7fc274a52af0d567b1533d5596">center</a> (const <a class="el" href="classbool.html">bool</a> respect_manifold=false, const <a class="el" href="classbool.html">bool</a> interpolate_from_surrounding=false) const</td></tr>
<tr class="separator:a309aff7fc274a52af0d567b1533d5596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80ddbc9b39806cb2131b5518caef50db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a80ddbc9b39806cb2131b5518caef50db">barycenter</a> () const</td></tr>
<tr class="separator:a80ddbc9b39806cb2131b5518caef50db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a9cecb2b7c9a1644fb5fd44bbba40ab0c">measure</a> () const</td></tr>
<tr class="separator:a9cecb2b7c9a1644fb5fd44bbba40ab0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21eeac18f82c9689857c225ca6be7e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ab21eeac18f82c9689857c225ca6be7e4">is_translation_of</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;o) const</td></tr>
<tr class="separator:ab21eeac18f82c9689857c225ca6be7e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classReferenceCell.html">ReferenceCell</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ad2f79864c20e5ee8283e9ddb6f7c0415">reference_cell</a> () const</td></tr>
<tr class="separator:ad2f79864c20e5ee8283e9ddb6f7c0415"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a4a5ed83117e0ff9276abeb9a4fbaac61">n_vertices</a> () const</td></tr>
<tr class="separator:a4a5ed83117e0ff9276abeb9a4fbaac61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48e25f9720160ac96bc7f4eea0977784"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a48e25f9720160ac96bc7f4eea0977784">n_lines</a> () const</td></tr>
<tr class="separator:a48e25f9720160ac96bc7f4eea0977784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af330fe95fe8d30a99884797f61236913"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces</a> () const</td></tr>
<tr class="separator:af330fe95fe8d30a99884797f61236913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae40947cf863ecef1ee08ec93f411baaa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#ae40947cf863ecef1ee08ec93f411baaa">vertex_indices</a> () const</td></tr>
<tr class="separator:ae40947cf863ecef1ee08ec93f411baaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44268b67d46418c49a0a5e47f404adcc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a44268b67d46418c49a0a5e47f404adcc">line_indices</a> () const</td></tr>
<tr class="separator:a44268b67d46418c49a0a5e47f404adcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b4cabec41161961ab25d91b6cdc2425"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessor.html#a5b4cabec41161961ab25d91b6cdc2425">face_indices</a> () const</td></tr>
<tr class="separator:a5b4cabec41161961ab25d91b6cdc2425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator address and state</div></td></tr>
<tr class="memitem:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level</a> () const</td></tr>
<tr class="separator:ae826bd9e6c976638366d9993e6a6c7c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bebfc1e42324fbf595487e1bf668a22"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a> () const</td></tr>
<tr class="separator:a6bebfc1e42324fbf595487e1bf668a22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5f75f0d6c68a1a67ea03bd4727c29529">state</a> () const</td></tr>
<tr class="separator:a5f75f0d6c68a1a67ea03bd4727c29529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af822c24c013e7b677f45ec2a8a41386a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af822c24c013e7b677f45ec2a8a41386a">get_triangulation</a> () const</td></tr>
<tr class="separator:af822c24c013e7b677f45ec2a8a41386a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ac97bc3b07691e1a0ba9f32074642ae66">space_dimension</a> = spacedim</td></tr>
<tr class="separator:ac97bc3b07691e1a0ba9f32074642ae66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a125ed55a8362723639a14d083d9e745c"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a> = dim</td></tr>
<tr class="separator:a125ed55a8362723639a14d083d9e745c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35e42860babc727fc028adfb9a3200b7"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> = structdim</td></tr>
<tr class="separator:a35e42860babc727fc028adfb9a3200b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a0dd9ea78cda7d19b9997bae1bf1d5fe0"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0dd9ea78cda7d19b9997bae1bf1d5fe0">neighbor_of_neighbor_internal</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a>) const</td></tr>
<tr class="separator:a0dd9ea78cda7d19b9997bae1bf1d5fe0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c380d489670714b30a3812801a1a53"><td class="memTemplParams" colspan="2">template&lt;int dim_, int spacedim_&gt; </td></tr>
<tr class="memitem:a96c380d489670714b30a3812801a1a53"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a96c380d489670714b30a3812801a1a53">point_inside_codim</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;p) const</td></tr>
<tr class="separator:a96c380d489670714b30a3812801a1a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a436333e85278d0d4f3feb80abc2db97c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a436333e85278d0d4f3feb80abc2db97c">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;)</td></tr>
<tr class="separator:a436333e85278d0d4f3feb80abc2db97c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cd4644115f0c10a4e07462029211274"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a7cd4644115f0c10a4e07462029211274">operator&lt;</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;other) const</td></tr>
<tr class="separator:a7cd4644115f0c10a4e07462029211274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88fce14be63f6000f7b5d70618dc14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af88fce14be63f6000f7b5d70618dc14b">operator==</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:af88fce14be63f6000f7b5d70618dc14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a044710b90a02f1d4e6c2e39c00f51ee7">operator!=</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a> &amp;) const</td></tr>
<tr class="separator:a044710b90a02f1d4e6c2e39c00f51ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d5a6b58e60a06216665e31c26704bd"><td class="memItemLeft" align="right" valign="top">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#ae6d5a6b58e60a06216665e31c26704bd">objects</a> () const</td></tr>
<tr class="separator:ae6d5a6b58e60a06216665e31c26704bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Advancement of iterators</div></td></tr>
<tr class="memitem:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a5a24bd66635320e66d1dff07e3cb26e1">operator++</a> ()</td></tr>
<tr class="separator:a5a24bd66635320e66d1dff07e3cb26e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a85d4f1dc476691cf77e88f2c3ed15afe">operator--</a> ()</td></tr>
<tr class="separator:a85d4f1dc476691cf77e88f2c3ed15afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a3ad5efb039ed878a124c9577acd92256"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1TriaAccessorImplementation_1_1PresentLevelType.html">internal::TriaAccessorImplementation::PresentLevelType</a>&lt; structdim, dim &gt;::type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a3ad5efb039ed878a124c9577acd92256">present_level</a></td></tr>
<tr class="separator:a3ad5efb039ed878a124c9577acd92256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf2d985abdb2c9a43ab97722305f34"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#a11cf2d985abdb2c9a43ab97722305f34">present_index</a></td></tr>
<tr class="separator:a11cf2d985abdb2c9a43ab97722305f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTriaAccessorBase.html#af02486bbb2ee4b94d1b51f03ba47257f">tria</a></td></tr>
<tr class="separator:af02486bbb2ee4b94d1b51f03ba47257f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a0d7efb46efc1d5dfe714e3d0689c1700"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a0d7efb46efc1d5dfe714e3d0689c1700">set_active_cell_index</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index</a>) const</td></tr>
<tr class="separator:a0d7efb46efc1d5dfe714e3d0689c1700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8122005ec0257e87cc6475a841790c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ab8122005ec0257e87cc6475a841790c3">set_global_active_cell_index</a> (const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:ab8122005ec0257e87cc6475a841790c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a11e0fd6f847735bfbbf9543511bc5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a5a11e0fd6f847735bfbbf9543511bc5b">set_global_level_cell_index</a> (const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index</a>) const</td></tr>
<tr class="separator:a5a11e0fd6f847735bfbbf9543511bc5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f559666292ef3769b136e0a1516dfd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ac7f559666292ef3769b136e0a1516dfd">set_parent</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#af7a594e870d1b725fed0c5231596709b">parent_index</a>)</td></tr>
<tr class="separator:ac7f559666292ef3769b136e0a1516dfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab75196e96aafda94a0a96d833fdc84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2ab75196e96aafda94a0a96d833fdc84">set_direction_flag</a> (const <a class="el" href="classbool.html">bool</a> new_direction_flag) const</td></tr>
<tr class="separator:a2ab75196e96aafda94a0a96d833fdc84"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:abe9e690d5d7904f804316e15362a2191"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abe9e690d5d7904f804316e15362a2191">Triangulation</a></td></tr>
<tr class="separator:abe9e690d5d7904f804316e15362a2191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa06609bdb8db3c02e2988fe92796820a"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:aa06609bdb8db3c02e2988fe92796820a"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aa06609bdb8db3c02e2988fe92796820a">parallel::TriangulationBase</a></td></tr>
<tr class="separator:aa06609bdb8db3c02e2988fe92796820a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1173edf91a9d914373821b6117f32a8f"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a1173edf91a9d914373821b6117f32a8f">::internal::TriangulationImplementation::Implementation</a></td></tr>
<tr class="separator:a1173edf91a9d914373821b6117f32a8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a8b5f94c07c2ca904c27c04ca38eac0e1">::internal::TriangulationImplementation::ImplementationMixedMesh</a></td></tr>
<tr class="separator:a8b5f94c07c2ca904c27c04ca38eac0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Accessing sub-objects and neighbors</h2></td></tr>
<tr class="memitem:abacf4d5819d5f9e96d0e597cd92ce41e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#abacf4d5819d5f9e96d0e597cd92ce41e">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:abacf4d5819d5f9e96d0e597cd92ce41e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9f633c95c8309133588ae7970a4083"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2d9f633c95c8309133588ae7970a4083">child_iterators</a> () const</td></tr>
<tr class="separator:a2d9f633c95c8309133588ae7970a4083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731df8f0245670b477495d804b60f4e7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a731df8f0245670b477495d804b60f4e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09ca7ccf82126f4c791dbf361b143b60"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a09ca7ccf82126f4c791dbf361b143b60">face_iterator_to_index</a> (const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt;&gt; &amp;<a class="el" href="classCellAccessor.html#a731df8f0245670b477495d804b60f4e7">face</a>) const</td></tr>
<tr class="separator:a09ca7ccf82126f4c791dbf361b143b60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed34bf314b75f184a848b72759d917cb"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::faces_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aed34bf314b75f184a848b72759d917cb">face_iterators</a> () const</td></tr>
<tr class="separator:aed34bf314b75f184a848b72759d917cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393ecccb4d12de31be253b60740befe9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a393ecccb4d12de31be253b60740befe9">face_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a393ecccb4d12de31be253b60740befe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b05364556328fdb8d6492c3459ab91d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a2b05364556328fdb8d6492c3459ab91d">neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:a2b05364556328fdb8d6492c3459ab91d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e47f00c82296ea941b41c0e0201f47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a87e47f00c82296ea941b41c0e0201f47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c3e14735a8d0dc265e4436e69706ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad9c3e14735a8d0dc265e4436e69706ab">neighbor_index</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:ad9c3e14735a8d0dc265e4436e69706ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae0f773bc457f562f34a49fa841db9e3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#aae0f773bc457f562f34a49fa841db9e3">neighbor_level</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:aae0f773bc457f562f34a49fa841db9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81e5dc97427e571da846e1fb0545aeb9"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a81e5dc97427e571da846e1fb0545aeb9">neighbor_of_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a81e5dc97427e571da846e1fb0545aeb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a570b9c4837247169156ae7c9d59ade33"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a570b9c4837247169156ae7c9d59ade33">neighbor_is_coarser</a> (const unsigned <a class="el" href="classint.html">int</a> face_no) const</td></tr>
<tr class="separator:a570b9c4837247169156ae7c9d59ade33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f9afc8fed399db26e15357cd8acfd3e"><td class="memItemLeft" align="right" valign="top">std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a9f9afc8fed399db26e15357cd8acfd3e">neighbor_of_coarser_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a>) const</td></tr>
<tr class="separator:a9f9afc8fed399db26e15357cd8acfd3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036e8dae65320c8d718b6fc88394293d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#a036e8dae65320c8d718b6fc88394293d">neighbor_face_no</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor</a>) const</td></tr>
<tr class="separator:a036e8dae65320c8d718b6fc88394293d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a20051ef5a6874f0ed22ce76706fcb"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCellAccessor.html#ad5a20051ef5a6874f0ed22ce76706fcb">is_level_cell</a> ()</td></tr>
<tr class="separator:ad5a20051ef5a6874f0ed22ce76706fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class CellAccessor&lt; dim, spacedim &gt;</h3>

<p>This class allows access to a cell: a line in one dimension, a quad in two dimension, etc.</p>
<p>The following refers to any dimension:</p>
<p>This class allows access to a <code>cell</code>, which is a line in 1D and a quad in 2D. Cells have more functionality than lines or quads by themselves, for example they can be flagged for refinement, they have neighbors, they have the possibility to check whether they are at the boundary etc. This class offers access to all this data. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02826">2826</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a9e1e1f35643e735193d89e70c5a28b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e1e1f35643e735193d89e70c5a28b54">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> =  typename <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim, dim, spacedim&gt;::<a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate the AccessorData type into the present class. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02832">2832</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a0e473b08fe4f390e918059d85b1afe60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e473b08fe4f390e918059d85b1afe60">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html#a0e473b08fe4f390e918059d85b1afe60">Container</a> =  <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the type of the container this is part of. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l02837">2837</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a90bf7670cf3c4571fe55e051d2503190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90bf7670cf3c4571fe55e051d2503190">&#9670;&nbsp;</a></span>LocalData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::<a class="el" href="classTriaAccessorBase.html#a90bf7670cf3c4571fe55e051d2503190">LocalData</a> =  void *</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data type to be used for passing parameters from iterators to the accessor classes in a unified way, no matter what the type of number of these parameters is. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00441">441</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a026b9553c7d56c103147d3e9a6d9a0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026b9553c7d56c103147d3e9a6d9a0ed">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>parent</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em> = <code>-1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html#a550277a207804869ea18cd8c7d307611">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. </p>

</div>
</div>
<a id="acb3fbe765bc2a08b056175f8f52da568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3fbe765bc2a08b056175f8f52da568">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_accessor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="ab34931ab97b3e7c7da47388b30c36707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34931ab97b3e7c7da47388b30c36707">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor exists to make certain constructs simpler to write in dimension independent code. For example, it allows assigning a face iterator to a line iterator, an operation that is useful in 2d but doesn't make any sense in 3d. The constructor here exists for the purpose of making the code conform to C++ but it will unconditionally abort; in other words, assigning a face iterator to a line iterator is better put into an if-statement that checks that the dimension is two, and assign to a quad iterator in 3d (an operator that, without this constructor would be illegal if we happen to compile for 2d). </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03936">3936</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="aecdfe299bf81ce75210d54e3f47684fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecdfe299bf81ce75210d54e3f47684fb">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another conversion operator between objects that don't make sense, just like the previous one. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03966">3966</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a6a95e342f30144f3e5b9fedb5a7ae814"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a95e342f30144f3e5b9fedb5a7ae814">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="a96ac0b773c7d711afd21d70651a749f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96ac0b773c7d711afd21d70651a749f4">&#9670;&nbsp;</a></span>CellAccessor() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="a68bf6ed208744e1c068bbac1f4fed9b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bf6ed208744e1c068bbac1f4fed9b9">&#9670;&nbsp;</a></span>~CellAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::~<a class="el" href="classCellAccessor.html">CellAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afe479b764e417ae5caa2dff2c3a0c733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe479b764e417ae5caa2dff2c3a0c733">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. These operators are usually used in a context like <code>iterator a,b; *a=*b;</code>. Presumably, the intent here is to copy the object pointed to by <code>b</code> to the object pointed to by <code>a</code>. However, the result of dereferencing an iterator is not an object but an accessor; consequently, this operation is not useful for iterators on triangulations. Consequently, this operator is declared as deleted and can not be used. </p>

</div>
</div>
<a id="a56fd380c25f52e90e2638e6fbf52c193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fd380c25f52e90e2638e6fbf52c193">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="abacf4d5819d5f9e96d0e597cd92ce41e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacf4d5819d5f9e96d0e597cd92ce41e">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the <code>ith</code> child. Overloaded version which returns a more reasonable iterator class. </p>

</div>
</div>
<a id="a2d9f633c95c8309133588ae7970a4083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9f633c95c8309133588ae7970a4083">&#9670;&nbsp;</a></span>child_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;<a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::max_children_per_cell&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::child_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of iterators to all children of this cell. </p>

</div>
</div>
<a id="a731df8f0245670b477495d804b60f4e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731df8f0245670b477495d804b60f4e7">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the <code>ith</code> face of this cell. </p>

</div>
</div>
<a id="a09ca7ccf82126f4c791dbf361b143b60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09ca7ccf82126f4c791dbf361b143b60">&#9670;&nbsp;</a></span>face_iterator_to_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_iterator_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; dim - 1, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the face number of <code>face</code> on the current cell. This is the inverse function of TriaAccessor::face(). </p>

</div>
</div>
<a id="aed34bf314b75f184a848b72759d917cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed34bf314b75f184a848b72759d917cb">&#9670;&nbsp;</a></span>face_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;dim - 1, dim, spacedim&gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::faces_per_cell&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of iterators to all faces of this cell. </p>

</div>
</div>
<a id="a393ecccb4d12de31be253b60740befe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393ecccb4d12de31be253b60740befe9">&#9670;&nbsp;</a></span>face_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::face_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the (global) index of the <code>ith</code> face of this cell.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, the index returned here is only global in the sense that it is specific to a particular <a class="el" href="classTriangulation.html">Triangulation</a> object or, in the case the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, specific to that part of the distributed triangulation stored on the current processor. </dd></dl>

</div>
</div>
<a id="a2b05364556328fdb8d6492c3459ab91d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b05364556328fdb8d6492c3459ab91d">&#9670;&nbsp;</a></span>neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to that cell that neighbors the present cell on the given face and subface number.</p>
<p>To succeed, the present cell must not be further refined, and the neighbor on the given face must be further refined exactly once; the returned cell is then a child of that neighbor.</p>
<p>The function may not be called in 1d, since there we have no subfaces. The implementation of this function is rather straightforward in 2d, by first determining which face of the neighbor cell the present cell is bordering on (this is what the <code>neighbor_of_neighbor</code> function does), and then asking <code>GeometryInfo::child_cell_on_subface</code> for the index of the child.</p>
<p>However, the situation is more complicated in 3d, since there faces may have more than one orientation, and we have to use <code>face_orientation</code>, <code>face_flip</code> and <code>face_rotation</code> for both this and the neighbor cell to figure out which cell we want to have.</p>
<p>This can lead to surprising results: if we are sitting on a cell and are asking for a cell behind subface <code>sf</code>, then this means that we are considering the subface for the face in the natural direction for the present cell. However, if the face as seen from this cell has <code><a class="el" href="classTriaAccessor.html#a452389bb368ba37c9c5542ef956526ee">face_orientation()</a>==false</code>, then the child of the face that separates the present cell from the neighboring cell's child is not necessarily the <code>sf-th</code> child of the face of this cell. This is so because the <code>subface_no</code> on a cell corresponds to the subface with respect to the intrinsic ordering of the present cell, whereas children of face iterators are computed with respect to the intrinsic ordering of faces; these two orderings are only identical if the face orientation is <code>true</code>, and reversed otherwise.</p>
<p>Similarly, effects of <code><a class="el" href="classTriaAccessor.html#ad90f5ff1a44cb8a6e08196dac6cdb22e">face_flip()</a>==true</code> and <code><a class="el" href="classTriaAccessor.html#a2f831f5ca8626677089f94af9be43a5b">face_rotation()</a>==true()</code>, both of which indicate a non-standard face have to be considered.</p>
<p>Fortunately, this is only very rarely of concern, since usually one simply wishes to loop over all finer neighbors at a given face of an active cell. Only in the process of refinement of a <a class="el" href="classTriangulation.html">Triangulation</a> we want to set neighbor information for both our child cells and the neighbor's children. Since we can respect orientation of faces from our current cell in that case, we do NOT respect face_orientation, face_flip and face_rotation of the present cell within this function, i.e. the returned neighbor's child is behind subface <code>subface</code> concerning the intrinsic ordering of the given face. </p>

</div>
</div>
<a id="a87e47f00c82296ea941b41c0e0201f47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e47f00c82296ea941b41c0e0201f47">&#9670;&nbsp;</a></span>neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the neighboring cell on the other side of the face with number <code>face_no</code>. If the neighbor does not exist, i.e., if the face with number <code>face_no</code> of the current object is at the boundary, then an invalid iterator is returned.</p>
<p>Consequently, the index <code>face_no</code> must be less than <a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces()</a>.</p>
<p>The neighbor of a cell has at most the same level as this cell. For example, consider the following situation: </p><div class="image">
<img src="limit_level_difference_at_vertices.png" alt="limit_level_difference_at_vertices.png"/>
</div>
<p>Here, if you are on the top right cell and you ask for its left neighbor (which is, according to the conventions spelled out in the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class, its <em>zeroth</em> neighbor), then you will get the mother cell of the four small cells at the top left. In other words, the cell you get as neighbor has the same refinement level as the one you're on right now (the top right one) and it may have children.</p>
<p>On the other hand, if you were at the top right cell of the four small cells at the top left, and you asked for the right neighbor (which is associated with index <code>face_no=1</code>), then you would get the large cell at the top right which in this case has a lower refinement level and no children of its own. </p>

</div>
</div>
<a id="ad9c3e14735a8d0dc265e4436e69706ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c3e14735a8d0dc265e4436e69706ab">&#9670;&nbsp;</a></span>neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the cell index of the neighboring cell on the other side of the face with index <code>face_no</code>. If the neighbor does not exist, this function returns -1.</p>
<p>This function is equivalent to <code>cell-&gt;neighbor(face_no)-&gt;<a class="el" href="classTriaAccessorBase.html#a6bebfc1e42324fbf595487e1bf668a22">index()</a></code>. See <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor()</a> for more details. </p>

</div>
</div>
<a id="aae0f773bc457f562f34a49fa841db9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae0f773bc457f562f34a49fa841db9e3">&#9670;&nbsp;</a></span>neighbor_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the level of the neighboring cell on the other side of the face with number <code>face_no</code>. If the neighbor does not exist, this function returns -1.</p>
<p>This function is equivalent to <code>cell-&gt;neighbor(face_no)-&gt;<a class="el" href="classTriaAccessorBase.html#ae826bd9e6c976638366d9993e6a6c7c0">level()</a></code>. See <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor()</a> for more details. </p>

</div>
</div>
<a id="a81e5dc97427e571da846e1fb0545aeb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81e5dc97427e571da846e1fb0545aeb9">&#9670;&nbsp;</a></span>neighbor_of_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the how-many'th neighbor this cell is of <code>cell-&gt;neighbor(face_no)</code>, i.e. return <code>other_face_no</code> such that <code>cell-&gt;neighbor(face_no)-&gt;neighbor(other_face_no)==cell</code>. This function is the right one if you want to know how to get back from a neighbor to the present cell.</p>
<p>Note that this operation is only useful if the neighbor is not coarser than the present cell. If the neighbor is coarser this function throws an exception. Use the <code>neighbor_of_coarser_neighbor</code> function in that case. </p>

</div>
</div>
<a id="a570b9c4837247169156ae7c9d59ade33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a570b9c4837247169156ae7c9d59ade33">&#9670;&nbsp;</a></span>neighbor_is_coarser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return, whether the neighbor is coarser then the present cell. This is important in case of anisotropic refinement where this information does not depend on the levels of the cells.</p>
<p>Note, that in an anisotropic setting, a cell can only be coarser than another one at a given face, not on a general basis. The face of the finer cell is contained in the corresponding face of the coarser cell, the finer face is either a child or a grandchild of the coarser face. </p>

</div>
</div>
<a id="a9f9afc8fed399db26e15357cd8acfd3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9afc8fed399db26e15357cd8acfd3e">&#9670;&nbsp;</a></span>neighbor_of_coarser_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_coarser_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of the <code>neighbor_of_neighbor</code> function for the case of a coarser neighbor. It returns a pair of numbers, face_no and subface_no, with the following property, if the neighbor is not refined: <code>cell-&gt;neighbor(neighbor)-&gt;neighbor_child_on_subface(face_no, subface_no)==cell</code>. In 3D, a coarser neighbor can still be refined. In that case subface_no denotes the child index of the neighbors face that relates to our face: <code>cell-&gt;neighbor(neighbor)-&gt;face(face_no)-&gt;child(subface_no)==cell-&gt;face(neighbor)</code>. This case in 3d and how it can happen is discussed in the introduction of the step-30 tutorial program.</p>
<p>This function is impossible for <code>dim==1</code>. </p>

</div>
</div>
<a id="a036e8dae65320c8d718b6fc88394293d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036e8dae65320c8d718b6fc88394293d">&#9670;&nbsp;</a></span>neighbor_face_no()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of the <code>neighbor_of_neighbor</code> and the <code>neighbor_of_coarser_neighbor</code> functions. It checks whether the neighbor is coarser or not and calls the respective function. In both cases, only the face_no is returned. </p>

</div>
</div>
<a id="ad5a20051ef5a6874f0ed22ce76706fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a20051ef5a6874f0ed22ce76706fcb">&#9670;&nbsp;</a></span>is_level_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_level_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compatibility interface with <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>. Always returns <code>false</code>. </p>

</div>
</div>
<a id="a5b60dfb7926e4a9d39c2208b0f86b256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b60dfb7926e4a9d39c2208b0f86b256">&#9670;&nbsp;</a></span>has_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the cell has a periodic neighbor at its <code>ith</code> face, this function returns true, otherwise, the returned value is false. </p>

</div>
</div>
<a id="a8dcd6d202db6c4578fc2623521185ea6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcd6d202db6c4578fc2623521185ea6">&#9670;&nbsp;</a></span>periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a cell with its <code>ith</code> face at a periodic boundary, see <a class="el" href="DEALGlossary.html#GlossPeriodicConstraints">the entry for periodic boundaries</a>, this function returns an iterator to the cell on the other side of the periodic boundary. If there is no periodic boundary at the <code>ith</code> face, an exception will be thrown. In order to avoid running into an exception, check the result of <a class="el" href="classCellAccessor.html#a5b60dfb7926e4a9d39c2208b0f86b256">has_periodic_neighbor()</a> for the <code>ith</code> face prior to using this function. The behavior of <a class="el" href="classCellAccessor.html#a8dcd6d202db6c4578fc2623521185ea6">periodic_neighbor()</a> is similar to <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor()</a>, in the sense that the returned cell has at most the same level of refinement as the current cell. On distributed meshes, by calling <a class="el" href="classTriangulation.html#a7117ea716b516ef11a205a5d0020fe40">Triangulation::add_periodicity()</a>, we can make sure that the element on the other side of the periodic boundary exists in this rank as a ghost cell or a locally owned cell. </p>

</div>
</div>
<a id="a1f18fcbae7e944c2e503905a266856e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f18fcbae7e944c2e503905a266856e2">&#9670;&nbsp;</a></span>neighbor_or_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_or_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a cell whose <code>ith</code> face is not at a boundary, this function returns the same result as <a class="el" href="classCellAccessor.html#a87e47f00c82296ea941b41c0e0201f47">neighbor()</a>. If the <code>ith</code> face is at a periodic boundary this function returns the same result as <a class="el" href="classCellAccessor.html#a8dcd6d202db6c4578fc2623521185ea6">periodic_neighbor()</a>. If neither of the aforementioned conditions are met, i.e. the <code>ith</code> face is on a nonperiodic boundary, an exception will be thrown. </p>

</div>
</div>
<a id="a752021a2f53bfa00dfe547adc662ffd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752021a2f53bfa00dfe547adc662ffd6">&#9670;&nbsp;</a></span>periodic_neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the periodic neighbor of the cell at a given face and subface number. The general guidelines for using this function is similar to the function <a class="el" href="classCellAccessor.html#a2b05364556328fdb8d6492c3459ab91d">neighbor_child_on_subface()</a>. The implementation of this function is consistent with <a class="el" href="classCellAccessor.html#ae61a7da21d9fcd55206cd7042b34c5fb">periodic_neighbor_of_coarser_periodic_neighbor()</a>. For instance, assume that we are sitting on a cell named <code>cell1</code>, whose neighbor behind the <code>ith</code> face is one level coarser. Let us name this coarser neighbor <code>cell2</code>. Then, by calling <a class="el" href="classCellAccessor.html#ae61a7da21d9fcd55206cd7042b34c5fb">periodic_neighbor_of_coarser_periodic_neighbor()</a>, from <code>cell1</code>, we get a <code>face_num</code> and a <code>subface_num</code>. Now, if we call <a class="el" href="classCellAccessor.html#a752021a2f53bfa00dfe547adc662ffd6">periodic_neighbor_child_on_subface()</a> from cell2, with the above face_num and subface_num, we get an iterator to <code>cell1</code>. </p>

</div>
</div>
<a id="ae61a7da21d9fcd55206cd7042b34c5fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae61a7da21d9fcd55206cd7042b34c5fb">&#9670;&nbsp;</a></span>periodic_neighbor_of_coarser_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_of_coarser_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a generalization of <a class="el" href="classCellAccessor.html#af92a480d8d1b269b21d95c7cc3c0a033">periodic_neighbor_of_periodic_neighbor()</a> for those cells which have a coarser periodic neighbor. The returned pair of numbers can be used in <a class="el" href="classCellAccessor.html#a752021a2f53bfa00dfe547adc662ffd6">periodic_neighbor_child_on_subface()</a> to get back to the current cell. In other words, the following assertion should be true, for a cell with coarser periodic neighbor: cell-&gt;periodic_neighbor(i)-&gt;periodic_neighbor_child_on_subface(face_no, subface_no)==cell </p>

</div>
</div>
<a id="ab1c3888e028fcfafd86b1eef59e73505"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c3888e028fcfafd86b1eef59e73505">&#9670;&nbsp;</a></span>periodic_neighbor_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the index of the periodic neighbor at the <code>ith</code> face of the current cell. If there is no periodic neighbor at the given face, the returned value is -1. </p>

</div>
</div>
<a id="a64fa397b3b27f4cda613208d127f0a98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fa397b3b27f4cda613208d127f0a98">&#9670;&nbsp;</a></span>periodic_neighbor_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_level </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns the level of the periodic neighbor at the <code>ith</code> face of the current cell. If there is no periodic neighbor at the given face, the returned value is -1. </p>

</div>
</div>
<a id="af92a480d8d1b269b21d95c7cc3c0a033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92a480d8d1b269b21d95c7cc3c0a033">&#9670;&nbsp;</a></span>periodic_neighbor_of_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_of_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a cell with a periodic neighbor at its <code>ith</code> face, this function returns the face number of that periodic neighbor such that the current cell is the periodic neighbor of that neighbor. In other words the following assertion holds for those cells which have a periodic neighbor with the same or a higher level of refinement as the current cell: <code>{cell-&gt;periodic_neighbor(i)-&gt;</code> periodic_neighbor(cell-&gt;periodic_neighbor_of_periodic_neighbor(i))==cell} For the cells with a coarser periodic neighbor, one should use <a class="el" href="classCellAccessor.html#ae61a7da21d9fcd55206cd7042b34c5fb">periodic_neighbor_of_coarser_periodic_neighbor()</a> and <a class="el" href="classCellAccessor.html#a752021a2f53bfa00dfe547adc662ffd6">periodic_neighbor_child_on_subface()</a> to get back to the current cell. </p>

</div>
</div>
<a id="afbdf47567f70bac8826dcd7e5782f968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbdf47567f70bac8826dcd7e5782f968">&#9670;&nbsp;</a></span>periodic_neighbor_face_no()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_face_no </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a cell has a periodic neighbor at its <code>ith</code> face, this function returns the face number of the periodic neighbor, which is connected to the <code>ith</code> face of this cell. </p>

</div>
</div>
<a id="ab737948031be71ea02495126a177ed8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab737948031be71ea02495126a177ed8a">&#9670;&nbsp;</a></span>periodic_neighbor_is_coarser()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::periodic_neighbor_is_coarser </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function returns true if the element on the other side of the periodic boundary is coarser and returns false otherwise. The implementation allows this function to work in the case of anisotropic refinement. </p>

</div>
</div>
<a id="a4b683043741a1167de1ab9dbda0e54f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b683043741a1167de1ab9dbda0e54f7">&#9670;&nbsp;</a></span>at_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the <code>ith</code> vertex or face (depending on the dimension) is part of the boundary. This is true, if the <code>ith</code> neighbor does not exist. </p>

</div>
</div>
<a id="ace4c08cb6a4ced3f610d9789d02ad202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace4c08cb6a4ced3f610d9789d02ad202">&#9670;&nbsp;</a></span>at_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::at_boundary </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the cell is at the boundary. Being at the boundary is defined by one face being on the boundary. Note that this does not catch cases where only one vertex of a quad or of a hex is at the boundary, or where only one line of a hex is at the boundary while the interiors of all faces are in the interior of the domain. For the latter case, the <code>has_boundary_lines</code> function is the right one to ask. </p>

</div>
</div>
<a id="a9fee6d28c03cd3ba90263ecb0e268b3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fee6d28c03cd3ba90263ecb0e268b3a">&#9670;&nbsp;</a></span>has_boundary_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::has_boundary_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a slight variation to the <code>at_boundary</code> function: for 1 and 2 dimensions, it is equivalent, for three dimensions it returns whether at least one of the 12 lines of the hexahedron is at a boundary. This, of course, includes the case where a whole face is at the boundary, but also some other cases. </p>

</div>
</div>
<a id="a902048fc67583f356fd3278a7d2aa8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902048fc67583f356fd3278a7d2aa8de">&#9670;&nbsp;</a></span>refine_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::refine_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>RefinementCase&lt;dim&gt;</code> this cell was flagged to be refined with. The return value of this function can be compared to a bool to check if this cell is flagged for any kind of refinement. For example, if you have previously called cell-&gt;<a class="el" href="classCellAccessor.html#a8c8359d5342b4ae7ae8b74fc3f4a1558">set_refine_flag()</a> for a cell, then you will enter the 'if' block in the following snippet:</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (cell-&gt;refine_flag_set())</div><div class="line">{</div><div class="line">  <span class="comment">// yes, this cell is marked for refinement.</span></div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="a8c8359d5342b4ae7ae8b74fc3f4a1558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c8359d5342b4ae7ae8b74fc3f4a1558">&#9670;&nbsp;</a></span>set_refine_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_refine_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim &gt;&#160;</td>
          <td class="paramname"><em>ref_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;&gt;::isotropic_refinement</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag the cell pointed to for refinement. This function is only allowed for active cells. Keeping the default value for <code>ref_case</code> will mark this cell for isotropic refinement.</p>
<p>If you choose anisotropic refinement, for example by passing as argument one of the flags RefinementCase::cut_x, RefinementCase::cut_y, RefinementCase::cut_z, or a combination of these, then keep in mind that refining in x-, y-, or z-direction happens with regard to the <em>local</em> coordinate system of the cell. In other words, these flags determine which edges and faces of the cell will be cut into new edges and faces. On the other hand, this process is independent of how the cell is oriented within the <em>global</em> coordinate system, and you should not assume any particular orientation of the cell's local coordinate system within the global coordinate system of the space it lives in. </p>

</div>
</div>
<a id="ad5ccb325d746a81fa4a8542d698b89c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ccb325d746a81fa4a8542d698b89c7">&#9670;&nbsp;</a></span>clear_refine_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_refine_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the refinement flag. </p>

</div>
</div>
<a id="a375a3010dcf7bd365a6d43429d64dcc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375a3010dcf7bd365a6d43429d64dcc1">&#9670;&nbsp;</a></span>flag_for_face_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_face_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>face_refinement_case</em> = <code><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;::isotropic_refinement</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the refinement flag of the cell to ensure (at least) the given refinement case <code>face_refinement_case</code> at face <code>face_no</code>, taking into account orientation, flip and rotation of the face. Return, whether the refinement flag had to be modified. This function is only allowed for active cells. </p>

</div>
</div>
<a id="aeb3fa84168f193c7877ff90b70bcee83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb3fa84168f193c7877ff90b70bcee83">&#9670;&nbsp;</a></span>flag_for_line_refinement()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::flag_for_line_refinement </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Modify the refinement flag of the cell to ensure that line <code>face_no</code> will be refined. Return, whether the refinement flag had to be modified. This function is only allowed for active cells. </p>

</div>
</div>
<a id="a448d8dc9bdecab5a250ed5ecb899ded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448d8dc9bdecab5a250ed5ecb899ded9">&#9670;&nbsp;</a></span>subface_case()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1SubfaceCase.html">internal::SubfaceCase</a>&lt;dim&gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subface_case </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the SubfaceCase of face <code>face_no</code>. Note that this is not identical to asking <code>cell-&gt;face(face_no)-&gt;<a class="el" href="classTriaAccessor.html#ae6a4a753f2ef5b2615a7e2fec21e0dec">refinement_case()</a></code> since the latter returns a <a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;dim-1&gt; and thus only considers one (anisotropic) refinement, whereas this function considers the complete refinement situation including possible refinement of the face's children. This function may only be called for active cells in 2d and 3d. </p>

</div>
</div>
<a id="ae4910a26c4458ce0dd444e6b7bec2564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4910a26c4458ce0dd444e6b7bec2564">&#9670;&nbsp;</a></span>coarsen_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::coarsen_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the coarsen flag is set or not. </p>

</div>
</div>
<a id="a6de037c4860dcaceb4f9429b981b715e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6de037c4860dcaceb4f9429b981b715e">&#9670;&nbsp;</a></span>set_coarsen_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag the cell pointed to for coarsening. This function is only allowed for active cells. </p>

</div>
</div>
<a id="ab9fd137b13ff401f168ea0433cb18e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9fd137b13ff401f168ea0433cb18e49">&#9670;&nbsp;</a></span>clear_coarsen_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::clear_coarsen_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear the coarsen flag. </p>

</div>
</div>
<a id="ae4769702cd7ab67a61b25778ea3021b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4769702cd7ab67a61b25778ea3021b2">&#9670;&nbsp;</a></span>material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::material_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the material id of this cell.</p>
<p>For a typical use of this function, see the step-28 tutorial program.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

</div>
</div>
<a id="a861d3679d23d3f4365f724c9cfe5fd77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861d3679d23d3f4365f724c9cfe5fd77">&#9670;&nbsp;</a></span>set_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the material id of this cell.</p>
<p>For a typical use of this function, see the step-28 tutorial program.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

</div>
</div>
<a id="a2b49d85f8793f5a95d6c50797c07be2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b49d85f8793f5a95d6c50797c07be2b">&#9670;&nbsp;</a></span>recursively_set_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>new_material_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the material id of this cell and all its children (and grand- children, and so on) to the given value.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossMaterialId">glossary</a> for more information. </p>

</div>
</div>
<a id="ae06835414c3c3f3359974f2c75a88033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06835414c3c3f3359974f2c75a88033">&#9670;&nbsp;</a></span>subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the subdomain id of this cell.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information.</p>
<dl class="section note"><dt>Note</dt><dd>The subdomain of a cell is a property only defined for active cells, i.e., cells that are not further refined. Consequently, you can only call this function if the cell it refers to has no children. For multigrid methods in parallel, it is also important to know which processor owns non-active cells, and for this you can call <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a>. </dd></dl>

</div>
</div>
<a id="a56098dab68574f96b42779d68c54269d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56098dab68574f96b42779d68c54269d">&#9670;&nbsp;</a></span>set_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the subdomain id of this cell.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information. This function should not be called if you use a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>The subdomain of a cell is a property only defined for active cells, i.e., cells that are not further refined. Consequently, you can only call this function if the cell it refers to has no children. For multigrid methods in parallel, it is also important to know which processor owns non-active cells, and for this you can call <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a>. </dd></dl>

</div>
</div>
<a id="a2c84842b2847744da6e48fbcabf777ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c84842b2847744da6e48fbcabf777ad">&#9670;&nbsp;</a></span>level_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::level_subdomain_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the level subdomain id of this cell. This is used for parallel multigrid where not only the global mesh (consisting of the active cells) is partitioned among processors, but also the individual levels of the hierarchy of recursively refined cells that make up the mesh. In other words, the level subdomain id is a property that is also defined for non-active cells if a multigrid hierarchy is used. </p>

</div>
</div>
<a id="a2bfad9f24d9ddbc86883614639d4886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bfad9f24d9ddbc86883614639d4886d">&#9670;&nbsp;</a></span>set_level_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_level_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_level_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the level subdomain id of this cell. This is used for parallel multigrid. </p>

</div>
</div>
<a id="a0108d0f1a0710c1e6d9b98f7cb2768fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0108d0f1a0710c1e6d9b98f7cb2768fa">&#9670;&nbsp;</a></span>recursively_set_subdomain_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::recursively_set_subdomain_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>new_subdomain_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the subdomain id of this cell (if it is active) or all its terminal children (and grand-children, and so on, as long as they have no children of their own) to the given value. Since the subdomain id is a concept that is only defined for cells that are active (i.e., have no children of their own), this function only sets the subdomain ids for all children and grand children of this cell that are actually active, skipping intermediate child cells.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossSubdomainId">glossary</a> for more information. This function should not be called if you use a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object since there the subdomain id is implicitly defined by which processor you're on. </p>

</div>
</div>
<a id="a13e7c4a89332133d5ce71a1a5aa8f64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13e7c4a89332133d5ce71a1a5aa8f64f">&#9670;&nbsp;</a></span>global_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::global_active_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a globally unique cell index for the current cell, assuming it is not artificial. The value is identical to <a class="el" href="classCellAccessor.html#ad4b8ec35236bea8ee91a72bbd19762fe">active_cell_index()</a> if the cell is part of a serial triangulation.</p>
<p>In the context of parallel triangulations, locally-owned cells are enumerated contiguously within each subdomain of the mesh. This ensures that the index returned by this function can be used as the index into vectors with a total of Triangulation::n_globally_active_cells() entries, and for which every process stores a contiguous part. If such a cell-data vector has been set up with <a class="el" href="classparallel_1_1TriangulationBase.html#a640568c9b7f4b50cf45b5c52a8420b05">parallel::TriangulationBase::global_active_cell_index_partitioner()</a>, the index returned by this function can then be used to access the correct vector entry. </p>

</div>
</div>
<a id="ae8e84609c2c6afbeefdaa9096ff50dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e84609c2c6afbeefdaa9096ff50dae">&#9670;&nbsp;</a></span>global_level_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::global_level_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a globally unique index for a non-artificial level cell.</p>
<dl class="section note"><dt>Note</dt><dd>Similar to <a class="el" href="classCellAccessor.html#a13e7c4a89332133d5ce71a1a5aa8f64f">global_active_cell_index()</a>. </dd></dl>

</div>
</div>
<a id="ae146ea059e9c27cb3e040b92d5c4e152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae146ea059e9c27cb3e040b92d5c4e152">&#9670;&nbsp;</a></span>direction_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::direction_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the orientation of this cell.</p>
<p>For the meaning of this flag, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>. </p>

</div>
</div>
<a id="ad4b8ec35236bea8ee91a72bbd19762fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b8ec35236bea8ee91a72bbd19762fe">&#9670;&nbsp;</a></span>active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::active_cell_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the how many-th active cell the current cell is (assuming the current cell is indeed active). This is useful, for example, if you are accessing the elements of a vector with as many entries as there are active cells. Such vectors are used for estimating the error on each cell of a triangulation, for specifying refinement criteria passed to the functions in <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>, and for generating cell-wise output.</p>
<p>The function throws an exception if the current cell is not active.</p>
<dl class="section note"><dt>Note</dt><dd>If the triangulation this function is called on is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, then active cells may be locally owned, ghost cells, or artificial (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">GlossLocallyOwnedCell</a>, <a class="el" href="DEALGlossary.html#GlossGhostCell">GlossGhostCell</a>, and <a class="el" href="DEALGlossary.html#GlossArtificialCell">GlossArtificialCell</a>). This function counts over all of them, including ghost and artificial active cells. This implies that the index returned by this function uniquely identifies a cell within the triangulation on a single processor, but does not uniquely identify the cell among the (parts of the) triangulation that is shared among processors. If you would like to identify active cells across processors, you need to consider the <a class="el" href="classCellId.html">CellId</a> of a cell returned by <a class="el" href="classCellAccessor.html#aee7d5ec9cac8af95a136554501ea4f0a">CellAccessor::id()</a>. </dd></dl>

</div>
</div>
<a id="af7a594e870d1b725fed0c5231596709b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a594e870d1b725fed0c5231596709b">&#9670;&nbsp;</a></span>parent_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index of the parent of this cell within the level of the triangulation to which the parent cell belongs. The level of the parent is of course one lower than that of the present cell. If the parent does not exist (i.e., if the object is at the coarsest level of the mesh hierarchy), an exception is generated. </p>

</div>
</div>
<a id="a174554a23387673fd516cc4efb1b739b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a174554a23387673fd516cc4efb1b739b">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classCellAccessor.html">CellAccessor</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the parent. If the parent does not exist (i.e., if the object is at the coarsest level of the mesh hierarchy), an exception is generated. </p>

</div>
</div>
<a id="a5096c47dd02a264799a1b7b18fd45b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5096c47dd02a264799a1b7b18fd45b3c">&#9670;&nbsp;</a></span>is_active()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_active </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test that the cell has no children (this is the criterion for whether a cell is called "active").</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossActive">glossary</a> for more information. </p>

</div>
</div>
<a id="a87a3ff6217f3b5b4537f6a101560f493"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87a3ff6217f3b5b4537f6a101560f493">&#9670;&nbsp;</a></span>is_locally_owned()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this cell is owned by the current processor or is owned by another processor. The function always returns true if applied to an object of type <a class="el" href="classTriangulation.html">Triangulation</a>, but may yield false if the triangulation is of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGhostCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_ghost() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned or is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

</div>
</div>
<a id="a9e6b3c485d88ed58114d1b470bb3693f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e6b3c485d88ed58114d1b470bb3693f">&#9670;&nbsp;</a></span>is_locally_owned_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_locally_owned_on_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if either the <a class="el" href="classTriangulation.html">Triangulation</a> is not distributed or if <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a> is equal to the id of the current processor. </p>

</div>
</div>
<a id="a54375bf8f17e51501a4da7a2fac852ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54375bf8f17e51501a4da7a2fac852ae">&#9670;&nbsp;</a></span>is_ghost()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_ghost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if: </p><ol>
<li>
This cell exists in the global mesh (i.e., it is not artificial), and </li>
<li>
This cell is owned by another processor (i.e., has a subdomain_id different from <a class="el" href="classTriangulation.html#a5827cdfafd5fef99803cde97b70e86bc">Triangulation::locally_owned_subdomain()</a>) </li>
</ol>
<p>In all other cases the returned value is false. In particular, only parallel Triangulations (i.e., Triangulations inheriting from <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>) can have ghost cells, so for a serial <a class="el" href="classTriangulation.html">Triangulation</a> the returned value is false.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossGhostCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_locally_owned() &amp;&amp; !is_artificial()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>For <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> and <a class="el" href="classparallel_1_1fullydistributed_1_1Triangulation.html">parallel::fullydistributed::Triangulation</a>, ghost cells are always adjacent to locally owned cells. For <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> they may not be, dependent on whether or not the triangulation uses artificial cells - see <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#ac7c582c85117ee2889c28267764244cb">parallel::shared::Triangulation::Triangulation()</a> for more information.</dd>
<dd>
Whether a cell is a ghost cell, artificial, or is locally owned is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

</div>
</div>
<a id="af0e47e37784c9f513cdef3c09a53439a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e47e37784c9f513cdef3c09a53439a">&#9670;&nbsp;</a></span>is_ghost_on_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_ghost_on_level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if either the <a class="el" href="classTriangulation.html">Triangulation</a> is not distributed or if the cell is not artificial and the <a class="el" href="classCellAccessor.html#a2c84842b2847744da6e48fbcabf777ad">level_subdomain_id()</a> is not equal to the id of the current processor. </p>

</div>
</div>
<a id="aef398493764dee787a796b436826847b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef398493764dee787a796b436826847b">&#9670;&nbsp;</a></span>is_artificial()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::is_artificial </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether this cell is artificial, i.e. it isn't one of the cells owned by the current processor, and it also doesn't border on one. As a consequence, it exists in the mesh to ensure that each processor has all coarse mesh cells and that the 2:1 ratio of neighboring cells is maintained, but it is not one of the cells we should work on on the current processor. In particular, there is no guarantee that this cell isn't, in fact, further refined on one of the other processors.</p>
<p>This function only makes sense if the triangulation used is of kind <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. In all other cases, the returned value is always false.</p>
<p>See the <a class="el" href="DEALGlossary.html#GlossArtificialCell">glossary</a> and the <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a> module for more information.</p>
<dl class="section post"><dt>Postcondition</dt><dd>The returned value is equal to <code>!is_ghost() &amp;&amp; !is_locally_owned()</code>.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>Whether a cell is a ghost cell, artificial, or is locally owned is a property that only pertains to cells that are active. Consequently, you can only call this function if the cell it refers to has no children. </dd></dl>

</div>
</div>
<a id="adb8a0465d3d7145513463b6a4a215fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8a0465d3d7145513463b6a4a215fbc">&#9670;&nbsp;</a></span>point_inside()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test whether the point <code>p</code> is inside this cell. Points on the boundary are counted as being inside the cell.</p>
<p>Note that this function assumes that the mapping between unit cell and real cell is (bi-, tri-)linear, i.e. that faces in 2d and edges in 3d are straight lines. If you have higher order transformations, results may be different as to whether a point is in- or outside the cell in real space.</p>
<p>In case of codim&gt;0, the point is first projected to the manifold where the cell is embedded and then check if this projection is inside the cell. </p>

</div>
</div>
<a id="abd998ef06bbaa081316d1f41ed5d6f49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd998ef06bbaa081316d1f41ed5d6f49">&#9670;&nbsp;</a></span>set_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>pointer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the neighbor <code>i</code> of this cell to the cell pointed to by <code>pointer</code>.</p>
<p>This function shouldn't really be public (but needs to for various reasons in order not to make a long list of functions friends): it modifies internal data structures and may leave things. Do not use it from application codes. </p>

</div>
</div>
<a id="aee7d5ec9cac8af95a136554501ea4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7d5ec9cac8af95a136554501ea4f0a">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classCellId.html">CellId</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a unique ID for the current cell. This ID is constructed from the path in the hierarchy from the coarse father cell and works correctly in parallel computations using objects of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>. This function is therefore useful in providing a unique identifier for cells (active or not) that also works for parallel triangulations. See the documentation of the <a class="el" href="classCellId.html">CellId</a> class for more information.</p>
<dl class="section note"><dt>Note</dt><dd>This operation takes O(level) time to compute. In most practical cases, the number of levels of a triangulation will depend logarithmically on the number of cells in the triangulation. </dd></dl>

</div>
</div>
<a id="a3cb9bed9b28bc791489cea0c867c476d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cb9bed9b28bc791489cea0c867c476d">&#9670;&nbsp;</a></span>diameter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as <a class="el" href="classTriaAccessor.html#af0e85725edb5d2bb43da61796f2fbbb9">TriaAccessor::diameter()</a> but also taking a <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class. </p>

</div>
</div>
<a id="a0dd9ea78cda7d19b9997bae1bf1d5fe0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd9ea78cda7d19b9997bae1bf1d5fe0">&#9670;&nbsp;</a></span>neighbor_of_neighbor_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::neighbor_of_neighbor_internal </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>neighbor</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function assumes that the neighbor is not coarser than the current cell. In this case it returns the <a class="el" href="classCellAccessor.html#a81e5dc97427e571da846e1fb0545aeb9">neighbor_of_neighbor()</a> value. If, however, the neighbor is coarser this function returns an <code>invalid_unsigned_int</code>.</p>
<p>This function is not for public use. Use the function <a class="el" href="classCellAccessor.html#a81e5dc97427e571da846e1fb0545aeb9">neighbor_of_neighbor()</a> instead which throws an exception if called for a coarser neighbor. If neighbor is indeed coarser (you get to know this by e.g. the <a class="el" href="classCellAccessor.html#a570b9c4837247169156ae7c9d59ade33">neighbor_is_coarser()</a> function) then the <a class="el" href="classCellAccessor.html#a9f9afc8fed399db26e15357cd8acfd3e">neighbor_of_coarser_neighbor()</a> function should be call. If you'd like to know only the <code>face_no</code> which is required to get back from the neighbor to the present cell then simply use the <a class="el" href="classCellAccessor.html#a036e8dae65320c8d718b6fc88394293d">neighbor_face_no()</a> function which can be used for coarser as well as non-coarser neighbors. </p>

</div>
</div>
<a id="a96c380d489670714b30a3812801a1a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c380d489670714b30a3812801a1a53">&#9670;&nbsp;</a></span>point_inside_codim()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int dim_, int spacedim_&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::point_inside_codim </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>As for any codim&gt;0 we can use a similar code and c++ does not allow partial templates. we use this auxiliary function that is then called from point_inside. </p>

</div>
</div>
<a id="a0d7efb46efc1d5dfe714e3d0689c1700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7efb46efc1d5dfe714e3d0689c1700">&#9670;&nbsp;</a></span>set_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_active_cell_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>active_cell_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the active cell index of a cell. This is done at the end of refinement. </p>

</div>
</div>
<a id="ab8122005ec0257e87cc6475a841790c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8122005ec0257e87cc6475a841790c3">&#9670;&nbsp;</a></span>set_global_active_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_global_active_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set global active cell index for a cell. </p>

</div>
</div>
<a id="a5a11e0fd6f847735bfbbf9543511bc5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a11e0fd6f847735bfbbf9543511bc5b">&#9670;&nbsp;</a></span>set_global_level_cell_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_global_level_cell_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a88f8129eb3e40ecc8022e92a1e15d70e">types::global_cell_index</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set global level cell index for a level cell. </p>

</div>
</div>
<a id="ac7f559666292ef3769b136e0a1516dfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f559666292ef3769b136e0a1516dfd">&#9670;&nbsp;</a></span>set_parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_parent </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>parent_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the parent of a cell. </p>

</div>
</div>
<a id="a2ab75196e96aafda94a0a96d833fdc84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ab75196e96aafda94a0a96d833fdc84">&#9670;&nbsp;</a></span>set_direction_flag()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classCellAccessor.html">CellAccessor</a>&lt; dim, spacedim &gt;::set_direction_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>new_direction_flag</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the orientation of this cell.</p>
<p>For the meaning of this flag, see <a class="el" href="DEALGlossary.html#GlossDirectionFlag">GlossDirectionFlag</a>. </p>

</div>
</div>
<a id="aeb0b77c3f3c1de1f604d456d0718efc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0b77c3f3c1de1f604d456d0718efc0">&#9670;&nbsp;</a></span>used()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::used </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test for the element being used or not. The return value is <code>true</code> for all iterators that are either normal iterators or active iterators, only raw iterators can return <code>false</code>. Since raw iterators are only used in the interiors of the library, you will not usually need this function. </p>

</div>
</div>
<a id="a76b3fb7b9d5de13f797e3c04d4dd03a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b3fb7b9d5de13f797e3c04d4dd03a5">&#9670;&nbsp;</a></span>vertex_iterator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;0, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_iterator </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> vertex bounding this object. Throw an exception if <code>dim=1</code>. </p>

</div>
</div>
<a id="a81afd26d765a4cec094b25767b8dd42a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81afd26d765a4cec094b25767b8dd42a">&#9670;&nbsp;</a></span>vertex_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global index of i-th vertex of the current object. The convention regarding the numbering of vertices is laid down in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>Note that the returned value is only the index of the geometrical vertex. It has nothing to do with possible degrees of freedom associated with it. For this, see the <code><a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">DoFAccessor::vertex_dof_index</a></code> functions.</p>
<dl class="section note"><dt>Note</dt><dd>Despite the name, the index returned here is only global in the sense that it is specific to a particular <a class="el" href="classTriangulation.html">Triangulation</a> object or, in the case the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, specific to that part of the distributed triangulation stored on the current processor. </dd></dl>

</div>
</div>
<a id="a3dd6518eb0cf5fccc5926470128415d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd6518eb0cf5fccc5926470128415d9">&#9670;&nbsp;</a></span>vertex()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the <code>ith</code> vertex. The reference is not const, i.e., it is possible to call this function on the left hand side of an assignment, thereby moving the vertex of a cell within the triangulation. Of course, doing so requires that you ensure that the new location of the vertex remains useful &ndash; for example, avoiding inverted or otherwise distorted (see also <a class="el" href="DEALGlossary.html#GlossDistorted">this glossary entry</a>).</p>
<dl class="section note"><dt>Note</dt><dd>When a cell is refined, its children inherit the position of the vertex positions of those vertices they share with the mother cell (plus the locations of the new vertices on edges, faces, and cell interiors that are created for the new child cells). If the vertex of a cell is moved, this implies that its children will also use these new locations. On the other hand, imagine a 2d situation where you have one cell that is refined (with four children) and then you move the central vertex connecting all four children. If you coarsen these four children again to the mother cell, then the location of the moved vertex is lost and if, in a later step, you refine the mother cell again, the then again new vertex will be placed again at the same position as the first time around &ndash; i.e., not at the location you had previously moved it to.</dd>
<dd>
The behavior described above is relevant if you have a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> object. There, refining a mesh always involves a re-partitioning. In other words, vertices of locally owned cells (see <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">this glossary entry</a>) that you may have moved to a different location on one processor may be moved to a different processor upon mesh refinement (even if these particular cells were not refined) which will re-create their position based on the position of the coarse cells they previously had, not based on the position these vertices had on the processor that previously owned them. In other words, in parallel computations, you will probably have to move nodes explicitly after every mesh refinement because vertex positions may or may not be preserved across the re-partitioning that accompanies mesh refinement. </dd></dl>

</div>
</div>
<a id="a54c8283c86c84e29f718cbfe4118b3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c8283c86c84e29f718cbfe4118b3b2">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::line_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> line bounding this object. </p>

</div>
</div>
<a id="a450f0e6e00b9711650f59143e2085d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a450f0e6e00b9711650f59143e2085d95">&#9670;&nbsp;</a></span>line_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Line index of the <code>ith</code> line bounding this object.</p>
<p>Implemented only for <code>structdim&gt;1</code>, otherwise an exception generated. </p>

</div>
</div>
<a id="a04dc361f8b3fb30c60a9e248c2108979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04dc361f8b3fb30c60a9e248c2108979">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriangulationImplementation:: Iterators&lt;dim, spacedim&gt;::quad_iterator <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> quad bounding this object. </p>

</div>
</div>
<a id="ab3f77d56ddde728b892e3c736a28cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f77d56ddde728b892e3c736a28cd0c">&#9670;&nbsp;</a></span>quad_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::quad_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Quad index of the <code>ith</code> quad bounding this object.</p>
<p>Implemented only for <code>structdim&gt;2</code>, otherwise an exception generated. </p>

</div>
</div>
<a id="a452389bb368ba37c9c5542ef956526ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452389bb368ba37c9c5542ef956526ee">&#9670;&nbsp;</a></span>face_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> has its normal pointing in the standard direction (<code>true</code>) or whether it is the opposite (<code>false</code>). Which is the standard direction is documented with the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class. In 1d and 2d, this is always <code>true</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="ad90f5ff1a44cb8a6e08196dac6cdb22e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90f5ff1a44cb8a6e08196dac6cdb22e">&#9670;&nbsp;</a></span>face_flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_flip </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> is rotated by 180 degrees (<code>true</code>) or not (<code>false</code>). In 1d and 2d, this is always <code>false</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a2f831f5ca8626677089f94af9be43a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f831f5ca8626677089f94af9be43a5b">&#9670;&nbsp;</a></span>face_rotation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_rotation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the face with index <code>face</code> is rotated by 90 degrees (<code>true</code>) or not (<code>false</code>). In 1d and 2d, this is always <code>false</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about. </p>

</div>
</div>
<a id="a08aaa41d4d6e0942d888efc21ca5d6c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08aaa41d4d6e0942d888efc21ca5d6c7">&#9670;&nbsp;</a></span>line_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_orientation </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the line with index <code>line</code> is oriented in standard direction. <code>true</code> indicates, that the line is oriented from vertex 0 to vertex 1, whereas it is the other way around otherwise. In 1d and 2d, this is always <code>true</code>, but in 3d it may be different, see the respective discussion in the documentation of the <a class="el" href="structGeometryInfo.html">GeometryInfo</a> class.</p>
<p>This function is really only for internal use in the library unless you absolutely know what this is all about.</p>
<p>This function queries <a class="el" href="classReferenceCell.html#a24db72fed8c0bf34ab1a1751ad2b1f38">ReferenceCell::standard_vs_true_line_orientation()</a>. </p>

</div>
</div>
<a id="a4ce77fc45536beea670a0b5c1d91539c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce77fc45536beea670a0b5c1d91539c">&#9670;&nbsp;</a></span>has_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::has_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Test whether the object has children. </p>

</div>
</div>
<a id="a634bf3e1c46e9ba87dfafa8c869e8972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a634bf3e1c46e9ba87dfafa8c869e8972">&#9670;&nbsp;</a></span>n_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of immediate children of this object. The number of children of an unrefined cell is zero. </p>

</div>
</div>
<a id="aa0c1e25935669a4b310671a26e9dcbd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0c1e25935669a4b310671a26e9dcbd2">&#9670;&nbsp;</a></span>number_of_children()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::number_of_children </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000037">Deprecated:</a></b></dt><dd>Use <a class="el" href="classTriaAccessor.html#a24fb24948b4e177f8e4eb737ec057397">n_active_descendants()</a> instead. </dd></dl>

</div>
</div>
<a id="a24fb24948b4e177f8e4eb737ec057397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fb24948b4e177f8e4eb737ec057397">&#9670;&nbsp;</a></span>n_active_descendants()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_active_descendants </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the number of active descendants of this objects. For example, if all of the eight children of a hex are further refined isotropically exactly once, the returned number will be 64, not 80.</p>
<p>If the present cell is not refined, one is returned.</p>
<p>If one considers a triangulation as a forest where the root of each tree are the coarse mesh cells and nodes have descendants (the children of a cell), then this function returns the number of terminal nodes in the sub-tree originating from the current object; consequently, if the current object is not further refined, the answer is one. </p>

</div>
</div>
<a id="aa39e613fd2e2c22bdc8ba340068e5713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa39e613fd2e2c22bdc8ba340068e5713">&#9670;&nbsp;</a></span>max_refinement_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::max_refinement_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of times that this object is refined. Note that not all its children are refined that often (which is why we prepend <code>max_</code>), the returned number is rather the maximum number of refinement in any branch of children of this object.</p>
<p>For example, if this object is refined, and one of its children is refined exactly one more time, then <code>max_refinement_depth</code> should return 2.</p>
<p>If this object is not refined (i.e. it is active), then the return value is zero. </p>

</div>
</div>
<a id="a237132d2e5161b34a05291e10f3d6feb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a237132d2e5161b34a05291e10f3d6feb">&#9670;&nbsp;</a></span>child_iterator_to_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_iterator_to_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the child number of <code>child</code> on the current cell. This is the inverse function of <a class="el" href="classTriaAccessor.html#ad791ab6cd4f749e0c9f601a2bc442bd9">TriaAccessor::child()</a>. </p>

</div>
</div>
<a id="aa035549b0c8b7eb7fcd33654bc73da29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa035549b0c8b7eb7fcd33654bc73da29">&#9670;&nbsp;</a></span>isotropic_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt;structdim, dim, spacedim&gt; &gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator to that object that is identical to the ith child for isotropic refinement. If the current object is refined isotropically, then the returned object is the ith child. If the current object is refined anisotropically, the returned child may in fact be a grandchild of the object, or may not exist at all (in which case an exception is generated). </p>

</div>
</div>
<a id="ae6a4a753f2ef5b2615a7e2fec21e0dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a4a753f2ef5b2615a7e2fec21e0dec">&#9670;&nbsp;</a></span>refinement_case()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classRefinementCase.html">RefinementCase</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::refinement_case </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classRefinementCase.html">RefinementCase</a> of this cell. </p>

</div>
</div>
<a id="acd7551fc85831a3fd4d5cd339b81d8c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7551fc85831a3fd4d5cd339b81d8c6">&#9670;&nbsp;</a></span>child_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index of the <code>ith</code> child. The level of the child is one higher than that of the present cell, if the children of a cell are accessed. The children of faces have no level. If the child does not exist, -1 is returned. </p>

</div>
</div>
<a id="a8adec5f5b7786cf43e6011d03cc7903a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8adec5f5b7786cf43e6011d03cc7903a">&#9670;&nbsp;</a></span>isotropic_child_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::isotropic_child_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index of the <code>ith</code> isotropic child. See the <a class="el" href="classTriaAccessor.html#aa035549b0c8b7eb7fcd33654bc73da29">isotropic_child()</a> function for a definition of this concept. If the child does not exist, -1 is returned. </p>

</div>
</div>
<a id="af2b4887416074f2ecdcd06512e864e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2b4887416074f2ecdcd06512e864e48">&#9670;&nbsp;</a></span>boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::boundary_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the boundary indicator of this object.</p>
<p>If the return value is the special value <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>, then this object is in the interior of the domain.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a654de9ccd776b524a27cd64bded48e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654de9ccd776b524a27cd64bded48e14">&#9670;&nbsp;</a></span>set_boundary_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_boundary_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the boundary indicator of the current object. The same applies as for the <a class="el" href="classTriaAccessor.html#af2b4887416074f2ecdcd06512e864e48">boundary_id()</a> function.</p>
<p>This function only sets the boundary object of the current object itself, not the indicators of the ones that bound it. For example, in 3d, if this function is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. If you want to set the boundary indicators of face and edges at the same time, use the <a class="el" href="classTriaAccessor.html#aa0304fb253839c45e64b60460ab040ae">set_all_boundary_ids()</a> function. You can see the result of not using the correct function in the results section of step-49.</p>
<dl class="section warning"><dt>Warning</dt><dd>You should never set the boundary indicator of an interior face (a face not at the boundary of the domain), or set the boundary indicator of an exterior face to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> (this value is reserved for another purpose). <a class="el" href="namespaceAlgorithms.html">Algorithms</a> may not work or produce very confusing results if boundary cells have a boundary indicator of <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> or if interior cells have boundary indicators other than <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>. Unfortunately, the current object has no means of finding out whether it really is at the boundary of the domain and so cannot determine whether the value you are trying to set makes sense under the current circumstances.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="aa0304fb253839c45e64b60460ab040ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0304fb253839c45e64b60460ab040ae">&#9670;&nbsp;</a></span>set_all_boundary_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_boundary_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do as <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a> but also set the boundary indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a> is called on a face, then the boundary indicator of the 4 edges that bound the face remain unchanged. In contrast, if you call the current function, the boundary indicators of face and edges are all set to the given value.</p>
<p>This function is useful if you set boundary indicators of faces in 3d (in 2d, the function does the same as <a class="el" href="classTriaAccessor.html#a654de9ccd776b524a27cd64bded48e14">set_boundary_id()</a>) and you do so because you want a curved boundary object to represent the part of the boundary that corresponds to the current face. In that case, the <a class="el" href="classTriangulation.html">Triangulation</a> class needs to figure out where to put new vertices upon mesh refinement, and higher order <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> objects also need to figure out where new interpolation points for a curved boundary approximation should be. In either case, the two classes first determine where interpolation points on the edges of a boundary face should be, asking the boundary object, before asking the boundary object for the interpolation points corresponding to the interior of the boundary face. For this to work properly, it is not sufficient to have set the boundary indicator for the face alone, but you also need to set the boundary indicators of the edges that bound the face. This function does all of this at once. You can see the result of not using the correct function in the results section of step-49.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ae4d63b9ebf9b5c31aa702e49c664e59d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d63b9ebf9b5c31aa702e49c664e59d">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a constant reference to the manifold object used for this object.</p>
<p>As explained in the <a class="el" href="group__manifold.html">Manifold description for triangulations</a> module, the process involved in finding the appropriate manifold description involves querying both the manifold or boundary indicators. See there for more information. </p>

</div>
</div>
<a id="a6c28dbcfefe0ffe1e51fe315c3565f94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c28dbcfefe0ffe1e51fe315c3565f94">&#9670;&nbsp;</a></span>manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::manifold_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the manifold indicator of this object.</p>
<p>If the return value is the special value <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>, then this object is associated with a standard Cartesian <a class="el" href="classManifold.html">Manifold</a> Description.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gafbeb21da36433dc2ec117b9694ca2557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb21da36433dc2ec117b9694ca2557">&#9670;&nbsp;</a></span>set_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_manifold_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the manifold indicator. The same applies as for the <code><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id()</a></code> function.</p>
<p>Note that it only sets the manifold object of the current object itself, not the indicators of the ones that bound it, nor of its children. For example, in 3d, if this function is called on a face, then the manifold indicator of the 4 edges that bound the face remain unchanged. If you want to set the manifold indicators of face, edges and all children at the same time, use the <a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids()</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga160a26ce22b36607556bcdcc20bc6d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160a26ce22b36607556bcdcc20bc6d61">&#9670;&nbsp;</a></span>set_all_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do as <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id()</a> but also set the manifold indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id()</a> is called on a face, then the manifold indicator of the 4 edges that bound the face remain unchanged. On the other hand, the manifold indicators of face and edges are all set at the same time using the current function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="a6aa91f3e086777b02a2f6eef7ac19ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa91f3e086777b02a2f6eef7ac19ebb">&#9670;&nbsp;</a></span>user_flag_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_flag_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a6dda85b6637fefd5db3d37ad7729fcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dda85b6637fefd5db3d37ad7729fcb1">&#9670;&nbsp;</a></span>set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a59ff7c1bc2b4fc8abcd9b3ef44b5f485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59ff7c1bc2b4fc8abcd9b3ef44b5f485">&#9670;&nbsp;</a></span>clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the user flag. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a63d791b3769c77bcfd1c56748a6c56fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d791b3769c77bcfd1c56748a6c56fa">&#9670;&nbsp;</a></span>recursively_set_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the user flag for this and all descendants. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a50b22f28a2baf2dd90b5309c3f0136af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b22f28a2baf2dd90b5309c3f0136af">&#9670;&nbsp;</a></span>recursively_clear_user_flag()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_flag </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the user flag for this and all descendants. See <a class="el" href="DEALGlossary.html#GlossUserFlags">GlossUserFlags</a> for more information. </p>

</div>
</div>
<a id="a3965091ec2c6ba6ed838a2479dd8110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3965091ec2c6ba6ed838a2479dd8110f">&#9670;&nbsp;</a></span>clear_user_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the user data to zero, independent if pointer or index. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="aceaaa0940be75dd7436769b55538aaac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceaaa0940be75dd7436769b55538aaac">&#9670;&nbsp;</a></span>set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the user pointer to <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a1fd20837028286220f0b2ba9b0d4b219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd20837028286220f0b2ba9b0d4b219">&#9670;&nbsp;</a></span>clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the user pointer to a <code>nullptr</code> pointer. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ad3700f2ce7587b2fbcaf85753c79bf40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3700f2ce7587b2fbcaf85753c79bf40">&#9670;&nbsp;</a></span>user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the value of the user pointer. It is in the responsibility of the user to make sure that the pointer points to something useful. You should use the new style cast operator to maintain a minimum of type safety, e.g.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between. <code>A <em>a=static_cast&lt;A</em>&gt;(cell-&gt;<a class="el" href="classTriaAccessor.html#ad3700f2ce7587b2fbcaf85753c79bf40">user_pointer()</a>);</code>.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a484e590959847d514d42814efa3e25c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a484e590959847d514d42814efa3e25c2">&#9670;&nbsp;</a></span>recursively_set_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_pointer </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the user pointer of this object and all its children to the given value. This is useful for example if all cells of a certain subdomain, or all faces of a certain part of the boundary should have user pointers pointing to objects describing this part of the domain or boundary.</p>
<p>Note that the user pointer is not inherited under mesh refinement, so after mesh refinement there might be cells or faces that don't have user pointers pointing to the describing object. In this case, simply loop over all the elements of the coarsest level that has this information, and use this function to recursively set the user pointer of all finer levels of the triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ad04d1802d9b1e8923dcfef41ea624edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad04d1802d9b1e8923dcfef41ea624edc">&#9670;&nbsp;</a></span>recursively_clear_user_pointer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_pointer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the user pointer of this object and all of its descendants. The same holds as said for the <a class="el" href="classTriaAccessor.html#a484e590959847d514d42814efa3e25c2">recursively_set_user_pointer()</a> function. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a0cca979ccf43e19af78dcb91d19cfd87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cca979ccf43e19af78dcb91d19cfd87">&#9670;&nbsp;</a></span>set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the user index to <code>p</code>.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </dd></dl>

</div>
</div>
<a id="a97a1e59ae7328b4c75c69720826736c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1e59ae7328b4c75c69720826736c0">&#9670;&nbsp;</a></span>clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the user index to 0. See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="ac7a24da10289811179abbfb57253e9d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7a24da10289811179abbfb57253e9d3">&#9670;&nbsp;</a></span>user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the value of the user index.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a309ae29be30ad5a259b1cd942e7d9e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309ae29be30ad5a259b1cd942e7d9e9d">&#9670;&nbsp;</a></span>recursively_set_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_set_user_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the user index of this object and all its children.</p>
<p>Note that the user index is not inherited under mesh refinement, so after mesh refinement there might be cells or faces that don't have the expected user indices. In this case, simply loop over all the elements of the coarsest level that has this information, and use this function to recursively set the user index of all finer levels of the triangulation.</p>
<dl class="section note"><dt>Note</dt><dd>User pointers and user indices are mutually exclusive. Therefore, you can only use one of them, unless you call <a class="el" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">Triangulation::clear_user_data()</a> in between.</dd></dl>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="a429e559fb261a631942d54c897243abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a429e559fb261a631942d54c897243abb">&#9670;&nbsp;</a></span>recursively_clear_user_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::recursively_clear_user_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Clear the user index of this object and all of its descendants. The same holds as said for the <a class="el" href="classTriaAccessor.html#a309ae29be30ad5a259b1cd942e7d9e9d">recursively_set_user_index()</a> function.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossUserData">GlossUserData</a> for more information. </p>

</div>
</div>
<a id="af0e85725edb5d2bb43da61796f2fbbb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e85725edb5d2bb43da61796f2fbbb9">&#9670;&nbsp;</a></span>diameter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::diameter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Diameter of the object.</p>
<p>The diameter of an object is computed to be the largest diagonal of the current object. If this object is a quadrilateral, then there are two such diagonal, and if it is a hexahedron, then there are four diagonals that connect "opposite" points. For triangles and tetrahedra, the function simply returns the length of the longest edge.</p>
<p>The situation is more difficult for wedges and pyramids: For wedges, we return the length of the longest diagonal of the three quadrilateral faces or the longest edge length of the two triangular faces. For pyramids, the same principle is applied.</p>
<p>In all of these cases, this definition of "diameter" is not necessarily the true diameter in the sense of the largest distance between points inside the object. Indeed, one can often construct objects for which it is not, though these are generally quite deformed compared to the reference shape. Furthermore, for objects that may use higher order mappings, one may have bulging faces that also create trouble for computing an exact representation of the diameter of the object. That said, the definition used above is completely sufficient for most computations. </p>

</div>
</div>
<a id="a7af8bab7e9ad732b6f3fa6a120ed5208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af8bab7e9ad732b6f3fa6a120ed5208">&#9670;&nbsp;</a></span>enclosing_ball()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;, <a class="el" href="classdouble.html">double</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::enclosing_ball </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pair of <a class="el" href="classPoint.html">Point</a> and double corresponding to the center and the radius of a reasonably small enclosing ball of the object.</p>
<p>The function implements Ritter's O(n) algorithm to get a reasonably small enclosing ball around the vertices of the object. The initial guess for the enclosing ball is taken to be the ball which contains the largest diagonal of the object as its diameter. Starting from such an initial guess, the algorithm tests whether all the vertices of the object (except the vertices of the largest diagonal) are geometrically within the ball. If any vertex (v) is found to be geometrically outside the ball, a new iterate of the ball is constructed by shifting its center and increasing the radius so as to geometrically enclose both the previous ball and the vertex (v). The algorithm terminates when all the vertices are geometrically inside the ball.</p>
<p>If a vertex (v) is geometrically inside a particular iterate of the ball, then it will continue to be so in the subsequent iterates of the ball (this is true <em>by</em> <em>construction</em>).</p>
<dl class="section note"><dt>Note</dt><dd>This function assumes d-linear mapping from the reference cell.</dd></dl>
<p><a href="http://geomalgorithms.com/a08-_containers.html">see this</a> and [Ritter 1990] </p>

</div>
</div>
<a id="acf87ae60fcf03c3eb4332ee6e634647f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf87ae60fcf03c3eb4332ee6e634647f">&#9670;&nbsp;</a></span>bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::bounding_box </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest bounding box that encloses the object.</p>
<p>Notice that this method is not aware of any mapping you may be using to do your computations. If you are using a mapping object that modifies the position of the vertices, like <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>, or <a class="el" href="classMappingFEField.html">MappingFEField</a>, then you should call the function <a class="el" href="classMapping.html#adf83c098abdb6607178efdb62af91ac0">Mapping::get_bounding_box()</a> instead. </p>

</div>
</div>
<a id="a49a088728d7acb727fdc13bb6664d91a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49a088728d7acb727fdc13bb6664d91a">&#9670;&nbsp;</a></span>extent_in_direction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::extent_in_direction </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>axis</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Length of an object in the direction of the given axis, specified in the local coordinate system. See the documentation of <a class="el" href="structGeometryInfo.html">GeometryInfo</a> for the meaning and enumeration of the local axes.</p>
<p>Note that the "length" of an object can be interpreted in a variety of ways. Here, we choose it as the maximal length of any of the edges of the object that are parallel to the chosen axis on the reference cell. </p>

</div>
</div>
<a id="a99b268c743742c3c9ab159ff916d9236"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b268c743742c3c9ab159ff916d9236">&#9670;&nbsp;</a></span>minimum_vertex_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::minimum_vertex_distance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the minimal distance between any two vertices. </p>

</div>
</div>
<a id="ad68f07dabea75fdc6af95db7ed5ed394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68f07dabea75fdc6af95db7ed5ed394">&#9670;&nbsp;</a></span>intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; structdim &gt; &amp;&#160;</td>
          <td class="paramname"><em>coordinates</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a point belonging to the Manifold&lt;dim,spacedim&gt; where this object lives, given its parametric coordinates on the reference <code>structdim</code> cell. This function queries the underlying manifold object, and can be used to obtain the exact geometrical location of arbitrary points on this object.</p>
<p>Notice that the argument <code>coordinates</code> are the coordinates on the <em>reference cell</em>, given in reference coordinates. In other words, the argument provides a weighting between the different vertices. For example, for lines, calling this function with argument <a class="el" href="classPoint.html">Point&lt;1&gt;</a>(.5), is equivalent to asking the line for its center. </p>

</div>
</div>
<a id="a3814b2ee53cd391e23dd4448a3d78abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3814b2ee53cd391e23dd4448a3d78abd">&#9670;&nbsp;</a></span>real_to_unit_cell_affine_approximation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;structdim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::real_to_unit_cell_affine_approximation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function computes a fast approximate transformation from the real to the unit cell by inversion of an affine approximation of the \(d\)-linear function from the reference \(d\)-dimensional cell.</p>
<p>The affine approximation of the unit to real cell mapping is found by a least squares fit of an affine function to the \(2^d\) vertices of the present object. For any valid mesh cell whose geometry is not degenerate, this operation results in a unique affine mapping. Thus, this function will return a finite result for all given input points, even in cases where the actual transformation by an actual bi-/trilinear or higher order mapping might be singular. Besides only approximating the mapping from the vertex points, this function also ignores the attached manifold descriptions. The result is only exact in case the transformation from the unit to the real cell is indeed affine, such as in one dimension or for Cartesian and affine (parallelogram) meshes in 2D/3D.</p>
<p>For exact transformations to the unit cell, use <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If dim&lt;spacedim we first project p onto the plane. </dd></dl>

</div>
</div>
<a id="a309aff7fc274a52af0d567b1533d5596"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a309aff7fc274a52af0d567b1533d5596">&#9670;&nbsp;</a></span>center()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::center </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>respect_manifold</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>interpolate_from_surrounding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Center of the object. The center of an object is defined to be the average of the locations of the vertices, which is also where a \(Q_1\) mapping would map the center of the reference cell. However, you can also ask this function to instead return the average of the vertices as computed by the underlying <a class="el" href="classManifold.html">Manifold</a> object associated with the current object, by setting to true the optional parameter <code>respect_manifold</code>. <a class="el" href="namespaceManifolds.html">Manifolds</a> would then typically pull back the coordinates of the vertices to a reference domain (not necessarily the reference cell), compute the average there, and then push forward the coordinates of the averaged point to the physical space again; the resulting point is guaranteed to lie within the manifold, even if the manifold is curved.</p>
<p>When the object uses a different manifold description as its surrounding, like when part of the bounding objects of this <a class="el" href="classTriaAccessor.html">TriaAccessor</a> use a non-flat manifold description but the object itself is flat, the result given by the <a class="el" href="classTriaAccessor.html#a309aff7fc274a52af0d567b1533d5596">TriaAccessor::center()</a> function may not be accurate enough, even when parameter <code>respect_manifold</code> is set to true. If you find this to be case, than you can further refine the computation of the center by setting to true the second additional parameter <code>interpolate_from_surrounding</code>. This computes the location of the center by a so-called transfinite interpolation from the center of all the bounding objects. For a 2D object, it puts a weight of <code>1/2</code> on each of the four surrounding lines and a weight <code>-1/4</code> on the four vertices. This corresponds to a linear interpolation between the descriptions of the four faces, subtracting the contribution of the vertices that is added twice when coming through both lines adjacent to the vertex. In 3D, the weights for faces are <code>1/2</code>, the weights for lines are <code>-1/4</code>, and the weights for vertices are <code>1/8</code>. For further information, also confer to the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> class that is able to not only apply this beneficial description to a single cell but all children of a coarse cell. </p>

</div>
</div>
<a id="a80ddbc9b39806cb2131b5518caef50db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80ddbc9b39806cb2131b5518caef50db">&#9670;&nbsp;</a></span>barycenter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::barycenter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the barycenter (also called centroid) of the object. The barycenter for an object \(K\) of dimension \(d\) in \(D\) space dimensions is given by the \(D\)-dimensional vector \(\mathbf x_K\) defined by </p><p class="formulaDsp">
\[ \mathbf x_K = \frac{1}{|K|} \int_K \mathbf x \; \textrm{d}x \]
</p>
<p> where the measure of the object is given by </p><p class="formulaDsp">
\[ |K| = \int_K \mathbf 1 \; \textrm{d}x. \]
</p>
<p> This function assumes that \(K\) is mapped by a \(d\)-linear function from the reference \(d\)-dimensional cell. Then the integrals above can be pulled back to the reference cell and evaluated exactly (if through lengthy and, compared to the <a class="el" href="classTriaAccessor.html#a309aff7fc274a52af0d567b1533d5596">center()</a> function, expensive computations). </p>

</div>
</div>
<a id="a9cecb2b7c9a1644fb5fd44bbba40ab0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cecb2b7c9a1644fb5fd44bbba40ab0c">&#9670;&nbsp;</a></span>measure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::measure </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the dim-dimensional measure of the object. For a dim-dimensional cell in dim-dimensional space, this equals its volume. On the other hand, for a 2d cell in 3d space, or if the current object pointed to is a 2d face of a 3d cell in 3d space, then the function computes the area the object occupies. For a one-dimensional object, return its length.</p>
<p>The function only computes the measure of cells, faces or edges assumed to be represented by (bi-/tri-)linear mappings. In other words, it only takes into account the locations of the vertices that bound the current object but not how the interior of the object may actually be mapped. In most simple cases, this is exactly what you want. However, for objects that are not "straight", e.g. 2d cells embedded in 3d space as part of a triangulation of a curved domain, two-dimensional faces of 3d cells that are not just parallelograms, or for faces that are at the boundary of a domain that is not just bounded by straight line segments or planes, this function only computes the dim-dimensional measure of a (bi-/tri-)linear interpolation of the "real" object as defined by the manifold or boundary object describing the real geometry of the object in question. If you want to consider the "real" geometry, you will need to compute the measure by integrating a function equal to one over the object, which after applying quadrature equals the summing the JxW values returned by the <a class="el" href="classFEValues.html">FEValues</a> or <a class="el" href="classFEFaceValues.html">FEFaceValues</a> object you will want to use for the integral. </p>

</div>
</div>
<a id="ab21eeac18f82c9689857c225ca6be7e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21eeac18f82c9689857c225ca6be7e4">&#9670;&nbsp;</a></span>is_translation_of()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::is_translation_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>o</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the current object is a translation of the given argument.</p>
<dl class="section note"><dt>Note</dt><dd>For the purpose of a triangulation, cells, faces, etc are only characterized by their vertices. The current function therefore only compares the locations of vertices. For many practical applications, however, it is not only the vertices that determine whether one cell is a translation of another, but also how the cell is mapped from the reference cell to its location in real space. For example, if we are using higher order mappings, then not only do the vertices have to be translations of each other, but also the points along edges. In these questions, therefore, it would be appropriate to ask the mapping, not the current function, whether two objects are translations of each other. </dd></dl>

</div>
</div>
<a id="ad2f79864c20e5ee8283e9ddb6f7c0415"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f79864c20e5ee8283e9ddb6f7c0415">&#9670;&nbsp;</a></span>reference_cell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classReferenceCell.html">ReferenceCell</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::reference_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reference cell type of the current object. </p>

</div>
</div>
<a id="a4a5ed83117e0ff9276abeb9a4fbaac61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5ed83117e0ff9276abeb9a4fbaac61">&#9670;&nbsp;</a></span>n_vertices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_vertices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of vertices. </p>

</div>
</div>
<a id="a48e25f9720160ac96bc7f4eea0977784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48e25f9720160ac96bc7f4eea0977784">&#9670;&nbsp;</a></span>n_lines()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of lines. </p>

</div>
</div>
<a id="af330fe95fe8d30a99884797f61236913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af330fe95fe8d30a99884797f61236913">&#9670;&nbsp;</a></span>n_faces()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::n_faces </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of faces.</p>
<dl class="section note"><dt>Note</dt><dd>Only implemented for cells (dim==spacedim). </dd></dl>

</div>
</div>
<a id="ae40947cf863ecef1ee08ec93f411baaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae40947cf863ecef1ee08ec93f411baaa">&#9670;&nbsp;</a></span>vertex_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::vertex_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <a class="el" href="classTriaAccessor.html#a4a5ed83117e0ff9276abeb9a4fbaac61">n_vertices()</a>. </p>

</div>
</div>
<a id="a44268b67d46418c49a0a5e47f404adcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44268b67d46418c49a0a5e47f404adcc">&#9670;&nbsp;</a></span>line_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::line_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <a class="el" href="classTriaAccessor.html#a48e25f9720160ac96bc7f4eea0977784">n_lines()</a>. </p>

</div>
</div>
<a id="a5b4cabec41161961ab25d91b6cdc2425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b4cabec41161961ab25d91b6cdc2425">&#9670;&nbsp;</a></span>face_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacestd__cxx20_1_1ranges.html#a109956a09689ca9e1379724719a2c4c4">std_cxx20::ranges::iota_view</a>&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::face_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object that can be thought of as an array containing all indices from zero to <a class="el" href="classTriaAccessor.html#af330fe95fe8d30a99884797f61236913">n_faces()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>Only implemented for cells (dim==spacedim). </dd></dl>

</div>
</div>
<a id="a436333e85278d0d4f3feb80abc2db97c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a436333e85278d0d4f3feb80abc2db97c">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Since this is only called from iterators, do not return anything, since the iterator will return itself.</p>
<p>This method is protected, since it is only to be called from the iterator class. </p>

</div>
</div>
<a id="a7cd4644115f0c10a4e07462029211274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cd4644115f0c10a4e07462029211274">&#9670;&nbsp;</a></span>operator<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Comparison operator for accessors. This operator is used when comparing iterators into objects of a triangulation, for example when putting them into a <code>std::map</code>.</p>
<p>If <a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> is less than <a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a>, we simply compare the index of such an object because faces and edges do not have levels. If <a class="el" href="classTriaAccessorBase.html#a35e42860babc727fc028adfb9a3200b7">structure_dimension</a> equals <a class="el" href="classTriaAccessorBase.html#a125ed55a8362723639a14d083d9e745c">dimension</a>, we compare the level first, and the index only if levels are equal. </p>

</div>
</div>
<a id="af88fce14be63f6000f7b5d70618dc14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88fce14be63f6000f7b5d70618dc14b">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality. </p>

</div>
</div>
<a id="a044710b90a02f1d4e6c2e39c00f51ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044710b90a02f1d4e6c2e39c00f51ee7">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality. </p>

</div>
</div>
<a id="a5a24bd66635320e66d1dff07e3cb26e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a24bd66635320e66d1dff07e3cb26e1">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator advances the iterator to the next element.</p>
<p>For <code>dim=1</code> only: The next element is next on this level if there are more. If the present element is the last on this level, the first on the next level is accessed. </p>

</div>
</div>
<a id="a85d4f1dc476691cf77e88f2c3ed15afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d4f1dc476691cf77e88f2c3ed15afe">&#9670;&nbsp;</a></span>operator--()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::operator-- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator moves the iterator to the previous element.</p>
<p>For <code>dim=1</code> only: The previous element is previous on this level if <code>index&gt;0</code>. If the present element is the first on this level, the last on the previous level is accessed. </p>

</div>
</div>
<a id="ae6d5a6b58e60a06216665e31c26704bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d5a6b58e60a06216665e31c26704bd">&#9670;&nbsp;</a></span>objects()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">::<a class="el" href="classinternal_1_1TriangulationImplementation_1_1TriaObjects.html">internal::TriangulationImplementation::TriaObjects</a>&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::objects </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to the other objects of a <a class="el" href="classTriangulation.html">Triangulation</a> with same dimension. </p>

</div>
</div>
<a id="ae826bd9e6c976638366d9993e6a6c7c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae826bd9e6c976638366d9993e6a6c7c0">&#9670;&nbsp;</a></span>level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::level </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For cells, this function returns the level within the mesh hierarchy at which this cell is located. For all other objects, the function returns zero.</p>
<dl class="section note"><dt>Note</dt><dd>Within a <a class="el" href="classTriangulation.html">Triangulation</a> object, cells are uniquely identified by a pair <code>(level, index)</code> where the former is the cell's refinement level and the latter is the index of the cell within this refinement level (the former being what this function returns). Consequently, there may be multiple cells on different refinement levels but with the same index within their level. Contrary to this, if the current object corresponds to a face or edge, then the object is uniquely identified solely by its index as faces and edges do not have a refinement level. For these objects, the current function always returns zero as the level. </dd></dl>

</div>
</div>
<a id="a6bebfc1e42324fbf595487e1bf668a22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bebfc1e42324fbf595487e1bf668a22">&#9670;&nbsp;</a></span>index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index of the element presently pointed to on the present level.</p>
<p>Within a <a class="el" href="classTriangulation.html">Triangulation</a> object, cells are uniquely identified by a pair <code>(level, index)</code> where the former is the cell's refinement level and the latter is the index of the cell within this refinement level (the latter being what this function returns). Consequently, there may be multiple cells on different refinement levels but with the same index within their level. Contrary to this, if the current object corresponds to a face or edge, then the object is uniquely identified solely by its index as faces and edges do not have a refinement level.</p>
<dl class="section note"><dt>Note</dt><dd>The indices objects returned by this function are not a contiguous set of numbers on each level: going from cell to cell, some of the indices in a level may be unused.</dd>
<dd>
If the triangulation is actually of type <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> then the indices are relatively only to that part of the distributed triangulation that is stored on the current processor. In other words, cells living in the partitions of the triangulation stored on different processors may have the same index even if they refer to the same cell, and the may have different indices even if they do refer to the same cell (e.g., if a cell is owned by one processor but is a ghost cell on another). </dd></dl>

</div>
</div>
<a id="a5f75f0d6c68a1a67ea03bd4727c29529"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f75f0d6c68a1a67ea03bd4727c29529">&#9670;&nbsp;</a></span>state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507">IteratorState::IteratorStates</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::state </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the state of the iterator. For the different states an accessor can be in, refer to the <a class="el" href="classTriaRawIterator.html">TriaRawIterator</a> documentation. </p>

</div>
</div>
<a id="af822c24c013e7b677f45ec2a8a41386a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af822c24c013e7b677f45ec2a8a41386a">&#9670;&nbsp;</a></span>get_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::get_triangulation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the triangulation which the object pointed to by this class belongs to. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="abe9e690d5d7904f804316e15362a2191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9e690d5d7904f804316e15362a2191">&#9670;&nbsp;</a></span>Triangulation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTriangulation.html">Triangulation</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03889">3889</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="aa06609bdb8db3c02e2988fe92796820a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa06609bdb8db3c02e2988fe92796820a">&#9670;&nbsp;</a></span>parallel::TriangulationBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03892">3892</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a1173edf91a9d914373821b6117f32a8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1173edf91a9d914373821b6117f32a8f">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03894">3894</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a8b5f94c07c2ca904c27c04ca38eac0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5f94c07c2ca904c27c04ca38eac0e1">&#9670;&nbsp;</a></span>::internal::TriangulationImplementation::ImplementationMixedMesh</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::TriangulationImplementation:: ImplementationMixedMesh</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l03896">3896</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac97bc3b07691e1a0ba9f32074642ae66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97bc3b07691e1a0ba9f32074642ae66">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::space_dimension = spacedim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimension of the space the object represented by this accessor lives in. For example, if this accessor represents a quad that is part of a two- dimensional surface in four-dimensional space, then this value is four. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00309">309</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a125ed55a8362723639a14d083d9e745c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a125ed55a8362723639a14d083d9e745c">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimensionality of the object that the thing represented by this accessor is part of. For example, if this accessor represents a line that is part of a hexahedron, then this value will be three. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00316">316</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a35e42860babc727fc028adfb9a3200b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35e42860babc727fc028adfb9a3200b7">&#9670;&nbsp;</a></span>structure_dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::structure_dimension = structdim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dimensionality of the current object represented by this accessor. For example, if it is line (irrespective of whether it is part of a quad or hex, and what dimension we are in), then this value equals 1. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00323">323</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a3ad5efb039ed878a124c9577acd92256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad5efb039ed878a124c9577acd92256">&#9670;&nbsp;</a></span>present_level</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::TriaAccessorImplementation:: PresentLevelType&lt;structdim, dim&gt;::type <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_level</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The level if this is a cell (<code>structdim==dim</code>). Else, contains zero. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00521">521</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="a11cf2d985abdb2c9a43ab97722305f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf2d985abdb2c9a43ab97722305f34">&#9670;&nbsp;</a></span>present_index</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::present_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Used to store the index of the element presently pointed to on the level presently used. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00527">527</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<a id="af02486bbb2ee4b94d1b51f03ba47257f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af02486bbb2ee4b94d1b51f03ba47257f">&#9670;&nbsp;</a></span>tria</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt;* <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt;::tria</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the triangulation which we act on. </p>

<p class="definition">Definition at line <a class="el" href="tria__accessor_8h_source.html#l00532">532</a> of file <a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="tria__accessor_8h_source.html">tria_accessor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
