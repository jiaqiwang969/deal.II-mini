<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDoFCellAccessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDoFCellAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo;  &#124; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dof__accessor_8h_source.html">deal.II/dofs/dof_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDoFCellAccessor__inherit__graph.svg" width="1207" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a14eaa9e4b4b0aa9faf84414d7fac2ed8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> = <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;</td></tr>
<tr class="separator:a14eaa9e4b4b0aa9faf84414d7fac2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac715be6a489bcf83b56caa5cfd04a995"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ac715be6a489bcf83b56caa5cfd04a995">BaseClass</a> = <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; dimension_, dimension_, space_dimension_, level_dof_access &gt;</td></tr>
<tr class="separator:ac715be6a489bcf83b56caa5cfd04a995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56b2fbf436c741d930551944c1ce726"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae56b2fbf436c741d930551944c1ce726">Container</a> = <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;</td></tr>
<tr class="separator:ae56b2fbf436c741d930551944c1ce726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a4ac52fd924b8b3854c771a8037026"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; dimension_ - 1, dimension_, space_dimension_, level_dof_access &gt; &gt;</td></tr>
<tr class="separator:a70a4ac52fd924b8b3854c771a8037026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3e7d1c5c9bacd29de30a6ca648b9de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae3e7d1c5c9bacd29de30a6ca648b9de7">parent</a> () const</td></tr>
<tr class="separator:ae3e7d1c5c9bacd29de30a6ca648b9de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420232a0d0f5e4935e4e088599d70219"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a420232a0d0f5e4935e4e088599d70219">set_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices)</td></tr>
<tr class="separator:a420232a0d0f5e4935e4e088599d70219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76cef754ca3b14d1f13ef2c01a4a999"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ac76cef754ca3b14d1f13ef2c01a4a999">set_mg_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices)</td></tr>
<tr class="separator:ac76cef754ca3b14d1f13ef2c01a4a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f15ef7cc39b0cec739222b6728a65c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a10f15ef7cc39b0cec739222b6728a65c">update_cell_dof_indices_cache</a> () const</td></tr>
<tr class="separator:a10f15ef7cc39b0cec739222b6728a65c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49329d7429a4dad355b2b8c859e7e60a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a49329d7429a4dad355b2b8c859e7e60a">get_dof_handler</a> () const</td></tr>
<tr class="separator:a49329d7429a4dad355b2b8c859e7e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2203fb607f6ae1f79d860a41efdf37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aa2203fb607f6ae1f79d860a41efdf37c">copy_from</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access2 &gt; &amp;a)</td></tr>
<tr class="separator:aa2203fb607f6ae1f79d860a41efdf37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a040127cdbb584aefbf38779ca7ac57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a9a040127cdbb584aefbf38779ca7ac57">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; &amp;da)</td></tr>
<tr class="separator:a9a040127cdbb584aefbf38779ca7ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b9816a464913e80b640d7778b6a2a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36b9816a464913e80b640d7778b6a2a6">DeclExceptionMsg</a> (ExcInvalidObject, &quot;This accessor object has not been &quot; &quot;associated with any <a class="el" href="classDoFHandler.html">DoFHandler</a> object.&quot;)</td></tr>
<tr class="separator:ga36b9816a464913e80b640d7778b6a2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9faa28de1bfa14fe42acae5ec0c795"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gace9faa28de1bfa14fe42acae5ec0c795">DeclException0</a> (ExcVectorNotEmpty)</td></tr>
<tr class="separator:gace9faa28de1bfa14fe42acae5ec0c795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f84a1c8defd39d3e0ce848f2c1f6caf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9f84a1c8defd39d3e0ce848f2c1f6caf">DeclException0</a> (ExcVectorDoesNotMatch)</td></tr>
<tr class="separator:ga9f84a1c8defd39d3e0ce848f2c1f6caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c716f4f4f6718bca364135fa8980527"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4c716f4f4f6718bca364135fa8980527">DeclException0</a> (ExcMatrixDoesNotMatch)</td></tr>
<tr class="separator:ga4c716f4f4f6718bca364135fa8980527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe397e0b77ee7550e2394ba96f7fb70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0fe397e0b77ee7550e2394ba96f7fb70">DeclException0</a> (ExcNotActive)</td></tr>
<tr class="separator:ga0fe397e0b77ee7550e2394ba96f7fb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00741f1400034d3faca2ca3bed41b29a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga00741f1400034d3faca2ca3bed41b29a">DeclException0</a> (ExcCantCompareIterators)</td></tr>
<tr class="separator:ga00741f1400034d3faca2ca3bed41b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ae8fec03877b971fd7832d92704be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ac6ae8fec03877b971fd7832d92704be4">operator==</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;) const</td></tr>
<tr class="separator:ac6ae8fec03877b971fd7832d92704be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90137a1310b0ec72b89cfb60e1f51145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a90137a1310b0ec72b89cfb60e1f51145">operator!=</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;) const</td></tr>
<tr class="separator:a90137a1310b0ec72b89cfb60e1f51145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization</div></td></tr>
<tr class="memitem:a3fdfeda1dae3c8c79aab8f8693d773f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a3fdfeda1dae3c8c79aab8f8693d773f4">DoFCellAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dimension_, space_dimension_ &gt; *tria, const <a class="el" href="classint.html">int</a> level, const <a class="el" href="classint.html">int</a> index, const <a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> *local_data)</td></tr>
<tr class="separator:a3fdfeda1dae3c8c79aab8f8693d773f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4773afe4306d7c470eff8bdcfa4945"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:a8a4773afe4306d7c470eff8bdcfa4945"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a8a4773afe4306d7c470eff8bdcfa4945">DoFCellAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a8a4773afe4306d7c470eff8bdcfa4945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e3b423ac414e0ade67250589747fff"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2, bool level_dof_access2&gt; </td></tr>
<tr class="memitem:a82e3b423ac414e0ade67250589747fff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a82e3b423ac414e0ade67250589747fff">DoFCellAccessor</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;)</td></tr>
<tr class="separator:a82e3b423ac414e0ade67250589747fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb101ef43d77d96339c8b3a5e57d5c7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#acb101ef43d77d96339c8b3a5e57d5c7a">DoFCellAccessor</a> (const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;)=default</td></tr>
<tr class="separator:acb101ef43d77d96339c8b3a5e57d5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108142a1c96d7e897b2e69bb1b22ca92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a108142a1c96d7e897b2e69bb1b22ca92">DoFCellAccessor</a> (<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a108142a1c96d7e897b2e69bb1b22ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c05e9518e81d651b9e09568274d444"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae0c05e9518e81d651b9e09568274d444">~DoFCellAccessor</a> ()=default</td></tr>
<tr class="separator:ae0c05e9518e81d651b9e09568274d444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2870a690c665b4cb0c0176c6944682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a7b2870a690c665b4cb0c0176c6944682">operator=</a> (const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;da)=delete</td></tr>
<tr class="separator:a7b2870a690c665b4cb0c0176c6944682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d175bf33624dd27a239239d1896d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a01d175bf33624dd27a239239d1896d3e">operator=</a> (<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a01d175bf33624dd27a239239d1896d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects and neighbors</div></td></tr>
<tr class="memitem:a83f4b0d83f95157c8563e74012997ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a83f4b0d83f95157c8563e74012997ab5">neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a83f4b0d83f95157c8563e74012997ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a08c59c362342524500047db9f19eae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a9a08c59c362342524500047db9f19eae">periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a9a08c59c362342524500047db9f19eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad80f30bcb7c29e1ae187df30d61ad8c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ad80f30bcb7c29e1ae187df30d61ad8c0">neighbor_or_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ad80f30bcb7c29e1ae187df30d61ad8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658978b9f615b5c1e1351cff86fe5749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a658978b9f615b5c1e1351cff86fe5749">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a658978b9f615b5c1e1351cff86fe5749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0133b5a7c0b2e585b1712f01cb2e2187"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dimension_ &gt;::max_children_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0133b5a7c0b2e585b1712f01cb2e2187">child_iterators</a> () const</td></tr>
<tr class="separator:a0133b5a7c0b2e585b1712f01cb2e2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d70e743293a3b7b63b8f9e2dba70d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a17d70e743293a3b7b63b8f9e2dba70d2">face</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a17d70e743293a3b7b63b8f9e2dba70d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706e62b6e969a1c7554d6b0e08391ea3"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dimension_ &gt;::faces_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a706e62b6e969a1c7554d6b0e08391ea3">face_iterators</a> () const</td></tr>
<tr class="separator:a706e62b6e969a1c7554d6b0e08391ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf6b3ae7147febfdb34f214dad849a09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#acf6b3ae7147febfdb34f214dad849a09">neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:acf6b3ae7147febfdb34f214dad849a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe02ec205e8cc8697a4324e3cd0d2b42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#afe02ec205e8cc8697a4324e3cd0d2b42">periodic_neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:afe02ec205e8cc8697a4324e3cd0d2b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Extracting values from global vectors</div></td></tr>
<tr class="memitem:a1702d1e9c1cb4fb07b70c38ac9165aaa"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a1702d1e9c1cb4fb07b70c38ac9165aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a1702d1e9c1cb4fb07b70c38ac9165aaa">get_dof_values</a> (const InputVector &amp;values, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_values) const</td></tr>
<tr class="separator:a1702d1e9c1cb4fb07b70c38ac9165aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4533f34e152298586da408827f8bac1a"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a4533f34e152298586da408827f8bac1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a4533f34e152298586da408827f8bac1a">get_dof_values</a> (const InputVector &amp;values, ForwardIterator local_values_begin, ForwardIterator local_values_end) const</td></tr>
<tr class="separator:a4533f34e152298586da408827f8bac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55050e07d9458ccc01a0456313d230f4"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a55050e07d9458ccc01a0456313d230f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a55050e07d9458ccc01a0456313d230f4">get_dof_values</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename InputVector::value_type &gt; &amp;constraints, const InputVector &amp;values, ForwardIterator local_values_begin, ForwardIterator local_values_end) const</td></tr>
<tr class="separator:a55050e07d9458ccc01a0456313d230f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3ca14113486423a02d9dcf281d1511"><td class="memTemplParams" colspan="2">template&lt;class OutputVector , typename number &gt; </td></tr>
<tr class="memitem:abd3ca14113486423a02d9dcf281d1511"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#abd3ca14113486423a02d9dcf281d1511">set_dof_values</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_values, OutputVector &amp;values) const</td></tr>
<tr class="separator:abd3ca14113486423a02d9dcf281d1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75210f15c0f8f837325de80792660c33"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a75210f15c0f8f837325de80792660c33"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a75210f15c0f8f837325de80792660c33">get_interpolated_dof_values</a> (const InputVector &amp;values, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;interpolated_values, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a75210f15c0f8f837325de80792660c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accf660b09b5b05d80befa10ddfa928fa"><td class="memTemplParams" colspan="2">template&lt;class OutputVector , typename number &gt; </td></tr>
<tr class="memitem:accf660b09b5b05d80befa10ddfa928fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#accf660b09b5b05d80befa10ddfa928fa">set_dof_values_by_interpolation</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_values, OutputVector &amp;values, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:accf660b09b5b05d80befa10ddfa928fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b373ea3845c1be186681ceb4d1d28f8"><td class="memTemplParams" colspan="2">template&lt;typename number , typename OutputVector &gt; </td></tr>
<tr class="memitem:a4b373ea3845c1be186681ceb4d1d28f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a4b373ea3845c1be186681ceb4d1d28f8">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_source, OutputVector &amp;global_destination) const</td></tr>
<tr class="separator:a4b373ea3845c1be186681ceb4d1d28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2ea6075920c592b31132352385415d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputVector &gt; </td></tr>
<tr class="memitem:add2ea6075920c592b31132352385415d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#add2ea6075920c592b31132352385415d">distribute_local_to_global</a> (ForwardIterator local_source_begin, ForwardIterator local_source_end, OutputVector &amp;global_destination) const</td></tr>
<tr class="separator:add2ea6075920c592b31132352385415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90bb534e64a5a9c10d9f6a161c1a0c5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputVector &gt; </td></tr>
<tr class="memitem:ab90bb534e64a5a9c10d9f6a161c1a0c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab90bb534e64a5a9c10d9f6a161c1a0c5">distribute_local_to_global</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutputVector::value_type &gt; &amp;constraints, ForwardIterator local_source_begin, ForwardIterator local_source_end, OutputVector &amp;global_destination) const</td></tr>
<tr class="separator:ab90bb534e64a5a9c10d9f6a161c1a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629b9490f29a4b030dd897a733116ccb"><td class="memTemplParams" colspan="2">template&lt;typename number , typename OutputMatrix &gt; </td></tr>
<tr class="memitem:a629b9490f29a4b030dd897a733116ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a629b9490f29a4b030dd897a733116ccb">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_source, OutputMatrix &amp;global_destination) const</td></tr>
<tr class="separator:a629b9490f29a4b030dd897a733116ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0917cd50db0119a5efe0309ec13370f"><td class="memTemplParams" colspan="2">template&lt;typename number , typename OutputMatrix , typename OutputVector &gt; </td></tr>
<tr class="memitem:ab0917cd50db0119a5efe0309ec13370f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab0917cd50db0119a5efe0309ec13370f">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, OutputMatrix &amp;global_matrix, OutputVector &amp;global_vector) const</td></tr>
<tr class="separator:ab0917cd50db0119a5efe0309ec13370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing the DoF indices of this object</div></td></tr>
<tr class="memitem:a15ef35e919b1005dc6050f9bca96956d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a15ef35e919b1005dc6050f9bca96956d">get_active_or_mg_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices) const</td></tr>
<tr class="separator:a15ef35e919b1005dc6050f9bca96956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab120d78d3fdf70cf83a52b870ec8d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">get_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices) const</td></tr>
<tr class="separator:aeab120d78d3fdf70cf83a52b870ec8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b7ee5a2c16b2dfacd9139bed6bed4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ad5b7ee5a2c16b2dfacd9139bed6bed4d">get_mg_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices) const</td></tr>
<tr class="separator:ad5b7ee5a2c16b2dfacd9139bed6bed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing the finite element associated with this object</div></td></tr>
<tr class="memitem:ace7438827be3421cdb64c67f28c7aa60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dimension_, space_dimension_ &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ace7438827be3421cdb64c67f28c7aa60">get_fe</a> () const</td></tr>
<tr class="separator:ace7438827be3421cdb64c67f28c7aa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a196a66be2e332d0f302e6b579f47fe"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index</a> () const</td></tr>
<tr class="separator:a5a196a66be2e332d0f302e6b579f47fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44babdcd7954cdfdd9f9497781cc22ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a44babdcd7954cdfdd9f9497781cc22ae">set_active_fe_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a44babdcd7954cdfdd9f9497781cc22ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with refinement indicators</div></td></tr>
<tr class="memitem:a7558706ae1d781bf54ec29f85e862d62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dimension_, space_dimension_ &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a7558706ae1d781bf54ec29f85e862d62">get_future_fe</a> () const</td></tr>
<tr class="separator:a7558706ae1d781bf54ec29f85e862d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d4d8562cb47b70b797369b8872b04d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae4d4d8562cb47b70b797369b8872b04d">future_fe_index</a> () const</td></tr>
<tr class="separator:ae4d4d8562cb47b70b797369b8872b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2896ef67d3d11ec3d23d382b19c46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab9f2896ef67d3d11ec3d23d382b19c46">set_future_fe_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab9f2896ef67d3d11ec3d23d382b19c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7949017e7a76aa15c2dcff7871401e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae7949017e7a76aa15c2dcff7871401e1">future_fe_index_set</a> () const</td></tr>
<tr class="separator:ae7949017e7a76aa15c2dcff7871401e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67f45fd024b1a960c2f67920dbab58c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#aa67f45fd024b1a960c2f67920dbab58c">clear_future_fe_index</a> () const</td></tr>
<tr class="separator:aa67f45fd024b1a960c2f67920dbab58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing sub-objects</div></td></tr>
<tr class="memitem:aad0cb2f5249c0ee51e693366e40e1388"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1DoFHandlerImplementation_1_1Iterators.html">internal::DoFHandlerImplementation::Iterators</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aad0cb2f5249c0ee51e693366e40e1388">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aad0cb2f5249c0ee51e693366e40e1388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad78d479734c818ddd3c928bb5e1537"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1DoFHandlerImplementation_1_1Iterators.html">internal::DoFHandlerImplementation::Iterators</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a7ad78d479734c818ddd3c928bb5e1537">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a7ad78d479734c818ddd3c928bb5e1537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing the DoF indices of this object</div></td></tr>
<tr class="memitem:a9553dfc2e807a7bce21a950e938a3e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a9553dfc2e807a7bce21a950e938a3e9f">get_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a9553dfc2e807a7bce21a950e938a3e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeace582710e57d3d8911e77d73a8b55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#adeace582710e57d3d8911e77d73a8b55">get_mg_dof_indices</a> (const <a class="el" href="classint.html">int</a> level, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:adeace582710e57d3d8911e77d73a8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4564ad65573f50f8b3d02dfb6d07e0ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a4564ad65573f50f8b3d02dfb6d07e0ac">set_mg_dof_indices</a> (const <a class="el" href="classint.html">int</a> level, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index)</td></tr>
<tr class="separator:a4564ad65573f50f8b3d02dfb6d07e0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa1f2d13ea10d3e36d7fc6d982467ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">vertex_dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a5aa1f2d13ea10d3e36d7fc6d982467ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4402930fd9d6e7745befbf0028cd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#acc4402930fd9d6e7745befbf0028cd59">mg_vertex_dof_index</a> (const <a class="el" href="classint.html">int</a> level, const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:acc4402930fd9d6e7745befbf0028cd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc20ce96d8d7501d113c578ecb2ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a65cc20ce96d8d7501d113c578ecb2ea8">dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a65cc20ce96d8d7501d113c578ecb2ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7c02ba6168b40bca90e4fb8c2f8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#acad7c02ba6168b40bca90e4fb8c2f8ee">mg_dof_index</a> (const <a class="el" href="classint.html">int</a> level, const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acad7c02ba6168b40bca90e4fb8c2f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Accessing the finite element associated with this object</div></td></tr>
<tr class="memitem:ad3a5c19a4bf840dad9e1185d78526b4b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ad3a5c19a4bf840dad9e1185d78526b4b">n_active_fe_indices</a> () const</td></tr>
<tr class="separator:ad3a5c19a4bf840dad9e1185d78526b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0021f581f717926769d03779c8739c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#add0021f581f717926769d03779c8739c">nth_active_fe_index</a> (const unsigned <a class="el" href="classint.html">int</a> n) const</td></tr>
<tr class="separator:add0021f581f717926769d03779c8739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc4f3541c18e4f2c59fd39061fd4caf"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a5cc4f3541c18e4f2c59fd39061fd4caf">get_active_fe_indices</a> () const</td></tr>
<tr class="separator:a5cc4f3541c18e4f2c59fd39061fd4caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107e710976f26c4ab9a49275c5ce23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aa107e710976f26c4ab9a49275c5ce23c">fe_index_is_active</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:aa107e710976f26c4ab9a49275c5ce23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad067228a1d5ae86639f2719b84a71c9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ad067228a1d5ae86639f2719b84a71c9e">get_fe</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:ad067228a1d5ae86639f2719b84a71c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ade1461f1a5ea5564fcc1ba2be6641f10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ade1461f1a5ea5564fcc1ba2be6641f10">is_level_cell</a> ()</td></tr>
<tr class="separator:ade1461f1a5ea5564fcc1ba2be6641f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6d4509b7753b800d9fd7039bca79f7ad"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a> = dimension_</td></tr>
<tr class="separator:a6d4509b7753b800d9fd7039bca79f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0e36ef5665c0ad1921049acb84604e"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> = space_dimension_</td></tr>
<tr class="separator:a8b0e36ef5665c0ad1921049acb84604e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8274de3efd9a8b566e3b7a27a1a286"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a5d8274de3efd9a8b566e3b7a27a1a286">dimension</a></td></tr>
<tr class="separator:a5d8274de3efd9a8b566e3b7a27a1a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebf5625b40e2ecedaaeef5f684d3fab"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a0ebf5625b40e2ecedaaeef5f684d3fab">space_dimension</a></td></tr>
<tr class="separator:a0ebf5625b40e2ecedaaeef5f684d3fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a616da3ae411e1649bc75ed330f756388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a616da3ae411e1649bc75ed330f756388">set_dof_handler</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; *dh)</td></tr>
<tr class="separator:a616da3ae411e1649bc75ed330f756388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3cdc6b6fa4abf71bdec21c022c0506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#abe3cdc6b6fa4abf71bdec21c022c0506">set_dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:abe3cdc6b6fa4abf71bdec21c022c0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17282fe1c8b6b2131f01455871065e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a17282fe1c8b6b2131f01455871065e0a">set_mg_dof_index</a> (const <a class="el" href="classint.html">int</a> level, const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index) const</td></tr>
<tr class="separator:a17282fe1c8b6b2131f01455871065e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48185a4fe62cf31fb6313777072e233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ac48185a4fe62cf31fb6313777072e233">set_vertex_dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:ac48185a4fe62cf31fb6313777072e233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af521f2a697ac2b7dec0e8196933979c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#af521f2a697ac2b7dec0e8196933979c4">set_mg_vertex_dof_index</a> (const <a class="el" href="classint.html">int</a> level, const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:af521f2a697ac2b7dec0e8196933979c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aea85e74a2de50f84acd6b53c8e2a55e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aea85e74a2de50f84acd6b53c8e2a55e1">dof_handler</a></td></tr>
<tr class="separator:aea85e74a2de50f84acd6b53c8e2a55e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0f77c88bd6841a98bf02a4a398551115"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:a0f77c88bd6841a98bf02a4a398551115"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0f77c88bd6841a98bf02a4a398551115">DoFHandler</a></td></tr>
<tr class="separator:a0f77c88bd6841a98bf02a4a398551115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf63b7b7600d230112f86fe73e1afdb"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0cf63b7b7600d230112f86fe73e1afdb">::internal::DoFCellAccessorImplementation::Implementation</a></td></tr>
<tr class="separator:a0cf63b7b7600d230112f86fe73e1afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt;<br />
class DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt;</h3>

<p>Grant access to the degrees of freedom on a cell.</p>
<p>Note that since for the class we derive from, i.e. <code>DoFAccessor&lt;dim&gt;</code>, the two template parameters are equal, the base class is actually derived from <a class="el" href="classCellAccessor.html">CellAccessor</a>, which makes the functions of this class available to the <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> class as well. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01369">1369</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a14eaa9e4b4b0aa9faf84414d7fac2ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eaa9e4b4b0aa9faf84414d7fac2ed8">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> =  <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dimension_, space_dimension_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Data type passed by the iterator class. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01389">1389</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="ac715be6a489bcf83b56caa5cfd04a995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac715be6a489bcf83b56caa5cfd04a995">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#ac715be6a489bcf83b56caa5cfd04a995">BaseClass</a> =  <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt;dimension_, dimension_, space_dimension_, level_dof_access&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an alias to the base class to make accessing some of the exception classes simpler. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01396">1396</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="ae56b2fbf436c741d930551944c1ce726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56b2fbf436c741d930551944c1ce726">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#ae56b2fbf436c741d930551944c1ce726">Container</a> =  <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dimension_, space_dimension_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define the type of the container this is part of. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01401">1401</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a70a4ac52fd924b8b3854c771a8037026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a4ac52fd924b8b3854c771a8037026">&#9670;&nbsp;</a></span>face_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a> =  <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt;dimension_ - 1, dimension_, space_dimension_, level_dof_access&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type for an iterator over the faces of a cell. This is what the <a class="el" href="classDoFCellAccessor.html#a17d70e743293a3b7b63b8f9e2dba70d2">face()</a> function returns. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01410">1410</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3fdfeda1dae3c8c79aab8f8693d773f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdfeda1dae3c8c79aab8f8693d773f4">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dimension_, space_dimension_ &gt; *&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor </p>

</div>
</div>
<a id="a8a4773afe4306d7c470eff8bdcfa4945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4773afe4306d7c470eff8bdcfa4945">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion constructor. This constructor exists to make certain constructs simpler to write in dimension independent code. For example, it allows assigning a face iterator to a line iterator, an operation that is useful in 2d but doesn't make any sense in 3d. The constructor here exists for the purpose of making the code conform to C++ but it will unconditionally abort; in other words, assigning a face iterator to a line iterator is better put into an if-statement that checks that the dimension is two, and assign to a quad iterator in 3d (an operator that, without this constructor would be illegal if we happen to compile for 2d). </p>

</div>
</div>
<a id="a82e3b423ac414e0ade67250589747fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e3b423ac414e0ade67250589747fff">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2, bool level_dof_access2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Another conversion operator between objects that don't make sense, just like the previous one. </p>

</div>
</div>
<a id="acb101ef43d77d96339c8b3a5e57d5c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb101ef43d77d96339c8b3a5e57d5c7a">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="a108142a1c96d7e897b2e69bb1b22ca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108142a1c96d7e897b2e69bb1b22ca92">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="ae0c05e9518e81d651b9e09568274d444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c05e9518e81d651b9e09568274d444">&#9670;&nbsp;</a></span>~DoFCellAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::~<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b2870a690c665b4cb0c0176c6944682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2870a690c665b4cb0c0176c6944682">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td>
          <td class="paramname"><em>da</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. These operators are usually used in a context like <code>iterator a,b; *a=*b;</code>. Presumably, the intent here is to copy the object pointed to by <code>b</code> to the object pointed to by <code>a</code>. However, the result of dereferencing an iterator is not an object but an accessor; consequently, this operation is not useful for iterators on DoF handler objects. Consequently, this operator is declared as deleted and can not be used. </p>

</div>
</div>
<a id="a01d175bf33624dd27a239239d1896d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d175bf33624dd27a239239d1896d3e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator. </p>

</div>
</div>
<a id="ae3e7d1c5c9bacd29de30a6ca648b9de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7d1c5c9bacd29de30a6ca648b9de7">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the parent of this cell as a DoF cell iterator. If the parent does not exist (i.e., if the object is at the coarsest level of the mesh hierarchy), an exception is generated.</p>
<p>This function is needed since the parent function of the base class <a class="el" href="classCellAccessor.html">CellAccessor</a> returns a triangulation cell accessor without access to the DoF data. </p>

</div>
</div>
<a id="a83f4b0d83f95157c8563e74012997ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f4b0d83f95157c8563e74012997ab5">&#9670;&nbsp;</a></span>neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>ith</code> neighbor as a DoF cell iterator. This function is needed since the neighbor function of the base class returns a cell accessor without access to the DoF data. </p>

</div>
</div>
<a id="a9a08c59c362342524500047db9f19eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a08c59c362342524500047db9f19eae">&#9670;&nbsp;</a></span>periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>ith</code> periodic neighbor as a DoF cell iterator. This function is needed since the neighbor function of the base class returns a cell accessor without access to the DoF data. </p>

</div>
</div>
<a id="ad80f30bcb7c29e1ae187df30d61ad8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad80f30bcb7c29e1ae187df30d61ad8c0">&#9670;&nbsp;</a></span>neighbor_or_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::neighbor_or_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>ith</code> neighbor or periodic neighbor as a DoF cell iterator. This function is needed since the neighbor function of the base class returns a cell accessor without access to the DoF data. </p>

</div>
</div>
<a id="a658978b9f615b5c1e1351cff86fe5749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658978b9f615b5c1e1351cff86fe5749">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <code>ith</code> child as a DoF cell iterator. This function is needed since the child function of the base class returns a cell accessor without access to the DoF data. </p>

</div>
</div>
<a id="a0133b5a7c0b2e585b1712f01cb2e2187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0133b5a7c0b2e585b1712f01cb2e2187">&#9670;&nbsp;</a></span>child_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dimension_&gt;::max_children_per_cell&gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::child_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of iterators to all children of this cell. </p>

</div>
</div>
<a id="a17d70e743293a3b7b63b8f9e2dba70d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d70e743293a3b7b63b8f9e2dba70d2">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator to the <code>ith</code> face of this cell.</p>
<p>This function returns a <a class="el" href="classDoFAccessor.html">DoFAccessor</a> with <code>structdim == 0</code> in 1D, a <a class="el" href="classDoFAccessor.html#aad0cb2f5249c0ee51e693366e40e1388">DoFAccessor::line</a> in 2D, and a <a class="el" href="classDoFAccessor.html#a7ad78d479734c818ddd3c928bb5e1537">DoFAccessor::quad</a> in 3d. </p>

</div>
</div>
<a id="a706e62b6e969a1c7554d6b0e08391ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706e62b6e969a1c7554d6b0e08391ea3">&#9670;&nbsp;</a></span>face_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;<a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dimension_&gt;::faces_per_cell&gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an array of iterators to all faces of this cell. </p>

</div>
</div>
<a id="acf6b3ae7147febfdb34f214dad849a09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf6b3ae7147febfdb34f214dad849a09">&#9670;&nbsp;</a></span>neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the result of the <code>neighbor_child_on_subface</code> function of the base class, but convert it so that one can also access the DoF data (the function in the base class only returns an iterator with access to the triangulation data). </p>

</div>
</div>
<a id="afe02ec205e8cc8697a4324e3cd0d2b42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe02ec205e8cc8697a4324e3cd0d2b42">&#9670;&nbsp;</a></span>periodic_neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::periodic_neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the result of the <code>periodic_neighbor_child_on_subface</code> function of the base class, but convert it so that one can also access the DoF data (the function in the base class only returns an iterator with access to the triangulation data). </p>

</div>
</div>
<a id="a1702d1e9c1cb4fb07b70c38ac9165aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1702d1e9c1cb4fb07b70c38ac9165aaa">&#9670;&nbsp;</a></span>get_dof_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect the values of the given vector restricted to the dofs of this cell in the standard ordering: dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1, etc, dofs on quad 0, etc. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">gather operation</a>.</p>
<p>The vector has to have the right size before being passed to this function. This function is only callable for active cells.</p>
<p>The input vector may be either a <code>Vector&lt;float&gt;</code>, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, or a BlockVector&lt;double&gt;, or a PETSc or Trilinos vector if deal.II is compiled to support these libraries. It is in the responsibility of the caller to assure that the types of the numbers stored in input and output vectors are compatible and with similar accuracy. </p>

</div>
</div>
<a id="a4533f34e152298586da408827f8bac1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4533f34e152298586da408827f8bac1a">&#9670;&nbsp;</a></span>get_dof_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect the values of the given vector restricted to the dofs of this cell in the standard ordering: dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1, etc, dofs on quad 0, etc. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">gather operation</a>.</p>
<p>The vector has to have the right size before being passed to this function. This function is only callable for active cells.</p>
<p>The input vector may be either a <code>Vector&lt;float&gt;</code>, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, or a BlockVector&lt;double&gt;, or a PETSc or Trilinos vector if deal.II is compiled to support these libraries. It is in the responsibility of the caller to assure that the types of the numbers stored in input and output vectors are compatible and with similar accuracy. </p>

</div>
</div>
<a id="a55050e07d9458ccc01a0456313d230f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55050e07d9458ccc01a0456313d230f4">&#9670;&nbsp;</a></span>get_dof_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Collect the values of the given vector restricted to the dofs of this cell in the standard ordering: dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1, etc, dofs on quad 0, etc. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">gather operation</a>.</p>
<p>The vector has to have the right size before being passed to this function. This function is only callable for active cells.</p>
<p>The input vector may be either a <code>Vector&lt;float&gt;</code>, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, or a BlockVector&lt;double&gt;, or a PETSc or Trilinos vector if deal.II is compiled to support these libraries. It is in the responsibility of the caller to assure that the types of the numbers stored in input and output vectors are compatible and with similar accuracy. The <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object passed as an argument to this function makes sure that constraints are correctly distributed when the dof values are calculated. </p>

</div>
</div>
<a id="abd3ca14113486423a02d9dcf281d1511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3ca14113486423a02d9dcf281d1511">&#9670;&nbsp;</a></span>set_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class OutputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the counterpart to <a class="el" href="classDoFCellAccessor.html#a1702d1e9c1cb4fb07b70c38ac9165aaa">get_dof_values()</a>: it takes a vector of values for the degrees of freedom of the cell pointed to by this iterator and writes these values into the global data vector <code>values</code>. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>. This function is only callable for active cells.</p>
<p>Note that for continuous finite elements, calling this function affects the dof values on neighboring cells as well. It may also violate continuity requirements for hanging nodes, if neighboring cells are less refined than the present one. These requirements are not taken care of and must be enforced by the user afterwards.</p>
<p>The vector has to have the right size before being passed to this function.</p>
<p>The output vector may be either a Vector&lt;float&gt;, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, or a BlockVector&lt;double&gt;, or a PETSc vector if deal.II is compiled to support these libraries. It is in the responsibility of the caller to assure that the types of the numbers stored in input and output vectors are compatible and with similar accuracy. </p>

</div>
</div>
<a id="a75210f15c0f8f837325de80792660c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75210f15c0f8f837325de80792660c33">&#9670;&nbsp;</a></span>get_interpolated_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_interpolated_dof_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolated_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;&#160;dimension_,&#160;space_dimension_&#160;&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the interpolation of the given finite element function to the present cell. In the simplest case, the cell is a terminal one, i.e., it has no children; then, the returned value is the vector of nodal values on that cell. You could as well get the desired values through the <code>get_dof_values</code> function. In the other case, when the cell has children, we use the restriction matrices provided by the finite element class to compute the interpolation from the children to the present cell.</p>
<p>If the cell is part of a <a class="el" href="classDoFHandler.html">DoFHandler</a> with hp-capabilities, cells only have an associated finite element space if they are active. However, this function is supposed to also provide information on inactive cells with children. Consequently, it carries a third argument that can be used in the hp-context that denotes the finite element space we are supposed to interpolate onto. If the cell is active, this function then obtains the finite element function from the <code>values</code> vector on this cell and interpolates it onto the space described by the <code>fe_index</code>th element of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> of which this cell is a part of. If the cell is not active, then we first perform this interpolation on all of its terminal children and then interpolate this function down to the cell requested keeping the function space the same.</p>
<p>It is assumed that both input vectors already have the right size beforehand.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike the <a class="el" href="classDoFCellAccessor.html#a1702d1e9c1cb4fb07b70c38ac9165aaa">get_dof_values()</a> function, this function is only available on cells, rather than on lines, quads, and hexes, since interpolation is presently only provided for cells by the finite element classes. </dd></dl>

</div>
</div>
<a id="accf660b09b5b05d80befa10ddfa928fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accf660b09b5b05d80befa10ddfa928fa">&#9670;&nbsp;</a></span>set_dof_values_by_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class OutputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_dof_values_by_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;&#160;dimension_,&#160;space_dimension_&#160;&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is the counterpart to <a class="el" href="classDoFCellAccessor.html#a75210f15c0f8f837325de80792660c33">get_interpolated_dof_values()</a>: you specify the dof values on a cell and these are interpolated to the children of the present cell and set on the terminal cells.</p>
<p>In principle, it works as follows: if the cell pointed to by this object is terminal (i.e., has no children), then the dof values are set in the global data vector by calling the <a class="el" href="classDoFCellAccessor.html#abd3ca14113486423a02d9dcf281d1511">set_dof_values()</a> function; otherwise, the values are prolonged to each of the children and this function is called for each of them.</p>
<p>Using the <a class="el" href="classDoFCellAccessor.html#a75210f15c0f8f837325de80792660c33">get_interpolated_dof_values()</a> and this function, you can compute the interpolation of a finite element function to a coarser grid by first getting the interpolated solution on a cell of the coarse grid and afterwards redistributing it using this function.</p>
<p>Note that for continuous finite elements, calling this function affects the dof values on neighboring cells as well. It may also violate continuity requirements for hanging nodes, if neighboring cells are less refined than the present one, or if their children are less refined than the children of this cell. These requirements are not taken care of and must be enforced by the user afterward.</p>
<p>If the cell is part of a <a class="el" href="classDoFHandler.html">DoFHandler</a> with hp-capabilities, cells only have an associated finite element space if they are active. However, this function is supposed to also work on inactive cells with children. Consequently, it carries a third argument that can be used in the hp- context that denotes the finite element space we are supposed to interpret the input vector of this function in. If the cell is active, this function then interpolates the input vector interpreted as an element of the space described by the <code>fe_index</code>th element of the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> associated with the <a class="el" href="classDoFHandler.html">DoFHandler</a> of which this cell is a part of, and interpolates it into the space that is associated with this cell. On the other hand, if the cell is not active, then we first perform this interpolation from this cell to its children using the given <code>fe_index</code> until we end up on an active cell, at which point we follow the procedure outlined at the beginning of the paragraph.</p>
<p>It is assumed that both vectors already have the right size beforehand. This function relies on the existence of a natural interpolation property of finite element spaces of a cell to its children, denoted by the prolongation matrices of finite element classes. For some elements, the spaces on coarse and fine grids are not nested, in which case the interpolation to a child is not the identity; refer to the documentation of the respective finite element class for a description of what the prolongation matrices represent in this case.</p>
<dl class="section note"><dt>Note</dt><dd>Unlike the <a class="el" href="classDoFCellAccessor.html#a1702d1e9c1cb4fb07b70c38ac9165aaa">get_dof_values()</a> function, this function is only available on cells, rather than on lines, quads, and hexes, since interpolation is presently only provided for cells by the finite element classes. </dd></dl>

</div>
</div>
<a id="a4b373ea3845c1be186681ceb4d1d28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b373ea3845c1be186681ceb4d1d28f8">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename number , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distribute a local (cell based) vector to a global one by mapping the local numbering of the degrees of freedom to the global one and entering the local values into the global vector. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>.</p>
<p>The elements are <em>added</em> to the existing elements in the global vector, rather than just set, since this is usually what one wants. You may also want to take a look at the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> function if you need to deal with constraints. </p>

</div>
</div>
<a id="add2ea6075920c592b31132352385415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2ea6075920c592b31132352385415d">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distribute a local (cell based) vector in iterator format to a global one by mapping the local numbering of the degrees of freedom to the global one and entering the local values into the global vector. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>.</p>
<p>The elements are <em>added</em> to the existing elements in the global vector, rather than just set, since this is usually what one wants. You may also want to take a look at the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> function if you need to deal with constraints. </p>

</div>
</div>
<a id="ab90bb534e64a5a9c10d9f6a161c1a0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90bb534e64a5a9c10d9f6a161c1a0c5">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Distribute a local (cell based) vector in iterator format to a global one by mapping the local numbering of the degrees of freedom to the global one and entering the local values into the global vector. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>.</p>
<p>The elements are <em>added</em> up to the elements in the global vector, rather than just set, since this is usually what one wants. Moreover, the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object passed to this function makes sure that also constraints are eliminated in this process. </p>

</div>
</div>
<a id="a629b9490f29a4b030dd897a733116ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629b9490f29a4b030dd897a733116ccb">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename number , typename OutputMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputMatrix &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does much the same as the <code>distribute_local_to_global(Vector,Vector)</code> function, but operates on matrices instead of vectors. If the matrix type is a sparse matrix then it is supposed to have non-zero entry slots where required. </p>

</div>
</div>
<a id="ab0917cd50db0119a5efe0309ec13370f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0917cd50db0119a5efe0309ec13370f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename number , typename OutputMatrix , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputMatrix &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does what the two <code>distribute_local_to_global</code> functions with vector and matrix argument do, but all at once. </p>

</div>
</div>
<a id="a15ef35e919b1005dc6050f9bca96956d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef35e919b1005dc6050f9bca96956d">&#9670;&nbsp;</a></span>get_active_or_mg_dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_active_or_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Obtain the global indices of the local degrees of freedom on this cell.</p>
<p>If this object accesses a level cell (indicated by the third template argument or <a class="el" href="classDoFAccessor.html#ade1461f1a5ea5564fcc1ba2be6641f10">is_level_cell</a>), then return the result of <a class="el" href="classDoFCellAccessor.html#ad5b7ee5a2c16b2dfacd9139bed6bed4d">get_mg_dof_indices()</a>, else return <a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">get_dof_indices()</a>.</p>
<p>You will get a level_cell_iterator when calling begin_mg() and a normal one otherwise.</p>
<p>Examples for this use are in the implementation of <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a>. </p>

</div>
</div>
<a id="aeab120d78d3fdf70cf83a52b870ec8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab120d78d3fdf70cf83a52b870ec8d6">&#9670;&nbsp;</a></span>get_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <em>global</em> indices of the degrees of freedom located on this object in the standard ordering defined by the finite element (i.e., dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1, etc, dofs on quad 0, etc.) This function is only available on <em>active</em> objects (see <a class="el" href="DEALGlossary.html#GlossActive">this glossary entry</a>).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dof_indices</td><td>The vector into which the indices will be written. It has to have the right size (namely, <code>fe.n_dofs_per_cell()</code>, <code>fe.dofs_per_face</code>, or <code>fe.dofs_per_line</code>, depending on which kind of object this function is called) before being passed to this function.</td></tr>
  </table>
  </dd>
</dl>
<p>This function reimplements the same function in the base class. In contrast to the function in the base class, we do not need the <code>fe_index</code> here because there is always a unique finite element index on cells.</p>
<p>This is a function which requires that the cell is active.</p>
<p>Also see <a class="el" href="classDoFCellAccessor.html#a15ef35e919b1005dc6050f9bca96956d">get_active_or_mg_dof_indices()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>In many places in the tutorial and elsewhere in the library, the argument to this function is called <code>local_dof_indices</code> by convention. The name is not meant to indicate the <em>local</em> numbers of degrees of freedom (which are always between zero and <code>fe.n_dofs_per_cell()</code>) but instead that the returned values are the <em>global</em> indices of those degrees of freedom that are located locally on the current cell. </dd></dl>

</div>
</div>
<a id="ad5b7ee5a2c16b2dfacd9139bed6bed4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b7ee5a2c16b2dfacd9139bed6bed4d">&#9670;&nbsp;</a></span>get_mg_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the global indices of the degrees of freedom on this cell in the level vector associated to the level of the cell. </p>

</div>
</div>
<a id="ace7438827be3421cdb64c67f28c7aa60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7438827be3421cdb64c67f28c7aa60">&#9670;&nbsp;</a></span>get_fe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dimension_, space_dimension_&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the finite element that is used on the cell pointed to by this iterator. For <a class="el" href="classDoFHandler.html">DoFHandler</a> objects without hp-capabilities, this is of course always the same element, independent of the cell we are presently on, but for hp-DoFHandler objects this may change from cell to cell.</p>
<dl class="section note"><dt>Note</dt><dd>Since degrees of freedom only exist on active cells for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities (i.e., there is currently no implementation of multilevel such objects), it does not make sense to query the finite element on non-active cells since they do not have finite element spaces associated with them without having any degrees of freedom. Consequently, this function will produce an exception when called on non-active cells. </dd></dl>

</div>
</div>
<a id="a5a196a66be2e332d0f302e6b579f47fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a196a66be2e332d0f302e6b579f47fe">&#9670;&nbsp;</a></span>active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::active_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the index inside the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> of the <a class="el" href="classFiniteElement.html">FiniteElement</a> used for this cell. This function is only useful if the <a class="el" href="classDoFHandler.html">DoFHandler</a> object associated with the current cell has hp-capabilities enabled.</p>
<dl class="section note"><dt>Note</dt><dd>Since degrees of freedom only exist on active cells for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities (i.e., there is currently no implementation of multilevel such objects), it does not make sense to query the finite element on non-active cells since they do not have finite element spaces associated with them without having any degrees of freedom. Consequently, this function will produce an exception when called on non-active cells.</dd>
<dd>
When using parallel meshes, either through the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> classes, it is only allowed to call this function on locally owned or ghost cells. No information is available on artificial cells. Furthermore, <code>active_fe_index</code> information is only exchanged from locally owned cells on one processor to other processors where they may be ghost cells, during the call to <a class="el" href="classDoFHandler.html#a9bfa2a27515e777f79bd98ec345fcdda">DoFHandler::set_fe()</a> and <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>. Be aware that if you call <a class="el" href="classDoFCellAccessor.html#a44babdcd7954cdfdd9f9497781cc22ae">set_active_fe_index()</a> on a cell after calling one of these functions, then this information will not be propagated to other processors who may have this cell as a ghost cell. See the documentation of <a class="el" href="classDoFHandler.html">DoFHandler</a> for more information. </dd></dl>

</div>
</div>
<a id="a44babdcd7954cdfdd9f9497781cc22ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44babdcd7954cdfdd9f9497781cc22ae">&#9670;&nbsp;</a></span>set_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the index of the <a class="el" href="classFiniteElement.html">FiniteElement</a> used for this cell. This determines which element in an <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> to use. This function is only useful if the DoF handler object associated with the current cell has hp- capabilities enabled.</p>
<dl class="section note"><dt>Note</dt><dd>Since degrees of freedom only exist on active cells for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities (i.e., there is currently no implementation of multilevel such objects), it does not make sense to query the finite element on non-active cells since they do not have finite element spaces associated with them without having any degrees of freedom. Consequently, this function will produce an exception when called on non-active cells.</dd>
<dd>
When using parallel meshes, either through the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> classes, it is only allowed to call this function on locally owned or ghost cells. No information is available on artificial cells. Furthermore, <code>active_fe_index</code> information is only exchanged from locally owned cells on one processor to other processors where they may be ghost cells, during the call to <a class="el" href="classDoFHandler.html#a9bfa2a27515e777f79bd98ec345fcdda">DoFHandler::set_fe()</a> and <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>. Be aware that if you call <a class="el" href="classDoFCellAccessor.html#a44babdcd7954cdfdd9f9497781cc22ae">set_active_fe_index()</a> on a cell after calling one of these functions, then this information will not be propagated to other processors who may have this cell as a ghost cell. See the documentation of <a class="el" href="classDoFHandler.html">DoFHandler</a> for more information. </dd></dl>

</div>
</div>
<a id="a420232a0d0f5e4935e4e088599d70219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420232a0d0f5e4935e4e088599d70219">&#9670;&nbsp;</a></span>set_dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the DoF indices of this cell to the given values. This function bypasses the DoF cache, if one exists for the given DoF handler class. </p>

</div>
</div>
<a id="ac76cef754ca3b14d1f13ef2c01a4a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76cef754ca3b14d1f13ef2c01a4a999">&#9670;&nbsp;</a></span>set_mg_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the Level DoF indices of this cell to the given values. </p>

</div>
</div>
<a id="a10f15ef7cc39b0cec739222b6728a65c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f15ef7cc39b0cec739222b6728a65c">&#9670;&nbsp;</a></span>update_cell_dof_indices_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::update_cell_dof_indices_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Update the cache in which we store the dof indices of this cell. </p>

</div>
</div>
<a id="a7558706ae1d781bf54ec29f85e862d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7558706ae1d781bf54ec29f85e862d62">&#9670;&nbsp;</a></span>get_future_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dimension_, space_dimension_&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_future_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the finite element that will be assigned to this cell next time the triangulation gets refined and coarsened. If no future finite element has been specified for this cell via the <a class="el" href="classDoFCellAccessor.html#ab9f2896ef67d3d11ec3d23d382b19c46">set_future_fe_index()</a> function, the active one will remain unchanged, in which case the active finite element will be returned.</p>
<p>For DoFHandlers without hp-capabilities enabled, this is of course always the same element, independent of the cell we are presently on, but for hp- <a class="el" href="classDoFHandler.html">DoFHandler</a> objects this may change from cell to cell.</p>
<dl class="section note"><dt>Note</dt><dd>Since degrees of freedom only exist on active cells for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities (i.e., there is currently no implementation of multilevel such objects), it does not make sense to query the finite element on non-active cells since they do not have finite element spaces associated with them without having any degrees of freedom. Consequently, this function will produce an exception when called on non-active cells. </dd></dl>

</div>
</div>
<a id="ae4d4d8562cb47b70b797369b8872b04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d4d8562cb47b70b797369b8872b04d">&#9670;&nbsp;</a></span>future_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::future_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the fe_index of the finite element that will be assigned to this cell next time the triangulation gets refined and coarsened. If no future finite element has been specified for this cell via the <a class="el" href="classDoFCellAccessor.html#ab9f2896ef67d3d11ec3d23d382b19c46">set_future_fe_index()</a> function, the active one will remain unchanged, in which case the fe_index of the active finite element will be returned.</p>
<dl class="section note"><dt>Note</dt><dd>Since degrees of freedom only exist on active cells for <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities (i.e., there is currently no implementation of multilevel such objects), it does not make sense to query the finite element on non-active cells since they do not have finite element spaces associated with them without having any degrees of freedom. Consequently, this function will produce an exception when called on non-active cells.</dd>
<dd>
When using parallel meshes, either through the <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> classes, it is only allowed to call this function on locally owned cells. </dd></dl>

</div>
</div>
<a id="ab9f2896ef67d3d11ec3d23d382b19c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f2896ef67d3d11ec3d23d382b19c46">&#9670;&nbsp;</a></span>set_future_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_future_fe_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the fe_index of the finite element that will be assigned to this cell next time the triangulation gets refined and coarsened. A previously assigned future finite element will be overwritten.</p>
<p>See notes of <a class="el" href="classDoFCellAccessor.html#ae4d4d8562cb47b70b797369b8872b04d">future_fe_index()</a> for information about restrictions on this functionality. </p>

</div>
</div>
<a id="ae7949017e7a76aa15c2dcff7871401e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7949017e7a76aa15c2dcff7871401e1">&#9670;&nbsp;</a></span>future_fe_index_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::future_fe_index_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether a future finite element has been set.</p>
<p>See notes of <a class="el" href="classDoFCellAccessor.html#ae4d4d8562cb47b70b797369b8872b04d">future_fe_index()</a> for information about restrictions on this functionality. </p>

</div>
</div>
<a id="aa67f45fd024b1a960c2f67920dbab58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67f45fd024b1a960c2f67920dbab58c">&#9670;&nbsp;</a></span>clear_future_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::clear_future_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Revoke the future finite element assigned. Thus, the active finite element will remain unchanged next time the triangulation gets refined and coarsened.</p>
<p>See notes on <a class="el" href="classDoFCellAccessor.html#ae4d4d8562cb47b70b797369b8872b04d">future_fe_index()</a> for information about restrictions on this functionality. </p>

</div>
</div>
<a id="a49329d7429a4dad355b2b8c859e7e60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49329d7429a4dad355b2b8c859e7e60a">&#9670;&nbsp;</a></span>get_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>&gt;&amp; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a handle on the <a class="el" href="classDoFHandler.html">DoFHandler</a> object which we are using. </p>

</div>
</div>
<a id="aa2203fb607f6ae1f79d860a41efdf37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2203fb607f6ae1f79d860a41efdf37c">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, dim, spacedim, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implement the copy operator needed for the iterator classes. </p>

</div>
</div>
<a id="a9a040127cdbb584aefbf38779ca7ac57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a040127cdbb584aefbf38779ca7ac57">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>da</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator used by the iterator class. Keeps the previously set dof handler, but sets the object coordinates of the <a class="el" href="classTriaAccessor.html">TriaAccessor</a>. </p>

</div>
</div>
<a id="ade1461f1a5ea5564fcc1ba2be6641f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1461f1a5ea5564fcc1ba2be6641f10">&#9670;&nbsp;</a></span>is_level_cell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::is_level_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tell the caller whether <a class="el" href="classDoFCellAccessor.html#a15ef35e919b1005dc6050f9bca96956d">get_active_or_mg_dof_indices()</a> accesses active or level dofs. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l02153">2153</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="aad0cb2f5249c0ee51e693366e40e1388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cb2f5249c0ee51e693366e40e1388">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::DoFHandlerImplementation:: Iterators&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access&gt;::line_iterator <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> line bounding this object. If the current object is a line itself, then the only valid index is <code>i</code> equals to zero, and the function returns an iterator to itself. </p>

</div>
</div>
<a id="a7ad78d479734c818ddd3c928bb5e1537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad78d479734c818ddd3c928bb5e1537">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::DoFHandlerImplementation:: Iterators&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access&gt;::quad_iterator <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <code>ith</code> quad bounding this object. If the current object is a quad itself, then the only valid index is <code>i</code> equals to zero, and the function returns an iterator to itself. </p>

</div>
</div>
<a id="a9553dfc2e807a7bce21a950e938a3e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9553dfc2e807a7bce21a950e938a3e9f">&#9670;&nbsp;</a></span>get_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <em>global</em> indices of the degrees of freedom located on this object in the standard ordering defined by the finite element (i.e., dofs on vertex 0, dofs on vertex 1, etc, dofs on line 0, dofs on line 1, etc, dofs on quad 0, etc.) This function is only available on <em>active</em> objects (see <a class="el" href="DEALGlossary.html#GlossActive">this glossary entry</a>).</p>
<p>The cells needs to be an active cell (and not artificial in a parallel distributed computation).</p>
<p>The vector has to have the right size before being passed to this function.</p>
<p>The last argument denotes the finite element index. For the standard <a class="el" href="classDoFHandler.html">DoFHandler</a> class, this value must be equal to its default value since that class only supports the same finite element on all cells anyway.</p>
<p>However, when the relevant <a class="el" href="classDoFHandler.html">DoFHandler</a> object has hp-capabilities enabled, different finite element objects may be used on different cells. On faces between two cells, as well as vertices, there may therefore be two sets of degrees of freedom, one for each of the finite elements used on the adjacent cells. In order to specify which set of degrees of freedom to work on, the last argument is used to disambiguate. Finally, if this function is called for a cell object, there can only be a single set of degrees of freedom, and fe_index has to match the result of <a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index()</a>.</p>
<p>For cells, there is only a single possible finite element index (namely the one for that cell, returned by <code>cell-&gt;active_fe_index</code>. Consequently, the derived <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> class has an overloaded version of this function that calls the present function with <code>cell-&gt;active_fe_index</code> as last argument. </p>

</div>
</div>
<a id="adeace582710e57d3d8911e77d73a8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeace582710e57d3d8911e77d73a8b55">&#9670;&nbsp;</a></span>get_mg_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global multilevel indices of the degrees of freedom that live on the current object with respect to the given level within the multigrid hierarchy. The indices refer to the local numbering for the level this line lives on. </p>

</div>
</div>
<a id="a4564ad65573f50f8b3d02dfb6d07e0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4564ad65573f50f8b3d02dfb6d07e0ac">&#9670;&nbsp;</a></span>set_mg_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the level DoF indices that are returned by get_mg_dof_indices. </p>

</div>
</div>
<a id="a5aa1f2d13ea10d3e36d7fc6d982467ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa1f2d13ea10d3e36d7fc6d982467ed">&#9670;&nbsp;</a></span>vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global DoF index of the <em>i</em> degree associated with the <code>vertexth</code> vertex of the present cell.</p>
<p>The last argument denotes the finite element index. For the standard <a class="el" href="classDoFHandler.html">DoFHandler</a> class, this value must be equal to its default value since that class only supports the same finite element on all cells anyway.</p>
<p>However, when hp-capabilities are enabled, different finite element objects may be used on different cells. On faces between two cells, as well as vertices, there may therefore be two sets of degrees of freedom, one for each of the finite elements used on the adjacent cells. In order to specify which set of degrees of freedom to work on, the last argument is used to disambiguate. Finally, if this function is called for a cell object, there can only be a single set of degrees of freedom, and fe_index has to match the result of <a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index()</a>. </p>

</div>
</div>
<a id="acc4402930fd9d6e7745befbf0028cd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4402930fd9d6e7745befbf0028cd59">&#9670;&nbsp;</a></span>mg_vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::mg_vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global DoF index of the <code>i</code>th degree of freedom associated with the <code>vertex</code>th vertex on level <code>level</code>. Also see <a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">vertex_dof_index()</a>. </p>

</div>
</div>
<a id="a65cc20ce96d8d7501d113c578ecb2ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cc20ce96d8d7501d113c578ecb2ea8">&#9670;&nbsp;</a></span>dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index of the <em>i</em>th degree of freedom of this object.</p>
<p>The last argument denotes the finite element index. For the standard <a class="el" href="classDoFHandler.html">DoFHandler</a> class, this value must be equal to its default value since that class only supports the same finite element on all cells anyway.</p>
<p>However, when hp-capabilities are enabled, different finite element objects may be used on different cells. On faces between two cells, as well as vertices, there may therefore be two sets of degrees of freedom, one for each of the finite elements used on the adjacent cells. In order to specify which set of degrees of freedom to work on, the last argument is used to disambiguate. Finally, if this function is called for a cell object, there can only be a single set of degrees of freedom, and fe_index has to match the result of <a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>While the <a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">get_dof_indices()</a> function returns an array that contains the indices of all degrees of freedom that somehow live on this object (i.e. on the vertices, edges or interior of this object), the current <a class="el" href="classDoFAccessor.html#a65cc20ce96d8d7501d113c578ecb2ea8">dof_index()</a> function only considers the DoFs that really belong to this particular object's interior. In other words, as an example, if the current object refers to a quad (a cell in 2d, a face in 3d) and the finite element associated with it is a bilinear one, then the <a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">get_dof_indices()</a> will return an array of size 4 while <a class="el" href="classDoFAccessor.html#a65cc20ce96d8d7501d113c578ecb2ea8">dof_index()</a> will produce an exception because no degrees are defined in the interior of the face. </dd></dl>

</div>
</div>
<a id="acad7c02ba6168b40bca90e4fb8c2f8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7c02ba6168b40bca90e4fb8c2f8ee">&#9670;&nbsp;</a></span>mg_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::mg_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the dof_index on the given level. Also see dof_index. </p>

</div>
</div>
<a id="ad3a5c19a4bf840dad9e1185d78526b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a5c19a4bf840dad9e1185d78526b4b">&#9670;&nbsp;</a></span>n_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::n_active_fe_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of finite elements that are active on a given object.</p>
<p>When hp-capabilities are disabled the answer is, of course, always one. However, when hp-capabilities are enabled, this isn't the case: If this is a cell, the answer is of course one. If it is a face, the answer may be one or two, depending on whether the two adjacent cells use the same finite element or not. If it is an edge in 3d, the possible return value may be one or any other value larger than that. </p>

</div>
</div>
<a id="add0021f581f717926769d03779c8739c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0021f581f717926769d03779c8739c">&#9670;&nbsp;</a></span>nth_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::nth_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the <code>n-th</code> active FE index on this object. For cells and all non- hp-objects, there is only a single active FE index, so the argument must be equal to zero. For lower-dimensional hp-objects, there are <a class="el" href="classDoFAccessor.html#ad3a5c19a4bf840dad9e1185d78526b4b">n_active_fe_indices()</a> active finite elements, and this function can be queried for their indices. </p>

</div>
</div>
<a id="a5cc4f3541c18e4f2c59fd39061fd4caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc4f3541c18e4f2c59fd39061fd4caf">&#9670;&nbsp;</a></span>get_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_active_fe_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns all active FE indices on this object.</p>
<p>The size of the returned set equals the number of finite elements that are active on this object. </p>

</div>
</div>
<a id="aa107e710976f26c4ab9a49275c5ce23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa107e710976f26c4ab9a49275c5ce23c">&#9670;&nbsp;</a></span>fe_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::fe_index_is_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the finite element with given index is active on the present object. When the current <a class="el" href="classDoFHandler.html">DoFHandler</a> does not have hp- capabilities, this is of course the case only if <code>fe_index</code> equals zero. For cells, it is the case if <code>fe_index</code> equals <a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index()</a> of this cell. For faces and other lower- dimensional objects, there may be more than one <code>fe_index</code> that are active on any given object (see <a class="el" href="classDoFAccessor.html#ad3a5c19a4bf840dad9e1185d78526b4b">n_active_fe_indices()</a>). </p>

</div>
</div>
<a id="ad067228a1d5ae86639f2719b84a71c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad067228a1d5ae86639f2719b84a71c9e">&#9670;&nbsp;</a></span>get_fe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>&gt;&amp; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the finite element used on this object with the given <code>fe_index</code>. <code>fe_index</code> must be used on this object, i.e. <code>fe_index_is_active(fe_index)</code> must return true. </p>

</div>
</div>
<a id="ga36b9816a464913e80b640d7778b6a2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36b9816a464913e80b640d7778b6a2a6">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidObject&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;This accessor object has not been &quot; &quot;associated with any <a class="el" href="classDoFHandler.html">DoFHandler</a> object.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="namespaceExceptions.html">Exceptions</a> for child classes </p>

</div>
</div>
<a id="gace9faa28de1bfa14fe42acae5ec0c795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9faa28de1bfa14fe42acae5ec0c795">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorNotEmpty&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga9f84a1c8defd39d3e0ce848f2c1f6caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f84a1c8defd39d3e0ce848f2c1f6caf">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorDoesNotMatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga4c716f4f4f6718bca364135fa8980527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c716f4f4f6718bca364135fa8980527">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcMatrixDoesNotMatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga0fe397e0b77ee7550e2394ba96f7fb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe397e0b77ee7550e2394ba96f7fb70">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNotActive&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function has been called for a cell which should be <a class="el" href="DEALGlossary.html#GlossActive">active</a>, but is refined. </p>

</div>
</div>
<a id="ga00741f1400034d3faca2ca3bed41b29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00741f1400034d3faca2ca3bed41b29a">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcCantCompareIterators&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ac6ae8fec03877b971fd7832d92704be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ae8fec03877b971fd7832d92704be4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality. Return <code>true</code> if the two accessors refer to the same object.</p>
<p>The template parameters of this function allow for a comparison of very different objects. Therefore, some of them are disabled. Namely, if the dimension, or the dof handler of the two objects differ, an exception is generated. It can be expected that this is an unwanted comparison.</p>
<p>The template parameter <code>level_dof_access2</code> is ignored, such that an iterator with level access can be equal to one with access to the active degrees of freedom. </p>

</div>
</div>
<a id="a90137a1310b0ec72b89cfb60e1f51145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90137a1310b0ec72b89cfb60e1f51145">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for inequality. The boolean not of <a class="el" href="classDoFAccessor.html#ac6ae8fec03877b971fd7832d92704be4">operator==()</a>. </p>

</div>
</div>
<a id="a616da3ae411e1649bc75ed330f756388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616da3ae411e1649bc75ed330f756388">&#9670;&nbsp;</a></span>set_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_dof_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>dh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reset the DoF handler pointer. </p>

</div>
</div>
<a id="abe3cdc6b6fa4abf71bdec21c022c0506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3cdc6b6fa4abf71bdec21c022c0506">&#9670;&nbsp;</a></span>set_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the index of the <em>i</em>th degree of freedom of this object to <code>index</code>.</p>
<p>The last argument denotes the finite element index. For the standard <a class="el" href="classDoFHandler.html">DoFHandler</a> class, this value must be equal to its default value since that class only supports the same finite element on all cells anyway.</p>
<p>However, when the relevant <a class="el" href="classDoFHandler.html">DoFHandler</a> has hp-capabilities, different finite element objects may be used on different cells. On faces between two cells, as well as vertices, there may therefore be two sets of degrees of freedom, one for each of the finite elements used on the adjacent cells. In order to specify which set of degrees of freedom to work on, the last argument is used to disambiguate. Finally, if this function is called for a cell object, there can only be a single set of degrees of freedom, and fe_index has to match the result of <a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index()</a>. </p>

</div>
</div>
<a id="a17282fe1c8b6b2131f01455871065e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17282fe1c8b6b2131f01455871065e0a">&#9670;&nbsp;</a></span>set_mg_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_mg_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac48185a4fe62cf31fb6313777072e233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48185a4fe62cf31fb6313777072e233">&#9670;&nbsp;</a></span>set_vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the global index of the <em>i</em> degree on the <code>vertex-th</code> vertex of the present cell to <code>index</code>.</p>
<p>The last argument denotes the finite element index. For the standard <a class="el" href="classDoFHandler.html">DoFHandler</a> class, this value must be equal to its default value since that class only supports the same finite element on all cells anyway.</p>
<p>However, when the relevant <a class="el" href="classDoFHandler.html">DoFHandler</a> has hp-capabilities, different finite element objects may be used on different cells. On faces between two cells, as well as vertices, there may therefore be two sets of degrees of freedom, one for each of the finite elements used on the adjacent cells. In order to specify which set of degrees of freedom to work on, the last argument is used to disambiguate. Finally, if this function is called for a cell object, there can only be a single set of degrees of freedom, and fe_index has to match the result of <a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index()</a>. </p>

</div>
</div>
<a id="af521f2a697ac2b7dec0e8196933979c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af521f2a697ac2b7dec0e8196933979c4">&#9670;&nbsp;</a></span>set_mg_vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_mg_vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0f77c88bd6841a98bf02a4a398551115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f77c88bd6841a98bf02a4a398551115">&#9670;&nbsp;</a></span>DoFHandler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classDoFHandler.html">DoFHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Manage the distribution and numbering of the degrees of freedom for hp- FEM algorithms. This class satisfies the <a class="el" href="group__Concepts.html#ConceptMeshType">MeshType concept</a> requirements.</p>
<p>The purpose of this class is to allow for an enumeration of degrees of freedom in the same way as the <a class="el" href="classDoFHandler.html">DoFHandler</a> class, but it allows to use a different finite element on every cell. To this end, one assigns an <code>active_fe_index</code> to every cell that indicates which element within a collection of finite elements (represented by an object of type <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>) is the one that lives on this cell. The class then enumerates the degree of freedom associated with these finite elements on each cell of a triangulation and, if possible, identifies degrees of freedom at the interfaces of cells if they match. If neighboring cells have degrees of freedom along the common interface that do not immediate match (for example, if you have \(Q_2\) and \(Q_3\) elements meeting at a common face), then one needs to compute constraints to ensure that the resulting finite element space on the mesh remains conforming.</p>
<p>The whole process of working with objects of this type is explained in step-27. Many of the algorithms this class implements are described in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>.</p>
<h3>Active FE indices and their behavior under mesh refinement</h3>
<p>The typical workflow for using this class is to create a mesh, assign an active FE index to every active cell, calls hp::DoFHandler::distribute_dofs(), and then assemble a linear system and solve a problem on this finite element space. However, one can skip assigning active FE indices upon mesh refinement in certain circumstances. In particular, the following rules apply:</p><ul>
<li>Upon mesh refinement, child cells inherit the active FE index of the parent.</li>
<li>When coarsening cells, the (now active) parent cell will be assigned an active FE index that is determined from its (no longer active) children, following the <a class="el" href="namespaceFiniteElementDomination.html">FiniteElementDomination</a> logic: Out of the set of elements previously assigned to the former children, we choose the one dominated by all children for the parent cell. If none was found, we pick the most dominant element in the whole collection that is dominated by all former children. See <a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">hp::FECollection::find_dominated_fe_extended()</a> for further information on this topic.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>Finite elements need to be assigned to each cell by either calling set_fe() or distribute_dofs() first to make this functionality available.</dd></dl>
<h3>Active FE indices and parallel meshes</h3>
<p>When this class is used with either a <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, you can only set active FE indices on cells that are locally owned, using a call such as <code>cell-&gt;set_active_fe_index(...)</code>. On the other hand, setting the active FE index on ghost or artificial cells is not allowed.</p>
<p>Ghost cells do acquire the information what element is active on them, however: whenever you call hp::DoFHandler::distribute_dofs(), all processors that participate in the parallel mesh exchange information in such a way that the active FE index on ghost cells equals the active FE index that was set on that processor that owned that particular ghost cell. Consequently, one can <em>query</em> the <code>active_fe_index</code> on ghost cells, just not set it by hand.</p>
<p>On artificial cells, no information is available about the <code>active_fe_index</code> used there. That's because we don't even know whether these cells exist at all, and even if they did, the current processor does not know anything specific about them. See <a class="el" href="DEALGlossary.html#GlossArtificialCell">the glossary entry on artificial cells</a> for more information.</p>
<p>During refinement and coarsening, information about the <code>active_fe_index</code> of each cell will be automatically transferred.</p>
<p>However, using a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> with an <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> requires additional attention during serialization, since no information on active FE indices will be automatically transferred. This has to be done manually using the prepare_for_serialization_of_active_fe_indices() and deserialize_active_fe_indices() functions. The former has to be called before <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a5cd3a35ff1a0b49c26b3d735af5d62b3">parallel::distributed::Triangulation::save()</a> is invoked, and the latter needs to be run after <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8d8d56c4155e1ab11e9f16799c71d3a3">parallel::distributed::Triangulation::load()</a>. If further data will be attached to the triangulation via the <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a>, <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>, or <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> classes, all corresponding preparation and deserialization function calls need to happen in the same order. Consult the documentation of <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> for more information.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000040">Deprecated:</a></b></dt><dd>The basic <a class="el" href="classDoFHandler.html">DoFHandler</a> is capable of hp-adaptation now. </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l02146">2146</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a0cf63b7b7600d230112f86fe73e1afdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf63b7b7600d230112f86fe73e1afdb">&#9670;&nbsp;</a></span>::internal::DoFCellAccessorImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::DoFCellAccessorImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l02147">2147</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6d4509b7753b800d9fd7039bca79f7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4509b7753b800d9fd7039bca79f7ad">&#9670;&nbsp;</a></span>dim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::dim = dimension_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract dimension from <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01378">1378</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a8b0e36ef5665c0ad1921049acb84604e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0e36ef5665c0ad1921049acb84604e">&#9670;&nbsp;</a></span>spacedim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::spacedim = space_dimension_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Extract space dimension from <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01383">1383</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a5d8274de3efd9a8b566e3b7a27a1a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8274de3efd9a8b566e3b7a27a1a286">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static variable that allows users of this class to discover the value of the second template argument. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00219">219</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a0ebf5625b40e2ecedaaeef5f684d3fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebf5625b40e2ecedaaeef5f684d3fab">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::space_dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A static variable that allows users of this class to discover the value of the third template argument. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00225">225</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="aea85e74a2de50f84acd6b53c8e2a55e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea85e74a2de50f84acd6b53c8e2a55e1">&#9670;&nbsp;</a></span>dof_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>&gt;* <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the address of the <a class="el" href="classDoFHandler.html">DoFHandler</a> object to be accessed. </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00657">657</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/dofs/<a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
