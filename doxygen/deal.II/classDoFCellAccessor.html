<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDoFCellAccessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classDoFCellAccessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a><a class="el" href="group__grid.html">Grids and Triangulations</a> &raquo; <a class="el" href="group__Iterators.html">Iterators on mesh-like containers</a> &raquo;  &#124; <a class="el" href="group__Accessors.html">Accessor classes of the mesh iterators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="dof__accessor_8h_source.html">deal.II/dofs/dof_accessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDoFCellAccessor__inherit__graph.svg" width="1314" height="176"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a14eaa9e4b4b0aa9faf84414d7fac2ed8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> = <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;</td></tr>
<tr class="separator:a14eaa9e4b4b0aa9faf84414d7fac2ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac715be6a489bcf83b56caa5cfd04a995"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ac715be6a489bcf83b56caa5cfd04a995">BaseClass</a> = <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; dimension_, dimension_, space_dimension_, level_dof_access &gt;</td></tr>
<tr class="separator:ac715be6a489bcf83b56caa5cfd04a995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56b2fbf436c741d930551944c1ce726"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae56b2fbf436c741d930551944c1ce726">Container</a> = <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;</td></tr>
<tr class="separator:ae56b2fbf436c741d930551944c1ce726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70a4ac52fd924b8b3854c771a8037026"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a> = <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; dimension_ - 1, dimension_, space_dimension_, level_dof_access &gt; &gt;</td></tr>
<tr class="separator:a70a4ac52fd924b8b3854c771a8037026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae3e7d1c5c9bacd29de30a6ca648b9de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae3e7d1c5c9bacd29de30a6ca648b9de7">parent</a> () const</td></tr>
<tr class="separator:ae3e7d1c5c9bacd29de30a6ca648b9de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab391b1952d50bbe49fb11e4d4a400acc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab391b1952d50bbe49fb11e4d4a400acc">set_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices)</td></tr>
<tr class="separator:ab391b1952d50bbe49fb11e4d4a400acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac76cef754ca3b14d1f13ef2c01a4a999"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ac76cef754ca3b14d1f13ef2c01a4a999">set_mg_dof_indices</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices)</td></tr>
<tr class="separator:ac76cef754ca3b14d1f13ef2c01a4a999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42873cdeb9f69ee1e1ce43e055e6e4f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a42873cdeb9f69ee1e1ce43e055e6e4f6">update_cell_dof_indices_cache</a> () const</td></tr>
<tr class="separator:a42873cdeb9f69ee1e1ce43e055e6e4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49329d7429a4dad355b2b8c859e7e60a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a49329d7429a4dad355b2b8c859e7e60a">get_dof_handler</a> () const</td></tr>
<tr class="separator:a49329d7429a4dad355b2b8c859e7e60a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2203fb607f6ae1f79d860a41efdf37c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aa2203fb607f6ae1f79d860a41efdf37c">copy_from</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access2 &gt; &amp;a)</td></tr>
<tr class="separator:aa2203fb607f6ae1f79d860a41efdf37c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a040127cdbb584aefbf38779ca7ac57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a9a040127cdbb584aefbf38779ca7ac57">copy_from</a> (const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; &amp;da)</td></tr>
<tr class="separator:a9a040127cdbb584aefbf38779ca7ac57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga36b9816a464913e80b640d7778b6a2a6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga36b9816a464913e80b640d7778b6a2a6">DeclExceptionMsg</a> (ExcInvalidObject, &quot;This accessor object has not been &quot; &quot;associated with any <a class="el" href="classDoFHandler.html">DoFHandler</a> object.&quot;)</td></tr>
<tr class="separator:ga36b9816a464913e80b640d7778b6a2a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gace9faa28de1bfa14fe42acae5ec0c795"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gace9faa28de1bfa14fe42acae5ec0c795">DeclException0</a> (ExcVectorNotEmpty)</td></tr>
<tr class="separator:gace9faa28de1bfa14fe42acae5ec0c795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9f84a1c8defd39d3e0ce848f2c1f6caf"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga9f84a1c8defd39d3e0ce848f2c1f6caf">DeclException0</a> (ExcVectorDoesNotMatch)</td></tr>
<tr class="separator:ga9f84a1c8defd39d3e0ce848f2c1f6caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c716f4f4f6718bca364135fa8980527"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4c716f4f4f6718bca364135fa8980527">DeclException0</a> (ExcMatrixDoesNotMatch)</td></tr>
<tr class="separator:ga4c716f4f4f6718bca364135fa8980527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fe397e0b77ee7550e2394ba96f7fb70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0fe397e0b77ee7550e2394ba96f7fb70">DeclException0</a> (ExcNotActive)</td></tr>
<tr class="separator:ga0fe397e0b77ee7550e2394ba96f7fb70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00741f1400034d3faca2ca3bed41b29a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga00741f1400034d3faca2ca3bed41b29a">DeclException0</a> (ExcCantCompareIterators)</td></tr>
<tr class="separator:ga00741f1400034d3faca2ca3bed41b29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6ae8fec03877b971fd7832d92704be4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ac6ae8fec03877b971fd7832d92704be4">operator==</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;) const</td></tr>
<tr class="separator:ac6ae8fec03877b971fd7832d92704be4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90137a1310b0ec72b89cfb60e1f51145"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a90137a1310b0ec72b89cfb60e1f51145">operator!=</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;) const</td></tr>
<tr class="separator:a90137a1310b0ec72b89cfb60e1f51145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造器和初始化</div></td></tr>
<tr class="memitem:a3fdfeda1dae3c8c79aab8f8693d773f4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a3fdfeda1dae3c8c79aab8f8693d773f4">DoFCellAccessor</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dimension_, space_dimension_ &gt; *tria, const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const <a class="el" href="classint.html">int</a> index, const <a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> *local_data)</td></tr>
<tr class="separator:a3fdfeda1dae3c8c79aab8f8693d773f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4773afe4306d7c470eff8bdcfa4945"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2&gt; </td></tr>
<tr class="memitem:a8a4773afe4306d7c470eff8bdcfa4945"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a8a4773afe4306d7c470eff8bdcfa4945">DoFCellAccessor</a> (const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;)</td></tr>
<tr class="separator:a8a4773afe4306d7c470eff8bdcfa4945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82e3b423ac414e0ade67250589747fff"><td class="memTemplParams" colspan="2">template&lt;int structdim2, int dim2, int spacedim2, bool level_dof_access2&gt; </td></tr>
<tr class="memitem:a82e3b423ac414e0ade67250589747fff"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a82e3b423ac414e0ade67250589747fff">DoFCellAccessor</a> (const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;)</td></tr>
<tr class="separator:a82e3b423ac414e0ade67250589747fff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb101ef43d77d96339c8b3a5e57d5c7a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#acb101ef43d77d96339c8b3a5e57d5c7a">DoFCellAccessor</a> (const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;)=default</td></tr>
<tr class="separator:acb101ef43d77d96339c8b3a5e57d5c7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a108142a1c96d7e897b2e69bb1b22ca92"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a108142a1c96d7e897b2e69bb1b22ca92">DoFCellAccessor</a> (<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a108142a1c96d7e897b2e69bb1b22ca92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c05e9518e81d651b9e09568274d444"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae0c05e9518e81d651b9e09568274d444">~DoFCellAccessor</a> ()=default</td></tr>
<tr class="separator:ae0c05e9518e81d651b9e09568274d444"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b2870a690c665b4cb0c0176c6944682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a7b2870a690c665b4cb0c0176c6944682">operator=</a> (const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;da)=delete</td></tr>
<tr class="separator:a7b2870a690c665b4cb0c0176c6944682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01d175bf33624dd27a239239d1896d3e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a01d175bf33624dd27a239239d1896d3e">operator=</a> (<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;)=default</td></tr>
<tr class="separator:a01d175bf33624dd27a239239d1896d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问子对象和相邻对象</div></td></tr>
<tr class="memitem:a83f4b0d83f95157c8563e74012997ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a83f4b0d83f95157c8563e74012997ab5">neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a83f4b0d83f95157c8563e74012997ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8654f9a388095fa14951341ba3739970"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a8654f9a388095fa14951341ba3739970">periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a8654f9a388095fa14951341ba3739970"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50b253e23370b91ac56e1db1c6c929c8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a50b253e23370b91ac56e1db1c6c929c8">neighbor_or_periodic_neighbor</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a50b253e23370b91ac56e1db1c6c929c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658978b9f615b5c1e1351cff86fe5749"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a658978b9f615b5c1e1351cff86fe5749">child</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a658978b9f615b5c1e1351cff86fe5749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0133b5a7c0b2e585b1712f01cb2e2187"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dimension_ &gt;::max_children_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0133b5a7c0b2e585b1712f01cb2e2187">child_iterators</a> () const</td></tr>
<tr class="separator:a0133b5a7c0b2e585b1712f01cb2e2187"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d70e743293a3b7b63b8f9e2dba70d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a17d70e743293a3b7b63b8f9e2dba70d2">face</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a17d70e743293a3b7b63b8f9e2dba70d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a706e62b6e969a1c7554d6b0e08391ea3"><td class="memItemLeft" align="right" valign="top">boost::container::small_vector&lt; <a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dimension_ &gt;::faces_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a706e62b6e969a1c7554d6b0e08391ea3">face_iterators</a> () const</td></tr>
<tr class="separator:a706e62b6e969a1c7554d6b0e08391ea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3fe8449042487bf12d34fb2dd574af2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ac3fe8449042487bf12d34fb2dd574af2">neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:ac3fe8449042487bf12d34fb2dd574af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cc1ced13a62bb91a32e442e72dcee65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0cc1ced13a62bb91a32e442e72dcee65">periodic_neighbor_child_on_subface</a> (const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no) const</td></tr>
<tr class="separator:a0cc1ced13a62bb91a32e442e72dcee65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">从全局向量中提取数值</div></td></tr>
<tr class="memitem:a1702d1e9c1cb4fb07b70c38ac9165aaa"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:a1702d1e9c1cb4fb07b70c38ac9165aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a1702d1e9c1cb4fb07b70c38ac9165aaa">get_dof_values</a> (const InputVector &amp;values, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_values) const</td></tr>
<tr class="separator:a1702d1e9c1cb4fb07b70c38ac9165aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4533f34e152298586da408827f8bac1a"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a4533f34e152298586da408827f8bac1a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a4533f34e152298586da408827f8bac1a">get_dof_values</a> (const InputVector &amp;values, ForwardIterator local_values_begin, ForwardIterator local_values_end) const</td></tr>
<tr class="separator:a4533f34e152298586da408827f8bac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55050e07d9458ccc01a0456313d230f4"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a55050e07d9458ccc01a0456313d230f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a55050e07d9458ccc01a0456313d230f4">get_dof_values</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename InputVector::value_type &gt; &amp;constraints, const InputVector &amp;values, ForwardIterator local_values_begin, ForwardIterator local_values_end) const</td></tr>
<tr class="separator:a55050e07d9458ccc01a0456313d230f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3ca14113486423a02d9dcf281d1511"><td class="memTemplParams" colspan="2">template&lt;class OutputVector , typename number &gt; </td></tr>
<tr class="memitem:abd3ca14113486423a02d9dcf281d1511"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#abd3ca14113486423a02d9dcf281d1511">set_dof_values</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_values, OutputVector &amp;values) const</td></tr>
<tr class="separator:abd3ca14113486423a02d9dcf281d1511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfbcb614074b264694b827d9b6e29cda"><td class="memTemplParams" colspan="2">template&lt;class InputVector , typename number &gt; </td></tr>
<tr class="memitem:acfbcb614074b264694b827d9b6e29cda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#acfbcb614074b264694b827d9b6e29cda">get_interpolated_dof_values</a> (const InputVector &amp;values, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;interpolated_values, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:acfbcb614074b264694b827d9b6e29cda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d5a3e00541638a146c531f3c5820f8"><td class="memTemplParams" colspan="2">template&lt;class OutputVector , typename number &gt; </td></tr>
<tr class="memitem:a75d5a3e00541638a146c531f3c5820f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a75d5a3e00541638a146c531f3c5820f8">set_dof_values_by_interpolation</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_values, OutputVector &amp;values, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dimension_, space_dimension_ &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a75d5a3e00541638a146c531f3c5820f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b373ea3845c1be186681ceb4d1d28f8"><td class="memTemplParams" colspan="2">template&lt;typename number , typename OutputVector &gt; </td></tr>
<tr class="memitem:a4b373ea3845c1be186681ceb4d1d28f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a4b373ea3845c1be186681ceb4d1d28f8">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_source, OutputVector &amp;global_destination) const</td></tr>
<tr class="separator:a4b373ea3845c1be186681ceb4d1d28f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add2ea6075920c592b31132352385415d"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputVector &gt; </td></tr>
<tr class="memitem:add2ea6075920c592b31132352385415d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#add2ea6075920c592b31132352385415d">distribute_local_to_global</a> (ForwardIterator local_source_begin, ForwardIterator local_source_end, OutputVector &amp;global_destination) const</td></tr>
<tr class="separator:add2ea6075920c592b31132352385415d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab90bb534e64a5a9c10d9f6a161c1a0c5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputVector &gt; </td></tr>
<tr class="memitem:ab90bb534e64a5a9c10d9f6a161c1a0c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab90bb534e64a5a9c10d9f6a161c1a0c5">distribute_local_to_global</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutputVector::value_type &gt; &amp;constraints, ForwardIterator local_source_begin, ForwardIterator local_source_end, OutputVector &amp;global_destination) const</td></tr>
<tr class="separator:ab90bb534e64a5a9c10d9f6a161c1a0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a629b9490f29a4b030dd897a733116ccb"><td class="memTemplParams" colspan="2">template&lt;typename number , typename OutputMatrix &gt; </td></tr>
<tr class="memitem:a629b9490f29a4b030dd897a733116ccb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a629b9490f29a4b030dd897a733116ccb">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_source, OutputMatrix &amp;global_destination) const</td></tr>
<tr class="separator:a629b9490f29a4b030dd897a733116ccb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0917cd50db0119a5efe0309ec13370f"><td class="memTemplParams" colspan="2">template&lt;typename number , typename OutputMatrix , typename OutputVector &gt; </td></tr>
<tr class="memitem:ab0917cd50db0119a5efe0309ec13370f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab0917cd50db0119a5efe0309ec13370f">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, OutputMatrix &amp;global_matrix, OutputVector &amp;global_vector) const</td></tr>
<tr class="separator:ab0917cd50db0119a5efe0309ec13370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问此对象的DoF指数</div></td></tr>
<tr class="memitem:a15ef35e919b1005dc6050f9bca96956d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a15ef35e919b1005dc6050f9bca96956d">get_active_or_mg_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices) const</td></tr>
<tr class="separator:a15ef35e919b1005dc6050f9bca96956d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeab120d78d3fdf70cf83a52b870ec8d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#aeab120d78d3fdf70cf83a52b870ec8d6">get_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices) const</td></tr>
<tr class="separator:aeab120d78d3fdf70cf83a52b870ec8d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5b7ee5a2c16b2dfacd9139bed6bed4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ad5b7ee5a2c16b2dfacd9139bed6bed4d">get_mg_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices) const</td></tr>
<tr class="separator:ad5b7ee5a2c16b2dfacd9139bed6bed4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问与此对象相关的有限元</div></td></tr>
<tr class="memitem:ace7438827be3421cdb64c67f28c7aa60"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dimension_, space_dimension_ &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ace7438827be3421cdb64c67f28c7aa60">get_fe</a> () const</td></tr>
<tr class="separator:ace7438827be3421cdb64c67f28c7aa60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a196a66be2e332d0f302e6b579f47fe"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a5a196a66be2e332d0f302e6b579f47fe">active_fe_index</a> () const</td></tr>
<tr class="separator:a5a196a66be2e332d0f302e6b579f47fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44babdcd7954cdfdd9f9497781cc22ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a44babdcd7954cdfdd9f9497781cc22ae">set_active_fe_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a44babdcd7954cdfdd9f9497781cc22ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">处理细化指标</div></td></tr>
<tr class="memitem:a7558706ae1d781bf54ec29f85e862d62"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dimension_, space_dimension_ &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a7558706ae1d781bf54ec29f85e862d62">get_future_fe</a> () const</td></tr>
<tr class="separator:a7558706ae1d781bf54ec29f85e862d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4d4d8562cb47b70b797369b8872b04d"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae4d4d8562cb47b70b797369b8872b04d">future_fe_index</a> () const</td></tr>
<tr class="separator:ae4d4d8562cb47b70b797369b8872b04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f2896ef67d3d11ec3d23d382b19c46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ab9f2896ef67d3d11ec3d23d382b19c46">set_future_fe_index</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:ab9f2896ef67d3d11ec3d23d382b19c46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7949017e7a76aa15c2dcff7871401e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#ae7949017e7a76aa15c2dcff7871401e1">future_fe_index_set</a> () const</td></tr>
<tr class="separator:ae7949017e7a76aa15c2dcff7871401e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67f45fd024b1a960c2f67920dbab58c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#aa67f45fd024b1a960c2f67920dbab58c">clear_future_fe_index</a> () const</td></tr>
<tr class="separator:aa67f45fd024b1a960c2f67920dbab58c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问子对象</div></td></tr>
<tr class="memitem:aad0cb2f5249c0ee51e693366e40e1388"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1DoFHandlerImplementation_1_1Iterators.html">internal::DoFHandlerImplementation::Iterators</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::line_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aad0cb2f5249c0ee51e693366e40e1388">line</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:aad0cb2f5249c0ee51e693366e40e1388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad78d479734c818ddd3c928bb5e1537"><td class="memItemLeft" align="right" valign="top">typename ::<a class="el" href="structinternal_1_1DoFHandlerImplementation_1_1Iterators.html">internal::DoFHandlerImplementation::Iterators</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::quad_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a7ad78d479734c818ddd3c928bb5e1537">quad</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a7ad78d479734c818ddd3c928bb5e1537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问此对象的DoF索引</div></td></tr>
<tr class="memitem:a9553dfc2e807a7bce21a950e938a3e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a9553dfc2e807a7bce21a950e938a3e9f">get_dof_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a9553dfc2e807a7bce21a950e938a3e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adeace582710e57d3d8911e77d73a8b55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#adeace582710e57d3d8911e77d73a8b55">get_mg_dof_indices</a> (const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:adeace582710e57d3d8911e77d73a8b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4564ad65573f50f8b3d02dfb6d07e0ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a4564ad65573f50f8b3d02dfb6d07e0ac">set_mg_dof_indices</a> (const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_indices, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index)</td></tr>
<tr class="separator:a4564ad65573f50f8b3d02dfb6d07e0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa1f2d13ea10d3e36d7fc6d982467ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a5aa1f2d13ea10d3e36d7fc6d982467ed">vertex_dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a5aa1f2d13ea10d3e36d7fc6d982467ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4402930fd9d6e7745befbf0028cd59"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#acc4402930fd9d6e7745befbf0028cd59">mg_vertex_dof_index</a> (const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:acc4402930fd9d6e7745befbf0028cd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc20ce96d8d7501d113c578ecb2ea8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a65cc20ce96d8d7501d113c578ecb2ea8">dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:a65cc20ce96d8d7501d113c578ecb2ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7c02ba6168b40bca90e4fb8c2f8ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#acad7c02ba6168b40bca90e4fb8c2f8ee">mg_dof_index</a> (const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:acad7c02ba6168b40bca90e4fb8c2f8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">访问与此对象相关的有限元</div></td></tr>
<tr class="memitem:ad3a5c19a4bf840dad9e1185d78526b4b"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ad3a5c19a4bf840dad9e1185d78526b4b">n_active_fe_indices</a> () const</td></tr>
<tr class="separator:ad3a5c19a4bf840dad9e1185d78526b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add0021f581f717926769d03779c8739c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#add0021f581f717926769d03779c8739c">nth_active_fe_index</a> (const unsigned <a class="el" href="classint.html">int</a> n) const</td></tr>
<tr class="separator:add0021f581f717926769d03779c8739c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc4f3541c18e4f2c59fd39061fd4caf"><td class="memItemLeft" align="right" valign="top">std::set&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a5cc4f3541c18e4f2c59fd39061fd4caf">get_active_fe_indices</a> () const</td></tr>
<tr class="separator:a5cc4f3541c18e4f2c59fd39061fd4caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa107e710976f26c4ab9a49275c5ce23c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aa107e710976f26c4ab9a49275c5ce23c">fe_index_is_active</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:aa107e710976f26c4ab9a49275c5ce23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad067228a1d5ae86639f2719b84a71c9e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ad067228a1d5ae86639f2719b84a71c9e">get_fe</a> (const unsigned <a class="el" href="classint.html">int</a> fe_index) const</td></tr>
<tr class="separator:ad067228a1d5ae86639f2719b84a71c9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ade1461f1a5ea5564fcc1ba2be6641f10"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ade1461f1a5ea5564fcc1ba2be6641f10">is_level_cell</a> ()</td></tr>
<tr class="separator:ade1461f1a5ea5564fcc1ba2be6641f10"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a6d4509b7753b800d9fd7039bca79f7ad"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a> = dimension_</td></tr>
<tr class="separator:a6d4509b7753b800d9fd7039bca79f7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b0e36ef5665c0ad1921049acb84604e"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> = space_dimension_</td></tr>
<tr class="separator:a8b0e36ef5665c0ad1921049acb84604e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8274de3efd9a8b566e3b7a27a1a286"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a5d8274de3efd9a8b566e3b7a27a1a286">dimension</a></td></tr>
<tr class="separator:a5d8274de3efd9a8b566e3b7a27a1a286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ebf5625b40e2ecedaaeef5f684d3fab"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a0ebf5625b40e2ecedaaeef5f684d3fab">space_dimension</a></td></tr>
<tr class="separator:a0ebf5625b40e2ecedaaeef5f684d3fab"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a616da3ae411e1649bc75ed330f756388"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a616da3ae411e1649bc75ed330f756388">set_dof_handler</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; *dh)</td></tr>
<tr class="separator:a616da3ae411e1649bc75ed330f756388"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3cdc6b6fa4abf71bdec21c022c0506"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#abe3cdc6b6fa4abf71bdec21c022c0506">set_dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:abe3cdc6b6fa4abf71bdec21c022c0506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17282fe1c8b6b2131f01455871065e0a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#a17282fe1c8b6b2131f01455871065e0a">set_mg_dof_index</a> (const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index) const</td></tr>
<tr class="separator:a17282fe1c8b6b2131f01455871065e0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48185a4fe62cf31fb6313777072e233"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#ac48185a4fe62cf31fb6313777072e233">set_vertex_dof_index</a> (const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:ac48185a4fe62cf31fb6313777072e233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af521f2a697ac2b7dec0e8196933979c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#af521f2a697ac2b7dec0e8196933979c4">set_mg_vertex_dof_index</a> (const <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>, const unsigned <a class="el" href="classint.html">int</a> vertex, const unsigned <a class="el" href="classint.html">int</a> i, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> index, const unsigned <a class="el" href="classint.html">int</a> fe_index=<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt;::invalid_fe_index) const</td></tr>
<tr class="separator:af521f2a697ac2b7dec0e8196933979c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aea85e74a2de50f84acd6b53c8e2a55e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFAccessor.html#aea85e74a2de50f84acd6b53c8e2a55e1">dof_handler</a></td></tr>
<tr class="separator:aea85e74a2de50f84acd6b53c8e2a55e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0f77c88bd6841a98bf02a4a398551115"><td class="memTemplParams" colspan="2">template&lt;int , int &gt; </td></tr>
<tr class="memitem:a0f77c88bd6841a98bf02a4a398551115"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0f77c88bd6841a98bf02a4a398551115">DoFHandler</a></td></tr>
<tr class="separator:a0f77c88bd6841a98bf02a4a398551115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cf63b7b7600d230112f86fe73e1afdb"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDoFCellAccessor.html#a0cf63b7b7600d230112f86fe73e1afdb">::internal::DoFCellAccessorImplementation::Implementation</a></td></tr>
<tr class="separator:a0cf63b7b7600d230112f86fe73e1afdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt;<br />
class DoFCellAccessor&lt; dimension_, space_dimension_, level_dof_access &gt;</h3>

<p>授予对单元格的自由度的访问权。 注意，因为对于我们派生的类，即<code>DoFAccessor&lt;dim&gt;</code>，两个模板参数是相等的，基类实际上是派生自CellAccessor，这使得这个类的函数对DoFCellAccessor类也可用。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01183">1183</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a14eaa9e4b4b0aa9faf84414d7fac2ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14eaa9e4b4b0aa9faf84414d7fac2ed8">&#9670;&nbsp;</a></span>AccessorData</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> =  <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dimension_, space_dimension_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>由迭代器类传递的数据类型。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01206">1206</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="ac715be6a489bcf83b56caa5cfd04a995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac715be6a489bcf83b56caa5cfd04a995">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#ac715be6a489bcf83b56caa5cfd04a995">BaseClass</a> =  <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt;dimension_, dimension_, space_dimension_, level_dof_access&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明基类的别名，使访问一些异常类更简单。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01213">1213</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="ae56b2fbf436c741d930551944c1ce726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae56b2fbf436c741d930551944c1ce726">&#9670;&nbsp;</a></span>Container</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#ae56b2fbf436c741d930551944c1ce726">Container</a> =  <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dimension_, space_dimension_&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>定义这个容器的类型，是它的一部分。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01219">1219</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a70a4ac52fd924b8b3854c771a8037026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70a4ac52fd924b8b3854c771a8037026">&#9670;&nbsp;</a></span>face_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a> =  <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt;dimension_ - 1, dimension_, space_dimension_, level_dof_access&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个单元格的面的迭代器的类型。这就是face()函数的返回值。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01228">1228</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a3fdfeda1dae3c8c79aab8f8693d773f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdfeda1dae3c8c79aab8f8693d773f4">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dimension_, space_dimension_ &gt; *&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFCellAccessor.html#a14eaa9e4b4b0aa9faf84414d7fac2ed8">AccessorData</a> *&#160;</td>
          <td class="paramname"><em>local_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数 </p>

</div>
</div>
<a id="a8a4773afe4306d7c470eff8bdcfa4945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4773afe4306d7c470eff8bdcfa4945">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInvalidAccessor.html">InvalidAccessor</a>&lt; structdim2, dim2, spacedim2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>转换构造器。这个构造器的存在是为了使某些构造在独立于维度的代码中写得更简单。例如，它允许将一个面的迭代器分配给一个线的迭代器，这个操作在2D中很有用，但在3D中没有任何意义。这里的构造函数是为了使代码符合C++的要求而存在的，但它会无条件地中止；换句话说，将一个面迭代器分配给一个线迭代器，最好放在一个if语句中，检查维度是否为2，并在3D中分配给一个四边形迭代器（如果没有这个构造函数，如果我们碰巧为2d编译，这个操作是非法的）。 </p>

</div>
</div>
<a id="a82e3b423ac414e0ade67250589747fff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82e3b423ac414e0ade67250589747fff">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;int structdim2, int dim2, int spacedim2, bool level_dof_access2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>另一个对象之间的转换操作符，就像之前的那个一样，没有意义。 </p>

</div>
</div>
<a id="acb101ef43d77d96339c8b3a5e57d5c7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb101ef43d77d96339c8b3a5e57d5c7a">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造器。 </p>

</div>
</div>
<a id="a108142a1c96d7e897b2e69bb1b22ca92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a108142a1c96d7e897b2e69bb1b22ca92">&#9670;&nbsp;</a></span>DoFCellAccessor() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。 </p>

</div>
</div>
<a id="ae0c05e9518e81d651b9e09568274d444"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c05e9518e81d651b9e09568274d444">&#9670;&nbsp;</a></span>~DoFCellAccessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::~<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解除构造函数 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b2870a690c665b4cb0c0176c6944682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2870a690c665b4cb0c0176c6944682">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&#160;</td>
          <td class="paramname"><em>da</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制操作符。这些操作符通常在类似<code>iterator a,b;a=*b;</code>的情况下使用。据推测，这里的意图是将 <code>b</code> 所指向的对象复制到 <code>a</code>. 所指向的对象。然而，取消引用迭代器的结果不是一个对象，而是一个访问器；因此，这个操作对于DoF处理程序对象上的迭代器是没用的。 因此，这个操作被声明为删除，不能被使用。 </p>

</div>
</div>
<a id="a01d175bf33624dd27a239239d1896d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01d175bf33624dd27a239239d1896d3e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt; &amp;&amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符。 </p>

</div>
</div>
<a id="ae3e7d1c5c9bacd29de30a6ca648b9de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3e7d1c5c9bacd29de30a6ca648b9de7">&#9670;&nbsp;</a></span>parent()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::parent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>以DoF单元格迭代器的形式返回该单元格的父级。如果父对象不存在（即，如果该对象处于网格层次结构的最粗层），将产生一个异常。 这个函数是需要的，因为基类CellAccessor的父函数返回一个没有访问DoF数据的三角形单元访问器。 </p>

</div>
</div>
<a id="a83f4b0d83f95157c8563e74012997ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83f4b0d83f95157c8563e74012997ab5">&#9670;&nbsp;</a></span>neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>ith</code> 邻居作为DoF单元迭代器返回。这个函数是需要的，因为基类的邻居函数返回一个没有访问DoF数据的单元格访问器。 </p>

</div>
</div>
<a id="a8654f9a388095fa14951341ba3739970"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8654f9a388095fa14951341ba3739970">&#9670;&nbsp;</a></span>periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 周期性邻居作为DoF单元的迭代器。这个函数是需要的，因为基类的邻居函数返回一个没有访问DoF数据的单元访问器。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8cc_source.html#l00172">172</a> of file <a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a>.</p>

</div>
</div>
<a id="a50b253e23370b91ac56e1db1c6c929c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50b253e23370b91ac56e1db1c6c929c8">&#9670;&nbsp;</a></span>neighbor_or_periodic_neighbor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::neighbor_or_periodic_neighbor </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>ith</code> 邻居或周期性邻居作为DoF单元的迭代器。 这个函数是需要的，因为基类的邻居函数返回一个没有访问DoF数据的单元格访问器。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8cc_source.html#l00185">185</a> of file <a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a>.</p>

</div>
</div>
<a id="a658978b9f615b5c1e1351cff86fe5749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658978b9f615b5c1e1351cff86fe5749">&#9670;&nbsp;</a></span>child()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt;<a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::child </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>ith</code> 的子单元作为DoF单元迭代器返回。这个函数是需要的，因为基类的子函数返回一个没有访问DoF数据的单元格访问器。 </p>

</div>
</div>
<a id="a0133b5a7c0b2e585b1712f01cb2e2187"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0133b5a7c0b2e585b1712f01cb2e2187">&#9670;&nbsp;</a></span>child_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt;dimension_, space_dimension_, level_dof_access&gt; &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dimension_&gt;::max_children_per_cell&gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::child_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元格所有子节点的迭代器数组。 </p>

</div>
</div>
<a id="a17d70e743293a3b7b63b8f9e2dba70d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17d70e743293a3b7b63b8f9e2dba70d2">&#9670;&nbsp;</a></span>face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::face </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此单元格的 <code>ith</code> 面的一个迭代器。 这个函数返回一个一维的 <code>structdim == 0</code> 的DoFAccessor，二维的 <a class="el" href="classDoFAccessor.html#aad0cb2f5249c0ee51e693366e40e1388">DoFAccessor::line</a> ，以及三维的 <a class="el" href="classDoFAccessor.html#a7ad78d479734c818ddd3c928bb5e1537">DoFAccessor::quad</a> 。 </p>

</div>
</div>
<a id="a706e62b6e969a1c7554d6b0e08391ea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a706e62b6e969a1c7554d6b0e08391ea3">&#9670;&nbsp;</a></span>face_iterators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt;<a class="el" href="classDoFCellAccessor.html#a70a4ac52fd924b8b3854c771a8037026">face_iterator</a>, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dimension_&gt;::faces_per_cell&gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::face_iterators </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该单元格所有面的迭代器数组。 </p>

</div>
</div>
<a id="ac3fe8449042487bf12d34fb2dd574af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3fe8449042487bf12d34fb2dd574af2">&#9670;&nbsp;</a></span>neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回基类中 <code>neighbor_child_on_subface</code> 函数的结果，但将其转换为也可以访问DoF数据（基类中的函数只返回一个访问三角形数据的迭代器）。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8cc_source.html#l00143">143</a> of file <a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a>.</p>

</div>
</div>
<a id="a0cc1ced13a62bb91a32e442e72dcee65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cc1ced13a62bb91a32e442e72dcee65">&#9670;&nbsp;</a></span>periodic_neighbor_child_on_subface()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTriaIterator.html">TriaIterator</a>&lt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt; &gt; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::periodic_neighbor_child_on_subface </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回基类中 <code>periodic_neighbor_child_on_subface</code> 函数的结果，但将其转换为也可以访问DoF数据（基类中的函数只返回一个可以访问三角测量数据的迭代器）。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8cc_source.html#l00157">157</a> of file <a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a>.</p>

</div>
</div>
<a id="a1702d1e9c1cb4fb07b70c38ac9165aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1702d1e9c1cb4fb07b70c38ac9165aaa">&#9670;&nbsp;</a></span>get_dof_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>收集限制在此单元格的道夫上的给定向量的值，其标准排序为：顶点0上的道夫，顶点1上的道夫，等等，行0上的道夫，行1上的道夫，等等，四边0上的道夫，等等。换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">聚集操作</a>。 在传递给这个函数之前，向量必须有合适的大小。这个函数只适用于活动单元的调用。 输入的向量可以是<code>Vector&lt;float&gt;</code>、Vector&lt;double&gt;或BlockVector&lt;double&gt;，或者是PETSc或Trilinos向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。 </p>

</div>
</div>
<a id="a4533f34e152298586da408827f8bac1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4533f34e152298586da408827f8bac1a">&#9670;&nbsp;</a></span>get_dof_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>收集限制在该单元格的道夫上的给定向量的值，其标准排序为：顶点0的道夫，顶点1的道夫，等等，行0的道夫，行1的道夫，等等，四边0的道夫，等等。换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">聚集操作</a>。 在传递给这个函数之前，向量必须有合适的大小。这个函数只适用于活动单元的调用。 输入的向量可以是<code>Vector&lt;float&gt;</code>、Vector&lt;double&gt;或BlockVector&lt;double&gt;，或者是PETSc或Trilinos向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。 </p>

</div>
</div>
<a id="a55050e07d9458ccc01a0456313d230f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55050e07d9458ccc01a0456313d230f4">&#9670;&nbsp;</a></span>get_dof_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename InputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_values_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>收集限制在该单元格的道夫上的给定向量的值，其标准排序为：顶点0的道夫，顶点1的道夫，等等，行0的道夫，行1的道夫，等等，四边0的道夫，等等。换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">聚集操作</a>。 在传递给这个函数之前，向量必须有合适的大小。这个函数只适用于活动单元的调用。 输入的向量可以是<code>Vector&lt;float&gt;</code>、Vector&lt;double&gt;或BlockVector&lt;double&gt;，或者是PETSc或Trilinos向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。作为参数传递给该函数的AffineConstraints对象可以确保在计算dof值时约束条件的分布是正确的。 </p>

</div>
</div>
<a id="abd3ca14113486423a02d9dcf281d1511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3ca14113486423a02d9dcf281d1511">&#9670;&nbsp;</a></span>set_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;class OutputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是get_dof_values()的对应函数：它接收这个迭代器所指向的单元的自由度值的向量，并将这些值写入全局数据向量 <code>values</code>. 换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 这个函数只对活动单元可调用。 请注意，对于连续的有限元，调用这个函数也会影响到相邻单元的dof值。如果相邻单元的精细度低于当前单元，它还可能违反悬挂节点的连续性要求。这些要求没有被考虑到，必须由用户事后强制执行。 向量在被传递给这个函数之前必须有合适的大小。 输出的向量可以是Vector&lt;float&gt;, <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a>, 或BlockVector&lt;double&gt;, 或PETSc向量，如果deal.II被编译为支持这些库。调用者有责任保证存储在输入和输出向量中的数字类型是兼容的，并且具有相似的精度。 </p>

</div>
</div>
<a id="acfbcb614074b264694b827d9b6e29cda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfbcb614074b264694b827d9b6e29cda">&#9670;&nbsp;</a></span>get_interpolated_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
<div class="memtemplate">
template&lt;class InputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::get_interpolated_dof_values </td>
          <td>(</td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolated_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dimension_,&#160;space_dimension_&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定的有限元函数对当前单元的插值。在最简单的情况下，该单元是一个终端单元，即它没有子单元；那么，返回值是该单元上的节点值向量。你也可以通过 <code>get_dof_values函数获得所需的值。在另一种情况下，当单元有子节点时，我们使用有限元类提供的限制矩阵来计算从子节点到本单元的内插。</code> 如果单元是具有hp能力的DoFHandler的一部分，单元只有在活动时才有相关的有限元空间。然而，这个函数也应该提供有子单元的非活动单元的信息。因此，它带有第三个参数，可以在hp-context中使用，表示我们应该插值到的有限元空间。如果单元是活动的，这个函数就会从这个单元的 <code>values</code> 向量中获得有限元函数，并将其插值到 <code>fe_index</code> 中的第1个元素所描述的空间，这个单元是DoFHandler中的一部分。如果该单元不是活动的，那么我们首先对其所有的终端子单元进行插值，然后将这个函数插值到所要求的单元，保持函数空间不变。 假设两个输入向量事先已经有了合适的大小。 </p><dl class="section note"><dt>Note</dt><dd>与get_dof_values()函数不同，这个函数只对单元格有效，而不是对线、四边形和六边形，因为插值目前只由有限元类为单元格提供。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__accessor__get_8cc_source.html#l00048">48</a> of file <a class="el" href="dof__accessor__get_8cc_source.html">dof_accessor_get.cc</a>.</p>

</div>
</div>
<a id="a75d5a3e00541638a146c531f3c5820f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75d5a3e00541638a146c531f3c5820f8">&#9670;&nbsp;</a></span>set_dof_values_by_interpolation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
<div class="memtemplate">
template&lt;class OutputVector , typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::set_dof_values_by_interpolation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dimension_,&#160;space_dimension_&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是get_interpolated_dof_values()的对应函数：你指定单元格上的dof值，这些值被内插到当前单元格的子单元，并设置在终端单元上。 原则上，它的工作原理如下：如果这个对象指向的单元格是终端（即没有子单元），那么通过调用set_dof_values()函数在全局数据向量中设置dof值；否则，这些值被延长到每个子单元，并为每个子单元调用这个函数。 使用get_interpolated_dof_values()和这个函数，你可以计算一个有限元函数对一个更粗的网格的内插，首先在粗网格的一个单元上得到内插的解，之后用这个函数重新分配。 请注意，对于连续有限元，调用这个函数也会影响到相邻单元上的道夫值。如果相邻的单元比现在的单元细化程度低，或者它们的子单元比这个单元的子单元细化程度低，那么它也可能违反悬挂节点的连续性要求。这些要求没有得到照顾，必须由用户事后强制执行。 如果单元格是具有hp能力的DoFHandler的一部分，单元格只有在活动时才有相关的有限元空间。然而，这个函数也应该在有子代的非活动单元上工作。 因此，它带有第三个参数，可以在hp-上下文中使用，表示我们应该解释这个函数的输入矢量的有限元空间。如果单元格是活动的，这个函数就会将输入向量解释为与该单元格所属的DoFHandler相关的 <code>fe_index</code> 的第三个元素所描述的空间元素，并将其插值到与该单元格相关的空间。另一方面，如果单元格不是活动的，那么我们首先使用给定的 <code>fe_index</code> 从这个单元格到它的子单元格进行内插，直到我们在一个活动的单元格上结束，这时我们遵循本段开头的程序。 假设两个向量事先已经有了合适的大小。 这个函数依赖于一个单元的有限元空间对其子女的自然插值属性的存在，由有限元类的延长矩阵表示。对于某些元素，粗网格和细网格上的空间没有嵌套，在这种情况下，对子单元的插值不是相同的；关于在这种情况下延长矩阵所代表的内容，请参考各自的有限元类的文档。 </p><dl class="section note"><dt>Note</dt><dd>与get_dof_values()函数不同，这个函数只对单元格有效，而不是对线、四边形和六边形，因为插值目前只由有限元类对单元格提供。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="dof__accessor__set_8cc_source.html#l00048">48</a> of file <a class="el" href="dof__accessor__set_8cc_source.html">dof_accessor_set.cc</a>.</p>

</div>
</div>
<a id="a4b373ea3845c1be186681ceb4d1d28f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b373ea3845c1be186681ceb4d1d28f8">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename number , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过将自由度的局部编号映射到全局编号并将局部值输入全局向量，将局部（基于单元）向量分配到全局向量。换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 这些元素被 <em> 添加到全局向量的现有元素中，而不是直接设置，因为这通常是人们想要的。如果你需要处理约束条件，你可能还想看一下 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数。 </em></p>

</div>
</div>
<a id="add2ea6075920c592b31132352385415d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add2ea6075920c592b31132352385415d">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过将自由度的本地编号映射到全局编号并将本地值输入全局向量，将迭代器格式的本地（基于单元）向量分配给全局向量。 换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 这些元素被 <em> 添加到全局向量中的现有元素上，而不是直接设置，因为这通常是人们想要的。如果你需要处理约束条件，你可能还想看一下 <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">AffineConstraints::distribute_local_to_global()</a> 函数。 </em></p>

</div>
</div>
<a id="ab90bb534e64a5a9c10d9f6a161c1a0c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90bb534e64a5a9c10d9f6a161c1a0c5">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutputVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>local_source_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过将自由度的本地编号映射到全局编号并将本地值输入全局向量，将迭代器格式的本地（基于单元）向量分布到全局向量中。 换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 这些元素被 <em> 添加到 </em> 全局向量中的元素，而不是仅仅设置，因为这通常是人们想要的。此外，传递给这个函数的AffineConstraints对象确保了在这个过程中也消除了约束。 </p>

</div>
</div>
<a id="a629b9490f29a4b030dd897a733116ccb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a629b9490f29a4b030dd897a733116ccb">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename number , typename OutputMatrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputMatrix &amp;&#160;</td>
          <td class="paramname"><em>global_destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与<code>distribute_local_to_global(Vector,Vector)</code>函数的作用基本相同，但是对矩阵而不是向量进行操作。如果矩阵类型是稀疏矩阵，那么它就应该在需要的地方有非零的入口槽。 </p>

</div>
</div>
<a id="ab0917cd50db0119a5efe0309ec13370f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0917cd50db0119a5efe0309ec13370f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;typename number , typename OutputMatrix , typename OutputVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputMatrix &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputVector &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数做了两个<code>distribute_local_to_global</code>函数与向量和矩阵参数的作用，但都是一次性的。 </p>

</div>
</div>
<a id="a15ef35e919b1005dc6050f9bca96956d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15ef35e919b1005dc6050f9bca96956d">&#9670;&nbsp;</a></span>get_active_or_mg_dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_active_or_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取此单元上的局部自由度的全局指数。 如果这个对象访问了一个水平单元（由第三个模板参数或::is_level_cell表示），那么返回get_mg_dof_indices()的结果，否则返回get_dof_indices()。 当调用begin_mg()时，你会得到一个level_cell_iterator，否则就是一个普通的level_cell_iterator。 这种用法的例子是在DoFRenumbering的实现中。 </p>

</div>
</div>
<a id="aeab120d78d3fdf70cf83a52b870ec8d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeab120d78d3fdf70cf83a52b870ec8d6">&#9670;&nbsp;</a></span>get_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回位于此对象上的自由度的<em>global</em>指数，其标准排序由有限元定义（即顶点0上的自由度，顶点1上的自由度，等等，行0上的自由度，行1上的自由度，等等，四边形0上的自由度，等等）该函数仅适用于<em>active</em>对象（见 本词汇条 ）。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">dof_indices</td><td>指数将被写入的向量。在传递给这个函数之前，它必须有合适的大小（即 <code>fe.n_dofs_per_cell()</code>, <code>fe.dofs_per_face</code> ，或 <code>fe.dofs_per_line</code> ，取决于这个函数被调用的对象的种类）。 这个函数重新实现了基类中的同一个函数。与基类中的函数相比，我们在这里不需要 <code>fe_index</code> ，因为单元格上总是有一个唯一的有限元索引。 这是一个要求单元格处于活动状态的函数。 也请看get_active_or_mg_dof_indices()。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>在本教程的许多地方和库的其他地方，这个函数的参数按惯例被称为 <code>local_dof_indices</code> 。这个名字并不意味着表示自由度的<em>local</em>数量（总是在0和 <code>fe.n_dofs_per_cell()</code> 之间），而是表示返回值是位于当前单元格上的那些自由度的<em>global</em>指数。 </dd></dl>

</div>
</div>
<a id="ad5b7ee5a2c16b2dfacd9139bed6bed4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5b7ee5a2c16b2dfacd9139bed6bed4d">&#9670;&nbsp;</a></span>get_mg_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检索该单元上的自由度在与该单元的级别相关的级别向量中的全局指数。 </p>

</div>
</div>
<a id="ace7438827be3421cdb64c67f28c7aa60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7438827be3421cdb64c67f28c7aa60">&#9670;&nbsp;</a></span>get_fe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dimension_, space_dimension_&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回用于此迭代器所指向的单元格的有限元。对于没有hp-capabilities的DoFHandler对象，这当然总是同一个元素，与我们目前所在的单元无关，但是对于hp-DoFHandler对象，这可能会在不同的单元之间变化。 </p><dl class="section note"><dt>Note</dt><dd>由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的此类对象），在非活动单元上查询有限元是没有意义的，因为它们没有任何自由度的有限元空间与它们相关联。因此，这个函数在非活动单元上调用时将产生一个异常。 </dd></dl>

</div>
</div>
<a id="a5a196a66be2e332d0f302e6b579f47fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a196a66be2e332d0f302e6b579f47fe">&#9670;&nbsp;</a></span>active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::active_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回用于该单元的有限元空间 <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> 内的索引。这个函数只有在与当前单元格相关的DoFHandler对象启用了hp-capabilities时才有用。 </p><dl class="section note"><dt>Note</dt><dd>由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的此类对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，当在非活动单元上调用该函数时将产生一个异常。 </dd>
<dd>
当使用平行网格时，无论是通过 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 还是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类，都只允许在本地拥有的或幽灵单元上调用此函数。没有关于人工单元的信息。 此外， <code>active_fe_index</code> 信息只在调用 <a class="el" href="classDoFHandler.html#a9bfa2a27515e777f79bd98ec345fcdda">DoFHandler::set_fe()</a> 和 <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>. 期间从一个处理器上的本地拥有的细胞交换到其他可能是幽灵细胞的处理器。 请注意，如果你在调用这些函数之一后在一个细胞上调用set_active_fe_index()，那么这个信息将不会传播给其他可能将这个细胞作为幽灵细胞的处理器。更多信息请参见DoFHandler的文档。 </dd></dl>

</div>
</div>
<a id="a44babdcd7954cdfdd9f9497781cc22ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44babdcd7954cdfdd9f9497781cc22ae">&#9670;&nbsp;</a></span>set_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置用于此单元的FiniteElement的索引。这决定了要使用 <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> 中的哪个元素。这个函数只有在与当前单元相关的DoF处理程序对象启用了hp-功能时才有用。 </p><dl class="section note"><dt>Note</dt><dd>由于自由度只存在于具有hp-能力的DoFHandler对象的活动单元上（即目前没有实现多层次的这种对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，当在非活动单元上调用该函数时，将产生一个异常。 </dd>
<dd>
当使用平行网格时，无论是通过 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 还是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类，都只允许在本地拥有的或幽灵单元上调用该函数。没有关于人工单元的信息。 此外， <code>active_fe_index</code> 信息只在调用 <a class="el" href="classDoFHandler.html#a9bfa2a27515e777f79bd98ec345fcdda">DoFHandler::set_fe()</a> 和 <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs()</a>. 期间，从一个处理器上的本地拥有的细胞交换到其他可能是幽灵细胞的处理器上。 请注意，如果你在调用这些函数之一后，在一个细胞上调用set_active_fe_index()，那么这个信息将不会传播给其他可能将这个细胞作为幽灵细胞的处理器。更多信息请参见DoFHandler的文档。 </dd></dl>

</div>
</div>
<a id="ab391b1952d50bbe49fb11e4d4a400acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab391b1952d50bbe49fb11e4d4a400acc">&#9670;&nbsp;</a></span>set_dof_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::set_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此单元的DoF指数设置为给定值。如果给定的DoF处理程序类存在DoF缓存，该函数会绕过DoF缓存。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8cc_source.html#l00124">124</a> of file <a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a>.</p>

</div>
</div>
<a id="ac76cef754ca3b14d1f13ef2c01a4a999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac76cef754ca3b14d1f13ef2c01a4a999">&#9670;&nbsp;</a></span>set_mg_dof_indices() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此单元格的Level DoF指数设置为给定值。 </p>

</div>
</div>
<a id="a42873cdeb9f69ee1e1ce43e055e6e4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42873cdeb9f69ee1e1ce43e055e6e4f6">&#9670;&nbsp;</a></span>update_cell_dof_indices_cache()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, bool lda&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, lda &gt;::update_cell_dof_indices_cache </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>更新缓存，我们在其中存储该单元的DoF指数。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8cc_source.html#l00108">108</a> of file <a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a>.</p>

</div>
</div>
<a id="a7558706ae1d781bf54ec29f85e862d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7558706ae1d781bf54ec29f85e862d62">&#9670;&nbsp;</a></span>get_future_fe()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dimension_, space_dimension_&gt;&amp; <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::get_future_fe </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回下次三角剖分被细化和粗化时将分配给该单元的有限元。如果没有通过set_future_fe_index()函数为该单元指定未来的有限元，则活动的有限元将保持不变，在这种情况下，将返回活动的有限元。 对于没有启用hp-capabilities的DoFHandler，这当然总是同一个元素，与我们目前所在的单元无关，但是对于hp- DoFHandler对象，这可能会在不同的单元之间变化。 </p><dl class="section note"><dt>Note</dt><dd>由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的此类对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，这个函数在非活动单元上调用时将产生一个异常。 </dd></dl>

</div>
</div>
<a id="ae4d4d8562cb47b70b797369b8872b04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4d4d8562cb47b70b797369b8872b04d">&#9670;&nbsp;</a></span>future_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::future_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回有限元的fe_index，该有限元将在下一次三角结构被细化和粗化时分配给该单元。如果没有通过set_future_fe_index()函数为该单元指定未来的有限元，则活动的单元将保持不变，在这种情况下，将返回活动有限元的fe_index。 </p><dl class="section note"><dt>Note</dt><dd>由于自由度只存在于具有hp-capabilities的DoFHandler对象的活动单元上（即目前没有实现多层次的这种对象），在非活动单元上查询有限元是没有意义的，因为它们没有与之相关的有限元空间，没有任何自由度。因此，当在非活动单元上调用该函数时，将产生一个异常。 </dd>
<dd>
当使用平行网格时，无论是通过 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 还是 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 类，只允许在本地拥有的单元上调用该函数。 </dd></dl>

</div>
</div>
<a id="ab9f2896ef67d3d11ec3d23d382b19c46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9f2896ef67d3d11ec3d23d382b19c46">&#9670;&nbsp;</a></span>set_future_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::set_future_fe_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置有限元的fe_index，该有限元将在下一次三角结构被细化和粗化时被分配给该单元。之前分配的未来有限元将被覆盖。 参见future_fe_index()的注释，以了解对该功能的限制信息。 </p>

</div>
</div>
<a id="ae7949017e7a76aa15c2dcff7871401e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7949017e7a76aa15c2dcff7871401e1">&#9670;&nbsp;</a></span>future_fe_index_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::future_fe_index_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回是否已经设置了未来有限元。 参见future_fe_index()的注释，以了解对该功能的限制信息。 </p>

</div>
</div>
<a id="aa67f45fd024b1a960c2f67920dbab58c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67f45fd024b1a960c2f67920dbab58c">&#9670;&nbsp;</a></span>clear_future_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::clear_future_fe_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>撤销分配的未来有限元。因此，在下一次三角结构被细化和粗化时，活动的有限元将保持不变。 参见future_fe_index()的说明，以了解对该功能的限制。 </p>

</div>
</div>
<a id="a49329d7429a4dad355b2b8c859e7e60a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49329d7429a4dad355b2b8c859e7e60a">&#9670;&nbsp;</a></span>get_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>&gt;&amp; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_dof_handler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个我们正在使用的DoFHandler对象的句柄。 </p>

</div>
</div>
<a id="aa2203fb607f6ae1f79d860a41efdf37c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2203fb607f6ae1f79d860a41efdf37c">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, dim, spacedim, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>实现迭代器类所需的复制操作。 </p>

</div>
</div>
<a id="a9a040127cdbb584aefbf38779ca7ac57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a040127cdbb584aefbf38779ca7ac57">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriaAccessorBase.html">TriaAccessorBase</a>&lt; structdim, dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>da</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器类所使用的复制运算器。保留之前设置的dof处理程序，但设置TriaAccessor的对象坐标。 </p>

</div>
</div>
<a id="ade1461f1a5ea5564fcc1ba2be6641f10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1461f1a5ea5564fcc1ba2be6641f10">&#9670;&nbsp;</a></span>is_level_cell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::is_level_cell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>告诉调用者get_active_or_mg_dof_indices()是访问活动的还是水平的道夫。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01794">1794</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="aad0cb2f5249c0ee51e693366e40e1388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad0cb2f5249c0ee51e693366e40e1388">&#9670;&nbsp;</a></span>line()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::DoFHandlerImplementation:: Iterators&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access&gt;::line_iterator <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::line </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向与此对象相界的 <code>ith</code> 线的指针。如果当前对象本身是一条线，那么唯一有效的索引是 <code>i</code> 等于零，并且该函数返回一个指向自身的迭代器。 </p>

</div>
</div>
<a id="a7ad78d479734c818ddd3c928bb5e1537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad78d479734c818ddd3c928bb5e1537">&#9670;&nbsp;</a></span>quad()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typename ::internal::DoFHandlerImplementation:: Iterators&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access&gt;::quad_iterator <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::quad </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向与此对象相邻的 <code>ith</code> 四边形的指针。如果当前对象本身是一个四边形，那么唯一有效的索引是 <code>i</code> 等于零，并且该函数返回一个指向自身的迭代器。 </p>

</div>
</div>
<a id="a9553dfc2e807a7bce21a950e938a3e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9553dfc2e807a7bce21a950e938a3e9f">&#9670;&nbsp;</a></span>get_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_dof_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回位于此对象上的自由度的<em>global</em>指数，以有限元定义的标准排序（即顶点0上的自由度，顶点1上的自由度，等等，行0上的自由度，行1上的自由度，等等，quad 0上的自由度，等等）此函数仅对<em>active</em>对象可用（见 此词汇条 ）。 单元需要是一个活跃的单元（而不是平行分布式计算中的人工）。 向量在传递给这个函数之前必须有合适的大小。 最后一个参数表示有限元素的索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一有限元。 然而，当相关的DoFHandler对象启用了hp-capabilities，不同的有限元对象可以在不同的单元格上使用。因此，在两个单元之间的面以及顶点上，可能有两组自由度，相邻单元上使用的每个有限元都有一个。为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 对于单元，只有一个可能的有限元指数（即该单元的指数，由 <code>cell-&gt;active_fe_index</code> 返回。 因此，派生的DoFCellAccessor类有一个该函数的重载版本，它以 <code>cell-&gt;active_fe_index</code> 为最后参数调用本函数。 </p>

</div>
</div>
<a id="adeace582710e57d3d8911e77d73a8b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adeace582710e57d3d8911e77d73a8b55">&#9670;&nbsp;</a></span>get_mg_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回当前对象上的自由度的全局多级指数，相对于多网格层次结构中的给定层次而言。指数是指该行所处层次的本地编号。 </p>

</div>
</div>
<a id="a4564ad65573f50f8b3d02dfb6d07e0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4564ad65573f50f8b3d02dfb6d07e0ac">&#9670;&nbsp;</a></span>set_mg_dof_indices() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_mg_dof_indices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置由get_mg_dof_indices返回的层次DoF指数。 </p>

</div>
</div>
<a id="a5aa1f2d13ea10d3e36d7fc6d982467ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa1f2d13ea10d3e36d7fc6d982467ed">&#9670;&nbsp;</a></span>vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与当前单元的 <code>vertexth</code> 顶点相关的<em>i</em>度的全局DoF指数。 最后一个参数表示的是有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类反正只支持所有单元上的相同有限元。 然而，当hp-capabilities被启用时，不同的有限元对象可以被用于不同的单元。因此，在两个单元之间的面以及顶点上，可能有两组自由度，相邻单元上使用的每个有限元都有一个。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 </p>

</div>
</div>
<a id="acc4402930fd9d6e7745befbf0028cd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4402930fd9d6e7745befbf0028cd59">&#9670;&nbsp;</a></span>mg_vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::mg_vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回与 <code>level</code>. 层的 <code>vertex</code> 个顶点相关的 <code>i</code> 个自由度的全局DoF索引。 也可以参见vertex_dof_index()。 </p>

</div>
</div>
<a id="a65cc20ce96d8d7501d113c578ecb2ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cc20ce96d8d7501d113c578ecb2ea8">&#9670;&nbsp;</a></span>dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个对象的第<em>i</em>个自由度的索引。 最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于它的默认值，因为该类反正只支持所有单元上的同一个有限元。 然而，当hp-capabilities被启用时，不同的有限元对象可以被用于不同的单元。因此，在两个单元之间的面以及顶点上，可能有两组自由度，相邻单元上使用的每个有限元都有一个。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果相匹配。 </p><dl class="section note"><dt>Note</dt><dd>虽然get_dof_indices()函数返回一个数组，其中包含以某种方式存在于这个对象上的所有自由度的索引（即在这个对象的顶点、边或内部），但当前的dof_index()函数只考虑真正属于这个特定对象内部的自由度。换句话说，举个例子，如果当前对象指的是一个四边形（2D中的单元，3D中的面），并且与之相关的有限元是双线性的，那么get_dof_indices()会返回一个大小为4的数组，而dof_index()会产生一个异常，因为在面的内部没有定义度。 </dd></dl>

</div>
</div>
<a id="acad7c02ba6168b40bca90e4fb8c2f8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7c02ba6168b40bca90e4fb8c2f8ee">&#9670;&nbsp;</a></span>mg_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::mg_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回给定层面上的dof_index。也见dof_index。 </p>

</div>
</div>
<a id="ad3a5c19a4bf840dad9e1185d78526b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a5c19a4bf840dad9e1185d78526b4b">&#9670;&nbsp;</a></span>n_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::n_active_fe_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回在给定对象上激活的有限元的数量。 当hp-capabilities被禁用时，答案当然总是1。 然而，当hp-capabilities被启用时，情况就不是这样了。如果这是一个单元，答案当然是1。如果它是一个面，答案可能是1或2，取决于相邻的两个单元是否使用相同的有限元。如果它是一个3D的边，可能的返回值可能是1或大于这个值的任何其他值。 </p>

</div>
</div>
<a id="add0021f581f717926769d03779c8739c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add0021f581f717926769d03779c8739c">&#9670;&nbsp;</a></span>nth_active_fe_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::nth_active_fe_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此对象上的 <code>n-th</code> 活动FE索引。对于单元格和所有非hp-objects，只有一个活跃的FE索引，所以参数必须等于0。对于低维的hp-objects，有n_active_fe_indices()活动有限元，这个函数可以查询它们的指数。 </p>

</div>
</div>
<a id="a5cc4f3541c18e4f2c59fd39061fd4caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc4f3541c18e4f2c59fd39061fd4caf">&#9670;&nbsp;</a></span>get_active_fe_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_active_fe_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回此对象上的所有活动FE指数。 返回的集合的大小等于此对象上活动的有限元的数量。 </p>

</div>
</div>
<a id="aa107e710976f26c4ab9a49275c5ce23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa107e710976f26c4ab9a49275c5ce23c">&#9670;&nbsp;</a></span>fe_index_is_active()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::fe_index_is_active </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果具有给定索引的有限元在当前对象上处于活动状态，则返回真。当当前DoFHandler没有hp-能力时，当然只有当 <code>fe_index</code> 等于0时才是这种情况。对于单元格来说，如果 <code>fe_index</code> 等于该单元格的active_fe_index()，则是这种情况。对于面和其他低维物体，可能有一个以上的 <code>fe_index</code> 在任何给定的物体上是活跃的（见n_active_fe_indices()）。 </p>

</div>
</div>
<a id="ad067228a1d5ae86639f2719b84a71c9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad067228a1d5ae86639f2719b84a71c9e">&#9670;&nbsp;</a></span>get_fe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>&gt;&amp; <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::get_fe </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回给定 <code>fe_index</code>. 在此对象上使用的有限元的引用 <code>fe_index</code> 必须在此对象上使用，即 <code>fe_index_is_active(fe_index)</code> 必须返回true。 </p>

</div>
</div>
<a id="ga36b9816a464913e80b640d7778b6a2a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga36b9816a464913e80b640d7778b6a2a6">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidObject&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;This accessor object has not been &quot; &quot;associated with any <a class="el" href="classDoFHandler.html">DoFHandler</a> object.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>子类的例外情况 </p>

</div>
</div>
<a id="gace9faa28de1bfa14fe42acae5ec0c795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gace9faa28de1bfa14fe42acae5ec0c795">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorNotEmpty&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ga9f84a1c8defd39d3e0ce848f2c1f6caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f84a1c8defd39d3e0ce848f2c1f6caf">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcVectorDoesNotMatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ga4c716f4f4f6718bca364135fa8980527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c716f4f4f6718bca364135fa8980527">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcMatrixDoesNotMatch&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ga0fe397e0b77ee7550e2394ba96f7fb70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fe397e0b77ee7550e2394ba96f7fb70">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcNotActive&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为一个应该是 活动  的单元格调用了一个函数，但它被细化了。 </p>

</div>
</div>
<a id="ga00741f1400034d3faca2ca3bed41b29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga00741f1400034d3faca2ca3bed41b29a">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcCantCompareIterators&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ac6ae8fec03877b971fd7832d92704be4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ae8fec03877b971fd7832d92704be4">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较是否相等。如果两个访问器引用的是同一个对象，则返回<code>true</code>。 这个函数的模板参数允许对非常不同的对象进行比较。因此，其中一些被禁用。也就是说，如果两个对象的尺寸或dof处理程序不同，会产生一个异常。可以预见，这是一个不需要的比较。 模板参数<code>level_dof_access2</code>被忽略了，这样，一个有级别访问的迭代器可以等于一个有活动自由度访问的迭代器。 </p>

</div>
</div>
<a id="a90137a1310b0ec72b89cfb60e1f51145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90137a1310b0ec72b89cfb60e1f51145">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim2, dim2, spacedim2, level_dof_access2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>比较不等式。操作符==()的布尔值不是。 </p>

</div>
</div>
<a id="a616da3ae411e1649bc75ed330f756388"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a616da3ae411e1649bc75ed330f756388">&#9670;&nbsp;</a></span>set_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_dof_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>dh</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>重置DoF处理程序指针。 </p>

</div>
</div>
<a id="abe3cdc6b6fa4abf71bdec21c022c0506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3cdc6b6fa4abf71bdec21c022c0506">&#9670;&nbsp;</a></span>set_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将此对象的<em>i</em>个自由度的索引设置为 <code>个索引。</code> 最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的同一有限元。 然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 </p>

</div>
</div>
<a id="a17282fe1c8b6b2131f01455871065e0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17282fe1c8b6b2131f01455871065e0a">&#9670;&nbsp;</a></span>set_mg_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_mg_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac48185a4fe62cf31fb6313777072e233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48185a4fe62cf31fb6313777072e233">&#9670;&nbsp;</a></span>set_vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将当前单元的 <code>vertex-th</code> 顶点上的<em>i</em>度的全局索引设置为 <code>index</code>. 最后一个参数表示有限元索引。对于标准的::DoFHandler类，这个值必须等于其默认值，因为该类无论如何只支持所有单元上的相同有限元。 然而，当相关的DoFHandler具有hp-capabilities时，不同的有限元对象可以在不同的单元上使用。在两个单元格之间的面上，以及顶点上，可能会有两组自由度，相邻单元格上使用的有限元各有一组。 为了指定在哪一组自由度上工作，最后一个参数被用来区别对待。最后，如果这个函数是为一个单元对象调用的，那么只能有一个自由度集，而且fe_index必须与active_fe_index()的结果一致。 </p>

</div>
</div>
<a id="af521f2a697ac2b7dec0e8196933979c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af521f2a697ac2b7dec0e8196933979c4">&#9670;&nbsp;</a></span>set_mg_vertex_dof_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::set_mg_vertex_dof_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_index</em> = <code><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim,&#160;spacedim&gt;::invalid_fe_index</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0f77c88bd6841a98bf02a4a398551115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f77c88bd6841a98bf02a4a398551115">&#9670;&nbsp;</a></span>DoFHandler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<div class="memtemplate">
template&lt;int , int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classDoFHandler.html">DoFHandler</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<ul>
<li>网格细化时，子单元会继承父单元的活动FE索引。</li>
<li>当粗化单元时，（现在活动的）父单元将被分配一个活动的FE索引，该索引由其（不再活动的）子单元决定，遵循FiniteElementDomination逻辑。在以前分配给前子女的元素集合中，我们选择一个由所有子女支配的元素作为父单元。如果没有找到，我们就在整个集合中挑选一个被所有以前的孩子支配的最主要的元素。关于这个主题的进一步信息，请参见 <a class="el" href="classhp_1_1FECollection.html#aae4e336f83e16ba6291d3748d52438d8">hp::FECollection::find_dominated_fe_extended()</a> 。 <dl class="section note"><dt>Note</dt><dd>有限元素需要先通过调用set_fe()或distribution_dofs()来分配给每个单元格，以使这个功能可用。 <h3>Active FE indices and parallel meshes</h3>
</dd></dl>
当这个类与 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> 或 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 一起使用时，你只能在本地拥有的单元上设置活动FE指数，使用诸如 <code>cell-&gt;set_active_fe_index(...)</code> 的调用。 另一方面，不允许在幽灵或人工单元上设置活动FE指数。 然而，幽灵单元确实获得了什么元素在其上处于活动状态的信息：每当你调用 hp::DoFHandler::distribute_dofs(), 时，所有参与并行网格的处理器都会以这样的方式交换信息，幽灵单元上的活动FE指数等于在拥有该特定幽灵单元的处理器上设置的活动FE指数。 因此，人们可以<em>query</em>幽灵单元上的 <code>active_fe_index</code> ，只是不能用手去设置。 在人工单元上，没有关于那里使用的 <code>active_fe_index</code> 的信息可用。这是因为我们甚至不知道这些细胞是否存在，即使存在，当前的处理器也不知道关于它们的任何具体信息。 更多信息见 人工细胞的词汇表条目 。 在细化和粗化过程中，关于每个单元的 <code>active_fe_index</code> 的信息将被自动转移。 然而，使用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 和 <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> 需要在序列化过程中额外注意，因为活动FE指数的信息不会被自动转移。这必须使用prepare_for_serialization_of_active_fe_indices()和deserialize_active_fe_indices()函数手动完成。前者必须在调用 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#ac954bc1132f894e7deadb42325d526ae">parallel::distributed::Triangulation::save()</a> 之前调用，后者需要在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a8474dcd5abd74ec77b8a1fea2d8ec3fe">parallel::distributed::Triangulation::load()</a>. 之后运行。 如果进一步的数据将通过 <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a>, <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a>, 或 <a class="el" href="classParticles_1_1ParticleHandler.html">Particles::ParticleHandler</a> 类附加到三角形上，所有相应的准备和反序列化函数调用需要以相同的顺序发生。更多信息请参考 <a class="el" href="classparallel_1_1distributed_1_1SolutionTransfer.html">parallel::distributed::SolutionTransfer</a> 的文档。 @ :: 现在能够进行hp-adaptation。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01787">1787</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a0cf63b7b7600d230112f86fe73e1afdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cf63b7b7600d230112f86fe73e1afdb">&#9670;&nbsp;</a></span>::internal::DoFCellAccessorImplementation::Implementation</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct ::internal::DoFCellAccessorImplementation::Implementation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01788">1788</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a6d4509b7753b800d9fd7039bca79f7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d4509b7753b800d9fd7039bca79f7ad">&#9670;&nbsp;</a></span>dim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::dim = dimension_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从DoFHandler中提取尺寸。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01193">1193</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a8b0e36ef5665c0ad1921049acb84604e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b0e36ef5665c0ad1921049acb84604e">&#9670;&nbsp;</a></span>spacedim</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimension_, int space_dimension_, bool level_dof_access&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFCellAccessor.html">DoFCellAccessor</a>&lt; dimension_, space_dimension_, level_dof_access &gt;::spacedim = space_dimension_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从DoFHandler中提取空间维度。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l01199">1199</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a5d8274de3efd9a8b566e3b7a27a1a286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8274de3efd9a8b566e3b7a27a1a286">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个静态变量，允许该类的用户发现第二个模板参数的值。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00177">177</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="a0ebf5625b40e2ecedaaeef5f684d3fab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ebf5625b40e2ecedaaeef5f684d3fab">&#9670;&nbsp;</a></span>space_dimension</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::space_dimension</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个静态变量，允许这个类的用户发现第三个模板参数的值。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00183">183</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<a id="aea85e74a2de50f84acd6b53c8e2a55e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea85e74a2de50f84acd6b53c8e2a55e1">&#9670;&nbsp;</a></span>dof_handler</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;<a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>&gt;* <a class="el" href="classDoFAccessor.html">DoFAccessor</a>&lt; structdim, <a class="el" href="classDoFCellAccessor.html#a6d4509b7753b800d9fd7039bca79f7ad">dim</a>, <a class="el" href="classDoFCellAccessor.html#a8b0e36ef5665c0ad1921049acb84604e">spacedim</a>, level_dof_access &gt;::dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储要访问的DoFHandler对象的地址。 </p>

<p class="definition">Definition at line <a class="el" href="dof__accessor_8h_source.html#l00571">571</a> of file <a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/dofs/<a class="el" href="dof__accessor_8h_source.html">dof_accessor.h</a></li>
<li>source/dofs/<a class="el" href="dof__accessor_8cc_source.html">dof_accessor.cc</a></li>
<li>source/dofs/<a class="el" href="dof__accessor__get_8cc_source.html">dof_accessor_get.cc</a></li>
<li>source/dofs/<a class="el" href="dof__accessor__set_8cc_source.html">dof_accessor_set.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
