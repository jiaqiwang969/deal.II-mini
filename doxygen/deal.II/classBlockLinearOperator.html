<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classBlockLinearOperator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: BlockLinearOperator&lt; Range, Domain, BlockPayload &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classBlockLinearOperator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockLinearOperator&lt; Range, Domain, BlockPayload &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__LAOperators.html">Linear Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="block__linear__operator_8h_source.html">deal.II/lac/block_linear_operator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BlockLinearOperator&lt; Range, Domain, BlockPayload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classBlockLinearOperator__inherit__graph.svg" width="434" height="352"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2b106db0ddd0a15dadaeffd860207745"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a> = <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;</td></tr>
<tr class="separator:a2b106db0ddd0a15dadaeffd860207745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2533970716e61d8476d73b5977d1d89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ad2533970716e61d8476d73b5977d1d89">BlockLinearOperator</a> (const BlockPayload &amp;payload)</td></tr>
<tr class="separator:ad2533970716e61d8476d73b5977d1d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ec9b81e5e32b47a1bd886bd35bb65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a7c2ec9b81e5e32b47a1bd886bd35bb65">BlockLinearOperator</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;)=default</td></tr>
<tr class="separator:a7c2ec9b81e5e32b47a1bd886bd35bb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7954607fc2738d7e6c4b245f9584103"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:ac7954607fc2738d7e6c4b245f9584103"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ac7954607fc2738d7e6c4b245f9584103">BlockLinearOperator</a> (const Op &amp;op)</td></tr>
<tr class="separator:ac7954607fc2738d7e6c4b245f9584103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89297fe5e51d1f7a259e4f8fc315b53"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n&gt; </td></tr>
<tr class="memitem:ac89297fe5e51d1f7a259e4f8fc315b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ac89297fe5e51d1f7a259e4f8fc315b53">BlockLinearOperator</a> (const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ac89297fe5e51d1f7a259e4f8fc315b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b31166960bf69ec7a224c8475ed9c3"><td class="memTemplParams" colspan="2">template&lt;std::size_t m&gt; </td></tr>
<tr class="memitem:a20b31166960bf69ec7a224c8475ed9c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a20b31166960bf69ec7a224c8475ed9c3">BlockLinearOperator</a> (const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;ops)</td></tr>
<tr class="separator:a20b31166960bf69ec7a224c8475ed9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af364b6a7badf5bb89544502e73f174ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#af364b6a7badf5bb89544502e73f174ba">operator=</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;)=default</td></tr>
<tr class="separator:af364b6a7badf5bb89544502e73f174ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4667a076be7c90b9ab1ce52c5dddafb8"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a4667a076be7c90b9ab1ce52c5dddafb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a4667a076be7c90b9ab1ce52c5dddafb8">operator=</a> (const Op &amp;op)</td></tr>
<tr class="separator:a4667a076be7c90b9ab1ce52c5dddafb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647d2c1ed00b17cea968232bcbc11dc2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n&gt; </td></tr>
<tr class="memitem:a647d2c1ed00b17cea968232bcbc11dc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a647d2c1ed00b17cea968232bcbc11dc2">operator=</a> (const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:a647d2c1ed00b17cea968232bcbc11dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c80efa27b434662583eca74c5b4a2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m&gt; </td></tr>
<tr class="memitem:a187c80efa27b434662583eca74c5b4a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a187c80efa27b434662583eca74c5b4a2">operator=</a> (const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;ops)</td></tr>
<tr class="separator:a187c80efa27b434662583eca74c5b4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac42d948813da72836e1a661acd3beea4"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ac42d948813da72836e1a661acd3beea4">n_block_rows</a></td></tr>
<tr class="separator:ac42d948813da72836e1a661acd3beea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab414e1ffc37fba57ef140634152736c9"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ab414e1ffc37fba57ef140634152736c9">n_block_cols</a></td></tr>
<tr class="separator:ab414e1ffc37fba57ef140634152736c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174ae91be3b59658fdcc5c5460bd350"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>(unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a6174ae91be3b59658fdcc5c5460bd350">block</a></td></tr>
<tr class="separator:a6174ae91be3b59658fdcc5c5460bd350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995891407aca97d53bbb2a80b9e0b3db"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, const Domain &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a></td></tr>
<tr class="separator:a995891407aca97d53bbb2a80b9e0b3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6da2c4b33b66c23ea2679ff100de3"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, const Domain &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a></td></tr>
<tr class="separator:a5eb6da2c4b33b66c23ea2679ff100de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6968174d73bf018f6d0c9181c730e217"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, const Range &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a></td></tr>
<tr class="separator:a6968174d73bf018f6d0c9181c730e217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36a8841e61b3dbea54cf3745e56c140"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, const Range &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a></td></tr>
<tr class="separator:ad36a8841e61b3dbea54cf3745e56c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa470d7770714cfe9a64bf0f0d817d71f"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#aa470d7770714cfe9a64bf0f0d817d71f">reinit_range_vector</a></td></tr>
<tr class="separator:aa470d7770714cfe9a64bf0f0d817d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a9e4c7d8bf0edbb253b938d831e43"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a818a9e4c7d8bf0edbb253b938d831e43">reinit_domain_vector</a></td></tr>
<tr class="separator:a818a9e4c7d8bf0edbb253b938d831e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creation of a BlockLinearOperator</div></td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename BlockPayload , typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gad48a267ed219e65f5316204a8e9c87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3b78c08372b54dc7bc9a2cf6b497baba">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga4f98cbf0ce0df665a068394a306fd0b7">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">block_diagonal_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Manipulation of a BlockLinearOperator</div></td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2e93f2424bc70a566a1a46ee8c0b1c31">block_forward_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga8b2bf4fd828e4ee7539bcc16c8b19777">block_back_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creation of a BlockLinearOperator</div></td></tr>
<tr class="memitem:ga0dcbb8ef00703fc453c9c38a35d9dad6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga0dcbb8ef00703fc453c9c38a35d9dad6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#ga0dcbb8ef00703fc453c9c38a35d9dad6">block_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;block_matrix)</td></tr>
<tr class="separator:ga0dcbb8ef00703fc453c9c38a35d9dad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29af932e0238c35b0dee9ea2554d6c17"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga29af932e0238c35b0dee9ea2554d6c17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#ga29af932e0238c35b0dee9ea2554d6c17">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga29af932e0238c35b0dee9ea2554d6c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5be3da7a2d60ec62018555d6a8a2d1"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:gabe5be3da7a2d60ec62018555d6a8a2d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gabe5be3da7a2d60ec62018555d6a8a2d1">block_diagonal_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;block_matrix)</td></tr>
<tr class="separator:gabe5be3da7a2d60ec62018555d6a8a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c6a35a2ccdaba1dd42ac7502314c02"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:gac8c6a35a2ccdaba1dd42ac7502314c02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gac8c6a35a2ccdaba1dd42ac7502314c02">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:gac8c6a35a2ccdaba1dd42ac7502314c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Indirectly applying constraints to LinearOperator</div></td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga814d426ef355ed315bb57cea21a7630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;linop)</td></tr>
<tr class="separator:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;linop, const Range &amp;right_hand_side)</td></tr>
<tr class="separator:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector space operations</div></td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Composition and manipulation of a LinearOperator</div></td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, BlockPayload::BlockType &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creation of a LinearOperator</div></td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga373310de5b48d5a70b9cdd47834da48f">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga373310de5b48d5a70b9cdd47834da48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2043a16b6855670766f46780a39f03f3">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga2043a16b6855670766f46780a39f03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a> (const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga14dbc8c2c27ea3fd45576528a891c6e2">linear_operator</a> (const OperatorExemplar &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creation of a LinearOperator</div></td></tr>
<tr class="memitem:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gaf2a467ed50213dea8c580b67ee466c7c">linear_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54eadb16250f94319528968b4975874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gab54eadb16250f94319528968b4975874">linear_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:gab54eadb16250f94319528968b4975874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Creation of a LinearOperator related to the Schur Complement</div></td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, BlockPayload::BlockType &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, BlockPayload::BlockType &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, BlockPayload::BlockType &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
In-place vector space operations</h2></td></tr>
<tr class="memitem:a99cd172538d9f6d20474deea30ab43f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">is_null_operator</a></td></tr>
<tr class="separator:a99cd172538d9f6d20474deea30ab43f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00069fdcd76bd6f0323ddb0f9421da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a9a00069fdcd76bd6f0323ddb0f9421da">operator+=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:a9a00069fdcd76bd6f0323ddb0f9421da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c73c9d7a1b1b95cdd50a35af95b6cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a3c73c9d7a1b1b95cdd50a35af95b6cba">operator-=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:a3c73c9d7a1b1b95cdd50a35af95b6cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0fe40dda4bc65ec1b7d57f52388bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator*=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:a07a0fe40dda4bc65ec1b7d57f52388bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b305867e831f96aaabe7a7aee8b774e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a2b305867e831f96aaabe7a7aee8b774e">operator*=</a> (typename Domain::value_type number)</td></tr>
<tr class="separator:a2b305867e831f96aaabe7a7aee8b774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Range, typename Domain, typename BlockPayload&gt;<br />
class BlockLinearOperator&lt; Range, Domain, BlockPayload &gt;</h3>

<p>A class to store the concept of a block linear operator.</p>
<p>This class increases the interface of <a class="el" href="classLinearOperator.html">LinearOperator</a> (which encapsulates the <code>Matrix</code> interface) by three additional functions: </p><div class="fragment"><div class="line">std::function&lt;unsigned int()&gt; <a class="code" href="classBlockLinearOperator.html#ac42d948813da72836e1a661acd3beea4">n_block_rows</a>;</div><div class="line">std::function&lt;unsigned int()&gt; <a class="code" href="classBlockLinearOperator.html#ab414e1ffc37fba57ef140634152736c9">n_block_cols</a>;</div><div class="line">std::function&lt;BlockType(unsigned int, unsigned int)&gt; <a class="code" href="classBlockLinearOperator.html#a6174ae91be3b59658fdcc5c5460bd350">block</a>;</div></div><!-- fragment --><p> that describe the underlying block structure (of an otherwise opaque) linear operator.</p>
<p>Objects of type <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> can be created similarly to <a class="el" href="classLinearOperator.html">LinearOperator</a> with a wrapper function: </p><div class="fragment"><div class="line"><a class="code" href="classBlockSparseMatrix.html">::BlockSparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> block_op_a = <a class="code" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>(A);</div></div><!-- fragment --><p>Alternatively, there are several helper functions available for creating instances from multiple independent matrices of possibly different types. Here is an example of a block diagonal matrix created from a <a class="el" href="classFullMatrix.html">FullMatrix</a> and a <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a>:</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> top_left(2, 2);</div><div class="line">top_left(0, 0) = 2.0;</div><div class="line">top_left(0, 1) = -1.0;</div><div class="line">top_left(1, 0) = -1.0;</div><div class="line">top_left(1, 1) = 2.0;</div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrixEZ.html">SparseMatrixEZ&lt;double&gt;</a> bottom_right(4, 4, 4);</div><div class="line"><span class="keywordflow">for</span> (std::size_t row_n = 0; row_n &lt; 4; ++row_n)</div><div class="line">  {</div><div class="line">    bottom_right.add(row_n, row_n, 1.0);</div><div class="line">    <span class="keywordflow">if</span> (row_n &lt; 3)</div><div class="line">      bottom_right.add(row_n, row_n + 1, -1.0);</div><div class="line">  }</div><div class="line"></div><div class="line"><span class="keyword">auto</span> top_left_op = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(top_left);</div><div class="line"><span class="keyword">auto</span> bottom_right_op = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(bottom_right);</div><div class="line">std::array&lt;decltype(top_left_op), 2&gt; operators {{top_left_op,</div><div class="line">                                                 bottom_right_op}};</div><div class="line"><span class="keyword">auto</span> block_op = <a class="code" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (operators);</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes {2, 4};</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> src(block_sizes);</div><div class="line">src = 2.0;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> dst(block_sizes);</div><div class="line">block_op.vmult(dst, src); <span class="comment">// now equal to 2, 2, 0, 0, 0, 2</span></div></div><!-- fragment --><p>A <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> can be sliced to a <a class="el" href="classLinearOperator.html">LinearOperator</a> at any time. This removes all information about the underlying block structure (because above <code>std::function</code> objects are no longer available) - the linear operator interface, however, remains intact.</p>
<dl class="section note"><dt>Note</dt><dd>This class makes heavy use of <code>std::function</code> objects and lambda functions. This flexibility comes with a run-time penalty. Only use this object to encapsulate object with medium to large individual block sizes, and small block structure (as a rule of thumb, matrix blocks greater than \(1000\times1000\)). </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00166">166</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2b106db0ddd0a15dadaeffd860207745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b106db0ddd0a15dadaeffd860207745">&#9670;&nbsp;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a> =  <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00172">172</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2533970716e61d8476d73b5977d1d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2533970716e61d8476d73b5977d1d89">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const BlockPayload &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an empty <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> object.</p>
<p>All<code>std::function</code> member objects of this class and its base class <a class="el" href="classLinearOperator.html">LinearOperator</a> are initialized with default variants that throw an exception upon invocation. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00181">181</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a7c2ec9b81e5e32b47a1bd886bd35bb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ec9b81e5e32b47a1bd886bd35bb65">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default copy constructor. </p>

</div>
</div>
<a id="ac7954607fc2738d7e6c4b245f9584103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7954607fc2738d7e6c4b245f9584103">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Templated copy constructor that creates a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> object from an object <code>op</code> for which the conversion function <code>block_operator</code> is defined. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00222">222</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ac89297fe5e51d1f7a259e4f8fc315b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89297fe5e51d1f7a259e4f8fc315b53">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> from a two-dimensional array <code>ops</code> of <a class="el" href="classLinearOperator.html">LinearOperator</a>. This constructor calls the corresponding <a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator()</a> specialization. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00233">233</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a20b31166960bf69ec7a224c8475ed9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b31166960bf69ec7a224c8475ed9c3">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a block-diagonal <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> from a one-dimensional array <code>ops</code> of <a class="el" href="classLinearOperator.html">LinearOperator</a>. This constructor calls the corresponding <a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator()</a> specialization. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00244">244</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af364b6a7badf5bb89544502e73f174ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af364b6a7badf5bb89544502e73f174ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default copy assignment operator. </p>

</div>
</div>
<a id="a4667a076be7c90b9ab1ce52c5dddafb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4667a076be7c90b9ab1ce52c5dddafb8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Templated copy assignment operator for an object <code>op</code> for which the conversion function <code>block_operator</code> is defined. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00261">261</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a647d2c1ed00b17cea968232bcbc11dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647d2c1ed00b17cea968232bcbc11dc2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment from a two-dimensional array <code>ops</code> of <a class="el" href="classLinearOperator.html">LinearOperator</a>. This assignment operator calls the corresponding <a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator()</a> specialization. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00274">274</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a187c80efa27b434662583eca74c5b4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187c80efa27b434662583eca74c5b4a2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy assignment from a one-dimensional array <code>ops</code> of <a class="el" href="classLinearOperator.html">LinearOperator</a> that creates a block-diagonal <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>. This assignment operator calls the corresponding <a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator()</a> specialization. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00287">287</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a9a00069fdcd76bd6f0323ddb0f9421da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a00069fdcd76bd6f0323ddb0f9421da">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition with a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>second_op</code> with the same <code>Domain</code> and <code>Range</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00324">324</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a3c73c9d7a1b1b95cdd50a35af95b6cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c73c9d7a1b1b95cdd50a35af95b6cba">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction with a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>second_op</code> with the same <code>Domain</code> and <code>Range</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00335">335</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a07a0fe40dda4bc65ec1b7d57f52388bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0fe40dda4bc65ec1b7d57f52388bb">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Composition of the <a class="el" href="classLinearOperator.html">LinearOperator</a> with an endomorphism <code>second_op</code> of the <code>Domain</code> space. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00346">346</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a2b305867e831f96aaabe7a7aee8b774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b305867e831f96aaabe7a7aee8b774e">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of the <a class="el" href="classLinearOperator.html">LinearOperator</a> with <code>number</code> from the right. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00357">357</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ga814d426ef355ed315bb57cea21a7630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814d426ef355ed315bb57cea21a7630a">&#9670;&nbsp;</a></span>distribute_constraints_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; distribute_constraints_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code> and an operator exemplar <code>exemplar</code> (this exemplar is usually a linear operator that describes the system matrix - it is only used to create domain and range vectors of appropriate sizes, its action <code>vmult</code> is never used). A <a class="el" href="classLinearOperator.html">LinearOperator</a> object associated with the "homogeneous
action" of the underlying <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object is returned:</p>
<p>Applying the <a class="el" href="classLinearOperator.html">LinearOperator</a> object on a vector <code>u</code> results in a vector <code>v</code> that stores the result of calling <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> on <code>u</code> - with one important difference: inhomogeneities are not applied, but always treated as 0 instead.</p>
<p>The <a class="el" href="classLinearOperator.html">LinearOperator</a> object created by this function is primarily used internally in <a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator()</a> to build up a modified system of linear equations. How to solve a linear system of equations with this approach is explained in detail in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, this function may not work correctly for distributed data structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00065">65</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga52c9bbeff68309fdc7e4975eddba5eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c9bbeff68309fdc7e4975eddba5eea">&#9670;&nbsp;</a></span>project_to_constrained_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; project_to_constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> <code>constraints</code> and an operator exemplar <code>exemplar</code>, return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the projection to the subspace of constrained degrees of freedom, i.e. all entries of the result vector that correspond to unconstrained degrees of freedom are set to zero. </p>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00158">158</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga4787b401a7e601750d85b8b4fc84c8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4787b401a7e601750d85b8b4fc84c8a5">&#9670;&nbsp;</a></span>constrained_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code> and a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>linop</code>, this function creates a <a class="el" href="classLinearOperator.html">LinearOperator</a> object consisting of the composition of three operations and a regularization: </p><div class="fragment"><div class="line">Ct * linop * <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> + Id_c;</div></div><!-- fragment --><p> with </p><div class="fragment"><div class="line"><a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>);</div><div class="line">Id_c = <a class="code" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a>(constraints, linop);</div></div><!-- fragment --><p> and <code>Id_c</code> is the projection to the subspace consisting of all vector entries associated with constrained degrees of freedom.</p>
<p>This <a class="el" href="classLinearOperator.html">LinearOperator</a> object is used together with <a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side()</a> to build up the following modified system of linear equations: </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> with a given (unconstrained) system matrix \(A\), right hand side \(b\), and linear constraints \(C\) with inhomogeneities \(k\).</p>
<p>A detailed explanation of this approach is given in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, this function may not work correctly for distributed data structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00246">246</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1985f642cfa97d522ffe9d21d2313ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1985f642cfa97d522ffe9d21d2313ce2">&#9670;&nbsp;</a></span>constrained_right_hand_side()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; constrained_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object <code>constraints</code>, a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>linop</code> and a right-hand side <code>right_hand_side</code>, this function creates a <a class="el" href="classPackagedOperation.html">PackagedOperation</a> that stores the following computation: </p><div class="fragment"><div class="line">Ct * (right_hand_side - linop * k)</div></div><!-- fragment --><p> with </p><div class="fragment"><div class="line"><a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>);</div></div><!-- fragment --><p>This <a class="el" href="classLinearOperator.html">LinearOperator</a> object is used together with <a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side()</a> to build up the following modified system of linear equations: </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> with a given (unconstrained) system matrix \(A\), right hand side \(b\), and linear constraints \(C\) with inhomogeneities \(k\).</p>
<p>A detailed explanation of this approach is given in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>Currently, this function may not work correctly for distributed data structures. </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00292">292</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="gad5b7eee8927ffd58475199d70e445b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7eee8927ffd58475199d70e445b16">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}+\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) + \mathrm{second\_op}(x)\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00390">390</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga19125a34d76f661b3da533c97afda332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19125a34d76f661b3da533c97afda332">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}-\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) - \mathrm{second\_op}(x)\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00449">449</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87b07e6da906c2a1a5ec6a45be2d5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b07e6da906c2a1a5ec6a45be2d5d7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a ScalarOperator object <code>op</code> with <code>number</code> from the left.</p>
<p>The <code>Domain</code> and <code>Range</code> types must implement the following <code>operator*=</code> member functions accepting the appropriate scalar Number type for rescaling:</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Domain::value_type</a>);</div><div class="line">Range &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Range::value_type</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00487">487</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga88637d015b1e6962c60305e7e739ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88637d015b1e6962c60305e7e739ffa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a ScalarOperator object from the right.</p>
<p>The <code>Domain</code> and <code>Range</code> types must implement the following <code>operator*=</code> member functions for rescaling:</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Domain::value_type</a>);</div><div class="line">Range &amp; <a class="code" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator *=</a>(<a class="code" href="namespacemystl.html#a998b84118b29d44caf80e83e25bbcecb">Range::value_type</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00554">554</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga148e5775d722a0e051f1b4a815650431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e5775d722a0e051f1b4a815650431">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Composition of two linear operators <code>first_op</code> and <code>second_op</code> given by \((\mathrm{first\_op}*\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(\mathrm{second\_op}(x))\) </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00587">587</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6bdc65fb2db56230e6bc7d545e81295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdc65fb2db56230e6bc7d545e81295d">&#9670;&nbsp;</a></span>transpose_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; transpose_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the transpose linear operations of <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00660">660</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87e38fbde431397c069a88692bd24ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e38fbde431397c069a88692bd24ae7">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an object representing the inverse of the <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code>.</p>
<p>The function takes references <code>solver</code> and <code>preconditioner</code> to an iterative solver and a preconditioner that are used in the <code>vmult</code> and <code>Tvmult</code> implementations of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object.</p>
<p>The <a class="el" href="classLinearOperator.html">LinearOperator</a> object that is created stores a reference to <code>solver</code> and <code>preconditioner</code>. Thus, both objects must remain a valid reference for the whole lifetime of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. Internal data structures of the <code>solver</code> object will be modified upon invocation of <code>vmult</code> or <code>Tvmult</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00701">701</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga484b23159d208db5fc2706b470bf3863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484b23159d208db5fc2706b470bf3863">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function that takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>preconditioner</code> as preconditioner argument. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00758">758</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga058953c3b4cfae4a9cd6fa75509960a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058953c3b4cfae4a9cd6fa75509960a2">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function without a preconditioner argument. In this case the <a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator()</a> of the <code>op</code> argument is used as a preconditioner. This is equivalent to using <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00816">816</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3deff1665b4dad59643251895e7f5239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deff1665b4dad59643251895e7f5239">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Special overload of above function that takes a <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> argument. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00836">836</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1a0a3fb15266869710e63e78658cfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0a3fb15266869710e63e78658cfaed">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType  &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the identity of the vector space <code>Range</code>.</p>
<p>The function takes an <code>std::function</code> object <code>reinit_vector</code> as an argument to initialize the <code>reinit_range_vector</code> and <code>reinit_domain_vector</code> objects of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00866">866</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga373310de5b48d5a70b9cdd47834da48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373310de5b48d5a70b9cdd47834da48f">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that is the identity of the vector space <code>Range</code>.</p>
<p>The function takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> and uses its range initializer to create an identity operator. In contrast to the function above, this function also ensures that the underlying Payload matches that of the input <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00899">899</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2043a16b6855670766f46780a39f03f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2043a16b6855670766f46780a39f03f3">&#9670;&nbsp;</a></span>null_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; null_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a nulled variant of the <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code>, i.e. with optimized <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">LinearOperator::vmult</a>, <a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">LinearOperator::vmult_add</a>, etc. functions and with <a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">LinearOperator::is_null_operator</a> set to true. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00919">919</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gacad49906c99b700ca6cafdef67977d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad49906c99b700ca6cafdef67977d0c">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType  &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that acts as a mean value filter. The <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult()</a> functions of this matrix subtract the mean values of the vector.</p>
<p>The function takes an <code>std::function</code> object <code>reinit_vector</code> as an argument to initialize the <code>reinit_range_vector</code> and <code>reinit_domain_vector</code> objects of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00956">956</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6cedb0a75c51801a6052bf7343b90685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cedb0a75c51801a6052bf7343b90685">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that acts as a mean value filter. The <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult()</a> functions of this matrix subtract the mean values of the vector.</p>
<p>The function takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>op</code> and uses its range initializer to create an mean value filter operator. The function also ensures that the underlying Payload matches that of the input <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00998">998</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6b74b7ed76e4aeea2c67c0bbb03e3e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that encapsulates generic <code>matrix</code> objects that act on a compatible <a class="el" href="classVector.html">Vector</a> type into a <a class="el" href="classLinearOperator.html">LinearOperator</a>. The <a class="el" href="classLinearOperator.html">LinearOperator</a> object that is created stores a reference to the matrix object. Thus, <code>matrix</code> must remain a valid reference for the whole lifetime of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object.</p>
<p>All changes made on <code>matrix</code> after the creation of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object are reflected by the operator object. For example, it is a valid procedure to first create a <a class="el" href="classLinearOperator.html">LinearOperator</a> and resize, reassemble the matrix later.</p>
<p>The Matrix class in question must provide the following minimal interface:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// (type specific) information how to create a Range and Domain vector</span></div><div class="line">  <span class="comment">// with appropriate size and internal layout</span></div><div class="line"></div><div class="line">  <span class="comment">// Application of matrix to vector src, writes the result into dst.</span></div><div class="line">  <a class="code" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line">  <span class="comment">// Application of the transpose of matrix to vector src, writes the</span></div><div class="line">  <span class="comment">// result into dst. (Depending on the usage of the linear operator</span></div><div class="line">  <span class="comment">// class this can be a dummy implementation throwing an error.)</span></div><div class="line">  <a class="code" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>The following (optional) interface is used if available:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="comment">// Application of matrix to vector src, adds the result to dst.</span></div><div class="line">  <a class="code" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line">  <span class="comment">// Application of the transpose of matrix to vector src, adds the</span></div><div class="line">  <span class="comment">// result to dst.</span></div><div class="line">  <a class="code" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>If the Matrix does not provide <code>vmult_add</code> and <code>Tvmult_add</code>, they are implemented in terms of <code>vmult</code> and <code>Tvmult</code> (requiring intermediate storage). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01379">1379</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga14dbc8c2c27ea3fd45576528a891c6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14dbc8c2c27ea3fd45576528a891c6e2">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const OperatorExemplar &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function that takes an operator object <code>operator_exemplar</code> as an additional reference. This object is used to populate the reinit_domain_vector and reinit_range_vector function objects. The reference <code>matrix</code> is used to construct vmult, Tvmult, etc.</p>
<p>This variant can, for example, be used to encapsulate preconditioners (that typically do not expose any information about the underlying matrix). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01407">1407</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaac20bebeb1b53fd00f838b63baac0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac20bebeb1b53fd00f838b63baac0456">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Variant of above function that takes a <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>operator_exemplar</code> as an additional reference. The reinit_domain_vector and reinit_range_vector function are copied from the <code>operator_exemplar</code> object.</p>
<p>The reference <code>matrix</code> is used to construct vmult, Tvmult, etc.</p>
<p>This variant can, for example, be used to encapsulate preconditioners (that typically do not expose any information about the underlying matrix). </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01461">1461</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaf2a467ed50213dea8c580b67ee466c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a467ed50213dea8c580b67ee466c7c">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that encapsulates generic <code>matrix</code> objects, based on an <code>operator_exemplar</code>, that act on a compatible <a class="el" href="classVector.html">Vector</a> type into a <a class="el" href="classLinearOperator.html">LinearOperator</a>.</p>
<p>This function is the equivalent of the <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>, but ensures full compatibility with Trilinos operations by preselecting the appropriate template parameters. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__linear__operator_8h_source.html#l00076">76</a> of file <a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a>.</p>

</div>
</div>
<a id="gab54eadb16250f94319528968b4975874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54eadb16250f94319528968b4975874">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A function that encapsulates generic <code>matrix</code> objects that act on a compatible <a class="el" href="classVector.html">Vector</a> type into a <a class="el" href="classLinearOperator.html">LinearOperator</a>.</p>
<p>This function is the equivalent of the <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>, but ensures full compatibility with Trilinos operations by preselecting the appropriate template parameters. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__linear__operator_8h_source.html#l00106">106</a> of file <a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga76acca911f21089cd3bb385d20ccc995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76acca911f21089cd3bb385d20ccc995">&#9670;&nbsp;</a></span>schur_complement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType  &gt; schur_complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a <a class="el" href="classLinearOperator.html">LinearOperator</a> that performs the operations associated with the Schur complement. There are two additional helper functions, <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a> and <a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution()</a>, that are likely necessary to be used in order to perform any useful tasks in linear algebra with this operator.</p>
<p>We construct the definition of the Schur complement in the following way:</p>
<p>Consider a general system of linear equations that can be decomposed into two major sets of equations: </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{K}\mathbf{d} = \mathbf{f} \quad \Rightarrow\quad \left(\begin{array}{cc} A &amp; B \\ C &amp; D \end{array}\right) \left(\begin{array}{cc} x \\ y \end{array}\right) = \left(\begin{array}{cc} f \\ g \end{array}\right), \end{eqnarray*}
</p>
<p> where \( A,B,C,D \) represent general subblocks of the matrix \( \mathbf{K} \) and, similarly, general subvectors of \( \mathbf{d},\mathbf{f} \) are given by \( x,y,f,g \) .</p>
<p>This is equivalent to the following two statements: </p><p class="formulaDsp">
\begin{eqnarray*} (1) \quad Ax + By &amp;=&amp; f \\ (2) \quad Cx + Dy &amp;=&amp; g \quad . \end{eqnarray*}
</p>
<p>Assuming that \( A,D \) are both square and invertible, we could then perform one of two possible substitutions, </p><p class="formulaDsp">
\begin{eqnarray*} (3) \quad x &amp;=&amp; A^{-1}(f - By) \quad \text{from} \quad (1) \\ (4) \quad y &amp;=&amp; D^{-1}(g - Cx) \quad \text{from} \quad (2) , \end{eqnarray*}
</p>
<p> which amount to performing block Gaussian elimination on this system of equations.</p>
<p>For the purpose of the current implementation, we choose to substitute (3) into (2) </p><p class="formulaDsp">
\begin{eqnarray*} C \: A^{-1}(f - By) + Dy &amp;=&amp; g \\ -C \: A^{-1} \: By + Dy &amp;=&amp; g - C \: A^{-1} \: f \quad . \end{eqnarray*}
</p>
<p> This leads to the result </p><p class="formulaDsp">
\[ (5) \quad (D - C\: A^{-1} \:B)y = g - C \: A^{-1} f \quad \Rightarrow \quad Sy = g&#39; \]
</p>
<p> with \( S = (D - C\: A^{-1} \:B) \) being the Schur complement and the modified right-hand side vector \( g&#39; = g - C \: A^{-1} f \) arising from the condensation step. Note that for this choice of \( S \), submatrix \( D \) need not be invertible and may thus be the null matrix. Ideally \( A \) should be well-conditioned.</p>
<p>So for any arbitrary vector \( a \), the Schur complement performs the following operation: </p><p class="formulaDsp">
\[ (6) \quad Sa = (D - C \: A^{-1} \: B)a \]
</p>
<p>A typical set of steps needed the solve a linear system (1),(2) would be:</p><ol type="1">
<li>Define the inverse matrix <code>A_inv</code> (using <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a>).</li>
<li>Define the Schur complement \( S \) (using <a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement()</a>).</li>
<li>Define iterative inverse matrix \( S^{-1} \) such that (6) holds. It is necessary to use a solver with a preconditioner to compute the approximate inverse operation of \( S \) since we never compute \( S \) directly, but rather the result of its operation. To achieve this, one may again use the <a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator()</a> in conjunction with the Schur complement that we've just constructed. Observe that the both \( S \) and its preconditioner operate over the same space as \( D \).</li>
<li>Perform pre-processing step on the RHS of (5) using <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a>: <p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
</li>
<li>Solve for \( y \) in (5): <p class="formulaDsp">
\[ y = S^{-1} g&#39; \]
</p>
</li>
<li>Perform the post-processing step from (3) using <a class="el" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution()</a>: <p class="formulaDsp">
\[ x = A^{-1} (f - By) \]
</p>
</li>
</ol>
<p>An illustration of typical usage of this operator for a fully coupled system is given below. </p><div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="schur__complement_8h.html">deal.II/lac/schur_complement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Given BlockMatrix K and BlockVectors d,F</span></div><div class="line"></div><div class="line"><span class="comment">// Decomposition of tangent matrix</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> B = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,1));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> D = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,1));</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of solution vector</span></div><div class="line"><span class="keyword">auto</span> x = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>.block(0);</div><div class="line"><span class="keyword">auto</span> y = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of RHS vector</span></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(0);</div><div class="line"><span class="keyword">auto</span> g = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Construction of inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> prec_A = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,prec_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(S,...,prec_S);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="comment">// PackagedOperation that represents the condensed form of g</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv * rhs;</div><div class="line"></div><div class="line"><span class="comment">// Compute x using resolved solution y</span></div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p>In the above example, the preconditioner for \( S \) was defined as the preconditioner for \( D \), which is valid since they operate on the same space. However, if \( D \) and \( S \) are too dissimilar, then this may lead to a large number of solver iterations as \( \text{prec}(D) \) is not a good approximation for \( S^{-1} \).</p>
<p>A better preconditioner in such a case would be one that provides a more representative approximation for \( S^{-1} \). One approach is shown in step-22, where \( D \) is the null matrix and the preconditioner for \( S^{-1} \) is derived from the mass matrix over this space.</p>
<p>From another viewpoint, a similar result can be achieved by first constructing an object that represents an approximation for \( S \) wherein expensive operation, namely \( A^{-1} \), is approximated. Thereafter we construct the approximate inverse operator \( \tilde{S}^{-1} \) which is then used as the preconditioner for computing \( S^{-1} \). </p><div class="fragment"><div class="line"><span class="comment">// Construction of approximate inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv_approx = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(preconditioner_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv_approx,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S_approx operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"></div><div class="line"><span class="comment">// Inner solver: Typically limited to few iterations</span></div><div class="line"><span class="comment">//               using IterationNumberControl</span></div><div class="line"><span class="keyword">auto</span> S_inv_approx = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S_approx,...,S_approx_prec);</div><div class="line"></div><div class="line"><span class="comment">// Construction of exact inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// Outer solver</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S,...,S_inv_approx);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv * rhs;</div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p> Note that due to the construction of <code>S_inv_approx</code> and subsequently <code>S_inv</code>, there are a pair of nested iterative solvers which could collectively consume a lot of resources. Therefore care should be taken in the choices leading to the construction of the iterative inverse_operators. One might consider the use of a <a class="el" href="classIterationNumberControl.html">IterationNumberControl</a> (or a similar mechanism) to limit the number of inner solver iterations. This controls the accuracy of the approximate inverse operation \( \tilde{S}^{-1} \) which acts only as the preconditioner for \( S^{-1} \). Furthermore, the preconditioner to \( \tilde{S}^{-1} \), which in this example is \( \text{prec}(D) \), should ideally be computationally inexpensive.</p>
<p>However, if an iterative solver based on <a class="el" href="classIterationNumberControl.html">IterationNumberControl</a> is used as a preconditioner then the preconditioning operation is not a linear operation. Here a flexible solver like <a class="el" href="classSolverFGMRES.html">SolverFGMRES</a> (flexible GMRES) is best employed as an outer solver in order to deal with the variable behavior of the preconditioner. Otherwise the iterative solver can stagnate somewhere near the tolerance of the preconditioner or generally behave erratically. Alternatively, using a <a class="el" href="classReductionControl.html">ReductionControl</a> would ensure that the preconditioner always solves to the same tolerance, thereby rendering its behavior constant.</p>
<p>Further examples of this functionality can be found in the test-suite, such as <code>tests/lac/schur_complement_01.cc</code> . The solution of a multi- component problem (namely step-22) using the schur_complement can be found in <code>tests/lac/schur_complement_03.cc</code> .</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00248">248</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac42d948813da72836e1a661acd3beea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42d948813da72836e1a661acd3beea4">&#9670;&nbsp;</a></span>n_block_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>()&gt; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::n_block_rows</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of blocks in a column (i.e, the number of "block rows", or the number \(m\), if interpreted as a \(m\times n\) block system). </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00297">297</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ab414e1ffc37fba57ef140634152736c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab414e1ffc37fba57ef140634152736c9">&#9670;&nbsp;</a></span>n_block_cols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>()&gt; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::n_block_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of blocks in a row (i.e, the number of "block columns", or the number \(n\), if interpreted as a \(m\times n\) block system). </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00303">303</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a6174ae91be3b59658fdcc5c5460bd350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6174ae91be3b59658fdcc5c5460bd350">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>(unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::block</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. This <code>std::function</code> object returns a <a class="el" href="classLinearOperator.html">LinearOperator</a> representing the \((i,j)\)-th block of the <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>. </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00310">310</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a995891407aca97d53bbb2a80b9e0b3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995891407aca97d53bbb2a80b9e0b3db">&#9670;&nbsp;</a></span>vmult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, const Domain &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::vmult</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Application of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object to a vector u of the <code>Domain</code> space giving a vector v of the <code>Range</code> space. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00275">275</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a5eb6da2c4b33b66c23ea2679ff100de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb6da2c4b33b66c23ea2679ff100de3">&#9670;&nbsp;</a></span>vmult_add</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, const Domain &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::vmult_add</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Application of the <a class="el" href="classLinearOperator.html">LinearOperator</a> object to a vector u of the <code>Domain</code> space. The result is added to the vector v. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00281">281</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a6968174d73bf018f6d0c9181c730e217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6968174d73bf018f6d0c9181c730e217">&#9670;&nbsp;</a></span>Tvmult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, const Range &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::Tvmult</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Application of the transpose <a class="el" href="classLinearOperator.html">LinearOperator</a> object to a vector u of the <code>Range</code> space giving a vector v of the <code>Domain</code> space. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00287">287</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ad36a8841e61b3dbea54cf3745e56c140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36a8841e61b3dbea54cf3745e56c140">&#9670;&nbsp;</a></span>Tvmult_add</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, const Range &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::Tvmult_add</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Application of the transpose <a class="el" href="classLinearOperator.html">LinearOperator</a> object to a vector <code>u</code> of the <code>Range</code> space.The result is added to the vector <code>v</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00293">293</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="aa470d7770714cfe9a64bf0f0d817d71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa470d7770714cfe9a64bf0f0d817d71f">&#9670;&nbsp;</a></span>reinit_range_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::reinit_range_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a vector v of the Range space to be directly usable as the destination parameter in an application of vmult. Similar to the reinit functions of the vector classes, the boolean determines whether a fast initialization is done, i.e., if it is set to false the content of the vector is set to 0. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00302">302</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a818a9e4c7d8bf0edbb253b938d831e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818a9e4c7d8bf0edbb253b938d831e43">&#9670;&nbsp;</a></span>reinit_domain_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::reinit_domain_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Initializes a vector of the Domain space to be directly usable as the source parameter in an application of vmult. Similar to the reinit functions of the vector classes, the boolean determines whether a fast initialization is done, i.e., if it is set to false the content of the vector is set to 0. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00312">312</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a99cd172538d9f6d20474deea30ab43f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cd172538d9f6d20474deea30ab43f0">&#9670;&nbsp;</a></span>is_null_operator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::is_null_operator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This bool is used to determine whether a linear operator is a null operator. In this case the class is able to optimize some operations like multiplication or addition. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00368">368</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a></li>
<li>include/deal.II/lac/<a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
