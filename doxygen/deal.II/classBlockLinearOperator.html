<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classBlockLinearOperator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: BlockLinearOperator&lt; Range, Domain, BlockPayload &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classBlockLinearOperator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockLinearOperator&lt; Range, Domain, BlockPayload &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__LAOperators.html">Linear Operators &lt;h3&gt;Linear Operator&lt;/h3&gt;</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="block__linear__operator_8h_source.html">deal.II/lac/block_linear_operator.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BlockLinearOperator&lt; Range, Domain, BlockPayload &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classBlockLinearOperator__inherit__graph.svg" width="463" height="352"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2b106db0ddd0a15dadaeffd860207745"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a> = <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;</td></tr>
<tr class="separator:a2b106db0ddd0a15dadaeffd860207745"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2533970716e61d8476d73b5977d1d89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ad2533970716e61d8476d73b5977d1d89">BlockLinearOperator</a> (const BlockPayload &amp;payload)</td></tr>
<tr class="separator:ad2533970716e61d8476d73b5977d1d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2ec9b81e5e32b47a1bd886bd35bb65"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a7c2ec9b81e5e32b47a1bd886bd35bb65">BlockLinearOperator</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;)=default</td></tr>
<tr class="separator:a7c2ec9b81e5e32b47a1bd886bd35bb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7954607fc2738d7e6c4b245f9584103"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:ac7954607fc2738d7e6c4b245f9584103"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ac7954607fc2738d7e6c4b245f9584103">BlockLinearOperator</a> (const Op &amp;op)</td></tr>
<tr class="separator:ac7954607fc2738d7e6c4b245f9584103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89297fe5e51d1f7a259e4f8fc315b53"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n&gt; </td></tr>
<tr class="memitem:ac89297fe5e51d1f7a259e4f8fc315b53"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ac89297fe5e51d1f7a259e4f8fc315b53">BlockLinearOperator</a> (const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ac89297fe5e51d1f7a259e4f8fc315b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b31166960bf69ec7a224c8475ed9c3"><td class="memTemplParams" colspan="2">template&lt;std::size_t m&gt; </td></tr>
<tr class="memitem:a20b31166960bf69ec7a224c8475ed9c3"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a20b31166960bf69ec7a224c8475ed9c3">BlockLinearOperator</a> (const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;ops)</td></tr>
<tr class="separator:a20b31166960bf69ec7a224c8475ed9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af364b6a7badf5bb89544502e73f174ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#af364b6a7badf5bb89544502e73f174ba">operator=</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;)=default</td></tr>
<tr class="separator:af364b6a7badf5bb89544502e73f174ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4667a076be7c90b9ab1ce52c5dddafb8"><td class="memTemplParams" colspan="2">template&lt;typename Op &gt; </td></tr>
<tr class="memitem:a4667a076be7c90b9ab1ce52c5dddafb8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a4667a076be7c90b9ab1ce52c5dddafb8">operator=</a> (const Op &amp;op)</td></tr>
<tr class="separator:a4667a076be7c90b9ab1ce52c5dddafb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a647d2c1ed00b17cea968232bcbc11dc2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n&gt; </td></tr>
<tr class="memitem:a647d2c1ed00b17cea968232bcbc11dc2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a647d2c1ed00b17cea968232bcbc11dc2">operator=</a> (const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:a647d2c1ed00b17cea968232bcbc11dc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187c80efa27b434662583eca74c5b4a2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m&gt; </td></tr>
<tr class="memitem:a187c80efa27b434662583eca74c5b4a2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a187c80efa27b434662583eca74c5b4a2">operator=</a> (const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;ops)</td></tr>
<tr class="separator:a187c80efa27b434662583eca74c5b4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ac42d948813da72836e1a661acd3beea4"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ac42d948813da72836e1a661acd3beea4">n_block_rows</a></td></tr>
<tr class="separator:ac42d948813da72836e1a661acd3beea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab414e1ffc37fba57ef140634152736c9"><td class="memItemLeft" align="right" valign="top">std::function&lt; unsigned <a class="el" href="classint.html">int</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#ab414e1ffc37fba57ef140634152736c9">n_block_cols</a></td></tr>
<tr class="separator:ab414e1ffc37fba57ef140634152736c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6174ae91be3b59658fdcc5c5460bd350"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>(unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockLinearOperator.html#a6174ae91be3b59658fdcc5c5460bd350">block</a></td></tr>
<tr class="separator:a6174ae91be3b59658fdcc5c5460bd350"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a995891407aca97d53bbb2a80b9e0b3db"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, const Domain &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a></td></tr>
<tr class="separator:a995891407aca97d53bbb2a80b9e0b3db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eb6da2c4b33b66c23ea2679ff100de3"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, const Domain &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a></td></tr>
<tr class="separator:a5eb6da2c4b33b66c23ea2679ff100de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6968174d73bf018f6d0c9181c730e217"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, const Range &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a></td></tr>
<tr class="separator:a6968174d73bf018f6d0c9181c730e217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36a8841e61b3dbea54cf3745e56c140"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, const Range &amp;u)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a></td></tr>
<tr class="separator:ad36a8841e61b3dbea54cf3745e56c140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa470d7770714cfe9a64bf0f0d817d71f"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Range &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#aa470d7770714cfe9a64bf0f0d817d71f">reinit_range_vector</a></td></tr>
<tr class="separator:aa470d7770714cfe9a64bf0f0d817d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a818a9e4c7d8bf0edbb253b938d831e43"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(Domain &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a818a9e4c7d8bf0edbb253b938d831e43">reinit_domain_vector</a></td></tr>
<tr class="separator:a818a9e4c7d8bf0edbb253b938d831e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个BlockLinearOperator</div></td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain , typename BlockPayload , typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gad48a267ed219e65f5316204a8e9c87a0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gad48a267ed219e65f5316204a8e9c87a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3b78c08372b54dc7bc9a2cf6b497baba">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga3b78c08372b54dc7bc9a2cf6b497baba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;, typename BlockMatrixType &gt; </td></tr>
<tr class="memitem:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (const BlockMatrixType &amp;block_matrix)</td></tr>
<tr class="separator:gaa37c982a2dd7106e7efc1b380b501bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga4f98cbf0ce0df665a068394a306fd0b7">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga4f98cbf0ce0df665a068394a306fd0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain , typename BlockPayload &gt; </td></tr>
<tr class="memitem:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaaaedcd8e4d6ed8ff7c6340f05deda5c2">block_diagonal_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:gaaaedcd8e4d6ed8ff7c6340f05deda5c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">对一个BlockLinearOperator的操纵</div></td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2e93f2424bc70a566a1a46ee8c0b1c31">block_forward_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga2e93f2424bc70a566a1a46ee8c0b1c31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplParams" colspan="2">template&lt;typename Range  = BlockVector&lt;double&gt;, typename Domain  = Range, typename BlockPayload  = internal::BlockLinearOperatorImplementation::EmptyBlockPayload&lt;&gt;&gt; </td></tr>
<tr class="memitem:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, typename BlockPayload::BlockType &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga8b2bf4fd828e4ee7539bcc16c8b19777">block_back_substitution</a> (const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;<a class="el" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>, const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Domain, Range, BlockPayload &gt; &amp;diagonal_inverse)</td></tr>
<tr class="separator:ga8b2bf4fd828e4ee7539bcc16c8b19777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个BlockLinearOperator</div></td></tr>
<tr class="memitem:ga0dcbb8ef00703fc453c9c38a35d9dad6"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga0dcbb8ef00703fc453c9c38a35d9dad6"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#ga0dcbb8ef00703fc453c9c38a35d9dad6">block_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;block_matrix)</td></tr>
<tr class="separator:ga0dcbb8ef00703fc453c9c38a35d9dad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga29af932e0238c35b0dee9ea2554d6c17"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, std::size_t n, typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:ga29af932e0238c35b0dee9ea2554d6c17"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#ga29af932e0238c35b0dee9ea2554d6c17">block_operator</a> (const std::array&lt; std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;, n &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:ga29af932e0238c35b0dee9ea2554d6c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe5be3da7a2d60ec62018555d6a8a2d1"><td class="memTemplParams" colspan="2">template&lt;typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:gabe5be3da7a2d60ec62018555d6a8a2d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gabe5be3da7a2d60ec62018555d6a8a2d1">block_diagonal_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;block_matrix)</td></tr>
<tr class="separator:gabe5be3da7a2d60ec62018555d6a8a2d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac8c6a35a2ccdaba1dd42ac7502314c02"><td class="memTemplParams" colspan="2">template&lt;std::size_t m, typename Range , typename Domain  = Range&gt; </td></tr>
<tr class="memitem:gac8c6a35a2ccdaba1dd42ac7502314c02"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1BlockLinearOperatorImplementation_1_1TrilinosBlockPayload.html">TrilinosWrappers::internal::BlockLinearOperatorImplementation::TrilinosBlockPayload</a>&lt; <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gac8c6a35a2ccdaba1dd42ac7502314c02">block_diagonal_operator</a> (const std::array&lt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; typename Range::BlockType, typename Domain::BlockType, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;, m &gt; &amp;ops)</td></tr>
<tr class="separator:gac8c6a35a2ccdaba1dd42ac7502314c02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">间接对LinearOperator施加约束</div></td></tr>
<tr class="memitem:ga814d426ef355ed315bb57cea21a7630a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga814d426ef355ed315bb57cea21a7630a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;exemplar)</td></tr>
<tr class="separator:ga52c9bbeff68309fdc7e4975eddba5eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;linop)</td></tr>
<tr class="separator:ga4787b401a7e601750d85b8b4fc84c8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1985f642cfa97d522ffe9d21d2313ce2">constrained_right_hand_side</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;constraints, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;linop, const Range &amp;right_hand_side)</td></tr>
<tr class="separator:ga1985f642cfa97d522ffe9d21d2313ce2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矢量空间操作</div></td></tr>
<tr class="memitem:gad5b7eee8927ffd58475199d70e445b16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gad5b7eee8927ffd58475199d70e445b16">operator+</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:gad5b7eee8927ffd58475199d70e445b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19125a34d76f661b3da533c97afda332"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga19125a34d76f661b3da533c97afda332">operator-</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:ga19125a34d76f661b3da533c97afda332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87b07e6da906c2a1a5ec6a45be2d5d7c">operator*</a> (typename Range::value_type number, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga87b07e6da906c2a1a5ec6a45be2d5d7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88637d015b1e6962c60305e7e739ffa9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga88637d015b1e6962c60305e7e739ffa9">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, typename Domain::value_type number)</td></tr>
<tr class="separator:ga88637d015b1e6962c60305e7e739ffa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">LinearOperator的组成和操作</div></td></tr>
<tr class="memitem:ga148e5775d722a0e051f1b4a815650431"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga148e5775d722a0e051f1b4a815650431">operator*</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, BlockPayload::BlockType &gt; &amp;first_op, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:ga148e5775d722a0e051f1b4a815650431"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga6bdc65fb2db56230e6bc7d545e81295d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga87e38fbde431397c069a88692bd24ae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver, const Preconditioner &amp;preconditioner)</td></tr>
<tr class="separator:ga87e38fbde431397c069a88692bd24ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga484b23159d208db5fc2706b470bf3863"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga484b23159d208db5fc2706b470bf3863">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;preconditioner)</td></tr>
<tr class="separator:ga484b23159d208db5fc2706b470bf3863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga058953c3b4cfae4a9cd6fa75509960a2">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver)</td></tr>
<tr class="separator:ga058953c3b4cfae4a9cd6fa75509960a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3deff1665b4dad59643251895e7f5239"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga3deff1665b4dad59643251895e7f5239">inverse_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op, Solver &amp;solver, const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;)</td></tr>
<tr class="separator:ga3deff1665b4dad59643251895e7f5239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个LinearOperator</div></td></tr>
<tr class="memitem:ga1a0a3fb15266869710e63e78658cfaed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga1a0a3fb15266869710e63e78658cfaed">identity_operator</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:ga1a0a3fb15266869710e63e78658cfaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga373310de5b48d5a70b9cdd47834da48f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga373310de5b48d5a70b9cdd47834da48f">identity_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga373310de5b48d5a70b9cdd47834da48f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2043a16b6855670766f46780a39f03f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga2043a16b6855670766f46780a39f03f3">null_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga2043a16b6855670766f46780a39f03f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacad49906c99b700ca6cafdef67977d0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gacad49906c99b700ca6cafdef67977d0c">mean_value_filter</a> (const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;reinit_vector)</td></tr>
<tr class="separator:gacad49906c99b700ca6cafdef67977d0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6cedb0a75c51801a6052bf7343b90685"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6cedb0a75c51801a6052bf7343b90685">mean_value_filter</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;op)</td></tr>
<tr class="separator:ga6cedb0a75c51801a6052bf7343b90685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a> (const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga6b74b7ed76e4aeea2c67c0bbb03e3e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga14dbc8c2c27ea3fd45576528a891c6e2">linear_operator</a> (const OperatorExemplar &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:ga14dbc8c2c27ea3fd45576528a891c6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac20bebeb1b53fd00f838b63baac0456"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#gaac20bebeb1b53fd00f838b63baac0456">linear_operator</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaac20bebeb1b53fd00f838b63baac0456"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个LinearOperator</div></td></tr>
<tr class="memitem:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gaf2a467ed50213dea8c580b67ee466c7c">linear_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;operator_exemplar, const Matrix &amp;matrix)</td></tr>
<tr class="separator:gaf2a467ed50213dea8c580b67ee466c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54eadb16250f94319528968b4975874"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__TrilinosWrappers.html#gab54eadb16250f94319528968b4975874">linear_operator</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:gab54eadb16250f94319528968b4975874"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">创建一个与舒尔补码有关的LinearOperator</div></td></tr>
<tr class="memitem:ga76acca911f21089cd3bb385d20ccc995"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, BlockPayload::BlockType &gt; &amp;A_inv, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, BlockPayload::BlockType &gt; &amp;B, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, BlockPayload::BlockType &gt; &amp;C, const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType &gt; &amp;D)</td></tr>
<tr class="separator:ga76acca911f21089cd3bb385d20ccc995"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
原地向量空间操作</h2></td></tr>
<tr class="memitem:a99cd172538d9f6d20474deea30ab43f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">is_null_operator</a></td></tr>
<tr class="separator:a99cd172538d9f6d20474deea30ab43f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a00069fdcd76bd6f0323ddb0f9421da"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a9a00069fdcd76bd6f0323ddb0f9421da">operator+=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:a9a00069fdcd76bd6f0323ddb0f9421da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c73c9d7a1b1b95cdd50a35af95b6cba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a3c73c9d7a1b1b95cdd50a35af95b6cba">operator-=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:a3c73c9d7a1b1b95cdd50a35af95b6cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07a0fe40dda4bc65ec1b7d57f52388bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a07a0fe40dda4bc65ec1b7d57f52388bb">operator*=</a> (const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Domain, BlockPayload::BlockType &gt; &amp;second_op)</td></tr>
<tr class="separator:a07a0fe40dda4bc65ec1b7d57f52388bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b305867e831f96aaabe7a7aee8b774e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearOperator.html#a2b305867e831f96aaabe7a7aee8b774e">operator*=</a> (typename Domain::value_type number)</td></tr>
<tr class="separator:a2b305867e831f96aaabe7a7aee8b774e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Range, typename Domain, typename BlockPayload&gt;<br />
class BlockLinearOperator&lt; Range, Domain, BlockPayload &gt;</h3>

<p>一个用于存储块状线性运算符概念的类。 这个类在LinearOperator（封装了 <code>Matrix</code> 接口）的接口上增加了三个额外的功能。</p>
<div class="fragment"><div class="line">std::function&lt;unsigned int()&gt; <a class="code" href="classBlockLinearOperator.html#ac42d948813da72836e1a661acd3beea4">n_block_rows</a>;</div><div class="line">std::function&lt;unsigned int()&gt; <a class="code" href="classBlockLinearOperator.html#ab414e1ffc37fba57ef140634152736c9">n_block_cols</a>;</div><div class="line">std::function&lt;BlockType(unsigned int, unsigned int)&gt; <a class="code" href="classBlockLinearOperator.html#a6174ae91be3b59658fdcc5c5460bd350">block</a>;</div></div><!-- fragment --><p> 描述（原本不透明的）线性运算符的底层块结构。 BlockLinearOperator类型的对象可以通过包装函数与LinearOperator类似地创建。</p>
<div class="fragment"><div class="line"><a class="code" href="classBlockSparseMatrix.html">::BlockSparseMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>;</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> block_op_a = <a class="code" href="group__LAOperators.html#gad48a267ed219e65f5316204a8e9c87a0">block_operator</a>(A);</div></div><!-- fragment --><p>另外，还有几个辅助函数可用于从可能不同类型的多个独立矩阵中创建实例。下面是一个由FullMatrix和SparseMatrixEZ创建的块状对角线矩阵的例子。</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> top_left(2, 2);</div><div class="line">top_left(0, 0) = 2.0;</div><div class="line">top_left(0, 1) =</div><div class="line"></div><div class="line">-1.0;</div><div class="line">top_left(1, 0) =</div><div class="line"></div><div class="line">-1.0;</div><div class="line">top_left(1, 1) = 2.0;</div><div class="line"></div><div class="line"><a class="code" href="classSparseMatrixEZ.html">SparseMatrixEZ&lt;double&gt;</a> bottom_right(4, 4, 4);</div><div class="line"><span class="keywordflow">for</span> (std::size_t row_n = 0; row_n &lt; 4; ++row_n)</div><div class="line">{</div><div class="line">  bottom_right.add(row_n, row_n, 1.0);</div><div class="line">  <span class="keywordflow">if</span> (row_n &lt; 3)</div><div class="line">    bottom_right.add(row_n, row_n + 1,</div><div class="line"></div><div class="line">-1.0);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keyword">auto</span> top_left_op = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(top_left);</div><div class="line"><span class="keyword">auto</span> bottom_right_op = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(bottom_right);</div><div class="line">std::array&lt;decltype(top_left_op), 2&gt; operators {{top_left_op,</div><div class="line">                                               bottom_right_op}};</div><div class="line"><span class="keyword">auto</span> block_op = <a class="code" href="group__LAOperators.html#gaa37c982a2dd7106e7efc1b380b501bd5">block_diagonal_operator</a> (operators);</div><div class="line"></div><div class="line"><a class="code" href="namespaceLinearAlgebra_1_1CUDAWrappers_1_1kernel.html#ad929a93e07fba9bcfa599f959ea3c1d9">std::vector&lt;BlockVector&lt;double&gt;::size_type</a>&gt; block_sizes {2, 4};</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> src(block_sizes);</div><div class="line">src = 2.0;</div><div class="line"><a class="code" href="classBlockVector.html">BlockVector&lt;double&gt;</a> dst(block_sizes);</div><div class="line">block_op.vmult(dst, src); <span class="comment">// now equal to 2, 2, 0, 0, 0, 2</span></div></div><!-- fragment --><p>一个BlockLinearOperator可以在任何时候被切成一个LinearOperator。这将删除所有关于底层块结构的信息（因为上述 <code>std::function</code> 对象不再可用）。</p>
<ul>
<li>线性操作符的接口，然而，仍然是完整的。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>这个类大量使用了 <code>std::function</code> 对象和lambda函数。这种灵活性伴随着运行时间的惩罚。只使用这个对象来封装具有中到大的单个块大小和小块结构的对象（作为经验法则，矩阵块大于 \(1000\times1000\) ）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00171">171</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2b106db0ddd0a15dadaeffd860207745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b106db0ddd0a15dadaeffd860207745">&#9670;&nbsp;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a> =  <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;typename Range::BlockType, typename Domain::BlockType, typename BlockPayload::BlockType&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00177">177</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2533970716e61d8476d73b5977d1d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2533970716e61d8476d73b5977d1d89">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const BlockPayload &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个空的BlockLinearOperator对象。 All<code>std::function</code> 这个类和它的基类LinearOperator的成员对象被初始化为默认变体，在调用时抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00185">185</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a7c2ec9b81e5e32b47a1bd886bd35bb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2ec9b81e5e32b47a1bd886bd35bb65">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的复制构造函数。 </p>

</div>
</div>
<a id="ac7954607fc2738d7e6c4b245f9584103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7954607fc2738d7e6c4b245f9584103">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>模板化的复制构造函数，从一个定义了转换函数 <code>block_operator</code> 的对象 <code>op</code> 中创建一个BlockLinearOperator对象。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00228">228</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ac89297fe5e51d1f7a259e4f8fc315b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89297fe5e51d1f7a259e4f8fc315b53">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个二维的LinearOperator数组 <code>ops</code> 中创建一个BlockLinearOperator。这个构造函数调用相应的block_operator()专用化。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00239">239</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a20b31166960bf69ec7a224c8475ed9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b31166960bf69ec7a224c8475ed9c3">&#9670;&nbsp;</a></span>BlockLinearOperator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::<a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一维数组 <code>ops</code> 的LinearOperator创建一个块对角线的BlockLinearOperator。这个构造函数调用相应的block_operator()专用化。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00250">250</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="af364b6a7badf5bb89544502e73f174ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af364b6a7badf5bb89544502e73f174ba">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的复制赋值运算器。 </p>

</div>
</div>
<a id="a4667a076be7c90b9ab1ce52c5dddafb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4667a076be7c90b9ab1ce52c5dddafb8">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;typename Op &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Op &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为一个定义了转换函数 <code>block_operator</code> 的对象 <code>op</code> 模板化的复制赋值运算符。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00269">269</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a647d2c1ed00b17cea968232bcbc11dc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647d2c1ed00b17cea968232bcbc11dc2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m, std::size_t n&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, n &gt;, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个二维数组 <code>ops</code> 的LinearOperator中复制赋值。 这个赋值运算符调用相应的block_operator()专用化。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00282">282</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a187c80efa27b434662583eca74c5b4a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187c80efa27b434662583eca74c5b4a2">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
<div class="memtemplate">
template&lt;std::size_t m&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt;Range, Domain, BlockPayload&gt;&amp; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; <a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>, m &gt; &amp;&#160;</td>
          <td class="paramname"><em>ops</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一维数组 <code>ops</code> 的LinearOperator复制赋值，创建一个块对角线的BlockLinearOperator。这个赋值运算符调用相应的block_operator()专用化。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00295">295</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a9a00069fdcd76bd6f0323ddb0f9421da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a00069fdcd76bd6f0323ddb0f9421da">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用LinearOperator <code>second_op</code> 进行加法运算，同 <code>Domain</code> 和 <code>Range</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00312">312</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a3c73c9d7a1b1b95cdd50a35af95b6cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c73c9d7a1b1b95cdd50a35af95b6cba">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用LinearOperator <code>second_op</code> 和 <code>Range</code>. 做减法。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00323">323</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a07a0fe40dda4bc65ec1b7d57f52388bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07a0fe40dda4bc65ec1b7d57f52388bb">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt;&amp; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与 <code>Domain</code> 空间的内形态 <code>second_op</code> 的LinearOperator的构成。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00335">335</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a2b305867e831f96aaabe7a7aee8b774e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b305867e831f96aaabe7a7aee8b774e">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt;Range, Domain, BlockPayload::BlockType &gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>LinearOperator与 <code>number</code> 从右边开始的标量乘法。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00346">346</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ga814d426ef355ed315bb57cea21a7630a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga814d426ef355ed315bb57cea21a7630a">&#9670;&nbsp;</a></span>distribute_constraints_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; distribute_constraints_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数接收一个AffineConstraints对象 <code>constraints</code> 和一个运算器示例 <code>exemplar</code> （这个示例通常是一个描述系统矩阵的线性运算器</p>
<p>-它只用于创建适当大小的域和范围向量，它的动作<code>vmult</code>从不使用）。) 一个与底层AffineConstraints对象的 "同质动作
"相关的LinearOperator对象被返回。 在向量 <code>u</code> 上应用LinearOperator对象的结果是一个向量 <code>v</code> ，它存储了在 <code>u</code> 上调用 <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute()</a> 的结果。</p>
<ul>
<li>有一个重要的区别：不均匀性不被应用，而是始终被视为0。 这个函数创建的LinearOperator对象主要在内部用于constrained_linear_operator()，以建立一个修正的线性方程组。如何用这种方法解决线性方程组，在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中有详细解释。</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00064">64</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga52c9bbeff68309fdc7e4975eddba5eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga52c9bbeff68309fdc7e4975eddba5eea">&#9670;&nbsp;</a></span>project_to_constrained_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; project_to_constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>exemplar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个AffineConstraints <code>constraints</code> 和一个运算符示例 <code>示例，返回一个LinearOperator，该运算符是对受限自由度子空间的投影，即结果向量中对应于非受限自由度的所有条目被设置为零。</code> </p>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00156">156</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga4787b401a7e601750d85b8b4fc84c8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4787b401a7e601750d85b8b4fc84c8a5">&#9670;&nbsp;</a></span>constrained_linear_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; constrained_linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个AffineConstraints对象 <code>constraints</code> 和一个LinearOperator <code>linop</code>, ，该函数创建一个LinearOperator对象，由三个操作和一个正则化组成。</p>
<div class="fragment"><div class="line">Ct linop <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> + Id_c;</div></div><!-- fragment --><p> 与</p>
<div class="fragment"><div class="line"><a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>);</div><div class="line">Id_c = <a class="code" href="group__constraints.html#ga52c9bbeff68309fdc7e4975eddba5eea">project_to_constrained_linear_operator</a>(constraints, linop);</div></div><!-- fragment --><p> 而 <code>Id_c</code> 是对由所有与受限自由度相关的向量条目组成的子空间的投影。 这个LinearOperator对象与constrained_right_hand_side()一起使用，建立了以下修改后的线性方程系统。 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> 具有给定的（无约束的）系统矩阵 \(A\) ，右手边 \(b\) ，以及具有不均匀性的线性约束 \(C\) 。 在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中对这种方法进行了详细解释。</p>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00241">241</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1985f642cfa97d522ffe9d21d2313ce2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1985f642cfa97d522ffe9d21d2313ce2">&#9670;&nbsp;</a></span>constrained_right_hand_side()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPackagedOperation.html">PackagedOperation</a>&lt; Range &gt; constrained_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename Range::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>linop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Range &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个AffineConstraints对象 <code>constraints</code>, 一个LinearOperator <code>linop和一个右手边</code> <code>right_hand_side</code>, ，这个函数创建一个PackagedOperation，存储以下计算结果。</p>
<div class="fragment"><div class="line">Ct (right_hand_side</div><div class="line"></div><div class="line">- linop k)</div></div><!-- fragment --><p> 与</p>
<div class="fragment"><div class="line"><a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> = <a class="code" href="group__constraints.html#ga814d426ef355ed315bb57cea21a7630a">distribute_constraints_linear_operator</a>(constraints, linop);</div><div class="line">Ct = <a class="code" href="group__LAOperators.html#ga6bdc65fb2db56230e6bc7d545e81295d">transpose_operator</a>(<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a>);</div></div><!-- fragment --><p>这个LinearOperator对象与constrained_right_hand_side()一起用于建立以下修改后的线性方程组。 </p><p class="formulaDsp">
\[ (C^T A C + Id_c) x = C^T (b - A\,k) \]
</p>
<p> 具有给定的（无约束的）系统矩阵 \(A\) ，右手边 \(b\) ，以及具有不均匀性的线性约束 \(C\) 。 在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中对这种方法进行了详细解释。</p>
<dl class="section note"><dt>Note</dt><dd>目前，这个函数对于分布式数据结构可能无法正确工作。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="constrained__linear__operator_8h_source.html#l00288">288</a> of file <a class="el" href="constrained__linear__operator_8h_source.html">constrained_linear_operator.h</a>.</p>

</div>
</div>
<a id="gad5b7eee8927ffd58475199d70e445b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad5b7eee8927ffd58475199d70e445b16">&#9670;&nbsp;</a></span>operator+()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的相加，由 \((\mathrm{first\_op}+\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) + \mathrm{second\_op}(x)\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00379">379</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga19125a34d76f661b3da533c97afda332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga19125a34d76f661b3da533c97afda332">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的减法，由 \((\mathrm{first\_op}-\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(x) - \mathrm{second\_op}(x)\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00441">441</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87b07e6da906c2a1a5ec6a45be2d5d7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87b07e6da906c2a1a5ec6a45be2d5d7c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">typename Range::value_type&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ScalarOperator对象 <code>op</code> 与 <code>number</code> 的标量乘法，从左边开始。 <code>Domain</code> 和 <code>Range</code> 类型必须实现以下 <code>operator*=</code> 成员函数，接受适当的标量Number类型进行重新缩放。</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classBlockLinearOperator.html#af364b6a7badf5bb89544502e73f174ba">operator=</a>(Domain::value_type);</div><div class="line">Range &amp; <a class="code" href="classBlockLinearOperator.html#af364b6a7badf5bb89544502e73f174ba">operator=</a>(Range::value_type);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00478">478</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga88637d015b1e6962c60305e7e739ffa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88637d015b1e6962c60305e7e739ffa9">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename Domain::value_type&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从右边开始对一个ScalarOperator对象进行标量乘法。 <code>Domain</code> 和 <code>Range</code> 类型必须实现以下 <code>operator*=</code> 成员函数，用于重新缩放。</p>
<div class="fragment"><div class="line">Domain &amp; <a class="code" href="classBlockLinearOperator.html#af364b6a7badf5bb89544502e73f174ba">operator=</a>(Domain::value_type);</div><div class="line">Range &amp; <a class="code" href="classBlockLinearOperator.html#af364b6a7badf5bb89544502e73f174ba">operator=</a>(Range::value_type);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00548">548</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga148e5775d722a0e051f1b4a815650431"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga148e5775d722a0e051f1b4a815650431">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Intermediate, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>first_op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Intermediate, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>second_op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个线性运算符 <code>first_op</code> 和 <code>second_op</code> 的组合，由 \((\mathrm{first\_op}*\mathrm{second\_op})x \dealcoloneq \mathrm{first\_op}(\mathrm{second\_op}(x))\) 给出。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00584">584</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6bdc65fb2db56230e6bc7d545e81295d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6bdc65fb2db56230e6bc7d545e81295d">&#9670;&nbsp;</a></span>transpose_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; transpose_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>op</code>. 的转置线性运算。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00656">656</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga87e38fbde431397c069a88692bd24ae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga87e38fbde431397c069a88692bd24ae7">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Preconditioner &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个代表LinearOperator的逆运算的对象 <code>op</code>. 。 该函数需要引用 <code>solver</code> 和 <code>preconditioner</code> 一个迭代求解器和一个预处理器，这些都是LinearOperator对象的 <code>vmult</code> and <code>Tvmult</code> 实现中使用的。 创建的 <a class="el" href="classLinearOperator.html">LinearOperator</a> 对象存储了对 <code>solver</code> 和 <code>preconditioner</code>. 的引用。因此，这两个对象必须在 <a class="el" href="classLinearOperator.html">LinearOperator</a> 对象的整个生命周期内保持有效引用。 <code>solver</code> 对象的内部数据结构将在调用 <code>vmult</code> or <code>Tvmult</code> 时被修改。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00695">695</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga484b23159d208db5fc2706b470bf3863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga484b23159d208db5fc2706b470bf3863">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>preconditioner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，接受 <a class="el" href="classLinearOperator.html">LinearOperator</a> <code>preconditioner</code> 作为预处理参数。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00752">752</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga058953c3b4cfae4a9cd6fa75509960a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga058953c3b4cfae4a9cd6fa75509960a2">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，没有预处理参数。在这种情况下， <code>op</code> 参数的ident_operator()被用作预处理。这等同于使用PreconditionIdentity。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00810">810</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga3deff1665b4dad59643251895e7f5239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3deff1665b4dad59643251895e7f5239">&#9670;&nbsp;</a></span>inverse_operator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain, Range, BlockPayload::BlockType  &gt; inverse_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Solver &amp;&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPreconditionIdentity.html">PreconditionIdentity</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的特殊重载，需要一个PreconditionIdentity参数。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00831">831</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga1a0a3fb15266869710e63e78658cfaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1a0a3fb15266869710e63e78658cfaed">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType  &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，它是向量空间的标识 <code>Range</code>. 。 该函数需要一个 <code>std::function</code> 对象 <code>reinit_vector</code> 作为参数，以初始化LinearOperator对象的 <code>reinit_range_vector</code> 和 <code>reinit_domain_vector</code> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00865">865</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga373310de5b48d5a70b9cdd47834da48f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga373310de5b48d5a70b9cdd47834da48f">&#9670;&nbsp;</a></span>identity_operator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; identity_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，它是向量空间的标识 <code>Range</code>. 。 该函数接收一个LinearOperator <code>op</code> 并使用其范围初始化器来创建一个身份算子。与上面的函数不同，这个函数还确保底层的Payload与输入的Payload相匹配 <code>op</code>. </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00898">898</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga2043a16b6855670766f46780a39f03f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2043a16b6855670766f46780a39f03f3">&#9670;&nbsp;</a></span>null_operator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; null_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回LinearOperator <code>op</code>, 的空变体，即具有优化的 <a class="el" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">LinearOperator::vmult</a>, <a class="el" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">LinearOperator::vmult_add</a>, 等函数，并将 <a class="el" href="classLinearOperator.html#a99cd172538d9f6d20474deea30ab43f0">LinearOperator::is_null_operator</a> 设置为真。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00920">920</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gacad49906c99b700ca6cafdef67977d0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacad49906c99b700ca6cafdef67977d0c">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Range, BlockPayload::BlockType  &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(Range &amp;, <a class="el" href="classbool.html">bool</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>reinit_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，作为一个均值过滤器。这个矩阵的vmult()函数减去向量的均值。 该函数需要一个 <code>std::function</code> 对象 <code>reinit_vector</code> 作为参数来初始化LinearOperator对象的 <code>reinit_range_vector</code> 和 <code>reinit_domain_vector</code> 对象。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00957">957</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6cedb0a75c51801a6052bf7343b90685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6cedb0a75c51801a6052bf7343b90685">&#9670;&nbsp;</a></span>mean_value_filter() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; mean_value_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>op</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，作为一个均值过滤器。这个矩阵的vmult()函数减去向量的均值。 该函数接收一个LinearOperator <code>op</code> 并使用其范围初始化器来创建一个均值过滤器运算器。该函数还确保底层的Payload与输入的Payload相匹配 <code>op</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00998">998</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga6b74b7ed76e4aeea2c67c0bbb03e3e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个将作用于兼容矢量类型的通用 <code>matrix</code> 对象封装为LinearOperator的函数。被创建的LinearOperator对象存储了一个对矩阵对象的引用。因此， <code>matrix</code> 必须在LinearOperator对象的整个生命周期内保持有效引用。 在创建LinearOperator对象之后，对 <code>matrix</code> 所做的所有更改都会被操作者对象所反映。例如，首先创建一个LinearOperator，然后调整大小，以后再重新组合矩阵，这是一个有效的程序。 有关的矩阵类必须提供以下最小接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// (type specific) information how to create a Range and Domain vector</span></div><div class="line"><span class="comment">// with appropriate size and internal layout</span></div><div class="line"></div><div class="line"><span class="comment">// Application of matrix to vector src, writes the result into dst.</span></div><div class="line"><a class="code" href="classLinearOperator.html#a995891407aca97d53bbb2a80b9e0b3db">vmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line"><span class="comment">// Application of the transpose of matrix to vector src, writes the</span></div><div class="line"><span class="comment">// result into dst. (Depending on the usage of the linear operator</span></div><div class="line"><span class="comment">// class this can be a dummy implementation throwing an error.)</span></div><div class="line"><a class="code" href="classLinearOperator.html#a6968174d73bf018f6d0c9181c730e217">Tvmult</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>如果有以下（可选）接口，则使用该接口。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>Matrix</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line"><span class="comment">// Application of matrix to vector src, adds the result to dst.</span></div><div class="line"><a class="code" href="classLinearOperator.html#a5eb6da2c4b33b66c23ea2679ff100de3">vmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line"></div><div class="line"><span class="comment">// Application of the transpose of matrix to vector src, adds the</span></div><div class="line"><span class="comment">// result to dst.</span></div><div class="line"><a class="code" href="classLinearOperator.html#ad36a8841e61b3dbea54cf3745e56c140">Tvmult_add</a>(Range &amp;dst, <span class="keyword">const</span> Domain &amp;src);</div><div class="line">};</div></div><!-- fragment --><p>如果矩阵不提供 <code>vmult_add</code> 和 <code>Tvmult_add</code> ，则以 <code>vmult</code> and <code>Tvmult</code> 的方式实现（需要中间存储）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01359">1359</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ga14dbc8c2c27ea3fd45576528a891c6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga14dbc8c2c27ea3fd45576528a891c6e2">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const OperatorExemplar &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，需要一个操作者对象 <code>operator_exemplar作为额外参考。这个对象被用来填充</code> reinit_domain_vector 和 reinit_range_vector 函数对象。引用 <code>matrix</code> 用于构造vmult、Tvmult等。 这个变体可以，例如，用于封装预处理程序（通常不暴露任何关于底层矩阵的信息）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01386">1386</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaac20bebeb1b53fd00f838b63baac0456"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaac20bebeb1b53fd00f838b63baac0456">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的变体，将LinearOperator <code>operator_exemplar作为一个额外的引用。reinit_domain_vector</code> 和 reinit_range_vector 函数是从 <code>operator_exemplar</code> 对象中复制的。 参考 <code>matrix</code> 用于构造vmult、Tvmult等。 这个变体可以，例如，用于封装预处理程序（通常不暴露任何关于底层矩阵的信息）。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l01436">1436</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="gaf2a467ed50213dea8c580b67ee466c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf2a467ed50213dea8c580b67ee466c7c">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>operator_exemplar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个封装通用 <code>matrix</code> 对象的函数，基于一个 <code>operator_exemplar</code>, ，作用于一个兼容的Vector类型，变成一个LinearOperator。 这个函数等同于 <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>, ，但通过预选适当的模板参数，确保与Trilinos操作完全兼容。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__linear__operator_8h_source.html#l00073">73</a> of file <a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a>.</p>

</div>
</div>
<a id="gab54eadb16250f94319528968b4975874"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54eadb16250f94319528968b4975874">&#9670;&nbsp;</a></span>linear_operator() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, <a class="el" href="classTrilinosWrappers_1_1internal_1_1LinearOperatorImplementation_1_1TrilinosPayload.html">TrilinosWrappers::internal::LinearOperatorImplementation::TrilinosPayload</a> &gt; linear_operator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个将作用于兼容矢量类型的通用 <code>matrix</code> 对象封装为LinearOperator的函数。 这个函数等同于 <a class="el" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>, ，但通过预先选择适当的模板参数，确保与Trilinos操作完全兼容。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__linear__operator_8h_source.html#l00099">99</a> of file <a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a>.</p>

</div>
</div>
<a id="ga76acca911f21089cd3bb385d20ccc995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76acca911f21089cd3bb385d20ccc995">&#9670;&nbsp;</a></span>schur_complement()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType  &gt; schur_complement </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Domain_1, Range_1, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>A_inv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_1, Domain_2, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_1, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range_2, Domain_2, BlockPayload::BlockType  &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个LinearOperator，执行与Schur补数相关的操作。有两个额外的辅助函数，condense_schur_rhs()和postprocess_schur_solution()，为了用这个操作符在线性代数中执行任何有用的任务，很可能需要使用这些函数。 我们以如下方式构建Schur补码的定义。 考虑一个一般的线性方程组，它可以被分解成两个主要的方程组。 </p><p class="formulaDsp">
\begin{eqnarray*} \mathbf{K}\mathbf{d} = \mathbf{f} \quad \Rightarrow\quad \left(\begin{array}{cc} A &amp; B \\ C &amp; D \end{array}\right) \left(\begin{array}{cc} x \\ y \end{array}\right) = \left(\begin{array}{cc} f \\ g \end{array}\right), \end{eqnarray*}
</p>
<p> 其中 \( A,B,C,D \) 代表矩阵 \( \mathbf{K} \) 的一般子块，同样地， \( \mathbf{d},\mathbf{f} \) 的一般子向量由 \( x,y,f,g \) 给出。 这等同于以下两个声明。 </p><p class="formulaDsp">
\begin{eqnarray*} (1) \quad Ax + By &amp;=&amp; f \\ (2) \quad Cx + Dy &amp;=&amp; g \quad . \end{eqnarray*}
</p>
<p>假设 \( A,D \) 既是正方形又是可倒置的，那么我们可以进行两种可能的替换， </p><p class="formulaDsp">
\begin{eqnarray*} (3) \quad x &amp;=&amp; A^{-1}(f - By) \quad \text{from} \quad (1) \\ (4) \quad y &amp;=&amp; D^{-1}(g - Cx) \quad \text{from} \quad (2) , \end{eqnarray*}
</p>
<p> 。 这相当于对这个方程组进行块状高斯消除。 就目前的实现而言，我们选择将（3）代入（2） </p><p class="formulaDsp">
\begin{eqnarray*} C \: A^{-1}(f - By) + Dy &amp;=&amp; g \\ -C \: A^{-1} \: By + Dy &amp;=&amp; g - C \: A^{-1} \: f \quad . \end{eqnarray*}
</p>
<p>。 这导致了结果 </p><p class="formulaDsp">
\[ (5) \quad (D - C\: A^{-1} \:B)y = g - C \: A^{-1} f \quad \Rightarrow \quad Sy = g&#39; \]
</p>
<p>，其中 \( S = (D - C\: A^{-1} \:B) \) 是舒尔补数，而修改后的右手边矢量 \( g&#39; = g - C \: A^{-1} f \) 则来自凝结步骤。请注意，对于 \( S \) 的这种选择，子矩阵 \( D \) 不需要是可逆的，因此可能是空矩阵。理想情况下 \( A \) 应该是条件良好的。 所以对于任何任意矢量 \( a \) ，舒尔补码进行以下操作。 </p><p class="formulaDsp">
\[ (6) \quad Sa = (D - C \: A^{-1} \: B)a \]
</p>
<p> 一个典型的解决线性系统(1),(2)所需的步骤集是。1. 定义逆矩阵 <code>A_inv</code> （使用inverse_operator()）。2. 2. 定义舒尔补码 \( S \) （使用schur_complement()）。3. 定义迭代逆矩阵 \( S^{-1} \) ，使(6)成立。有必要使用带有预处理程序的求解器来计算 \( S \) 的近似逆运算，因为我们从未直接计算 \( S \) ，而是计算其运算的结果。为了实现这一点，可以再次使用inverse_operator()与我们刚刚构建的Schur补码结合起来。请注意， \( S \) 和它的预处理程序都是在与 \( D \) 相同的空间内运行的。4. 4. 使用 <a class="el" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs()</a> 对(5)的RHS进行预处理步骤。 </p><p class="formulaDsp">
\[ g&#39; = g - C \: A^{-1} \: f \]
</p>
<p> 5. 求解（5）中的 \( y \) 。 </p><p class="formulaDsp">
\[ y = S^{-1} g&#39; \]
</p>
<p> 6. 使用postprocess_schur_solution()执行（3）中的后处理步骤。 </p><p class="formulaDsp">
\[ x = A^{-1} (f - By) \]
</p>
<p> 下面给出了该算子在全耦合系统中的典型用法说明。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include&lt;<a class="code" href="schur__complement_8h.html">deal.II/lac/schur_complement.h</a>&gt;</span></div><div class="line"></div><div class="line"><span class="comment">// Given BlockMatrix K and BlockVectors d,F</span></div><div class="line"></div><div class="line"><span class="comment">// Decomposition of tangent matrix</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> B = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(0,1));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a09916360abaee5f1fb31994dbc96787b">C</a> = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,0));</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> D = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(K.block(1,1));</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of solution vector</span></div><div class="line"><span class="keyword">auto</span> x = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>.block(0);</div><div class="line"><span class="keyword">auto</span> y = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Decomposition of RHS vector</span></div><div class="line"><span class="keyword">auto</span> f = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(0);</div><div class="line"><span class="keyword">auto</span> g = <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#aa87528a28ad8a95fa89a3876e6f986c8">F</a>.block(1);</div><div class="line"></div><div class="line"><span class="comment">// Construction of inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> prec_A = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,prec_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>&lt;...&gt;(S,...,prec_S);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="comment">// PackagedOperation that represents the condensed form of g</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv rhs;</div><div class="line"></div><div class="line"><span class="comment">// Compute x using resolved solution y</span></div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p>在上面的例子中， \( S \) 的预处理器被定义为 \( D \) 的预处理器，这是有效的，因为它们在同一空间内运行。然而，如果 \( D \) 和 \( S \) 太不相似，那么这可能导致大量的求解器迭代，因为 \( \text{prec}(D) \) 不是 \( S^{-1} \) 的良好近似。 在这种情况下，更好的预处理程序是为 \( S^{-1} \) 提供更具代表性的近似。一种方法显示在 <a class="el" href="step_22.html">step-22</a> 中，其中 \( D \) 是空矩阵， \( S^{-1} \) 的预处理器是由这个空间的质量矩阵导出的。 从另一个角度来看，类似的结果可以通过首先构造一个代表 \( S \) 的近似对象来实现，其中昂贵的操作，即 \( A^{-1} \) ，被近似。此后，我们构建近似的反算子 \( \tilde{S}^{-1} \) ，然后将其作为计算 \( S^{-1} \) 的前提条件。</p>
<div class="fragment"><div class="line"><span class="comment">// Construction of approximate inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> A_inv_approx = <a class="code" href="group__LAOperators.html#ga6b74b7ed76e4aeea2c67c0bbb03e3e24">linear_operator</a>(preconditioner_A);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv_approx,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// D and S_approx operate on same space</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_approx_prec = <a class="code" href="classPreconditionSelector.html">PreconditionSelector</a>&lt;...&gt;(D);</div><div class="line"></div><div class="line"><span class="comment">// Inner solver: Typically limited to few iterations</span></div><div class="line"><span class="comment">//               using IterationNumberControl</span></div><div class="line"><span class="keyword">auto</span> S_inv_approx = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S_approx,...,S_approx_prec);</div><div class="line"></div><div class="line"><span class="comment">// Construction of exact inverse of Schur complement</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S = <a class="code" href="group__LAOperators.html#ga76acca911f21089cd3bb385d20ccc995">schur_complement</a>(A_inv,B,C,D);</div><div class="line"></div><div class="line"><span class="comment">// Outer solver</span></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> S_inv = <a class="code" href="group__LAOperators.html#ga87e38fbde431397c069a88692bd24ae7">inverse_operator</a>(S,...,S_inv_approx);</div><div class="line"></div><div class="line"><span class="comment">// Solve reduced block system</span></div><div class="line"><span class="keyword">auto</span> rhs = <a class="code" href="group__LAOperators.html#ga2c071b6555ac9e2eb543b7da5100889b">condense_schur_rhs</a> (A_inv,C,f,g);</div><div class="line"></div><div class="line"><span class="comment">// Solve for y</span></div><div class="line">y = S_inv rhs;</div><div class="line">x = <a class="code" href="group__LAOperators.html#gab965c40b54990bbcbc129a1cd218ee21">postprocess_schur_solution</a> (A_inv,B,y,f);</div></div><!-- fragment --><p> 请注意，由于构建 <code>S_inv_approx和随后的</code> <code>S_inv，有一对嵌套的迭代求解器，可能会共同消耗大量的资源。因此，在构建迭代逆运算器的过程中，应该注意选择。我们可以考虑使用IterationNumberControl（或类似的机制）来限制内部求解器的迭代次数。这可以控制近似逆运算</code> \( \tilde{S}^{-1} \) 的精度，该运算仅作为 \( S^{-1} \) 的预处理程序发挥作用。此外， \( \tilde{S}^{-1} \) 的先决条件，在本例中是 \( \text{prec}(D) \) ，理想情况下应该是计算成本低的。 然而，如果使用基于IterationNumberControl的迭代求解器作为预处理器，那么预处理操作就不是线性操作了。这里最好采用SolverFGMRES（灵活的GMRES）这样的灵活求解器作为外部求解器，以处理预处理器的可变行为。否则，迭代求解器可能会在预处理器的容忍度附近停滞不前，或者普遍表现得不稳定。另外，使用ReductionControl可以确保前置条件器总是以相同的容差进行求解，从而使其行为恒定。 这种功能的更多例子可以在测试套件中找到，如 <code>tests/lac/schur_complement_01.cc</code> 。使用schur_complement解决一个多组件问题（即 <a class="el" href="step_22.html">step-22</a> ），可以在 <code>tests/lac/schur_complement_03.cc</code> 中找到。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="schur__complement_8h_source.html#l00229">229</a> of file <a class="el" href="schur__complement_8h_source.html">schur_complement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac42d948813da72836e1a661acd3beea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac42d948813da72836e1a661acd3beea4">&#9670;&nbsp;</a></span>n_block_rows</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>()&gt; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::n_block_rows</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一列中的块数（即 "块行 "的数量，或者数字 \(m\) ，如果解释为 \(m\times n\) 块系统）。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00306">306</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="ab414e1ffc37fba57ef140634152736c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab414e1ffc37fba57ef140634152736c9">&#9670;&nbsp;</a></span>n_block_cols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;unsigned <a class="el" href="classint.html">int</a>()&gt; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::n_block_cols</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一行的块数（即 "块列 "的数量，或者数字 \(n\) ，如果解释为 \(m\times n\) 块系统）。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00313">313</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a6174ae91be3b59658fdcc5c5460bd350"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6174ae91be3b59658fdcc5c5460bd350">&#9670;&nbsp;</a></span>block</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Range, typename Domain, typename BlockPayload&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classBlockLinearOperator.html#a2b106db0ddd0a15dadaeffd860207745">BlockType</a>(unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>)&gt; <a class="el" href="classBlockLinearOperator.html">BlockLinearOperator</a>&lt; Range, Domain, BlockPayload &gt;::block</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>访问具有给定坐标的块。这个 <code>std::function</code> 对象返回一个LinearOperator，代表BlockLinearOperator的 \((i,j)\) -th块。 </p>

<p class="definition">Definition at line <a class="el" href="block__linear__operator_8h_source.html#l00321">321</a> of file <a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a>.</p>

</div>
</div>
<a id="a995891407aca97d53bbb2a80b9e0b3db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995891407aca97d53bbb2a80b9e0b3db">&#9670;&nbsp;</a></span>vmult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, const Domain &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::vmult</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将LinearOperator对象应用于 <code>Domain</code> 空间的向量u，得到 <code>Range</code> 空间的向量v。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00264">264</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a5eb6da2c4b33b66c23ea2679ff100de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eb6da2c4b33b66c23ea2679ff100de3">&#9670;&nbsp;</a></span>vmult_add</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, const Domain &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::vmult_add</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将LinearOperator对象应用于 <code>Domain</code> 空间的向量u。其结果被添加到向量v中。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00271">271</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a6968174d73bf018f6d0c9181c730e217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6968174d73bf018f6d0c9181c730e217">&#9670;&nbsp;</a></span>Tvmult</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, const Range &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::Tvmult</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对 <code>Range</code> 空间的向量u应用转置LinearOperator对象，得到 <code>Domain</code> 空间的向量v。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00278">278</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="ad36a8841e61b3dbea54cf3745e56c140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad36a8841e61b3dbea54cf3745e56c140">&#9670;&nbsp;</a></span>Tvmult_add</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, const Range &amp;u)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::Tvmult_add</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对 <code>Range</code> 空间的向量 <code>u</code> 应用转置LinearOperator对象。结果被添加到向量 <code>v</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00285">285</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="aa470d7770714cfe9a64bf0f0d817d71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa470d7770714cfe9a64bf0f0d817d71f">&#9670;&nbsp;</a></span>reinit_range_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Range &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::reinit_range_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>初始化Range空间的一个向量v，可以直接作为vmult应用中的目标参数使用。与向量类的reinit函数类似，布尔值决定是否进行快速初始化，也就是说，如果它被设置为false，向量的内容就被设置为0。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00291">291</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a818a9e4c7d8bf0edbb253b938d831e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a818a9e4c7d8bf0edbb253b938d831e43">&#9670;&nbsp;</a></span>reinit_domain_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(Domain &amp;v, <a class="el" href="classbool.html">bool</a> omit_zeroing_entries)&gt; <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::reinit_domain_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>初始化域空间的一个向量，以便在vmult的应用中可以直接作为源参数使用。与向量类的reinit函数类似，布尔值决定是否进行快速初始化，也就是说，如果它被设置为false，向量的内容就被设置为0。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00298">298</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<a id="a99cd172538d9f6d20474deea30ab43f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99cd172538d9f6d20474deea30ab43f0">&#9670;&nbsp;</a></span>is_null_operator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearOperator.html">LinearOperator</a>&lt; Range, Domain, BlockPayload::BlockType  &gt;::is_null_operator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个bool用于确定线性运算符是否是空运算符。在这种情况下，该类能够优化一些操作，如乘法或加法。 </p>

<p class="definition">Definition at line <a class="el" href="linear__operator_8h_source.html#l00356">356</a> of file <a class="el" href="linear__operator_8h_source.html">linear_operator.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="block__linear__operator_8h_source.html">block_linear_operator.h</a></li>
<li>include/deal.II/lac/<a class="el" href="trilinos__linear__operator_8h_source.html">trilinos_linear_operator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
