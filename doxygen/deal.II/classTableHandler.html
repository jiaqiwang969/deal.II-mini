<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTableHandler.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TableHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classTableHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TableHandler Class Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__textoutput.html">Textual output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="table__handler_8h_source.html">deal.II/base/table_handler.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TableHandler:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTableHandler__inherit__graph.svg" width="152" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTableHandler_1_1Column.html">Column</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a84255fd53f3c75dcbdc4706079d56d8a"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a> { <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317">table_with_headers</a>, 
<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aabc13cea8f6e7f62b88b05bf8028f9b58">table_with_separate_column_description</a>, 
<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa1f608224ad0de4e828c4baf4ab071ba0">simple_table_with_separate_column_description</a>, 
<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aab8dfaad92bc515243a8a3704f92f6a1a">org_mode_table</a>
 }</td></tr>
<tr class="separator:a84255fd53f3c75dcbdc4706079d56d8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7824771057567647419de994788c1b52"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a7824771057567647419de994788c1b52">TableHandler</a> ()</td></tr>
<tr class="separator:a7824771057567647419de994788c1b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be10de14f8b3cc9caadad77ea3247b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3be10de14f8b3cc9caadad77ea3247b2">declare_column</a> (const std::string &amp;key)</td></tr>
<tr class="separator:a3be10de14f8b3cc9caadad77ea3247b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5484a9516db419a90540a40aba4c6d84"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5484a9516db419a90540a40aba4c6d84"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a> (const std::string &amp;key, const T value)</td></tr>
<tr class="separator:a5484a9516db419a90540a40aba4c6d84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d43be403f341a60b9cc61ac761c5706"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a2d43be403f341a60b9cc61ac761c5706">start_new_row</a> ()</td></tr>
<tr class="separator:a2d43be403f341a60b9cc61ac761c5706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cb7335fc1afcc338b6d57e43be39116"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a4cb7335fc1afcc338b6d57e43be39116">set_auto_fill_mode</a> (const <a class="el" href="classbool.html">bool</a> state)</td></tr>
<tr class="separator:a4cb7335fc1afcc338b6d57e43be39116"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cd640c9e3a2736dfe5c345ebe652d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a> (const std::string &amp;key, const std::string &amp;superkey)</td></tr>
<tr class="separator:ab3cd640c9e3a2736dfe5c345ebe652d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab83b34eb9cbd403bf2cff04d162ebccc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab83b34eb9cbd403bf2cff04d162ebccc">set_column_order</a> (const std::vector&lt; std::string &gt; &amp;new_order)</td></tr>
<tr class="separator:ab83b34eb9cbd403bf2cff04d162ebccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4766582d0900d3095fc2efad21ae83e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#af4766582d0900d3095fc2efad21ae83e">set_precision</a> (const std::string &amp;key, const unsigned <a class="el" href="classint.html">int</a> precision)</td></tr>
<tr class="separator:af4766582d0900d3095fc2efad21ae83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aded59db14d0341e6ea6cc27165fa918d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aded59db14d0341e6ea6cc27165fa918d">set_scientific</a> (const std::string &amp;key, const <a class="el" href="classbool.html">bool</a> scientific)</td></tr>
<tr class="separator:aded59db14d0341e6ea6cc27165fa918d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac85c292764a506f0691507a0d29b10ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ac85c292764a506f0691507a0d29b10ff">set_tex_caption</a> (const std::string &amp;key, const std::string &amp;tex_caption)</td></tr>
<tr class="separator:ac85c292764a506f0691507a0d29b10ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36ab3fd473ea2f8a21d0bb914db59342"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a36ab3fd473ea2f8a21d0bb914db59342">set_tex_table_caption</a> (const std::string &amp;table_caption)</td></tr>
<tr class="separator:a36ab3fd473ea2f8a21d0bb914db59342"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed20f49e64bfc90d0ab72e6fad5376ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aed20f49e64bfc90d0ab72e6fad5376ef">set_tex_table_label</a> (const std::string &amp;table_label)</td></tr>
<tr class="separator:aed20f49e64bfc90d0ab72e6fad5376ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896a239cd72d9839f8a55db563f0f57"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3896a239cd72d9839f8a55db563f0f57">set_tex_supercaption</a> (const std::string &amp;superkey, const std::string &amp;tex_supercaption)</td></tr>
<tr class="separator:a3896a239cd72d9839f8a55db563f0f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11013123ef4b3e44e4ee22e40be21b67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a11013123ef4b3e44e4ee22e40be21b67">set_tex_format</a> (const std::string &amp;key, const std::string &amp;format=&quot;c&quot;)</td></tr>
<tr class="separator:a11013123ef4b3e44e4ee22e40be21b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c4ec9981f3880c6c852ed3aceb08fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a45c4ec9981f3880c6c852ed3aceb08fe">write_text</a> (std::ostream &amp;out, const <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a> format=<a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317">table_with_headers</a>) const</td></tr>
<tr class="separator:a45c4ec9981f3880c6c852ed3aceb08fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35a3f91ac146fad800eb38437b5e74e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ab35a3f91ac146fad800eb38437b5e74e">write_tex</a> (std::ostream &amp;file, const <a class="el" href="classbool.html">bool</a> with_header=true) const</td></tr>
<tr class="separator:ab35a3f91ac146fad800eb38437b5e74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90b814947450218cde1fa257d7968a30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a90b814947450218cde1fa257d7968a30">clear</a> ()</td></tr>
<tr class="separator:a90b814947450218cde1fa257d7968a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad554fd6402d33e6db20b33604758182f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ad554fd6402d33e6db20b33604758182f">clear_current_row</a> ()</td></tr>
<tr class="separator:ad554fd6402d33e6db20b33604758182f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a3896c62fe9aeb1830446d9d1c27b1fdb">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3896c62fe9aeb1830446d9d1c27b1fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ga1964d29d3dd7fab64ca4a4bd1a2bbed5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1964d29d3dd7fab64ca4a4bd1a2bbed5">ExcColumnNotExistent</a> (std::string arg1)</td></tr>
<tr class="separator:ga1964d29d3dd7fab64ca4a4bd1a2bbed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66c6e7096fbed10aee78fcd37407ff6a"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga66c6e7096fbed10aee78fcd37407ff6a">ExcSuperColumnNotExistent</a> (std::string arg1)</td></tr>
<tr class="separator:ga66c6e7096fbed10aee78fcd37407ff6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5cc45c15bf5ae0b1950b0d810d66914d"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5cc45c15bf5ae0b1950b0d810d66914d">ExcColumnOrSuperColumnNotExistent</a> (std::string arg1)</td></tr>
<tr class="separator:ga5cc45c15bf5ae0b1950b0d810d66914d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6fe2afaa41c467464137ae6afb5b32ab"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga6fe2afaa41c467464137ae6afb5b32ab">ExcWrongNumberOfDataEntries</a> (std::string arg1, <a class="el" href="classint.html">int</a> arg2, std::string arg3, <a class="el" href="classint.html">int</a> arg4)</td></tr>
<tr class="separator:ga6fe2afaa41c467464137ae6afb5b32ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga24fdf1a66743a8f55586aa75deda2cb0"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga24fdf1a66743a8f55586aa75deda2cb0">ExcUndefinedTexFormat</a> (std::string arg1)</td></tr>
<tr class="separator:ga24fdf1a66743a8f55586aa75deda2cb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a69b916dc7fb2f171f3965ab1b0fe4d65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a69b916dc7fb2f171f3965ab1b0fe4d65">get_selected_columns</a> (std::vector&lt; std::string &gt; &amp;sel_columns) const</td></tr>
<tr class="separator:a69b916dc7fb2f171f3965ab1b0fe4d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670d250f5bce3406d55ab3d4bc72cded"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a670d250f5bce3406d55ab3d4bc72cded">n_rows</a> () const</td></tr>
<tr class="separator:a670d250f5bce3406d55ab3d4bc72cded"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ae9eadbc232f49cf4a39b9eea5318b0c7"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#ae9eadbc232f49cf4a39b9eea5318b0c7">column_order</a></td></tr>
<tr class="separator:ae9eadbc232f49cf4a39b9eea5318b0c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc479809cac5dad2ebb0b8b202ca3d1b"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, <a class="el" href="structTableHandler_1_1Column.html">Column</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#afc479809cac5dad2ebb0b8b202ca3d1b">columns</a></td></tr>
<tr class="separator:afc479809cac5dad2ebb0b8b202ca3d1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::vector&lt; std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3">supercolumns</a></td></tr>
<tr class="separator:a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fadd66861022772b9901ee96b5b6004"><td class="memItemLeft" align="right" valign="top">std::map&lt; std::string, std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a8fadd66861022772b9901ee96b5b6004">tex_supercaptions</a></td></tr>
<tr class="separator:a8fadd66861022772b9901ee96b5b6004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0920e405beec2a978f2921ccf88ea1d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#aa0920e405beec2a978f2921ccf88ea1d">tex_table_caption</a></td></tr>
<tr class="separator:aa0920e405beec2a978f2921ccf88ea1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ba6a6cc6f4b5c170bdfc9bc0313e26"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a98ba6a6cc6f4b5c170bdfc9bc0313e26">tex_table_label</a></td></tr>
<tr class="separator:a98ba6a6cc6f4b5c170bdfc9bc0313e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825579ea69b3eb16e52f1ec2673b6dec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableHandler.html#a825579ea69b3eb16e52f1ec2673b6dec">auto_fill_mode</a></td></tr>
<tr class="separator:a825579ea69b3eb16e52f1ec2673b6dec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>TableHandler存储任意值类型的TableEntries，并将表以文本或tex格式写入输出流。值的类型实际上可以从列到列，从行到行而变化。 </p><h3>Usage</h3>
<p>最重要的函数是模板化的函数 <code><a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value(const std::string &amp;key, const T value)</a></code> ，如果这一列还不存在，就在表中添加一个名字为<code>key</code>的列，并在这一列中添加类型为<code>T</code>（必须是<code>int</code>, <code>unsigned int</code>, <code>double</code>, <code>std::string</code>) 的给定值。 表格完成后，有不同的输出可能性，例如，用write_tex()输出到latex文件，或用write_text()输出为文本。 两个（或多个）列可以通过两次（或多次）调用add_column_to_supercolumn()合并成一个 "超级列"，见那里。此外，还有一个函数可以为每一列设置数字输出的精度，还有几个函数可以在tex模式下规定列的格式和标题。 在 <a class="el" href="step_13.html">step-13</a> 教程程序中也给出了对这个类的详细解释。</p>
<h3>Example</h3>
<p>这是一个简单的例子，演示了这个类的用法。第一列包括数字 \(i=1 \dots n\) ，第二列 \(1^2 \dots n^2\) ，第三列 \(\sqrt{1}\dots\sqrt{n}\) ，其中第二列和第三列被合并成一个超级列，超级键为<code>平方和根</code>。此外，第一列向右对齐（默认是<code>居中</code>），平方根的精度被设置为6（而不是默认的4）。</p>
<div class="fragment"><div class="line"><a class="code" href="classTableHandler.html">TableHandler</a> table;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 1; i &lt;= n; ++i)</div><div class="line">{</div><div class="line">  table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;numbers&quot;</span>, i);</div><div class="line">  table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;squares&quot;</span>, i i);</div><div class="line">  table.<a class="code" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">add_value</a>(<span class="stringliteral">&quot;square roots&quot;</span>, std::sqrt(i));</div><div class="line">}</div><div class="line"><span class="comment">// merge the second and third column</span></div><div class="line">table.<a class="code" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a>(<span class="stringliteral">&quot;squares&quot;</span>, <span class="stringliteral">&quot;squares and roots&quot;</span>);</div><div class="line">table.<a class="code" href="classTableHandler.html#ab3cd640c9e3a2736dfe5c345ebe652d1">add_column_to_supercolumn</a>(<span class="stringliteral">&quot;square roots&quot;</span>, <span class="stringliteral">&quot;squares and roots&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// additional settings</span></div><div class="line">table.<a class="code" href="classTableHandler.html#a11013123ef4b3e44e4ee22e40be21b67">set_tex_format</a>(<span class="stringliteral">&quot;numbers&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);</div><div class="line">table.<a class="code" href="classTableHandler.html#af4766582d0900d3095fc2efad21ae83e">set_precision</a>(<span class="stringliteral">&quot;square roots&quot;</span>, 6);</div><div class="line"></div><div class="line"><span class="comment">// output</span></div><div class="line">std::ofstream out_file(<span class="stringliteral">&quot;number_table.tex&quot;</span>);</div><div class="line">table.<a class="code" href="classTableHandler.html#ab35a3f91ac146fad800eb38437b5e74e">write_tex</a>(out_file);</div><div class="line">out_file.close();</div></div><!-- fragment --><h3>Dealing with sparse data: auto-fill mode</h3>
<p>当生成输出时，TableHandler期望所有的列都有完全相同数量的元素，因此结果实际上是一个表。这假定在每个迭代（时间步骤、非线性迭代等）中，你都会填满每一列。另一方面，这不一定是你想做的。例如，可能计算非线性残差的函数每隔几个时间步数才被调用一次；或者，计算网格统计的函数只有在网格实际上被细化时才被调用。在这些情况下，对于某些列来说，add_value()函数的调用频率会比较低，因此该列的元素会比较少；此外，这些元素不会与包含本次迭代中产生的其他数据元素的行对齐。一个完全不同的情况是，表被填满，在以后的时间里，我们使用其中的数据来计算其他行的元素；ConvergenceTable类做了这样的事情。 为了支持这两种情况，TableHandler类有一个叫做<em> auto-fill mode</em>的属性。默认情况下，自动填充模式是关闭的，但它可以通过调用set_auto_fill_mode()来启用。如果自动填充模式被启用，我们使用以下算法。</p>
<ul>
<li>当调用 <code>add_value(key, value)</code> 时，我们计算对应于 <code>key</code> 的列中的元素数量。让我们把这个数字称为 \(m\) 。</li>
<li>我们还确定其他列中元素的最大数量；称其为 \(n\) 。</li>
<li>如果 \(m &lt; n-1\) ，那么我们将 \(n-m-1\) 对象的副本 <code><a class="el" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T()</a></code> 添加到该列。这里， <code>T</code> 是给定的数据类型 <code>value</code>. For example, if <code>T</code> 是数字类型，那么 <code><a class="el" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T()</a></code> is the number zero; if <code>T</code> 就是 <code>std::string</code>, then <code><a class="el" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T()</a></code> 是空字符串 <code>""</code> 。</li>
<li>将给定的值添加到该列中。 用默认元素填充该列，确保添加后该列的条目数与其他最长的列一样多。换句话说，如果我们跳过了之前对给定键的add_value()的调用，那么填充将把默认值输入到这一列。 如果你试图跳过为一个键添加值，如果为这个键添加元素是你在给定的迭代或时间步长中要做的第一件事，那么所描述的算法将失败，因为我们将填充到<em>previous</em>迭代或时间步长中最长的列的长度。你可能需要在你的程序中重新安排添加到这一列的顺序，在添加到将一直被添加到的一列之后；或者，你可能想在每次迭代开始时，在表格中添加迭代的编号，例如在第1列。 在上面的案例中，我们总是在列<b>above</b>中填充被添加到一列的元素。然而，也有一种情况，我们必须要垫上<b>below</b>。也就是说，如果前面的一行已经用 <a class="el" href="classTableHandler.html#a5484a9516db419a90540a40aba4c6d84">TableHandler::add_value()</a>, 完全填充，后续的几行已经被部分填充，然后我们通过write_text()或write_tex()要求输出。在这种情况下，最后几行只填充了部分内容，需要在最后加入的元素下面进行填充。和以前一样，我们通过使用与该列最后一个元素相同类型的默认构造对象来实现。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00244">244</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a84255fd53f3c75dcbdc4706079d56d8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84255fd53f3c75dcbdc4706079d56d8a">&#9670;&nbsp;</a></span>TextOutputFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TableHandler::TextOutputFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一组选项，当用write_text()函数输出时，应该如何格式化一个表格。存在以下可能性。</p>
<ul>
<li><code>table_with_headers</code> : 表格的格式是，内容在每一列的键下对齐，也就是说，键位于每一列的顶部。这适合于列数不多的表格，在这种情况下，整个表格可以显示在屏幕上。输出看起来像这样。 <div class="fragment"><div class="line">key1 key2 key3</div><div class="line">0    0    <span class="stringliteral">&quot;&quot;</span></div><div class="line">1    0    <span class="stringliteral">&quot;&quot;</span></div><div class="line">2    13   a</div><div class="line">1    0    <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --></li>
<li><code>table_with_separate_column_description</code> : 当有很多列，而表格整体不能显示在屏幕上时，这是一种更好的格式。在这里，列键首先被逐一列在自己的行上，并被编号以提高可读性。此外，这些描述行的前缀是'#'，以标明这些行是注释，供那些想把下面的表作为数据来读的程序使用，应该忽略这些描述行。GNUPLOT就是这样一个程序，它将自动忽略这些前缀的行。使用这个选项的输出结果看起来像这样。 <div class="fragment"><div class="line"><span class="preprocessor"># 1: key1</span></div><div class="line"><span class="preprocessor"># 2: key2</span></div><div class="line"><span class="preprocessor"># 3: key3</span></div><div class="line">0 0  <span class="stringliteral">&quot;&quot;</span></div><div class="line">1 0  <span class="stringliteral">&quot;&quot;</span></div><div class="line">2 13 a</div><div class="line">1 0  <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --></li>
<li><code>simple_table_with_separate_column_description</code> : 这种格式与 <code>table_with_separate_column_description</code> 非常相似，但它跳过了用额外的空白空间对齐列。这提高了大表的write_text()的性能。输出示例。 <div class="fragment"><div class="line"><span class="preprocessor"># 1: key1</span></div><div class="line"><span class="preprocessor"># 2: key2</span></div><div class="line"><span class="preprocessor"># 3: key3</span></div><div class="line">0 0 <span class="stringliteral">&quot;&quot;</span></div><div class="line">1 0 <span class="stringliteral">&quot;&quot;</span></div><div class="line">2 13 a</div><div class="line">1 0 <span class="stringliteral">&quot;&quot;</span></div></div><!-- fragment --></li>
<li><code>org_mode_table</code> : 输出为 org-mode (<a href="http://orgmode.org/">http://orgmode.org/</a>) 表格格式。将org-mode表格转换为HTML/LaTeX/csv很容易。 输出示例。 <div class="fragment"><div class="line">| key1 | key2 | key3 |</div><div class="line">| 0    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div><div class="line">| 1    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div><div class="line">| 2    | 13   | a    |</div><div class="line">| 1    | 0    | <span class="stringliteral">&quot;&quot;</span>   |</div></div><!-- fragment --> </li>
</ul>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317"></a>table_with_headers&#160;</td><td class="fielddoc"><p>打印带有页眉的表格。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aabc13cea8f6e7f62b88b05bf8028f9b58"></a>table_with_separate_column_description&#160;</td><td class="fielddoc"><p>为每一列标签单独打印表格。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aa1f608224ad0de4e828c4baf4ab071ba0"></a>simple_table_with_separate_column_description&#160;</td><td class="fielddoc"><p>像table_with_separate_column_description一样，但不对包含列标签的列进行对齐。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a84255fd53f3c75dcbdc4706079d56d8aab8dfaad92bc515243a8a3704f92f6a1a"></a>org_mode_table&#160;</td><td class="fielddoc"><p>以org模式的格式打印表格。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00311">311</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a7824771057567647419de994788c1b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7824771057567647419de994788c1b52">&#9670;&nbsp;</a></span>TableHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TableHandler::TableHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00197">197</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3be10de14f8b3cc9caadad77ea3247b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be10de14f8b3cc9caadad77ea3247b2">&#9670;&nbsp;</a></span>declare_column()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::declare_column </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过给它一个名字来声明表格中的一个列的存在。 正如在该类的文档中所讨论的，这通常是不必要的。</p>
<ul>
<li>只是通过add_value()函数为一个给定的列键添加一个值，也声明了该列。因此，这个函数只有在以下情况下才是必要的：你希望一个列也能显示出来，即使你从未在这一列的任何行中添加过条目；或者，更有可能的是，如果你想规定以后打印列的顺序，在条目被放进列之前以特定顺序声明列。 后者的目的也可以通过在程序中以任何顺序向表中添加条目，然后调用set_column_order()来实现。然而，这种方法需要知道</li>
<li>在你的软件的一个中心位置</li>
<li>软件的其他部分写入的所有列键，以及它们应该如何排序。这对小程序来说很容易做到，但对大型代码库来说可能不可行，因为代码库的部分内容只根据运行时的参数来执行。) </li>
</ul>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00204">204</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a5484a9516db419a90540a40aba4c6d84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5484a9516db419a90540a40aba4c6d84">&#9670;&nbsp;</a></span>add_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::add_value </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加一个键为<code>key</code>的列（如果尚未存在），并将类型为<code>T</code>的值添加到该列。<code>T</code>类型的值必须可以转换为<code>int, unsigned int, double, std::uint64_t, std::string</code> 中的一种，否则将导致编译器错误。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00865">865</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a2d43be403f341a60b9cc61ac761c5706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d43be403f341a60b9cc61ac761c5706">&#9670;&nbsp;</a></span>start_new_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::start_new_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果一行只被部分填满，那么就把该行中某一列中不存在元素的所有元素设置为空字符串。这类似于在介绍中描述的 "auto_fill_mode"，但更普遍，因为它允许你开始向新行的某一列中写入内容，而不必知道该列在前一行已经被写入。 如果当前行的所有列都被写入了，那么这个函数根本就不做任何事情。换句话说，从概念上讲，这个函数 "完成 "了当前行，尽管它的用例是 "开始 "一个新行。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00218">218</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a4cb7335fc1afcc338b6d57e43be39116"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cb7335fc1afcc338b6d57e43be39116">&#9670;&nbsp;</a></span>set_auto_fill_mode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_auto_fill_mode </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>state</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>开启或关闭自动填充模式。关于自动填充模式的描述，请参见该类的一般文档。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00245">245</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ab3cd640c9e3a2736dfe5c345ebe652d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3cd640c9e3a2736dfe5c345ebe652d1">&#9670;&nbsp;</a></span>add_column_to_supercolumn()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::add_column_to_supercolumn </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>superkey</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个超级列（如果还不存在的话）并将列纳入其中。 列和超级列的键分别是<code>key</code>和<code>superkey</code>。 要将两个列<code>c1</code>和<code>c2</code>合并到一个超级列<code>sc</code>，因此调用<code>add_column_to_supercolumn(c1,sc)</code>和<code>add_column_to_supercolumn(c2,sc)</code>。 关于列的顺序，超级列取代了被添加到超级列的第一列。在超级列中，输出的顺序是按照添加到超级列中的列的顺序。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00252">252</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ab83b34eb9cbd403bf2cff04d162ebccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab83b34eb9cbd403bf2cff04d162ebccc">&#9670;&nbsp;</a></span>set_column_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_column_order </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>改变表格中列和超级列的顺序。 <code>new_order</code>包括列和超列的键和超键，其顺序是用户希望它们被输出。如果包含了超键，子列的键就不需要在这个向量中明确提及。 超级列内的子列的顺序是不可改变的，仍然是按照列被添加到超级列的顺序。 这个函数也可以用来把列数太多的大表分解成小表。例如，你可以用前五列调用这个函数，然后调用其中一个<code>write_*</code>函数，然后用下五列调用这个函数，再一次<code>write_*</code>，如此循环。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00296">296</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="af4766582d0900d3095fc2efad21ae83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4766582d0900d3095fc2efad21ae83e">&#9670;&nbsp;</a></span>set_precision()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_precision </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置<code>precision</code>，例如，双数或浮点数变量的写入方式。<code>precision</code>与调用<code>out&lt;&lt;setprecision(precision)</code>时相同。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00359">359</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="aded59db14d0341e6ea6cc27165fa918d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aded59db14d0341e6ea6cc27165fa918d">&#9670;&nbsp;</a></span>set_scientific()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_scientific </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置<code>scientific_flag</code>。真表示科学，假表示定点记数法。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00372">372</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ac85c292764a506f0691507a0d29b10ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac85c292764a506f0691507a0d29b10ff">&#9670;&nbsp;</a></span>set_tex_caption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_caption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tex_caption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置tex输出的<code>key</code>列的标题。你可能想选择与<code>key</code>不同的，如果它包含公式或类似结构。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00310">310</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a36ab3fd473ea2f8a21d0bb914db59342"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36ab3fd473ea2f8a21d0bb914db59342">&#9670;&nbsp;</a></span>set_tex_table_caption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_table_caption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>table_caption</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置整个<code>table</code>的tex标题，用于tex输出。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00320">320</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="aed20f49e64bfc90d0ab72e6fad5376ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed20f49e64bfc90d0ab72e6fad5376ef">&#9670;&nbsp;</a></span>set_tex_table_label()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_table_label </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>table_label</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置这个<code>表的标签</code>，用于文本输出。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00328">328</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a3896a239cd72d9839f8a55db563f0f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896a239cd72d9839f8a55db563f0f57">&#9670;&nbsp;</a></span>set_tex_supercaption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_supercaption </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>superkey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>tex_supercaption</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置超级列的标题<code>superkey</code>，用于特克斯输出。 你可能想选择与<code>superkey</code>不同的，如果它包含公式或类似的结构。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00336">336</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a11013123ef4b3e44e4ee22e40be21b67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11013123ef4b3e44e4ee22e40be21b67">&#9670;&nbsp;</a></span>set_tex_format()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::set_tex_format </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;c&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置一个列的tex输出格式，例如：<code>c</code>, <code>r</code>, <code>l</code>, 或者<code>p{3cm}</code>。默认是<code>c</code>。另外，如果没有为某一列调用这个函数，默认值将被预设为<code>c</code>。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00347">347</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a45c4ec9981f3880c6c852ed3aceb08fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c4ec9981f3880c6c852ed3aceb08fe">&#9670;&nbsp;</a></span>write_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::write_text </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8a">TextOutputFormat</a>&#160;</td>
          <td class="paramname"><em>format</em> = <code><a class="el" href="classTableHandler.html#a84255fd53f3c75dcbdc4706079d56d8aa3a2f08767f7c1c0c87d0ff4916696317">table_with_headers</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将表格作为格式化的文本写入给定的流中。文本的格式是这样的：它将数据表示为格式化的文本列。为了避免在自动读取这些表格时出现问题，例如用于后处理，如果该表的某个单元格中的条目是空的（即它是通过调用add_value()函数用空字符串创建的），那么该表的条目将被打印为 <code>""</code> 。 第二个参数表示如何显示列键。更多信息请参见TextOutputFormat的描述。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00384">384</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ab35a3f91ac146fad800eb38437b5e74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35a3f91ac146fad800eb38437b5e74e">&#9670;&nbsp;</a></span>write_tex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::write_tex </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>with_header</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将表写成一个tex文件。如果 <code>with_header</code> 被设置为false，那么就不使用 <code>\documentclass{...}</code>, <code>\begin{document}</code> 和 <code>\end{document}</code> 。这样，该文件就可以用 <code>\input{table_file}</code> 这样的命令包含到一个现有的tex文件中。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00600">600</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a90b814947450218cde1fa257d7968a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90b814947450218cde1fa257d7968a30">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除表格的行，即在所有底层存储数据结构上调用clear()。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00742">742</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="ad554fd6402d33e6db20b33604758182f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad554fd6402d33e6db20b33604758182f">&#9670;&nbsp;</a></span>clear_current_row()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::clear_current_row </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>删除所有在当前行添加的值。例如，当一个时间步长被拒绝，所有关于它的数据记录都需要被丢弃时，这就很有用。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00807">807</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a3896c62fe9aeb1830446d9d1c27b1fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3896c62fe9aeb1830446d9d1c27b1fdb">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00924">924</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a69b916dc7fb2f171f3965ab1b0fe4d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b916dc7fb2f171f3965ab1b0fe4d65">&#9670;&nbsp;</a></span>get_selected_columns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TableHandler::get_selected_columns </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sel_columns</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>帮助函数，给出<code>column_order</code>中提到的所有列的键的向量，其中每个超级列的键被其子列的键所替代。 这个函数隐含地检查数据的一致性。结果在<code>sel_columns</code>中返回。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00776">776</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<a id="a670d250f5bce3406d55ab3d4bc72cded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670d250f5bce3406d55ab3d4bc72cded">&#9670;&nbsp;</a></span>n_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TableHandler::n_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>内置函数，给出表中的行数，并检查每一列的行数是否相等。这个函数可以在写输出之前调用。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8cc_source.html#l00755">755</a> of file <a class="el" href="table__handler_8cc_source.html">table_handler.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ae9eadbc232f49cf4a39b9eea5318b0c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9eadbc232f49cf4a39b9eea5318b0c7">&#9670;&nbsp;</a></span>column_order</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::string&gt; TableHandler::column_order</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个变量，按照用户希望的顺序存储列和超列的键。默认情况下这是添加列的顺序。这个顺序可以通过set_column_order()来改变。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00688">688</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="afc479809cac5dad2ebb0b8b202ca3d1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc479809cac5dad2ebb0b8b202ca3d1b">&#9670;&nbsp;</a></span>columns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, <a class="el" href="structTableHandler_1_1Column.html">Column</a>&gt; TableHandler::columns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个从列键到列的映射（不是超级列）。 这个字段被声明为可变的，以便write_text()和write_tex()函数可以是常数，即使它们在'auto_fill_mode'开启的情况下可能会在下面填充列。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00695">695</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d8ccfeb4f8cb5df5ab21a8e1d53c3b3">&#9670;&nbsp;</a></span>supercolumns</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::vector&lt;std::string&gt; &gt; TableHandler::supercolumns</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个从每个超级列的键到其子列的键的正确顺序的映射。 允许一个超级列与一个列有相同的键。 注意，我们在这里不使用<code>multimap</code>，因为每个超级列键的顺序是相关的。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00703">703</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a8fadd66861022772b9901ee96b5b6004"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fadd66861022772b9901ee96b5b6004">&#9670;&nbsp;</a></span>tex_supercaptions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;std::string, std::string&gt; TableHandler::tex_supercaptions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个从超级列键到超级列标题的映射，在tex输出中使用。 默认情况下，这些只是超级列的键，但它们可以通过<code>set_tex_supercaptions(...)</code>改变。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00710">710</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="aa0920e405beec2a978f2921ccf88ea1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0920e405beec2a978f2921ccf88ea1d">&#9670;&nbsp;</a></span>tex_table_caption</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableHandler::tex_table_caption</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表格本身的标题。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00716">716</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a98ba6a6cc6f4b5c170bdfc9bc0313e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ba6a6cc6f4b5c170bdfc9bc0313e26">&#9670;&nbsp;</a></span>tex_table_label</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string TableHandler::tex_table_label</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该表的标签。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00721">721</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<a id="a825579ea69b3eb16e52f1ec2673b6dec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825579ea69b3eb16e52f1ec2673b6dec">&#9670;&nbsp;</a></span>auto_fill_mode</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TableHandler::auto_fill_mode</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表示是否应该使用自动填充模式的标志。 </p>

<p class="definition">Definition at line <a class="el" href="table__handler_8h_source.html#l00727">727</a> of file <a class="el" href="table__handler_8h_source.html">table_handler.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="table__handler_8h_source.html">table_handler.h</a></li>
<li>source/base/<a class="el" href="table__handler_8cc_source.html">table_handler.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
