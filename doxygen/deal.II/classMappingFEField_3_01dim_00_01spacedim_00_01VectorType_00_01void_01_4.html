<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MappingFEField&lt; dim, spacedim, VectorType, void &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">MappingFEField&lt; dim, spacedim, VectorType, void &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__mapping.html">Mappings between reference and real cell</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="mapping__fe__field_8h_source.html">deal.II/fe/mapping_fe_field.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for MappingFEField&lt; dim, spacedim, VectorType, void &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4__inherit__graph.svg" width="191" height="216"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4_1_1InternalData.html">InternalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2aac9318f1f370711efc55e2f299c0ff"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a2aac9318f1f370711efc55e2f299c0ff">MappingFEField</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ade0b4f48538986bb8834d9b9f0427bd2">euler_dof_handler</a>, const <a class="el" href="classVectorType.html">VectorType</a> &amp;<a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3c281acbb6fe69834cb997c15e85d3cd">euler_vector</a>, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a2aac9318f1f370711efc55e2f299c0ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae07b23e7ae32b26d19d16822ba2202c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ae07b23e7ae32b26d19d16822ba2202c3">MappingFEField</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ade0b4f48538986bb8834d9b9f0427bd2">euler_dof_handler</a>, const std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;<a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3c281acbb6fe69834cb997c15e85d3cd">euler_vector</a>, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ae07b23e7ae32b26d19d16822ba2202c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f6dfe3a66514f99e5a76ea90ba41e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a69f6dfe3a66514f99e5a76ea90ba41e3">MappingFEField</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;<a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ade0b4f48538986bb8834d9b9f0427bd2">euler_dof_handler</a>, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;<a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3c281acbb6fe69834cb997c15e85d3cd">euler_vector</a>, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a69f6dfe3a66514f99e5a76ea90ba41e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0be8698d4e0b8ae38498b047562d169c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a0be8698d4e0b8ae38498b047562d169c">MappingFEField</a> (const <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt; &amp;mapping)</td></tr>
<tr class="separator:a0be8698d4e0b8ae38498b047562d169c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2b823d047182108edd0246e59ba1a7"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#afb2b823d047182108edd0246e59ba1a7">clone</a> () const override</td></tr>
<tr class="separator:afb2b823d047182108edd0246e59ba1a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4890f33ce8c5c45a6f619bbd7858da3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ae4890f33ce8c5c45a6f619bbd7858da3">preserves_vertex_locations</a> () const override</td></tr>
<tr class="separator:ae4890f33ce8c5c45a6f619bbd7858da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455bc293caaf0b182cf402d7d149a967"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a455bc293caaf0b182cf402d7d149a967">is_compatible_with</a> (const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;reference_cell) const override</td></tr>
<tr class="separator:a455bc293caaf0b182cf402d7d149a967"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebec7a7f973f793d1299dbe6f7d877c"><td class="memItemLeft" align="right" valign="top">virtual boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6ebec7a7f973f793d1299dbe6f7d877c">get_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const override</td></tr>
<tr class="separator:a6ebec7a7f973f793d1299dbe6f7d877c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea6995c5361d9447596692ee5f2b5520"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#aea6995c5361d9447596692ee5f2b5520">get_degree</a> () const</td></tr>
<tr class="separator:aea6995c5361d9447596692ee5f2b5520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce02667a49bcb0b4279f8e30f872140"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6ce02667a49bcb0b4279f8e30f872140">get_component_mask</a> () const</td></tr>
<tr class="separator:a6ce02667a49bcb0b4279f8e30f872140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd38d2a51c69acee66d3f9772793b14e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#acd38d2a51c69acee66d3f9772793b14e">DeclException0</a> (ExcInactiveCell)</td></tr>
<tr class="separator:acd38d2a51c69acee66d3f9772793b14e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8ba9b759a4fa93259ab6c4d9c2d3d74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#af8ba9b759a4fa93259ab6c4d9c2d3d74">get_center</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classbool.html">bool</a> map_center_of_reference_cell=true) const</td></tr>
<tr class="separator:af8ba9b759a4fa93259ab6c4d9c2d3d74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf83c098abdb6607178efdb62af91ac0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#adf83c098abdb6607178efdb62af91ac0">get_bounding_box</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:adf83c098abdb6607178efdb62af91ac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapping points between reference and real cells</div></td></tr>
<tr class="memitem:acd27d688c61d6719bb902b8405fa62d1"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#acd27d688c61d6719bb902b8405fa62d1">transform_unit_to_real_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const override</td></tr>
<tr class="separator:acd27d688c61d6719bb902b8405fa62d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94985e3815456d79b48b211ff8ac0bb5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a94985e3815456d79b48b211ff8ac0bb5">transform_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const override</td></tr>
<tr class="separator:a94985e3815456d79b48b211ff8ac0bb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions to transform tensors from reference to real coordinates</div></td></tr>
<tr class="memitem:a5b63fc7b79396fd7183faeac076c6542"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a5b63fc7b79396fd7183faeac076c6542"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d0116e92fd0d46050a9778be4784b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#af4d0116e92fd0d46050a9778be4784b7">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:af4d0116e92fd0d46050a9778be4784b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b8a16e75a86ef434897ad4a61f92bd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#af7b8a16e75a86ef434897ad4a61f92bd">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:af7b8a16e75a86ef434897ad4a61f92bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fd27cb5d3a85b1398c7370759b808e2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6fd27cb5d3a85b1398c7370759b808e2">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a6fd27cb5d3a85b1398c7370759b808e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a663b249b38077cd745b9abcf364d67"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1a663b249b38077cd745b9abcf364d67">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const override</td></tr>
<tr class="separator:a1a663b249b38077cd745b9abcf364d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mapping points between reference and real cells</div></td></tr>
<tr class="memitem:a20dfb5b4ff276093c6fb9957c6fcc6b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a20dfb5b4ff276093c6fb9957c6fcc6b2">transform_points_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;real_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;unit_points) const</td></tr>
<tr class="separator:a20dfb5b4ff276093c6fb9957c6fcc6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca0e49bd04f5f52ad9a481367706c985"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aca0e49bd04f5f52ad9a481367706c985">project_real_point_to_unit_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:aca0e49bd04f5f52ad9a481367706c985"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Exceptions</div></td></tr>
<tr class="memitem:a72122ff6ee588e788415f3124c48bb0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a72122ff6ee588e788415f3124c48bb0d">DeclException0</a> (ExcInvalidData)</td></tr>
<tr class="separator:a72122ff6ee588e788415f3124c48bb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5086637353e09ce6fb8d84f81be8affa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5086637353e09ce6fb8d84f81be8affa">DeclExceptionMsg</a> (ExcTransformationFailed, &quot;Computing the mapping between a real space point and a point in reference &quot; &quot;space failed, typically because the given point lies outside the cell &quot; &quot;where the inverse mapping is not unique.&quot;)</td></tr>
<tr class="separator:ga5086637353e09ce6fb8d84f81be8affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga142dcb2a567c72d6cc2607070cd56a83">DeclException3</a> (ExcDistortedMappedCell, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The image of the mapping applied to cell with <a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> [&quot;&lt;&lt; arg1&lt;&lt; &quot;] is distorted. The cell geometry or the &quot;&lt;&lt; &quot;mapping are invalid, giving a non-positive volume &quot;&lt;&lt; &quot;fraction of &quot;&lt;&lt; arg2&lt;&lt; &quot; in quadrature point &quot;&lt;&lt; arg3&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Interface with FEValues</div></td></tr>
<tr class="memitem:a85e75b674cebc41831eac23a44732fcf"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a85e75b674cebc41831eac23a44732fcf">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:a85e75b674cebc41831eac23a44732fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69cb4dd66dd3745b483f4703cb1fb69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:ac69cb4dd66dd3745b483f4703cb1fb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baf527d46a7f2391dbb3dd5dc416864"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a9baf527d46a7f2391dbb3dd5dc416864">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a9baf527d46a7f2391dbb3dd5dc416864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aa51c964b1e51b69db3f4933b97bff8c8">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f6025bc3f10e8f7da2c8a68eaff4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a9f7f6025bc3f10e8f7da2c8a68eaff4a">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:a9f7f6025bc3f10e8f7da2c8a68eaff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:add203f2ce20fc8a6aad82e80d3825788"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#add203f2ce20fc8a6aad82e80d3825788">do_transform_unit_to_real_cell</a> (const InternalData &amp;mdata) const</td></tr>
<tr class="separator:add203f2ce20fc8a6aad82e80d3825788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6604164b04e8fdf53f67187d1d3af66b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6604164b04e8fdf53f67187d1d3af66b">do_transform_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;initial_p_unit, InternalData &amp;mdata) const</td></tr>
<tr class="separator:a6604164b04e8fdf53f67187d1d3af66b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1c82c515734dab588884ec2d5d336a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ac1c82c515734dab588884ec2d5d336a0">update_internal_dofs</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const typename <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::InternalData &amp;data) const</td></tr>
<tr class="separator:ac1c82c515734dab588884ec2d5d336a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a747551b81dc26237d1a1f8ac339119ed"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a747551b81dc26237d1a1f8ac339119ed">compute_shapes_virtual</a> (const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;unit_points, typename <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::InternalData &amp;data) const</td></tr>
<tr class="separator:a747551b81dc26237d1a1f8ac339119ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb6f4a7b36bcd85b4abd4074e2d32e69"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#aeb6f4a7b36bcd85b4abd4074e2d32e69">compute_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const unsigned <a class="el" href="classint.html">int</a> n_original_q_points, InternalData &amp;data) const</td></tr>
<tr class="separator:aeb6f4a7b36bcd85b4abd4074e2d32e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43b886e222124466e80daed7be18e8e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a43b886e222124466e80daed7be18e8e6">compute_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const unsigned <a class="el" href="classint.html">int</a> n_original_q_points, InternalData &amp;data) const</td></tr>
<tr class="separator:a43b886e222124466e80daed7be18e8e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interface with FEValues</div></td></tr>
<tr class="memitem:af4b3f80410cfda8ba053af5c477d1ed5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#af4b3f80410cfda8ba053af5c477d1ed5">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const override</td></tr>
<tr class="separator:af4b3f80410cfda8ba053af5c477d1ed5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23e78efa4528e975803e66ff3922e2b8"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a23e78efa4528e975803e66ff3922e2b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1808495923cb8417fc41f7906784ac34"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a1808495923cb8417fc41f7906784ac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68bca44deed0136f2febd3fc7483b516"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a68bca44deed0136f2febd3fc7483b516">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const override</td></tr>
<tr class="separator:a68bca44deed0136f2febd3fc7483b516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f2177161a38be46c6ac112c01a51575"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a3f2177161a38be46c6ac112c01a51575"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a03e47057d9f0ab498cdb71bb20001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a46a03e47057d9f0ab498cdb71bb20001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a8ac55ec9d7987514ea7befcbb0d08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const override</td></tr>
<tr class="separator:a29a8ac55ec9d7987514ea7befcbb0d08"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a43fc097320021ebf5373bb1a98a70d13"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a43fc097320021ebf5373bb1a98a70d13">uses_level_dofs</a></td></tr>
<tr class="separator:a43fc097320021ebf5373bb1a98a70d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c281acbb6fe69834cb997c15e85d3cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classVectorType.html">VectorType</a>, <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3c281acbb6fe69834cb997c15e85d3cd">euler_vector</a></td></tr>
<tr class="separator:a3c281acbb6fe69834cb997c15e85d3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade0b4f48538986bb8834d9b9f0427bd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;, <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ade0b4f48538986bb8834d9b9f0427bd2">euler_dof_handler</a></td></tr>
<tr class="separator:ade0b4f48538986bb8834d9b9f0427bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90a280db7ed570fddfb8387abd8b668"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classComponentMask.html">ComponentMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ac90a280db7ed570fddfb8387abd8b668">fe_mask</a></td></tr>
<tr class="separator:ac90a280db7ed570fddfb8387abd8b668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92bf155d1b9e4ebb4ad9a4d77f1ec888"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a92bf155d1b9e4ebb4ad9a4d77f1ec888">fe_to_real</a></td></tr>
<tr class="separator:a92bf155d1b9e4ebb4ad9a4d77f1ec888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc3ae1b6da4bf5d22e07f1f34f70fe20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#acc3ae1b6da4bf5d22e07f1f34f70fe20">fe_values</a></td></tr>
<tr class="separator:acc3ae1b6da4bf5d22e07f1f34f70fe20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7498c5e41e23ff3e88ec15cba2bb07f"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ad7498c5e41e23ff3e88ec15cba2bb07f">fe_values_mutex</a></td></tr>
<tr class="separator:ad7498c5e41e23ff3e88ec15cba2bb07f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac6ceb25349e7c6c63e822560818e9599"><td class="memTemplParams" colspan="2">template&lt;int , int , class , class &gt; </td></tr>
<tr class="memitem:ac6ceb25349e7c6c63e822560818e9599"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ac6ceb25349e7c6c63e822560818e9599">MappingFEField</a></td></tr>
<tr class="separator:ac6ceb25349e7c6c63e822560818e9599"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim, typename VectorType&gt;<br />
class MappingFEField&lt; dim, spacedim, VectorType, void &gt;</h3>

<p>The <a class="el" href="classMappingFEField.html">MappingFEField</a> is a generalization of the <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a> class, for arbitrary vector finite elements. The two main differences are that this class uses a vector of absolute positions instead of a vector of displacements, and it allows for arbitrary <a class="el" href="classFiniteElement.html">FiniteElement</a> types, instead of only <a class="el" href="classFE__Q.html">FE_Q</a>.</p>
<p>This class effectively decouples the topology from the geometry, by relegating all geometrical information to some components of a <a class="el" href="classFiniteElement.html">FiniteElement</a> vector field. The components that are used for the geometry can be arbitrarily selected at construction time.</p>
<p>The idea is to consider the <a class="el" href="classTriangulation.html">Triangulation</a> as a parameter configuration space, on which we construct an arbitrary geometrical mapping, using the instruments of the deal.II library: a vector of degrees of freedom, a <a class="el" href="classDoFHandler.html">DoFHandler</a> associated to the geometry of the problem and a <a class="el" href="classComponentMask.html">ComponentMask</a> that tells us which components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> to use for the mapping.</p>
<p>Typically, the <a class="el" href="classDoFHandler.html">DoFHandler</a> operates on a finite element that is constructed as a system element (<a class="el" href="classFESystem.html">FESystem()</a>) from continuous <a class="el" href="classFE__Q.html">FE_Q()</a> (for iso-parametric discretizations) or <a class="el" href="classFE__Bernstein.html">FE_Bernstein()</a> (for iso-geometric discretizations) objects. An example is shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classFE__Q.html">FE_Q&lt;dim,spacedim&gt;</a> feq(1);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classFESystem.html">FESystem&lt;dim,spacedim&gt;</a> fesystem(feq, spacedim);</div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim,spacedim&gt;</a> dhq(triangulation);</div><div class="line">dhq.distribute_dofs(fesystem);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classComponentMask.html">ComponentMask</a> mask(spacedim, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> eulerq(dhq.n_dofs());</div><div class="line"><span class="comment">// Fills the euler vector with information from the Triangulation</span></div><div class="line"><a class="code" href="namespaceVectorTools.html#afcb40e50d2fa4807762faefed206f5e3">VectorTools::get_position_vector</a>(dhq, eulerq, mask);</div><div class="line"><a class="code" href="classMappingFEField.html">MappingFEField&lt;dim,spacedim&gt;</a> map(dhq, eulerq, mask);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00128">128</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2aac9318f1f370711efc55e2f299c0ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aac9318f1f370711efc55e2f299c0ff">&#9670;&nbsp;</a></span>MappingFEField() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::<a class="el" href="classMappingFEField.html">MappingFEField</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>euler_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>euler_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. The first argument is a VectorType that specifies the transformation of the domain from the reference to the current configuration.</p>
<p>In general this class decouples geometry from topology, allowing users to define geometries which are only topologically equivalent to the underlying <a class="el" href="classTriangulation.html">Triangulation</a>, but which may otherwise be arbitrary. Differently from what happens in <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>, the <a class="el" href="classFiniteElement.html">FiniteElement</a> field which is passed to the constructor is interpreted as an absolute geometrical configuration, therefore one has to make sure that the euler_vector actually represents a valid geometry (i.e., one with no inverted cells, or with no zero-volume cells).</p>
<p>If the underlying <a class="el" href="classFiniteElement.html">FiniteElement</a> is a system of <a class="el" href="classFE__Q.html">FE_Q()</a>, and euler_vector is initialized using <a class="el" href="namespaceVectorTools.html#afcb40e50d2fa4807762faefed206f5e3">VectorTools::get_position_vector()</a>, then this class is in all respects identical to <a class="el" href="classMappingQ.html">MappingQ()</a>.</p>
<p>The optional <a class="el" href="classComponentMask.html">ComponentMask</a> argument can be used to specify what components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> to use for the geometrical transformation. If no mask is specified at construction time, then a default one is used, which makes this class works in the same way of <a class="el" href="classMappingQEulerian.html">MappingQEulerian()</a>, i.e., the first spacedim components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> are assumed to represent the geometry of the problem.</p>
<p>Notice that if a mask is specified, it has to match in size the underlying <a class="el" href="classFiniteElement.html">FiniteElement</a>, and it has to have exactly spacedim non-zero elements, indicating the components (in order) of the <a class="el" href="classFiniteElement.html">FiniteElement</a> which will be used for the geometry.</p>
<p>If an incompatible mask is passed, an exception is thrown. </p>

</div>
</div>
<a id="ae07b23e7ae32b26d19d16822ba2202c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae07b23e7ae32b26d19d16822ba2202c3">&#9670;&nbsp;</a></span>MappingFEField() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::<a class="el" href="classMappingFEField.html">MappingFEField</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>euler_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>euler_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor taking vectors on the multigrid levels rather than the active cells only. The vector of vectors is expected to have as many entries as there are global levels in the triangulation and provide valid data on each level, i.e., be of compatible length DoFHandler::n_dofs(level). A prerequisite of this constructor is that <a class="el" href="classDoFHandler.html#a9aed31323cbd7619edac310c47e7a7ad">DoFHandler::distribute_mg_dofs()</a> has been called. Apart from the level vectors, the same arguments as in the other constructor need to be provided. </p>

</div>
</div>
<a id="a69f6dfe3a66514f99e5a76ea90ba41e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69f6dfe3a66514f99e5a76ea90ba41e3">&#9670;&nbsp;</a></span>MappingFEField() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::<a class="el" href="classMappingFEField.html">MappingFEField</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>euler_dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>euler_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor with <a class="el" href="classMGLevelObject.html">MGLevelObject</a> instead of std::vector, otherwise the same as above. It is required that <code>euler_vector.max_level()+1</code> equals the global number of levels in the triangulation. The minimum level may be zero or more &mdash; it only needs to be consistent between what is set here and later used for evaluation of the mapping. </p>

</div>
</div>
<a id="a0be8698d4e0b8ae38498b047562d169c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0be8698d4e0b8ae38498b047562d169c">&#9670;&nbsp;</a></span>MappingFEField() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::<a class="el" href="classMappingFEField.html">MappingFEField</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afb2b823d047182108edd0246e59ba1a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2b823d047182108edd0246e59ba1a7">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to a copy of the present object. The caller of this copy then assumes ownership of it. </p>

<p>Implements <a class="el" href="classMapping.html#aefbf70ea6f93dba57ac3fa7eb2e51992">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ae4890f33ce8c5c45a6f619bbd7858da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4890f33ce8c5c45a6f619bbd7858da3">&#9670;&nbsp;</a></span>preserves_vertex_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::preserves_vertex_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See the documentation of <a class="el" href="classMapping.html#accdebb05aa5f08dda54941868ce9fbe8">Mapping::preserves_vertex_locations()</a> for the purpose of this function. The implementation in this class always returns <code>false</code>. </p>

<p>Implements <a class="el" href="classMapping.html#accdebb05aa5f08dda54941868ce9fbe8">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a455bc293caaf0b182cf402d7d149a967"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455bc293caaf0b182cf402d7d149a967">&#9670;&nbsp;</a></span>is_compatible_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::is_compatible_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;&#160;</td>
          <td class="paramname"><em>reference_cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns if this instance of <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> is compatible with the type of cell in <code>reference_cell</code>. </p>

<p>Implements <a class="el" href="classMapping.html#a0d8ac8be12bd87c4e7f529778ec317de">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6ebec7a7f973f793d1299dbe6f7d877c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ebec7a7f973f793d1299dbe6f7d877c">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual boost::container::small_vector&lt;<a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_cell&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mapped vertices of a cell.</p>
<p>This mapping ignores the vertices of the <a class="el" href="classTriangulation.html">Triangulation</a> it is associated to, and constructs the position of the vertices according to the <code>euler_vector</code> that was passed at construction time. </p>

<p>Reimplemented from <a class="el" href="classMapping.html#ac4cabb5f6791b258e04f44e50f554a06">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="acd27d688c61d6719bb902b8405fa62d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd27d688c61d6719bb902b8405fa62d1">&#9670;&nbsp;</a></span>transform_unit_to_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform_unit_to_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the point <code>p</code> on the unit cell to the corresponding point on the real cell <code>cell</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Iterator to the cell that will be used to define the mapping. </td></tr>
    <tr><td class="paramname">p</td><td>Location of a point on the reference cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The location of the reference point mapped to real space using the mapping defined by the class derived from the current one that implements the mapping, and the coordinates of the cell identified by the first argument. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#ae5df63553eb8ed170c3b90524853dd48">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a94985e3815456d79b48b211ff8ac0bb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94985e3815456d79b48b211ff8ac0bb5">&#9670;&nbsp;</a></span>transform_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map the point <code>p</code> on the real <code>cell</code> to the corresponding point on the unit cell, and return its coordinates. This function provides the inverse of the mapping provided by <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#acd27d688c61d6719bb902b8405fa62d1">transform_unit_to_real_cell()</a>.</p>
<p>In the codimension one case, this function returns the normal projection of the real point <code>p</code> on the curve or surface identified by the <code>cell</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Polynomial mappings from the reference (unit) cell coordinates to the coordinate system of a real cell are not always invertible if the point for which the inverse mapping is to be computed lies outside the cell's boundaries. In such cases, the current function may fail to compute a point on the reference cell whose image under the mapping equals the given point <code>p</code>. If this is the case then this function throws an exception of type Mapping::ExcTransformationFailed . Whether the given point <code>p</code> lies outside the cell can therefore be determined by checking whether the returned reference coordinates lie inside or outside the reference cell (e.g., using <a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">GeometryInfo::is_inside_unit_cell()</a>) or whether the exception mentioned above has been thrown.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>Iterator to the cell that will be used to define the mapping. </td></tr>
    <tr><td class="paramname">p</td><td>Location of a point on the given cell. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The reference cell location of the point that when mapped to real space equals the coordinates given by the second argument. This mapping uses the mapping defined by the class derived from the current one that implements the mapping, and the coordinates of the cell identified by the first argument. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5b63fc7b79396fd7183faeac076c6542"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b63fc7b79396fd7183faeac076c6542">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a field of vectors or 1-differential forms according to the selected MappingKind.</p>
<dl class="section note"><dt>Note</dt><dd>Normally, this function is called by a finite element, filling <a class="el" href="classFEValues.html">FEValues</a> objects. For this finite element, there should be an alias MappingKind like <code>mapping_bdm</code>, <code>mapping_nedelec</code>, etc. This alias should be preferred to using the kinds below.</dd></dl>
<p>The mapping kinds currently implemented by derived classes are: </p><ul>
<li>
<p class="startli"><code>mapping_contravariant:</code> maps a vector field on the reference cell to the physical cell through the Jacobian: </p><p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
<p> In physics, this is usually referred to as the contravariant transformation. Mathematically, it is the push forward of a vector field.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>mapping_covariant:</code> maps a field of one-forms on the reference cell to a field of one-forms on the physical cell. (Theoretically this would refer to a DerivativeForm&lt;1,dim,1&gt; but we canonically identify this type with a <a class="el" href="classTensor.html">Tensor&lt;1,dim&gt;</a>). Mathematically, it is the pull back of the differential form </p><p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
<p> Gradients of scalar differentiable functions are transformed this way.</p>
<p>In the case when dim=spacedim the previous formula reduces to </p><p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})^{-T}\hat{\mathbf u}(\hat{\mathbf x}) \]
</p>
<p> because we assume that the mapping \(\mathbf F_K\) is always invertible, and consequently its Jacobian \(J\) is an invertible matrix.</p>
<p class="endli"></p>
</li>
<li>
<code>mapping_piola:</code> A field of <em>dim-1</em>-forms on the reference cell is also represented by a vector field, but again transforms differently, namely by the Piola transform <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a68bca44deed0136f2febd3fc7483b516">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af4d0116e92fd0d46050a9778be4784b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d0116e92fd0d46050a9778be4784b7">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a field of differential forms from the reference cell to the physical cell. It is useful to think of \(\mathbf{T} = \nabla \mathbf u\) and \(\hat{\mathbf T} = \hat \nabla \hat{\mathbf u}\), with \(\mathbf u\) a vector field. The mapping kinds currently implemented by derived classes are: </p><ul>
<li>
<p class="startli"><code>mapping_covariant:</code> maps a field of forms on the reference cell to a field of forms on the physical cell. Mathematically, it is the pull back of the differential form </p><p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
<p> Jacobians of spacedim-vector valued differentiable functions are transformed this way.</p>
<p class="endli">In the case when dim=spacedim the previous formula reduces to </p><p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf u}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<dl class="section note"><dt>Note</dt><dd>It would have been more reasonable to make this transform a template function with the rank in <code><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, rank&gt;</code>. Unfortunately C++ does not allow templatized virtual functions. This is why we identify <code><a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt;1, dim, 1&gt;</code> with a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> when using <a class="el" href="group__mapping.html#ggac6eaf900d562c52002dbccc6bdd89275a35d1e9fba325e2d103c1fea732fc05b1">mapping_covariant()</a> in the function <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> above this one.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a68bca44deed0136f2febd3fc7483b516">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a871f491f3d06fda8a30157c8c2b6ae08">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af7b8a16e75a86ef434897ad4a61f92bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b8a16e75a86ef434897ad4a61f92bd">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a tensor field from the reference cell to the physical cell. These tensors are usually the Jacobians in the reference cell of vector fields that have been pulled back from the physical cell. The mapping kinds currently implemented by derived classes are: </p><ul>
<li>
<code>mapping_contravariant_gradient:</code> it assumes \(\mathbf u(\mathbf x) = J \hat{\mathbf u}\) so that <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_gradient:</code> it assumes \(\mathbf u(\mathbf x) = J^{-T} \hat{\mathbf u}\) so that <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x})^{-T} \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_gradient:</code> it assumes \(\mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) so that <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000023">Todo:</a></b></dt><dd>The formulas for mapping_covariant_gradient, mapping_contravariant_gradient and mapping_piola_gradient are only true as stated for linear mappings. If, for example, the mapping is bilinear (or has a higher order polynomial degree) then there is a missing term associated with the derivative of \(J\).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a68bca44deed0136f2febd3fc7483b516">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#ab22b7178a30a5ec26003ffc8fd02d8dd">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6fd27cb5d3a85b1398c7370759b808e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fd27cb5d3a85b1398c7370759b808e2">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a tensor field from the reference cell to the physical cell. This tensors are most of times the hessians in the reference cell of vector fields that have been pulled back from the physical cell.</p>
<p>The mapping kinds currently implemented by derived classes are: </p><ul>
<li>
<p class="startli"><code>mapping_covariant_gradient:</code> maps a field of forms on the reference cell to a field of forms on the physical cell. Mathematically, it is the pull back of the differential form </p><p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \hat{\mathbf T}_{iJK}(\hat{\mathbf x}) J_{jJ}^{\dagger} J_{kK}^{\dagger}\]
</p>
<p>,</p>
<p class="endli">where </p><p class="formulaDsp">
\[ J^{\dagger} = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
 </li>
</ul>
<p>Hessians of spacedim-vector valued differentiable functions are transformed this way (After subtraction of the product of the derivative with the Jacobian gradient).</p>
<p>In the case when dim=spacedim the previous formula reduces to </p><p class="formulaDsp">
\[J^{\dagger} = J^{-1}\]
</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a68bca44deed0136f2febd3fc7483b516">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. (Note that the array view is <code>const</code>, but the tensors it points to are not.) </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#abe09058f596dbda03936270390f3d2e4">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1a663b249b38077cd745b9abcf364d67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a663b249b38077cd745b9abcf364d67">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a field of 3-differential forms from the reference cell to the physical cell. It is useful to think of \(\mathbf{T}_{ijk} = D^2_{jk} \mathbf u_i\) and \(\mathbf{\hat T}_{IJK} = \hat D^2_{JK} \mathbf{\hat u}_I\), with \(\mathbf u_i\) a vector field.</p>
<p>The mapping kinds currently implemented by derived classes are: </p><ul>
<li>
<code>mapping_contravariant_hessian:</code> it assumes \(\mathbf u_i(\mathbf x) = J_{iI} \hat{\mathbf u}_I\) so that <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_hessian:</code> it assumes \(\mathbf u_i(\mathbf x) = J_{iI}^{-T} \hat{\mathbf u}_I\) so that <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_iI(\hat{\mathbf x})^{-1} \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_hessian:</code> it assumes \(\mathbf u_i(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) so that <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>An array (or part of an array) of input objects that should be mapped. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>The kind of mapping to be applied. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>A pointer to an object of type <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> that contains information previously stored by the mapping. The object pointed to was created by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a68bca44deed0136f2febd3fc7483b516">get_subface_data()</a> function, and will have been updated as part of a call to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a>, or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> for the current cell, before calling the current function. In other words, this object also represents with respect to which cell the transformation should be applied to. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>An array (or part of an array) into which the transformed objects should be placed. </td></tr>
  </table>
  </dd>
</dl>

<p>Implements <a class="el" href="classMapping.html#a38deb68a3d62e46bababbcb10bc928d8">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aea6995c5361d9447596692ee5f2b5520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea6995c5361d9447596692ee5f2b5520">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::get_degree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the degree of the mapping, i.e. the value which was passed to the constructor. </p>

</div>
</div>
<a id="a6ce02667a49bcb0b4279f8e30f872140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce02667a49bcb0b4279f8e30f872140">&#9670;&nbsp;</a></span>get_component_mask()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::get_component_mask </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <a class="el" href="classComponentMask.html">ComponentMask</a> of the mapping, i.e. which components to use for the mapping. </p>

</div>
</div>
<a id="acd38d2a51c69acee66d3f9772793b14e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd38d2a51c69acee66d3f9772793b14e">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInactiveCell&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="af4b3f80410cfda8ba053af5c477d1ed5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b3f80410cfda8ba053af5c477d1ed5">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a set of update flags, compute which other quantities <em>also</em> need to be computed in order to satisfy the request by the given flags. Then return the combination of the original set of flags and those just computed.</p>
<p>As an example, if <code>update_flags</code> contains update_JxW_values (i.e., the product of the determinant of the Jacobian and the weights provided by the quadrature formula), a mapping may require the computation of the full Jacobian matrix in order to compute its determinant. They would then return not just update_JxW_values, but also update_jacobians. (This is not how it is actually done internally in the derived classes that compute the JxW values &ndash; they set update_contravariant_transformation instead, from which the determinant can also be computed &ndash; but this does not take away from the instructiveness of the example.)</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a4c62b5a55ca40e2b38c6a3a1f460d540">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a23e78efa4528e975803e66ff3922e2b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e78efa4528e975803e66ff3922e2b8">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create and return a pointer to an object into which mappings can store data that only needs to be computed once but that can then be used whenever the mapping is applied to a concrete cell (e.g., in the various <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> functions, as well as in the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a> and <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> that form the interface of mappings with the <a class="el" href="classFEValues.html">FEValues</a> class).</p>
<p>Derived classes will return pointers to objects of a type derived from <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> (see there for more information) and may pre- compute some information already (in accordance with what will be asked of the mapping in the future, as specified by the update flags) and for the given quadrature object. Subsequent calls to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a> and friends will then receive back the object created here (with the same set of update flags and for the same quadrature object). Derived classes can therefore pre-compute some information in their <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a> function and store it in the internal data object.</p>
<p>The mapping classes do not keep track of the objects created by this function. Ownership will therefore rest with the caller.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>A set of flags that define what is expected of the mapping class in future calls to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> or the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a> group of functions. This set of flags may contain flags that mappings do not know how to deal with (e.g., for information that is in fact computed by the finite element classes, such as UpdateFlags::update_values). Derived classes will need to store these flags, or at least that subset of flags that will require the mapping to perform any actions in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, in InternalDataBase::update_each. </td></tr>
    <tr><td class="paramname">quadrature</td><td>The quadrature object for which mapping information will have to be computed. This includes the locations and weights of quadrature points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly created object of type InternalDataBase (or a derived class). Ownership of this object passes to the calling function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++ allows that virtual functions in derived classes may return pointers to objects not of type InternalDataBase but in fact pointers to objects of classes <em>derived</em> from InternalDataBase. (This feature is called "covariant return types".) This is useful in some contexts where the calling is within the derived class and will immediately make use of the returned object, knowing its real (derived) type. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a1808495923cb8417fc41f7906784ac34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1808495923cb8417fc41f7906784ac34">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a>, but in preparation for later calls to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a46a03e47057d9f0ab498cdb71bb20001">fill_fe_face_values()</a> that will need information about mappings from the reference face to a face of a concrete cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>A set of flags that define what is expected of the mapping class in future calls to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> or the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a> group of functions. This set of flags may contain flags that mappings do not know how to deal with (e.g., for information that is in fact computed by the finite element classes, such as UpdateFlags::update_values). Derived classes will need to store these flags, or at least that subset of flags that will require the mapping to perform any actions in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, in InternalDataBase::update_each. </td></tr>
    <tr><td class="paramname">quadrature</td><td>The quadrature object for which mapping information will have to be computed. This includes the locations and weights of quadrature points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly created object of type InternalDataBase (or a derived class). Ownership of this object passes to the calling function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++ allows that virtual functions in derived classes may return pointers to objects not of type InternalDataBase but in fact pointers to objects of classes <em>derived</em> from InternalDataBase. (This feature is called "covariant return types".) This is useful in some contexts where the calling is within the derived class and will immediately make use of the returned object, knowing its real (derived) type. </dd></dl>

<p>Reimplemented from <a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a68bca44deed0136f2febd3fc7483b516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68bca44deed0136f2febd3fc7483b516">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;typename <a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Like <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a> and <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a1808495923cb8417fc41f7906784ac34">get_face_data()</a>, but in preparation for later calls to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> or <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a29a8ac55ec9d7987514ea7befcbb0d08">fill_fe_subface_values()</a> that will need information about mappings from the reference face to a child of a face (i.e., subface) of a concrete cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>A set of flags that define what is expected of the mapping class in future calls to <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b63fc7b79396fd7183faeac076c6542">transform()</a> or the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a> group of functions. This set of flags may contain flags that mappings do not know how to deal with (e.g., for information that is in fact computed by the finite element classes, such as UpdateFlags::update_values). Derived classes will need to store these flags, or at least that subset of flags that will require the mapping to perform any actions in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3f2177161a38be46c6ac112c01a51575">fill_fe_values()</a>, in InternalDataBase::update_each. </td></tr>
    <tr><td class="paramname">quadrature</td><td>The quadrature object for which mapping information will have to be computed. This includes the locations and weights of quadrature points. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to a newly created object of type InternalDataBase (or a derived class). Ownership of this object passes to the calling function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++ allows that virtual functions in derived classes may return pointers to objects not of type InternalDataBase but in fact pointers to objects of classes <em>derived</em> from InternalDataBase. (This feature is called "covariant return types".) This is useful in some contexts where the calling is within the derived class and will immediately make use of the returned object, knowing its real (derived) type. </dd></dl>

<p>Implements <a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">Mapping&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a3f2177161a38be46c6ac112c01a51575"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f2177161a38be46c6ac112c01a51575">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a46a03e47057d9f0ab498cdb71bb20001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a03e47057d9f0ab498cdb71bb20001">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a29a8ac55ec9d7987514ea7befcbb0d08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a8ac55ec9d7987514ea7befcbb0d08">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="add203f2ce20fc8a6aad82e80d3825788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add203f2ce20fc8a6aad82e80d3825788">&#9670;&nbsp;</a></span>do_transform_unit_to_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::do_transform_unit_to_real_cell </td>
          <td>(</td>
          <td class="paramtype">const InternalData &amp;&#160;</td>
          <td class="paramname"><em>mdata</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform a point <code>p</code> on the unit cell to the point <code>p_real</code> on the real cell <code>cell</code> and returns <code>p_real</code>.</p>
<p>This function is called by <code>transform_unit_to_real_cell</code> and multiple times (through the Newton iteration) by <code>transform_real_to_unit_cell_internal</code>.</p>
<p>Takes a reference to an <code><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4_1_1InternalData.html">InternalData</a></code> that must already include the shape values at point <code>p</code> and the mapping support points of the cell.</p>
<p>This <code><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4_1_1InternalData.html">InternalData</a></code> argument avoids multiple computations of the shape values at point <code>p</code> and especially multiple computations of the mapping support points. </p>

</div>
</div>
<a id="a6604164b04e8fdf53f67187d1d3af66b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6604164b04e8fdf53f67187d1d3af66b">&#9670;&nbsp;</a></span>do_transform_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::do_transform_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>initial_p_unit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalData &amp;&#160;</td>
          <td class="paramname"><em>mdata</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform the point <code>p</code> on the real cell to the corresponding point on the unit cell <code>cell</code> by a Newton iteration.</p>
<p>Takes a reference to an <code><a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4_1_1InternalData.html">InternalData</a></code> that is assumed to be previously created by the <code>get_data</code> function with <code>UpdateFlags</code> including <code>update_transformation_values</code> and <code>update_transformation_gradients</code> and a one point <a class="el" href="classQuadrature.html">Quadrature</a> that includes the given initial guess for the transformation <code>initial_p_unit</code>. Hence this function assumes that <code>mdata</code> already includes the transformation shape values and gradients computed at <code>initial_p_unit</code>.</p>
<p><code>mdata</code> will be changed by this function. </p>

</div>
</div>
<a id="ac1c82c515734dab588884ec2d5d336a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1c82c515734dab588884ec2d5d336a0">&#9670;&nbsp;</a></span>update_internal_dofs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::update_internal_dofs </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::InternalData &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update internal degrees of freedom. </p>

</div>
</div>
<a id="a747551b81dc26237d1a1f8ac339119ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a747551b81dc26237d1a1f8ac339119ed">&#9670;&nbsp;</a></span>compute_shapes_virtual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::compute_shapes_virtual </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::InternalData &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>See the documentation of the base class for detailed information. </p>

</div>
</div>
<a id="aeb6f4a7b36bcd85b4abd4074e2d32e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb6f4a7b36bcd85b4abd4074e2d32e69">&#9670;&nbsp;</a></span>compute_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::compute_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_original_q_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalData &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a43b886e222124466e80daed7be18e8e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b886e222124466e80daed7be18e8e6">&#9670;&nbsp;</a></span>compute_face_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::compute_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_original_q_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InternalData &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af8ba9b759a4fa93259ab6c4d9c2d3d74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8ba9b759a4fa93259ab6c4d9c2d3d74">&#9670;&nbsp;</a></span>get_center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_center </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>map_center_of_reference_cell</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the mapped center of a cell.</p>
<p>If you are using a (bi-,tri-)linear mapping that preserves vertex locations, this function simply returns the value also produced by <code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code>. However, there are also mappings that add displacements or choose completely different locations, e.g., <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>, <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a>, or <a class="el" href="classMappingFEField.html">MappingFEField</a>, and mappings based on high order polynomials, for which the center may not coincide with the average of the vertex locations.</p>
<p>By default, this function returns the push forward of the center of the reference cell. If the parameter <code>map_center_of_reference_cell</code> is set to false, than the return value will be the average of the vertex locations, as returned by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6ebec7a7f973f793d1299dbe6f7d877c">get_vertices()</a> method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell for which you want to compute the center </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_center_of_reference_cell</td><td>A flag that switches the algorithm for the computation of the cell center from <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#acd27d688c61d6719bb902b8405fa62d1">transform_unit_to_real_cell()</a> applied to the center of the reference cell to computing the vertex averages. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf83c098abdb6607178efdb62af91ac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf83c098abdb6607178efdb62af91ac0">&#9670;&nbsp;</a></span>get_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt;spacedim&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the bounding box of a mapped cell.</p>
<p>If you are using a (bi-,tri-)linear mapping that preserves vertex locations, this function simply returns the value also produced by <code>cell-&gt;bounding_box()</code>. However, there are also mappings that add displacements or choose completely different locations, e.g., <a class="el" href="classMappingQEulerian.html">MappingQEulerian</a>, <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a>, or <a class="el" href="classMappingFEField.html">MappingFEField</a>.</p>
<p>For linear mappings, this function returns the bounding box containing all the vertices of the cell, as returned by the <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6ebec7a7f973f793d1299dbe6f7d877c">get_vertices()</a> method. For higher order mappings defined through support points, the bounding box is only guaranteed to contain all the support points, and it is, in general, only an approximation of the true bounding box, which may be larger.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell for which you want to compute the bounding box </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#abf5f5dbae84e98b22f4c308ab32ac2fc">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQEulerian.html#a4e2ea8f7d71d690684f4a64e8e45229e">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a75a4cafb981e1ac5771ee8923e895000">MappingQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingFE.html#ae2c43285043e2a581b280938f36ec7b5">MappingFE&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a20dfb5b4ff276093c6fb9957c6fcc6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20dfb5b4ff276093c6fb9957c6fcc6b2">&#9670;&nbsp;</a></span>transform_points_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform_points_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>real_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Map multiple points from the real point locations to points in reference locations. The functionality is essentially the same as looping over all points and calling the <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a> function for each point individually, but it can be much faster for certain mappings that implement a more specialized version such as <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>. The only difference in behavior is that this function will never throw an ExcTransformationFailed() exception. If the transformation fails for <code>real_points[i]</code>, the returned <code>unit_points[i]</code> contains std::numeric_limits&lt;double&gt;::infinity() as the first entry. </p>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#a2c55652165dcdd09feb57238258e3530">MappingQGeneric&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aca0e49bd04f5f52ad9a481367706c985"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca0e49bd04f5f52ad9a481367706c985">&#9670;&nbsp;</a></span>project_real_point_to_unit_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;dim - 1&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::project_real_point_to_unit_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transform the point <code>p</code> on the real <code>cell</code> to the corresponding point on the reference cell, and then project this point to a (dim-1)-dimensional point in the coordinate system of the face with the given face number <code>face_no</code>. Ideally the point <code>p</code> is near the face <code>face_no</code>, but any point in the cell can technically be projected.</p>
<p>This function does not make physical sense when dim=1, so it throws an exception in this case. </p>

</div>
</div>
<a id="a72122ff6ee588e788415f3124c48bb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72122ff6ee588e788415f3124c48bb0d">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidData&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a85e75b674cebc41831eac23a44732fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e75b674cebc41831eac23a44732fcf">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000028">Deprecated:</a></b></dt><dd>Use the version taking a <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> argument. </dd></dl>

</div>
</div>
<a id="ac69cb4dd66dd3745b483f4703cb1fb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69cb4dd66dd3745b483f4703cb1fb69">&#9670;&nbsp;</a></span>fill_fe_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute information about the mapping from the reference cell to the real cell indicated by the first argument to this function. Derived classes will have to implement this function based on the kind of mapping they represent. It is called by <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a>.</p>
<p>Conceptually, this function's represents the application of the mapping \(\mathbf x=\mathbf F_K(\hat {\mathbf x})\) from reference coordinates \(\mathbf\in [0,1]^d\) to real space coordinates \(\mathbf x\) for a given cell \(K\). Its purpose is to compute the following kinds of data:</p>
<ul>
<li>Data that results from the application of the mapping itself, e.g., computing the location \(\mathbf x_q = \mathbf F_K(\hat{\mathbf x}_q)\) of quadrature points on the real cell, and that is directly useful to users of <a class="el" href="classFEValues.html">FEValues</a>, for example during assembly.</li>
<li>Data that is necessary for finite element implementations to compute their shape functions on the real cell. To this end, the <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> function calls <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> after the current function, and the output of this function serves as input to <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. Examples of information that needs to be computed here for use by the finite element classes is the Jacobian of the mapping, \(\hat\nabla \mathbf F_K(\hat{\mathbf x})\) or its inverse, for example to transform the gradients of shape functions on the reference cell to the gradients of shape functions on the real cell.</li>
</ul>
<p>The information computed by this function is used to fill the various member variables of the output argument of this function. Which of the member variables of that structure should be filled is determined by the update flags stored in the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> object passed to this function.</p>
<p>An extensive discussion of the interaction between this function and <a class="el" href="classFEValues.html">FEValues</a> can be found in the <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and FEValues work together</a> documentation module.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>Whether or not the cell given as first argument is simply a translation, rotation, etc of the cell for which this function was called the most recent time. This information is computed simply by matching the vertices (as stored by the <a class="el" href="classTriangulation.html">Triangulation</a>) between the previous and the current cell. The value passed here may be modified by implementations of this function and should then be returned (see the discussion of the return value of this function). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The object is used both to map the location of quadrature points, as well as to compute the JxW values for each quadrature point (which involves the quadrature weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>A reference to an object previously created by <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>internal_data</code> object. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An updated value of the <code>cell_similarity</code> argument to this function. The returned value will be used for the corresponding argument when <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> calls <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. In most cases, derived classes will simply want to return the value passed for <code>cell_similarity</code>. However, implementations of this function may downgrade the level of cell similarity. This is, for example, the case for classes that take not only into account the locations of the vertices of a cell (as reported by the <a class="el" href="classTriangulation.html">Triangulation</a>), but also other information specific to the mapping. The purpose is that <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> can compute whether a cell is similar to the previous one only based on the cell's vertices, whereas the mapping may also consider displacement fields (e.g., in the <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a> and <a class="el" href="classMappingFEField.html">MappingFEField</a> classes). In such cases, the mapping may conclude that the previously computed cell similarity is too optimistic, and invalidate it for subsequent use in <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> by returning a less optimistic cell similarity value.</dd></dl>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classFEValues.html">FEValues</a> ensures that this function is always called with the same pair of <code>internal_data</code> and <code>output_data</code> objects. In other words, if an implementation of this function knows that it has written a piece of data into the output argument in a previous call, then there is no need to copy it there again in a later call if the implementation knows that this is the same value. </dd></dl>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#aaf9214b0965ab7fd09776390bbc285d5">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#aba7bf1413812893f040b089ade029fe5">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a50321c8317de6e2c15237fd5a26ce8f3">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9baf527d46a7f2391dbb3dd5dc416864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baf527d46a7f2391dbb3dd5dc416864">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, but for faces of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face of the given cell for which information is requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The object is used both to map the location of quadrature points, as well as to compute the JxW values for each quadrature point (which involves the quadrature weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>A reference to an object previously created by <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>internal_data</code> object. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#a6c41a25f46990d74e31bcf8c35eab283">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a03294c2ec4863998c728cf2da714b616">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a9d1b43a1d32c7408db2af571d68a98b1">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa51c964b1e51b69db3f4933b97bff8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c964b1e51b69db3f4933b97bff8c8">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000029">Deprecated:</a></b></dt><dd>Use the version taking a <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> argument. </dd></dl>

</div>
</div>
<a id="a9f7f6025bc3f10e8f7da2c8a68eaff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7f6025bc3f10e8f7da2c8a68eaff4a">&#9670;&nbsp;</a></span>fill_fe_subface_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is the equivalent to <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, but for subfaces (i.e., children of faces) of cells. See there for an extensive discussion of its purpose. It is called by <a class="el" href="classFESubfaceValues.html#a341778d1291f936d5192a39f2531472a">FESubfaceValues::reinit()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>The cell of the triangulation for which this function is to compute a mapping from the reference cell to. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>The number of the face of the given cell for which information is requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subface_no</td><td>The number of the child of a face of the given cell for which information is requested. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>A reference to the quadrature formula in use for the current evaluation. This quadrature object is the same as the one used when creating the <code>internal_data</code> object. The object is used both to map the location of quadrature points, as well as to compute the JxW values for each quadrature point (which involves the quadrature weights). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>A reference to an object previously created by <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a23e78efa4528e975803e66ff3922e2b8">get_data()</a> and that may be used to store information the mapping can compute once on the reference cell. See the documentation of the <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> class for an extensive description of the purpose of these objects. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>A reference to an object whose member variables should be computed. Not all of the members of this argument need to be filled; which ones need to be filled is determined by the update flags stored inside the <code>internal_data</code> object. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#a2a707e9b13deefd7eeebad152dd9698e">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a330ec34dc48d22e3b8e004aeb9717bde">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a899d901798c72c932e9b8653895fedae">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac6ceb25349e7c6c63e822560818e9599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6ceb25349e7c6c63e822560818e9599">&#9670;&nbsp;</a></span>MappingFEField</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<div class="memtemplate">
template&lt;int , int , class , class &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classMappingFEField.html">MappingFEField</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00707">707</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a43fc097320021ebf5373bb1a98a70d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fc097320021ebf5373bb1a98a70d13">&#9670;&nbsp;</a></span>uses_level_dofs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classbool.html">bool</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::uses_level_dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specifies whether we access unknowns on the active dofs (with a single Euler vector) or on the level dofs (via a vector of Euler vectors). </p>

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00590">590</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<a id="a3c281acbb6fe69834cb997c15e85d3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c281acbb6fe69834cb997c15e85d3cd">&#9670;&nbsp;</a></span>euler_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classVectorType.html">VectorType</a>, <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt;dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void&gt; &gt; &gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::euler_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reference to the vector of shifts. </p>

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00597">597</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<a id="ade0b4f48538986bb8834d9b9f0427bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade0b4f48538986bb8834d9b9f0427bd2">&#9670;&nbsp;</a></span>euler_dof_handler</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt;, <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt;dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void&gt; &gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::euler_dof_handler</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the <a class="el" href="classDoFHandler.html">DoFHandler</a> to which the mapping vector is associated. </p>

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00604">604</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<a id="ac90a280db7ed570fddfb8387abd8b668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90a280db7ed570fddfb8387abd8b668">&#9670;&nbsp;</a></span>fe_mask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classComponentMask.html">ComponentMask</a> <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fe_mask</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00668">668</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<a id="a92bf155d1b9e4ebb4ad9a4d77f1ec888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92bf155d1b9e4ebb4ad9a4d77f1ec888">&#9670;&nbsp;</a></span>fe_to_real</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fe_to_real</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> between indices in the FE space and the real space. This vector contains one index for each component of the finite element space. If the index is one for which the <a class="el" href="classComponentMask.html">ComponentMask</a> which is used to construct this element is false, then <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a> is returned, otherwise the component in real space is returned. For example, if we construct the mapping using <a class="el" href="classComponentMask.html">ComponentMask(spacedim, true)</a>, then this vector contains {0,1,2} in spacedim = 3. </p>

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00679">679</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<a id="acc3ae1b6da4bf5d22e07f1f34f70fe20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc3ae1b6da4bf5d22e07f1f34f70fe20">&#9670;&nbsp;</a></span>fe_values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFEValues.html">FEValues</a>&lt;dim, spacedim&gt; <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fe_values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classFEValues.html">FEValues</a> object used to query the given finite element field at the support points in the reference configuration. </p>

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00685">685</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<a id="ad7498c5e41e23ff3e88ec15cba2bb07f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7498c5e41e23ff3e88ec15cba2bb07f">&#9670;&nbsp;</a></span>fe_values_mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classMappingFEField.html">MappingFEField</a>&lt; dim, spacedim, <a class="el" href="classVectorType.html">VectorType</a>, void &gt;::fe_values_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A variable to guard access to the fe_values variable. </p>

<p class="definition">Definition at line <a class="el" href="mapping__fe__field_8h_source.html#l00690">690</a> of file <a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/fe/<a class="el" href="mapping__fe__field_8h_source.html">mapping_fe_field.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
