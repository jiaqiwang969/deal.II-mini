<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classMapping.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Mapping&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classMapping-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Mapping&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a> &raquo; <a class="el" href="group__mapping.html">Mappings between reference and real cell</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用FEValues、FEFaceValues和FESubfaceValues类所需的信息。这些接口的具体实现是在派生类中提供的。  
 <a href="classMapping.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="mapping_8h_source.html">deal.II/fe/mapping.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Mapping&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classMapping__inherit__graph.svg" width="964" height="604"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a047daf3a42b246bc78ac8981edf1610a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a047daf3a42b246bc78ac8981edf1610a">~Mapping</a> () override=default</td></tr>
<tr class="separator:a047daf3a42b246bc78ac8981edf1610a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefbf70ea6f93dba57ac3fa7eb2e51992"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aefbf70ea6f93dba57ac3fa7eb2e51992">clone</a> () const =0</td></tr>
<tr class="separator:aefbf70ea6f93dba57ac3fa7eb2e51992"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f37fd5b4a965f3f4ae0d0ca3060156"><td class="memItemLeft" align="right" valign="top">virtual boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#af3f37fd5b4a965f3f4ae0d0ca3060156">get_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:af3f37fd5b4a965f3f4ae0d0ca3060156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a6376f7ab802afb171a00a1a7748cf2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a8a6376f7ab802afb171a00a1a7748cf2">get_center</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classbool.html">bool</a> map_center_of_reference_cell=true) const</td></tr>
<tr class="separator:a8a6376f7ab802afb171a00a1a7748cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d2861c7e444384240609ec53093a54"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a50d2861c7e444384240609ec53093a54">get_bounding_box</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:a50d2861c7e444384240609ec53093a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accdebb05aa5f08dda54941868ce9fbe8"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#accdebb05aa5f08dda54941868ce9fbe8">preserves_vertex_locations</a> () const =0</td></tr>
<tr class="separator:accdebb05aa5f08dda54941868ce9fbe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d8ac8be12bd87c4e7f529778ec317de"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a0d8ac8be12bd87c4e7f529778ec317de">is_compatible_with</a> (const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;reference_cell) const =0</td></tr>
<tr class="separator:a0d8ac8be12bd87c4e7f529778ec317de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">引用单元格和实数单元格之间的映射点</div></td></tr>
<tr class="memitem:ae5df63553eb8ed170c3b90524853dd48"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ae5df63553eb8ed170c3b90524853dd48">transform_unit_to_real_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p) const =0</td></tr>
<tr class="separator:ae5df63553eb8ed170c3b90524853dd48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba6aaa1745359910e1b465a0f5fb27"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">transform_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const =0</td></tr>
<tr class="separator:a38ba6aaa1745359910e1b465a0f5fb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e4eddf3673a9b22104c05bfdfe96bbb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a0e4eddf3673a9b22104c05bfdfe96bbb">transform_points_real_to_unit_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;real_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;unit_points) const</td></tr>
<tr class="separator:a0e4eddf3673a9b22104c05bfdfe96bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078f4e617fdb287e1dc7a5efa227b0ae"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a078f4e617fdb287e1dc7a5efa227b0ae">project_real_point_to_unit_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:a078f4e617fdb287e1dc7a5efa227b0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">异常情况 @{</div></td></tr>
<tr class="memitem:a72122ff6ee588e788415f3124c48bb0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a72122ff6ee588e788415f3124c48bb0d">DeclException0</a> (ExcInvalidData)</td></tr>
<tr class="separator:a72122ff6ee588e788415f3124c48bb0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5086637353e09ce6fb8d84f81be8affa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga5086637353e09ce6fb8d84f81be8affa">DeclExceptionMsg</a> (ExcTransformationFailed, &quot;Computing the mapping between a real space point and a point in reference &quot; &quot;space failed, typically because the given point lies outside the cell &quot; &quot;where the inverse mapping is not unique.&quot;)</td></tr>
<tr class="separator:ga5086637353e09ce6fb8d84f81be8affa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga142dcb2a567c72d6cc2607070cd56a83">DeclException3</a> (ExcDistortedMappedCell, <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The image of the mapping applied to cell with <a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> [&quot;&lt;&lt; arg1&lt;&lt; &quot;] is distorted. The cell geometry or the &quot;&lt;&lt; &quot;mapping are invalid, giving a non-positive volume &quot;&lt;&lt; &quot;fraction of &quot;&lt;&lt; arg2&lt;&lt; &quot; in quadrature point &quot;&lt;&lt; arg3&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:ga142dcb2a567c72d6cc2607070cd56a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">将张量从参考坐标转换为实数坐标的函数</div></td></tr>
<tr class="memitem:a74e30e87fe9ab3716231384db8053c19"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a74e30e87fe9ab3716231384db8053c19">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;output) const =0</td></tr>
<tr class="separator:a74e30e87fe9ab3716231384db8053c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871f491f3d06fda8a30157c8c2b6ae08"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a871f491f3d06fda8a30157c8c2b6ae08">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const =0</td></tr>
<tr class="separator:a871f491f3d06fda8a30157c8c2b6ae08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22b7178a30a5ec26003ffc8fd02d8dd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ab22b7178a30a5ec26003ffc8fd02d8dd">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;output) const =0</td></tr>
<tr class="separator:ab22b7178a30a5ec26003ffc8fd02d8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe09058f596dbda03936270390f3d2e4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#abe09058f596dbda03936270390f3d2e4">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const =0</td></tr>
<tr class="separator:abe09058f596dbda03936270390f3d2e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38deb68a3d62e46bababbcb10bc928d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a38deb68a3d62e46bababbcb10bc928d8">transform</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;input, const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a> kind, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;output) const =0</td></tr>
<tr class="separator:a38deb68a3d62e46bababbcb10bc928d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">与FEValues的接口</div></td></tr>
<tr class="memitem:a4c62b5a55ca40e2b38c6a3a1f460d540"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a4c62b5a55ca40e2b38c6a3a1f460d540">requires_update_flags</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags) const =0</td></tr>
<tr class="separator:a4c62b5a55ca40e2b38c6a3a1f460d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdce92a1ba733f9652de666d3475a34"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a2fdce92a1ba733f9652de666d3475a34">get_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature) const =0</td></tr>
<tr class="separator:a2fdce92a1ba733f9652de666d3475a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3955d81e5bb00f69c566e0890fddeb6"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#af3955d81e5bb00f69c566e0890fddeb6">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:af3955d81e5bb00f69c566e0890fddeb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e75b674cebc41831eac23a44732fcf"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a85e75b674cebc41831eac23a44732fcf">get_face_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const</td></tr>
<tr class="separator:a85e75b674cebc41831eac23a44732fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa101c7827bf40a80b9adac393d830af1"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aa101c7827bf40a80b9adac393d830af1">get_subface_data</a> (const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> update_flags, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature) const =0</td></tr>
<tr class="separator:aa101c7827bf40a80b9adac393d830af1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69cb4dd66dd3745b483f4703cb1fb69"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">fill_fe_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> cell_similarity, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:ac69cb4dd66dd3745b483f4703cb1fb69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9baf527d46a7f2391dbb3dd5dc416864"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a9baf527d46a7f2391dbb3dd5dc416864">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:a9baf527d46a7f2391dbb3dd5dc416864"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aa51c964b1e51b69db3f4933b97bff8c8">fill_fe_face_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, <a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const</td></tr>
<tr class="separator:aa51c964b1e51b69db3f4933b97bff8c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7f6025bc3f10e8f7da2c8a68eaff4a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a9f7f6025bc3f10e8f7da2c8a68eaff4a">fill_fe_subface_values</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face_no, const unsigned <a class="el" href="classint.html">int</a> subface_no, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;internal_data, ::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;output_data) const =0</td></tr>
<tr class="separator:a9f7f6025bc3f10e8f7da2c8a68eaff4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:aaae1cf0eb77f09ffb83fe685445f8cd4"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#aaae1cf0eb77f09ffb83fe685445f8cd4">FEValuesBase&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:aaae1cf0eb77f09ffb83fe685445f8cd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96dfe2e490e255ed133bf6289e47f46f"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a96dfe2e490e255ed133bf6289e47f46f">FEValues&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:a96dfe2e490e255ed133bf6289e47f46f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a2ae7b2d193590c89e5a5f23d31f81"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#a65a2ae7b2d193590c89e5a5f23d31f81">FEFaceValues&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:a65a2ae7b2d193590c89e5a5f23d31f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ff73a151c0885be1f554c91eb9668b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMapping.html#ad5ff73a151c0885be1f554c91eb9668b">FESubfaceValues&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:ad5ff73a151c0885be1f554c91eb9668b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class Mapping&lt; dim, spacedim &gt;</h3>

<p>映射类的抽象基类。 该类声明了用于描述从参考（单位）单元到实空间单元的映射功能的接口，以及用于填写使用FEValues、FEFaceValues和FESubfaceValues类所需的信息。这些接口的具体实现是在派生类中提供的。 </p>
<h3>Mathematics of the mapping</h3>
<p>映射是一种转换 \(\mathbf x = \mathbf F_K(\hat{\mathbf x})\) ，它将参考单元 \([0,1]^\text{dim}\) 中的点 \(\hat{\mathbf x}\) 映射到实际网格单元 \(K\subset{\mathbb R}^\text{spacedim}\) 中的点 \(\mathbf x\) 。这种映射的许多应用都需要这种映射的雅各布， \(J(\hat{\mathbf x}) = \hat\nabla {\mathbf F}_K(\hat{\mathbf x})\) 。例如，如果dim=spacedim=2，我们有 </p><p class="formulaDsp">
\[ J(\hat{\mathbf x}) = \left(\begin{matrix} \frac{\partial x}{\partial \hat x} &amp; \frac{\partial x}{\partial \hat y} \\ \frac{\partial y}{\partial \hat x} &amp; \frac{\partial y}{\partial \hat y} \end{matrix}\right) \]
</p>
<p> 。 </p><h4>Mapping of scalar functions</h4>
<p>*标量有限元的形状函数通常是在参考单元上定义的，然后根据规则 </p><p class="formulaDsp">
\[ \varphi(\mathbf x) = \varphi\bigl(\mathbf F_K(\hat{\mathbf x})\bigr) = \hat \varphi(\hat{\mathbf x}). \]
</p>
<p>简单地进行映射。</p>
<h4>Mapping of integrals</h4>
<p>使用简单的变量变化，标量函数在一个单元上的积分 \(K\) 可以表示为在参考单元上的积分 \(\hat K\) 。具体来说，体积形式 \(d\hat x\) 被转换为 </p><p class="formulaDsp">
\[ \int_K u(\mathbf x)\,dx = \int_{\hat K} \hat u(\hat{\mathbf x}) \left|\text{det}J(\hat{\mathbf x})\right| \,d\hat x. \]
</p>
<p>。 在这种积分被正交近似的表达中，这就导致了形式为 </p><p class="formulaDsp">
\[ \int_K u(\mathbf x)\,dx \approx \sum_{q} \hat u(\hat{\mathbf x}_q) \underbrace{\left|\text{det}J(\hat{\mathbf x}_q)\right| w_q}_{=: \text{JxW}_q}. \]
</p>
<p>的项。 这里，每个正交点的权重 \(\text{JxW}_q\) （其中<em>JxW</em>象征着<em>Jacobian times <a class="el" href="classQuadrature.html">Quadrature</a> Weights</em>）在原始积分中扮演了 \(dx\) 的角色。因此，它们出现在所有计算正交积分的代码中，并通过 <a class="el" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">FEValues::JxW()</a>. 访问。 </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000020">Todo:</a></b></dt><dd>记录了在二维-1的情况下会发生什么。</dd></dl>
<h4>Mapping of vector fields, differential forms and gradients of vector fields</h4>
<p>矢量场或微分形式（标量函数的梯度） \(\mathbf v\) ，以及矢量场的梯度 \(\mathbf T\) 的变换遵循一般形式 </p><p class="formulaDsp">
\[ \mathbf v(\mathbf x) = \mathbf A(\hat{\mathbf x}) \hat{\mathbf v}(\hat{\mathbf x}), \qquad \mathbf T(\mathbf x) = \mathbf A(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) \mathbf B(\hat{\mathbf x}). \]
</p>
<p> 微分形式<b>A</b>和<b>B</b>是由被转换的对象的种类决定。这些转换是通过transform()函数进行的，被转换的对象的类型由其MappingKind参数指定。关于可能的选择，请看那里的文档。 </p><h4>Derivatives of the mapping</h4>
<p>一些应用需要映射的导数，其中一阶导数是映射的Jacobian， \(J_{iJ}(\hat{\mathbf x})=\frac{\partial x_i}{\partial \hat x_J}\) ，如上所述。映射的高阶导数也有类似的定义，例如，雅各布导数 \(\hat H_{iJK}(\hat{\mathbf x}) = \frac{\partial^2 x_i}{\partial \hat x_J \partial \hat x_K}\) ，以及雅各布二阶导数 \(\hat K_{iJKL}(\hat{\mathbf x}) = \frac{\partial^3 x_i}{\partial \hat x_J \partial \hat x_K \partial \hat x_L}\) 。定义高阶导数的 "前推
"版本也很有用：雅各布前推导数， \(H_{ijk}(\hat{\mathbf x}) = \frac{\partial^2 x_i}{\partial \hat x_J \partial \hat x_K}(J_{jJ})^{-1}(J_{kK})^{-1}\) ，以及雅各布后推导数， \(K_{ijkl}(\hat{\mathbf x}) = \frac{\partial^3 x_i}{\partial \hat x_J \partial \hat x_K \partial \hat x_L}(J_{jJ})^{-1}(J_{kK})^{-1}(J_{lL})^{-1}\) 。这些向前推的版本可以用来计算定义在参考单元上的函数相对于实际单元坐标的高阶导数。例如，相对于实细胞坐标的雅各布导数由以下公式给出。 </p><p class="formulaDsp">
\[ \frac{\partial}{\partial x_j}\left[J_{iJ}(\hat{\mathbf x})\right] = H_{ikn}(\hat{\mathbf x})J_{nJ}(\hat{\mathbf x}), \]
</p>
<p>，而相对于实细胞坐标的雅各布反导也同样由以下公式给出。 </p><p class="formulaDsp">
\[ \frac{\partial}{\partial x_j}\left[\left(J_{iJ}(\hat{\mathbf x})\right)^{-1}\right] = -H_{nik}(\hat{\mathbf x})\left(J_{nJ}(\hat{\mathbf x})\right)^{-1}. \]
</p>
<p> 以类似的方式，在参考单元上定义的函数的高阶导数，相对于实数单元坐标，可以使用雅各布式推前高阶导数来定义。例如，Jacobian pushed-forward导数相对于实际单元坐标的导数由以下公式给出。 </p><p class="formulaDsp">
\[ \frac{\partial}{\partial x_l}\left[H_{ijk}(\hat{\mathbf x})\right] = K_{ijkl}(\hat{\mathbf x}) -H_{mjl}(\hat{\mathbf x})H_{imk}(\hat{\mathbf x})-H_{mkl}(\hat{\mathbf x})H_{imj}(\hat{\mathbf x}). \]
</p>
 <h3>References</h3>
<p>关于微分几何和有限元的一般出版物是调查报告 </p><ul>
<li>
Douglas N. Arnold, Richard S. Falk, and Ragnar Winther. <em>Finite element exterior calculus: from Hodge theory to numerical stability.</em> Bull. Amer. Math. Soc. (N.S.), 47:281-354, 2010. <a href="http://dx.doi.org/10.1090/S0273-0979-10-01278-4">DOI: 10.1090/S0273-0979-10-01278-4</a>. </li>
</ul>
<p>皮奥拉变换的描述来自休斯顿大学Ronald H. W. Hoppe的<a href="http://www.math.uh.edu/~rohop/spring_05/downloads/">lecture notes</a>，第七章。 </p>

<p class="definition">Definition at line <a class="el" href="mapping_8h_source.html#l00248">248</a> of file <a class="el" href="mapping_8h_source.html">mapping.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a047daf3a42b246bc78ac8981edf1610a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a047daf3a42b246bc78ac8981edf1610a">&#9670;&nbsp;</a></span>~Mapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::~<a class="el" href="classMapping.html">Mapping</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>虚拟解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aefbf70ea6f93dba57ac3fa7eb2e51992"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefbf70ea6f93dba57ac3fa7eb2e51992">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping.html">Mapping</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向当前对象副本的指针。然后，这个副本的调用者将拥有它的所有权。 这个函数在这个基类中被声明为抽象的虚函数，派生类将不得不实现它。 这个函数主要由 <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a> 类使用。 </p>

<p>Implemented in <a class="el" href="classMappingQ.html#ac20cc628269287050bc74cc74a85c139">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ab6d18faeac73381981eeb2da8f882f38">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQEulerian.html#a20829c9a27e30a255729c66b6a93cb32">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classMappingQGeneric.html#ab68e57c7c366164037c204b7d30c9961">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ1Eulerian.html#a85e9162da1ab583349b014e3bf99d90b">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classMappingQCache.html#ab111812de834e9ae85c92c664b9f8302">MappingQCache&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#ad3db8d200e8d92fff4fad4a51caa9fa3">MappingCartesian&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#ac908a26c2ca5ee158f8135335c0a4f12">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingManifold.html#ab8663bc160fe57d36adbfba73c1b816d">MappingManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ1.html#ac62818625ca8bd3e287ede5b66fe91d6">MappingQ1&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingC1.html#a4f2af8401ec7639b92a7fc1cf20a4be9">MappingC1&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af3f37fd5b4a965f3f4ae0d0ca3060156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f37fd5b4a965f3f4ae0d0ca3060156">&#9670;&nbsp;</a></span>get_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">boost::container::small_vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_cell &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个单元格的映射顶点。 大多数时候，这些值将仅仅是由 <code>cell-&gt;vertex(v)</code> 返回的顶点 <code>v</code> 的坐标，即由三角法存储的信息。 然而，也有增加位移或选择完全不同位置的映射，例如MappingQEulerian, <a class="el" href="classMappingQ1Eulerian.html">MappingQ1Eulerian</a>, 或MappingFEField。 这个函数的默认实现只是返回三角形所存储的信息，即： <code>cell-&gt;vertex(v)</code> . </p>

<p>Reimplemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ae1f6479ed386a00610eb138937705b5b">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQEulerian_1_1MappingQEulerianGeneric.html#a550a08b0626318f016ba6f7b6c7b115f">MappingQEulerian&lt; dim, VectorType, spacedim &gt;::MappingQEulerianGeneric</a>, <a class="el" href="classMappingQEulerian.html#a27e82d02aea674ad2463141b3188b8c7">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, and <a class="el" href="classMappingQ1Eulerian.html#a1b6dcd79f532e305122ef10ab31665a8">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00033">33</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a8a6376f7ab802afb171a00a1a7748cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a6376f7ab802afb171a00a1a7748cf2">&#9670;&nbsp;</a></span>get_center()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_center </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>map_center_of_reference_cell</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个单元格的映射中心。 如果你使用的是保留顶点位置的(bi-,tri-)线性映射，这个函数只是返回同样由<code>cell-&gt;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center()</a></code>产生的值。然而，也有一些映射会增加位移或选择完全不同的位置，例如MappingQEulerian、MappingQ1Eulerian或MappingFEField，以及基于高阶多项式的映射，对于这些映射，中心可能不会与顶点位置的平均值重合。 默认情况下，该函数返回参考单元中心的前推。如果参数 <code>map_center_of_reference_cell</code> 被设置为false，那么返回值将是由get_vertices()方法返回的顶点位置的平均值。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>你想计算中心的单元格 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">map_center_of_reference_cell</td><td>一个标志，用于将计算单元格中心的算法从应用于参考单元格中心的transform_unit_to_real_cell()转换为计算顶点平均数。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00049">49</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a50d2861c7e444384240609ec53093a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d2861c7e444384240609ec53093a54">&#9670;&nbsp;</a></span>get_bounding_box()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; spacedim &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_bounding_box </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回映射的单元格的边界盒。 如果你使用的是保留顶点位置的(bi-,tri-)线性映射，这个函数简单地返回同样由<code>cell-&gt;bounding_box()</code>产生的值。然而，也有一些映射会增加位移或选择完全不同的位置，例如MappingQEulerian、MappingQ1Eulerian或MappingFEField。 对于线性映射，该函数返回包含单元格所有顶点的边界框，如get_vertices()方法所返回的。对于通过支持点定义的高阶映射，边界盒只保证包含所有支持点，而且一般来说，它只是真正边界盒的近似值，可能更大。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格</td><td>你想计算边界框的单元格 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#a215e8c4e5161b4531c339c62d066f605">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQEulerian.html#a71a17c22f99d5faca0456fda65be2ed1">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a4a20f4c766e3a09c9ea6a6a9852d2209">MappingQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingFE.html#a61c8dcdf5a982990be0e79219557cccf">MappingFE&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00074">74</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="accdebb05aa5f08dda54941868ce9fbe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accdebb05aa5f08dda54941868ce9fbe8">&#9670;&nbsp;</a></span>preserves_vertex_locations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::preserves_vertex_locations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回映射是否保留了顶点位置。换句话说，这个函数返回参考单元格顶点的映射位置（由 <a class="el" href="structGeometryInfo.html#a328671c4ef755bea25625d068eaa8d31">GeometryInfo::unit_cell_vertex()</a>) 给出）是否等于 <code>cell-&gt;vertex()</code> 的结果（即由三角法存储的信息）。 例如，派生类中的实现对MappingQ、MappingQGeneric、MappingCartesian返回 <code>true</code> ，但对MappingQEulerian、MappingQ1Eulerian、MappingFEField返回 <code>false</code> 。 </p>

<p>Implemented in <a class="el" href="classMappingQEulerian_1_1MappingQEulerianGeneric.html#ac41edeb71867654c46fce368b80146de">MappingQEulerian&lt; dim, VectorType, spacedim &gt;::MappingQEulerianGeneric</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#aecf69c4beb5b0b18382161d74f91edfc">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#ae4dd9672848fd7657d3d42bd82d43fb6">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQEulerian.html#a516485960c1867ad2e96a1736cffacf8">MappingQEulerian&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classMappingQ1Eulerian.html#a02a8266e551f1fbfb1f74a729ac387c2">MappingQ1Eulerian&lt; dim, VectorType, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a5ce8820a3a72cfd31612d5cc2f7ee075">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#ac1efb859dc9767e64cfff3345d1fd7d7">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQCache.html#a73e3dbb03b4a54cd2436831fa9626773">MappingQCache&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#ab8704ad6d4fa78dad9d42c5877d9f83e">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a7f5868b1ac3170a354ca3fe797131f3e">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0d8ac8be12bd87c4e7f529778ec317de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d8ac8be12bd87c4e7f529778ec317de">&#9670;&nbsp;</a></span>is_compatible_with()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::is_compatible_with </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classReferenceCell.html">ReferenceCell</a> &amp;&#160;</td>
          <td class="paramname"><em>reference_cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个Mapping实例是否与 <code>reference_cell</code>. 中的单元格类型兼容。 </p>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#acc490a7d079a6996380d9da814492643">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a6d64a71ab7336dde2370cd958eb9898a">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#afda09e02a3ee5ec03dfa0eb91e1c98ea">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a96031287093bb9d5410e18533d15eeb5">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#aac4d9b3eeb8eb3dfc6a97c034f716122">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a3da5c2cd7b695373009b04941e0bdfe6">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ae5df63553eb8ed170c3b90524853dd48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5df63553eb8ed170c3b90524853dd48">&#9670;&nbsp;</a></span>transform_unit_to_real_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform_unit_to_real_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将单元格上的点 <code>p</code> 映射到实数单元格上的相应点 <code>cell</code>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">单元格</td><td>迭代器到将用于定义映射的单元。 </td></tr>
    <tr><td class="paramname">p</td><td>参考单元格上一个点的位置。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>参考点的位置，使用由当前实现映射的派生类所定义的映射映射到实空间，以及第一个参数所确定的单元格的坐标。 </dd></dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ac051c51b80c416660170d58b25570237">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a25716700fc33cb61661c1854a391a6ee">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#ac044bfceb5034603c3b44410831dd6a8">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#afaaaa8c7c3047bab305416f134962b3f">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#acd8e601e962721ba7d27e6ffd124b2f9">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a171350ab14035536cb4905314ad2fec7">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a38ba6aaa1745359910e1b465a0f5fb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ba6aaa1745359910e1b465a0f5fb27">&#9670;&nbsp;</a></span>transform_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;dim&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将实数 <code>p</code> 上的点 <code>cell</code> 映射到单元格上的相应点，并返回其坐标。这个函数提供了transform_unit_to_real_cell()所提供的映射的逆映射。 在一维的情况下，本函数返回实点 <code>p</code> 在 <code>cell</code>. 所标识的曲线或曲面上的法线投影。 </p><dl class="section note"><dt>Note</dt><dd>如果要计算反映射的点位于单元格边界之外，从参考（单位）单元格坐标到实数单元格坐标系的多项式映射并不总是可逆的。在这种情况下，当前函数可能无法计算参考单元上的一个点，该点在映射下的图像等于给定的点 <code>p</code>. 如果是这种情况，该函数会抛出一个 Mapping::ExcTransformationFailed 类型的异常。因此，给定的点 <code>p</code> 是否位于单元格之外可以通过检查返回的参考坐标是否位于参考单元格之内或之外来确定（例如，使用 <a class="el" href="structGeometryInfo.html#ace2d235da3d7459096d535d360bcf3d3">GeometryInfo::is_inside_unit_cell()</a>) 或上述异常是否被抛出。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>将用于定义映射的单元的迭代器。 </td></tr>
    <tr><td class="paramname">p</td><td>给定单元格上的一个点的位置。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>点的参考单元位置，当映射到实空间时等于第二个参数给出的坐标。这个映射使用由当前实现映射的派生类所定义的映射，以及第一个参数所确定的单元格的坐标。 </dd></dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a5b279be3ccd33a20463b1103e5e1c663">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a0218e12c99cc01a46bbe76f79a8c7c64">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#ad080ba84f31a1f4bbd547c591a278c39">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a199a6db2f11aad19af39f870be661267">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#ad519feafa229fec578470d48023dcba7">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a3a8235299e5ebbb409a423086b8b31df">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a0e4eddf3673a9b22104c05bfdfe96bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e4eddf3673a9b22104c05bfdfe96bbb">&#9670;&nbsp;</a></span>transform_points_real_to_unit_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform_points_real_to_unit_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>real_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unit_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将多个点从真实点位置映射到参考位置的点。其功能基本上与在所有点上循环并为每个点单独调用 <a class="el" href="classMapping.html#a38ba6aaa1745359910e1b465a0f5fb27">Mapping::transform_real_to_unit_cell()</a> 函数相同，但对于某些实现了更专业的版本的映射，如MappingQGeneric，其速度会更快。行为上的唯一区别是，这个函数永远不会抛出ExcTransformationFailed()异常。如果对<code>real_points[i]</code>转换失败，返回的<code>unit_points[i]</code>包含 std::numeric_limits&lt;double&gt;::infinity() 作为第一个条目。 </p>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#a7fed5446020926f01f434e18568bdda1">MappingQGeneric&lt; dim, spacedim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00087">87</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a078f4e617fdb287e1dc7a5efa227b0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078f4e617fdb287e1dc7a5efa227b0ae">&#9670;&nbsp;</a></span>project_real_point_to_unit_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim - 1 &gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::project_real_point_to_unit_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将实数 <code>cell</code> 上的点 <code>p</code> 转换为参考单元上的对应点，然后将此点投射到给定面数 <code>face_no</code>. 的面的坐标系中的一个(dim-1)维的点，理想情况下，点 <code>p</code> 靠近面 <code>face_no</code>, ，但技术上单元中的任何点都可以被投影。 当dim=1时，这个函数没有物理意义，所以在这种情况下它会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="mapping_8cc_source.html#l00111">111</a> of file <a class="el" href="mapping_8cc_source.html">mapping.cc</a>.</p>

</div>
</div>
<a id="a72122ff6ee588e788415f3124c48bb0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72122ff6ee588e788415f3124c48bb0d">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidData&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a4c62b5a55ca40e2b38c6a3a1f460d540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c62b5a55ca40e2b38c6a3a1f460d540">&#9670;&nbsp;</a></span>requires_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::requires_update_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一组更新标志，计算哪些其他的量<em>also</em>需要被计算，以满足给定标志的请求。 然后返回原始标志集和刚刚计算的标志的组合。 举个例子，如果 <code>update_flags</code> 包含update_JxW_values（即雅各布式的行列式和正交公式提供的权重的乘积），一个映射可能需要计算完整的雅各布式矩阵，以便计算其行列式。然后他们将不仅返回update_JxW_values，而且还返回update_jacobians。在计算JxW值的派生类中，内部实际上不是这样做的</p>
<ul>
<li>他们设置了update_contravariant_transformation来代替，由此也可以计算出行列式。</li>
<li>但这并不影响这个例子的启发性）。) 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 <dl class="section see"><dt>See also</dt><dd><a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> </dd></dl>
</li>
</ul>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#ac8f9dce75f554ce486bafd9d92f7744e">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a253771b6546afa4d2c86370c091c4635">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingManifold.html#a8713cda64df67b53f894be2712a07d30">MappingManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a6b6a822c04d5187b8729efa73e50b63d">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQ.html#ae772c05feadd3a7a753c351c78ffad25">MappingQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingCartesian.html#a3154c4afab952cc154833555030b9311">MappingCartesian&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2fdce92a1ba733f9652de666d3475a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdce92a1ba733f9652de666d3475a34">&#9670;&nbsp;</a></span>get_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建并返回一个指向对象的指针，映射可以在该对象中存储数据，这些数据只需要计算一次，但在映射应用于具体单元时都可以使用（例如，在各种transform()函数中，以及构成映射与FEValues类接口的fill_fe_values()、fill_fe_face_values()和fill_fe_subface_values()中）。 派生类将返回指向从 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 派生的类型的对象的指针（更多信息见那里），并且可能已经预先计算了一些信息（根据未来对映射的要求，由更新标志指定）和给定的正交对象。随后对transform()或fill_fe_values()和friends的调用将收到这里创建的对象（具有相同的更新标志集和相同的正交对象）。因此，派生类可以在其get_data()函数中预先计算一些信息，并将其存储在内部数据对象中。 映射类不会跟踪由该函数创建的对象。因此，所有权将归调用者所有。 关于这个函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义了在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>必须计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，因为在派生类中的调用将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#ad6390683e78a73d58de5b5c48446e5fc">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a9a66a10ce2b30d71906de3e16c7595cb">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a6dbe4effa0d042a74bd10c2531001000">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingManifold.html#ab41ec1aa795379b6831971f6a1eaa711">MappingManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a2a91247a05bb8b0830dac3feead8c857">MappingQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingCartesian.html#afa8128571ede910b4dc27d0ee00cf384">MappingCartesian&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af3955d81e5bb00f69c566e0890fddeb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3955d81e5bb00f69c566e0890fddeb6">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()一样，但是为以后调用transform()或fill_fe_face_values()做准备，这些调用需要关于从参考面到具体单元面的映射信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>需要计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，因为在派生类中的调用将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Reimplemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a8f3a3cc8cc5dada24f9ede277572ace4">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#ae8dbbf44bd25ced74d96458c62a4b74f">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a194be68c6a768ee607c8fcbd972acdba">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingManifold.html#ab9182174944f7d13f86d0a27dc37a3fc">MappingManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a97d541cb896cd92874e299d0e30a71e1">MappingQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingCartesian.html#a2e7c350976357adcdda6b622dfeeea75">MappingCartesian&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a85e75b674cebc41831eac23a44732fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e75b674cebc41831eac23a44732fcf">&#9670;&nbsp;</a></span>get_face_data() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_face_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000030">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="aa101c7827bf40a80b9adac393d830af1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa101c7827bf40a80b9adac393d830af1">&#9670;&nbsp;</a></span>get_subface_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a>&gt; <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::get_subface_data </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td>
          <td class="paramname"><em>update_flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像get_data()和get_face_data()一样，但是为以后调用transform()或fill_fe_subface_values()做准备，这些调用将需要关于从参考面到具体单元的面的子（即子面）的映射信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">update_flags</td><td>一组标志，定义在未来调用transform()或fill_fe_values()函数组时对映射类的期望。这组标志可能包含映射不知道如何处理的标志（例如，对于事实上由有限元类计算的信息，如 UpdateFlags::update_values). 派生类将需要存储这些标志，或者至少是需要映射在fill_fe_values()中执行任何操作的标志子集，在 <a class="el" href="classMapping_1_1InternalDataBase.html#a43f4579d65a86db27d208ebf42ad3f44">InternalDataBase::update_each</a>. </td></tr>
    <tr><td class="paramname">quadrature</td><td>必须计算映射信息的正交对象。这包括正交点的位置和权重。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个指向新创建的InternalDataBase类型（或派生类）对象的指针。该对象的所有权转移给调用函数。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>C++允许派生类中的虚拟函数可以返回不是InternalDataBase类型的对象的指针，但实际上是指向InternalDataBase的类<em>derived</em>的对象的指针。(这个特性被称为 "共变返回类型"。)这在某些情况下是很有用的，在这些情况下，调用是在派生类中，并且将立即使用返回的对象，知道它的真实（派生）类型。 </dd></dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#addf995cd9199a5456c69885e1773971e">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a48f66b84a5495273300392c6e2bec063">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a8cef4f3e024bb1f0a68fb330f6656cf0">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingManifold.html#af6dcd94f41c1b4fe96d9779744e33268">MappingManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a4df30dc89b42435d39d5547cc6f398cb">MappingQ&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingCartesian.html#a43146477038d5fab2469c01e5001092b">MappingCartesian&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ac69cb4dd66dd3745b483f4703cb1fb69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69cb4dd66dd3745b483f4703cb1fb69">&#9670;&nbsp;</a></span>fill_fe_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a> <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceCellSimilarity.html#abbf8aa4eab099bd2356cb51200494c13">CellSimilarity::Similarity</a>&#160;</td>
          <td class="paramname"><em>cell_similarity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算从参考单元到此函数的第一个参数所指示的实数单元的映射信息。派生类将不得不根据它们所代表的映射类型来实现这个函数。它被 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a>. 调用。从概念上讲，这个函数代表了从参考坐标 \(\mathbf\in [0,1]^d\) 到实空间坐标 \(\mathbf x\) 的映射 \(K\) 的应用。它的目的是计算以下种类的数据。</p>
<ul>
<li>从应用映射本身产生的数据，例如，计算实数单元上正交点的位置 \(\mathbf x_q = \mathbf F_K(\hat{\mathbf x}_q)\) ，对FEValues的用户直接有用，例如在装配过程中。</li>
<li>数据是有限元实现在真实单元上计算其形状函数所必需的。为此， <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 函数在当前函数后调用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> ，该函数的输出作为 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. 的输入。这里需要计算的信息的例子是映射的Jacobian， \(\hat\nabla \mathbf F_K(\hat{\mathbf x})\) 或其逆，例如，将参考单元上的形状函数的梯度转换为实单元上形状函数的梯度。 这个函数计算出来的信息被用来填充这个函数的输出参数的各个成员变量。该结构中的哪些成员变量应该被填充，由存储在传递给该函数的 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 对象中的更新标志决定。 关于此函数和FEValues之间的互动的广泛讨论可以在 <a class="el" href="group__FE__vs__Mapping__vs__FEValues.html">How Mapping, FiniteElement, and</a> 文档模块中找到。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，本函数要计算从参考单元格到的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_similarity</td><td>作为第一个参数的单元格是否是最近一次调用此函数的单元格的简单平移、旋转等。这个信息是通过匹配前一个单元和当前单元之间的顶点（由三角结构存储）简单计算出来的。这里传递的值可能被这个函数的实现所修改，然后应该被返回（见关于这个函数的返回值的讨论）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>这个函数的 <code>cell_similarity</code> 参数的一个更新值。当 <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 调用 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a>. 时，返回的值将被用于相应的参数。在大多数情况下，派生类只想返回为 <code>cell_similarity传递的值。然而，这个函数的实现可能会降低细胞相似度的级别。例如，对于那些不仅考虑到单元格顶点的位置（如Triangulation所报告的），而且还考虑到映射的其他特定信息的类，就是这种情况。目的是</code> <a class="el" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">FEValues::reinit()</a> 可以只根据单元格的顶点来计算一个单元格是否与前一个单元格相似，而映射也可以考虑位移场（例如，在MappingQ1Eulerian和MappingFEField类中）。在这种情况下，映射可能会得出结论，先前计算的单元格相似度过于乐观，并通过返回一个不那么乐观的单元格相似度值，使其在随后的使用中无效 <a class="el" href="classFiniteElement.html#a76218870e645f59e07c7ab650cf31a79">FiniteElement::fill_fe_values()</a> 。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>FEValues确保这个函数总是用同一对 <code>internal_data</code> 和 <code>output_data</code> 对象调用。换句话说，如果这个函数的实现知道它在之前的调用中已经把一个数据写入了输出参数，那么在以后的调用中，如果实现知道这是同一个值，就没有必要再把它复制到那里。 </dd></dl>
</li>
</ul>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#a55f47dbce73174cb01825bd1e5cfda6d">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a59b63864eafeb2108b680877a9e98d48">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a5fab53e64c416d06a467ef51082ec594">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9baf527d46a7f2391dbb3dd5dc416864"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9baf527d46a7f2391dbb3dd5dc416864">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, ，但用于单元格的面。有关其目的的广泛讨论，请参见那里。它被 <a class="el" href="classFEFaceValues.html#a49db483b7252515ea578be6d57c5874b">FEFaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">单元格所调用，该函数要计算从参考单元格到的映射。</td><td></td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>请求提供信息的给定单元的面的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>当前评估中使用的正交公式的引用。此正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非这个参数的所有成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classMappingQGeneric.html#ac29df449ce7ed25d529cdfcd45873133">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a168c668ed9104cf9ee21a61fc752aa34">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#afce07f0330ff95ddf05a3c3ea944aaa2">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="aa51c964b1e51b69db3f4933b97bff8c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa51c964b1e51b69db3f4933b97bff8c8">&#9670;&nbsp;</a></span>fill_fe_face_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_face_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000031">Deprecated:</a></b></dt><dd>使用带有 <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a> 参数的版本。</dd></dl>

</div>
</div>
<a id="a9f7f6025bc3f10e8f7da2c8a68eaff4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7f6025bc3f10e8f7da2c8a68eaff4a">&#9670;&nbsp;</a></span>fill_fe_subface_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::fill_fe_subface_values </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>subface_no</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="classinternal_1_1FEValuesImplementation_1_1MappingRelatedData.html">internal::FEValuesImplementation::MappingRelatedData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>output_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数等同于 <a class="el" href="classMapping.html#ac69cb4dd66dd3745b483f4703cb1fb69">Mapping::fill_fe_values()</a>, ，但适用于单元格的子面（即面的子女）。关于其目的的广泛讨论见那里。它被 <a class="el" href="classFESubfaceValues.html#a341778d1291f936d5192a39f2531472a">FESubfaceValues::reinit()</a>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cell</td><td>三角形中的单元格，这个函数要为其计算从参考单元格到的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">face_no</td><td>请求提供信息的给定单元的面的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">subface_no</td><td>请求提供信息的给定单元的面的子的编号。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>对当前评估中使用的正交公式的引用。这个正交对象与创建 <code>internal_data</code> 对象时使用的对象相同。该对象既用于映射正交点的位置，也用于计算每个正交点的JxW值（涉及正交权重）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal_data</td><td>一个对先前由get_data()创建的对象的引用，可用于存储映射在参考单元上可以计算一次的信息。参见 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类的文档，以了解这些对象的用途的广泛描述。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output_data</td><td>对成员变量应被计算的对象的引用。并非所有这个参数的成员都需要被填充；哪些成员需要被填充是由存储在 <code>internal_data</code> 对象内的更新标志决定的。 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingQGeneric.html#a57a3be45fcb87da0a08e12472e26f5fd">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a138b962e1730d898efc05d2d7ed7534c">MappingFE&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a4f87d1f43404d195f52c21fe096014ed">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a74e30e87fe9ab3716231384db8053c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74e30e87fe9ab3716231384db8053c19">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据所选的MappingKind对矢量或1-差分形式的场进行变换。 </p><dl class="section note"><dt>Note</dt><dd>通常情况下，这个函数被一个有限元调用，填充FEValues对象。对于这个有限元，应该有一个别名MappingKind，如 <code>mapping_bdm</code>, <code>mapping_nedelec</code>, 等。这个别名应该优先于使用下面的种类。 目前由派生类实现的映射种类是。 <ul>
<li>
<code>mapping_contravariant:</code> 通过Jacobian将参考单元上的矢量场映射到物理单元。 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 在物理学中，这通常被称为反变量变换。在数学上，它是一个矢量场的前推。 </li>
<li>
<code>mapping_covariant:</code> 将参考单元上的一形场映射到物理单元上的一形场。理论上，这将指的是DerivativeForm&lt;1,dim,1&gt;，但我们将这种类型与Tensor&lt;1,dim&gt;进行规范性的识别）。在数学上，它是微分形式的回拉 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}\hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
标量可微分函数的梯度是这样转化的。 在dim=spacedim的情况下，前面的公式简化为 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = J(\hat{\mathbf x})^{-T}\hat{\mathbf u}(\hat{\mathbf x}) \]
</p>
，因为我们假设映射 \(\mathbf F_K\) 总是可逆的，因此其雅各布 \(J\) 是一个可逆矩阵。 </li>
<li>
<code>mapping_piola:</code> 参考单元上的<em>dim-1</em>形式的场也由矢量场表示，但同样以不同的方式变换，即通过皮奥拉变换 <p class="formulaDsp">
\[ \mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x}). \]
</p>
 </li>
</ul>
</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分而被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">输出</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a105a3624cd1597fa8f85d96dbc2f44ed">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a92313b892a6d57dfac68f7abeda952bf">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a8d38ae55553333d2d2da4b22ef7ad9ce">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a37f968fef3c85a01ea705b56a4f6a882">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#afc0d95ff142523a648601d25524e286b">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a111bccf73a1d0c9bfee7d1cce02c558b">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a871f491f3d06fda8a30157c8c2b6ae08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871f491f3d06fda8a30157c8c2b6ae08">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 1, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个微分形式的场从参考单元转换到物理单元。 认为 \(\mathbf{T} = \nabla \mathbf u\) 和 \(\hat{\mathbf T} = \hat \nabla \hat{\mathbf u}\) 是有用的， \(\mathbf u\) 是一个矢量场。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_covariant:</code> 将参考单元上的形式域映射到物理单元上的形式域。在数学上，它是微分形式的回拉 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
间隔向量值微分函数的雅各布斯是这样转换的。 在dim=spacedim的情况下，前面的公式简化为 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \hat{\mathbf u}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<p>。 </p><dl class="section note"><dt>Note</dt><dd>如果把这个变换变成一个模板函数，其等级在<code><a class="el" href="classDerivativeForm.html">DerivativeForm</a> &lt;1, dim, rank &gt;</code>. 中会更合理，可惜C++不允许模板化虚拟函数。这就是为什么我们在这个函数transform()上面使用mapping_covariant()时，将<code><a class="el" href="classDerivativeForm.html">DerivativeForm</a> &lt;1, dim, 1 &gt;</code> 标识为 <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> 。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>应该被映射的输入对象的一个数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">输出</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3b78d6a5299ab7af4ef6d5baa55aefb9">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a9585e10bdca9ca62a5e574875617e3da">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a85c0f75032706b44482ddb85e4264549">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#a79b7f7a47eaa6a543168328aec09981c">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#a9e6709b3ef57f8007452fb6f3b61628b">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a5945851b3c8911d8fd173485af5dabeb">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="ab22b7178a30a5ec26003ffc8fd02d8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab22b7178a30a5ec26003ffc8fd02d8dd">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 2, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个张量场从参考单元转换到物理单元。 这些张量通常是参考单元中已经从物理单元拉回来的矢量场的雅各布系数。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_contravariant_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = J \hat{\mathbf u}\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = J^{-T} \hat{\mathbf u}\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = J(\hat{\mathbf x})^{-T} \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_gradient:</code> 它假设 \(\mathbf u(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) 这样 <p class="formulaDsp">
\[ \mathbf T(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J(\hat{\mathbf x}) \hat{\mathbf T}(\hat{\mathbf x}) J(\hat{\mathbf x})^{-1}. \]
</p>
 ] </li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000021">Todo:</a></b></dt><dd>mapping_covariant_gradient、mapping_contravariant_gradient和mapping_piola_gradient的公式只对线性映射而言是真的。例如，如果映射是双线性的（或具有高阶多项式程度），那么就会有一个与 \(J\) 的导数相关的缺失项。</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它所指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a3771f2c9ebae7141642636b124a680cf">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#a0527f139542e7bc4a82d718a4137499d">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a11a3566e6ca07a4e86ccd6ca8e1cfe5a">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#ae051d875095b10b806cdb90c5d659055">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#ac4a881ef9e83408787664db398253e5e">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a0615db206608bbe7e2e69ab3cf8c6acc">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="abe09058f596dbda03936270390f3d2e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe09058f596dbda03936270390f3d2e4">&#9670;&nbsp;</a></span>transform() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classDerivativeForm.html">DerivativeForm</a>&lt; 2, dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个张量场从参考单元转换到物理单元。 这种张量在大多数情况下是参考单元中的向量场的 hessians，这些向量场已经从物理单元拉回来。 目前由派生类实现的映射种类有。 </p><ul>
<li>
<code>mapping_covariant_gradient:</code> 将参考单元上的形式场映射到物理单元上的形式场。在数学上，它是微分形式 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \hat{\mathbf T}_{iJK}(\hat{\mathbf x}) J_{jJ}^{\dagger} J_{kK}^{\dagger}\]
</p>
的回拉，其中 <p class="formulaDsp">
\[ J^{\dagger} = J(\hat{\mathbf x})(J(\hat{\mathbf x})^{T} J(\hat{\mathbf x}))^{-1}. \]
</p>
 </li>
</ul>
<p>间隔向量值可微函数的Hessians是这样转化的（在减去导数与雅各布梯度的乘积后）。 在dim=spacedim的情况下，前面的公式简化为 </p><p class="formulaDsp">
\[J^{\dagger} = J^{-1}\]
</p>
 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">input</td><td>应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向类型为 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。(注意，数组视图是 <code>常数，但它指向的张量不是。</code>) </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a0ff1fa4fc4cd8782b302b3a6f642319a">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#af84a343f050259f1d7270fb60c066713">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#a5fb799c7303bc8ba79dcab5464f698d5">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#ab0aa370d99003247f658ef070e2cee9f">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#a3295c3d23b00c645d998f1793ff7ad54">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a81371d835c5346f9b99ea231d765dda8">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a38deb68a3d62e46bababbcb10bc928d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38deb68a3d62e46bababbcb10bc928d8">&#9670;&nbsp;</a></span>transform() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::transform </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classTensor.html">Tensor</a>&lt; 3, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>input</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="group__mapping.html#gac6eaf900d562c52002dbccc6bdd89275">MappingKind</a>&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt;::<a class="el" href="classMapping_1_1InternalDataBase.html">InternalDataBase</a> &amp;&#160;</td>
          <td class="paramname"><em>internal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 3, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个3差分形式的场从参考单元转换到物理单元。 认为 \(\mathbf{T}_{ijk} = D^2_{jk} \mathbf u_i\) 和 \(\mathbf{\hat T}_{IJK} = \hat D^2_{JK} \mathbf{\hat u}_I\) 很有用， \(\mathbf u_i\) 是一个矢量场。 目前由派生类实现的映射种类是。 </p><ul>
<li>
<code>mapping_contravariant_hessian:</code> 它假定 \(\mathbf u_i(\mathbf x) = J_{iI} \hat{\mathbf u}_I\) 以便 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_covariant_hessian:</code> 它假定 \(\mathbf u_i(\mathbf x) = J_{iI}^{-T} \hat{\mathbf u}_I\) 以便 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = J_iI(\hat{\mathbf x})^{-1} \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
<li>
<code>mapping_piola_hessian:</code> ] 它假定 \(\mathbf u_i(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf u}(\hat{\mathbf x})\) 这样 <p class="formulaDsp">
\[ \mathbf T_{ijk}(\mathbf x) = \frac{1}{\text{det}\;J(\hat{\mathbf x})} J_{iI}(\hat{\mathbf x}) \hat{\mathbf T}_{IJK}(\hat{\mathbf x}) J_{jJ}(\hat{\mathbf x})^{-1} J_{kK}(\hat{\mathbf x})^{-1}. \]
</p>
 </li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">输入</td><td>一个应该被映射的输入对象的数组（或数组的一部分）。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">kind</td><td>要应用的映射的种类。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">internal</td><td>一个指向 <a class="el" href="classMapping_1_1InternalDataBase.html">Mapping::InternalDataBase</a> 类型的对象的指针，该对象包含先前由映射存储的信息。指向的对象是由get_data()、get_face_data()或get_subface_data()函数创建的，在调用当前函数之前，将作为对当前单元格的fill_fe_values()、fill_fe_face_values()或fill_fe_subface_values()调用的一部分被更新。换句话说，这个对象也代表了与哪个单元格有关的变换应该被应用。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">output</td><td>一个数组（或数组的一部分），转换后的对象应该被放入其中。 </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classMappingFEField_3_01dim_00_01spacedim_00_01VectorType_00_01void_01_4.html#a4a4b612a063299652cefcbe822cc7774">MappingFEField&lt; dim, spacedim, VectorType, void &gt;</a>, <a class="el" href="classMappingQGeneric.html#ab37b2188f37b3945e498afba8182613f">MappingQGeneric&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingQ.html#afcc3537969ea26cbc92647d553fed15e">MappingQ&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingFE.html#afa1ae4ffe861e0ab84453f9da735323a">MappingFE&lt; dim, spacedim &gt;</a>, <a class="el" href="classMappingCartesian.html#a850c0a8e9a535af305cadf85241ce759">MappingCartesian&lt; dim, spacedim &gt;</a>, and <a class="el" href="classMappingManifold.html#a55b5bbbe2e75bfed1c88083c39685f12">MappingManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="aaae1cf0eb77f09ffb83fe685445f8cd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae1cf0eb77f09ffb83fe685445f8cd4">&#9670;&nbsp;</a></span>FEValuesBase< dim, spacedim ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFEValuesBase.html">FEValuesBase</a>&lt; dim, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping_8h_source.html#l00869">869</a> of file <a class="el" href="mapping_8h_source.html">mapping.h</a>.</p>

</div>
</div>
<a id="a96dfe2e490e255ed133bf6289e47f46f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96dfe2e490e255ed133bf6289e47f46f">&#9670;&nbsp;</a></span>FEValues< dim, spacedim ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFEValues.html">FEValues</a>&lt; dim, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping_8h_source.html#l00870">870</a> of file <a class="el" href="mapping_8h_source.html">mapping.h</a>.</p>

</div>
</div>
<a id="a65a2ae7b2d193590c89e5a5f23d31f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a2ae7b2d193590c89e5a5f23d31f81">&#9670;&nbsp;</a></span>FEFaceValues< dim, spacedim ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFEFaceValues.html">FEFaceValues</a>&lt; dim, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping_8h_source.html#l00871">871</a> of file <a class="el" href="mapping_8h_source.html">mapping.h</a>.</p>

</div>
</div>
<a id="ad5ff73a151c0885be1f554c91eb9668b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ff73a151c0885be1f554c91eb9668b">&#9670;&nbsp;</a></span>FESubfaceValues< dim, spacedim ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a>&lt; dim, spacedim &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mapping_8h_source.html#l00872">872</a> of file <a class="el" href="mapping_8h_source.html">mapping.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/fe/<a class="el" href="mapping_8h_source.html">mapping.h</a></li>
<li>source/fe/<a class="el" href="mapping_8cc_source.html">mapping.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
