<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/tensor_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II/base/tensor.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ee90d91a514b839c31faec7a1d916f67.html">deal.II</a></li><li class="navelem"><a class="el" href="dir_90a2ad6518b731f1dc196d14153b8b6b.html">base</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tensor.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2deal_8II_2base_2exceptions_8h_source.html">deal.II/base/exceptions.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="numbers_8h_source.html">deal.II/base/numbers.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="table__indices_8h_source.html">deal.II/base/table_indices.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="tensor__accessors_8h_source.html">deal.II/base/tensor_accessors.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="include_2deal_8II_2base_2utilities_8h_source.html">deal.II/base/utilities.h</a>&gt;</code><br />
<code>#include &lt;adolc/adouble.h&gt;</code><br />
<code>#include &lt;cmath&gt;</code><br />
<code>#include &lt;ostream&gt;</code><br />
<code>#include &lt;utility&gt;</code><br />
<code>#include &lt;vector&gt;</code><br />
</div>
<p><a href="tensor_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor_3_010_00_01dim_00_01Number_01_4.html">Tensor&lt; 0, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html">Tensor&lt; rank_, dim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceinternal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceinternal_1_1TensorImplementation"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1TensorImplementation.html">internal::TensorImplementation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a90b0bb7059f1e3416d6ef17d9e3e12c7"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber , typename std::enable_if&lt; !std::is_integral&lt; typename ProductType&lt; Number, OtherNumber &gt;::type &gt;::value, int &gt;::type  = 0&gt; </td></tr>
<tr class="memitem:a90b0bb7059f1e3416d6ef17d9e3e12c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceinternal_1_1TensorImplementation.html#a90b0bb7059f1e3416d6ef17d9e3e12c7">internal::TensorImplementation::division_operator</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a90b0bb7059f1e3416d6ef17d9e3e12c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output functions for Tensor objects</div></td></tr>
<tr class="memitem:a26060566f66f799dab8bbe04289ed81b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:a26060566f66f799dab8bbe04289ed81b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a26060566f66f799dab8bbe04289ed81b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:a26060566f66f799dab8bbe04289ed81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c3b3312173253961fda78ac2b7bf4b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a92c3b3312173253961fda78ac2b7bf4b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a92c3b3312173253961fda78ac2b7bf4b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:a92c3b3312173253961fda78ac2b7bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector space operations on Tensor objects:</div></td></tr>
<tr class="memitem:a866270925a280330ae3e2bd05e648dc4"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename Other &gt; </td></tr>
<tr class="memitem:a866270925a280330ae3e2bd05e648dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Other, Number &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a866270925a280330ae3e2bd05e648dc4">operator*</a> (const Other &amp;object, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a866270925a280330ae3e2bd05e648dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27223b3f4809138f070ca30369b7f26"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename Other &gt; </td></tr>
<tr class="memitem:ad27223b3f4809138f070ca30369b7f26"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, Other &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ad27223b3f4809138f070ca30369b7f26">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;t, const Other &amp;object)</td></tr>
<tr class="separator:ad27223b3f4809138f070ca30369b7f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af378a072e8881e65058bd937de898a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a6af378a072e8881e65058bd937de898a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a6af378a072e8881e65058bd937de898a">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a6af378a072e8881e65058bd937de898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361b2cfdd860d356ad80c91147c76327"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a361b2cfdd860d356ad80c91147c76327"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a361b2cfdd860d356ad80c91147c76327">operator/</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a361b2cfdd860d356ad80c91147c76327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab976c32648a69f93416e35b2c6c82800"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab976c32648a69f93416e35b2c6c82800"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ab976c32648a69f93416e35b2c6c82800">operator+</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:ab976c32648a69f93416e35b2c6c82800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2c7983fc5c58b67291507d41c20d0"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a2ed2c7983fc5c58b67291507d41c20d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a2ed2c7983fc5c58b67291507d41c20d0">operator-</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:a2ed2c7983fc5c58b67291507d41c20d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94c55da76e6d429a04c325ec2db311a"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ad94c55da76e6d429a04c325ec2db311a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ad94c55da76e6d429a04c325ec2db311a">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:ad94c55da76e6d429a04c325ec2db311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4635b4d8f14ce045aeec05eaed74ba8"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:aa4635b4d8f14ce045aeec05eaed74ba8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#aa4635b4d8f14ce045aeec05eaed74ba8">operator*</a> (const Number &amp;factor, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:aa4635b4d8f14ce045aeec05eaed74ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071fce7ab1078d6407cb42ff790ef0ce"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a071fce7ab1078d6407cb42ff790ef0ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a071fce7ab1078d6407cb42ff790ef0ce">operator/</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a071fce7ab1078d6407cb42ff790ef0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8406ed86acf24dbf6e3fa6e2c531cf5f"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a8406ed86acf24dbf6e3fa6e2c531cf5f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a8406ed86acf24dbf6e3fa6e2c531cf5f">operator+</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:a8406ed86acf24dbf6e3fa6e2c531cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca33b30cb806b4240462114190ff5f1"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:acca33b30cb806b4240462114190ff5f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#acca33b30cb806b4240462114190ff5f1">operator-</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:acca33b30cb806b4240462114190ff5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7435d412395211da77bfd33a98d86c8e"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a7435d412395211da77bfd33a98d86c8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a7435d412395211da77bfd33a98d86c8e">schur_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a7435d412395211da77bfd33a98d86c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8b98a183ecfdb74d685655f1a7edd"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ac8b8b98a183ecfdb74d685655f1a7edd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ac8b8b98a183ecfdb74d685655f1a7edd">schur_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:ac8b8b98a183ecfdb74d685655f1a7edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Contraction operations and the outer product for tensor objects</div></td></tr>
<tr class="memitem:ad59ec316272a55b8516586404f86075d"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber , typename  = typename std::enable_if&lt;rank_1 &gt;= 1 &amp;&amp; rank_2&gt; </td></tr>
<tr class="memitem:ad59ec316272a55b8516586404f86075d"><td class="memTemplItemLeft" align="right" valign="top">OtherNumber ::type ::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ad59ec316272a55b8516586404f86075d">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:ad59ec316272a55b8516586404f86075d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9711379deb6b31d5ef98c5aa194e7057"><td class="memTemplParams" colspan="2">template&lt;int index_1, int index_2, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9711379deb6b31d5ef98c5aa194e7057"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a9711379deb6b31d5ef98c5aa194e7057">contract</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a9711379deb6b31d5ef98c5aa194e7057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef2ce44eebfa45884c747b286128555"><td class="memTemplParams" colspan="2">template&lt;int index_1, int index_2, int index_3, int index_4, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a3ef2ce44eebfa45884c747b286128555"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 4, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a3ef2ce44eebfa45884c747b286128555">double_contract</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a3ef2ce44eebfa45884c747b286128555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d0baf87e7b3d210ee9c0922a4b7f9f"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a71d0baf87e7b3d210ee9c0922a4b7f9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a71d0baf87e7b3d210ee9c0922a4b7f9f">scalar_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;left, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a71d0baf87e7b3d210ee9c0922a4b7f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff476b88727f4418ec899ec85471063"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, int, typename &gt; class TensorT1, template&lt; int, int, typename &gt; class TensorT2, template&lt; int, int, typename &gt; class TensorT3, int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:aeff476b88727f4418ec899ec85471063"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; T1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T2, T3 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#aeff476b88727f4418ec899ec85471063">contract3</a> (const TensorT1&lt; rank_1, dim, T1 &gt; &amp;left, const TensorT2&lt; rank_1+rank_2, dim, T2 &gt; &amp;middle, const TensorT3&lt; rank_2, dim, T3 &gt; &amp;right)</td></tr>
<tr class="separator:aeff476b88727f4418ec899ec85471063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b76d52ead3fafce2f9c8e06cd1762ba"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a0b76d52ead3fafce2f9c8e06cd1762ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a0b76d52ead3fafce2f9c8e06cd1762ba">outer_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a0b76d52ead3fafce2f9c8e06cd1762ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Special operations on tensors of rank 1</div></td></tr>
<tr class="memitem:a9b0ea33c5eb6c2986072c80d4916599b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a9b0ea33c5eb6c2986072c80d4916599b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a9b0ea33c5eb6c2986072c80d4916599b">cross_product_2d</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;src)</td></tr>
<tr class="separator:a9b0ea33c5eb6c2986072c80d4916599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8718a0f27d7cfaa0b91464bb81e2c28"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number1 , typename Number2 &gt; </td></tr>
<tr class="memitem:af8718a0f27d7cfaa0b91464bb81e2c28"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number1, Number2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#af8718a0f27d7cfaa0b91464bb81e2c28">cross_product_3d</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number1 &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number2 &gt; &amp;src2)</td></tr>
<tr class="separator:af8718a0f27d7cfaa0b91464bb81e2c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Special operations on tensors of rank 2</div></td></tr>
<tr class="memitem:a3e191fd2cb0ed2b86e5ca58aaedcdd13"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a3e191fd2cb0ed2b86e5ca58aaedcdd13"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a3e191fd2cb0ed2b86e5ca58aaedcdd13">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a3e191fd2cb0ed2b86e5ca58aaedcdd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a5bcd00c2a33b1af85f2ffc2976243"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ab6a5bcd00c2a33b1af85f2ffc2976243"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ab6a5bcd00c2a33b1af85f2ffc2976243">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 1, Number &gt; &amp;t)</td></tr>
<tr class="separator:ab6a5bcd00c2a33b1af85f2ffc2976243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b6b774c5a94e2d75219bc1de767f5"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ad34b6b774c5a94e2d75219bc1de767f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ad34b6b774c5a94e2d75219bc1de767f5">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:ad34b6b774c5a94e2d75219bc1de767f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fff6c2d9823b88726460d9bd373a5b"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae9fff6c2d9823b88726460d9bd373a5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#ae9fff6c2d9823b88726460d9bd373a5b">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:ae9fff6c2d9823b88726460d9bd373a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947dac48d007097defaf2736e4586e1d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a947dac48d007097defaf2736e4586e1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a947dac48d007097defaf2736e4586e1d">trace</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;d)</td></tr>
<tr class="separator:a947dac48d007097defaf2736e4586e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addae444929c0f639ff2a684d87616220"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:addae444929c0f639ff2a684d87616220"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#addae444929c0f639ff2a684d87616220">invert</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;)</td></tr>
<tr class="separator:addae444929c0f639ff2a684d87616220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2991e0d54a5ae64c50fe9573570c5fcd"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a2991e0d54a5ae64c50fe9573570c5fcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a2991e0d54a5ae64c50fe9573570c5fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403b17edbfb509662833ac8f5213f20"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a1403b17edbfb509662833ac8f5213f20"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a1403b17edbfb509662833ac8f5213f20">adjugate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a1403b17edbfb509662833ac8f5213f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378f1d72d70a9f08c4f6edab2cbe2c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a05378f1d72d70a9f08c4f6edab2cbe2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a05378f1d72d70a9f08c4f6edab2cbe2c">cofactor</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a05378f1d72d70a9f08c4f6edab2cbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a1fd2ad72ff18b882744a2413bca73"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a92a1fd2ad72ff18b882744a2413bca73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a92a1fd2ad72ff18b882744a2413bca73">project_onto_orthogonal_tensors</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;A)</td></tr>
<tr class="separator:a92a1fd2ad72ff18b882744a2413bca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ba01d979880b278cd4b573dd9c653b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a93ba01d979880b278cd4b573dd9c653b"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a93ba01d979880b278cd4b573dd9c653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858195ddbd94c49d6a2cdd447fc5ee63"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a858195ddbd94c49d6a2cdd447fc5ee63"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="tensor_8h.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a858195ddbd94c49d6a2cdd447fc5ee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a26060566f66f799dab8bbe04289ed81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26060566f66f799dab8bbe04289ed81b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for tensors. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01824">1824</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a92c3b3312173253961fda78ac2b7bf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c3b3312173253961fda78ac2b7bf4b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for tensors of rank 0. Since such tensors are scalars, we simply print this one value. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01845">1845</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a866270925a280330ae3e2bd05e648dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866270925a280330ae3e2bd05e648dc4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Other, Number &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a tensor of rank 0 with an object from the left.</p>
<p>This function unwraps the underlying <code>Number</code> stored in the <a class="el" href="classTensor.html">Tensor</a> and multiplies <code>object</code> with it.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01872">1872</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad27223b3f4809138f070ca30369b7f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27223b3f4809138f070ca30369b7f26">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, Other &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a tensor of rank 0 with an object from the right.</p>
<p>This function unwraps the underlying <code>Number</code> stored in the <a class="el" href="classTensor.html">Tensor</a> and multiplies <code>object</code> with it.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01892">1892</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a6af378a072e8881e65058bd937de898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af378a072e8881e65058bd937de898a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scalar multiplication of two tensors of rank 0.</p>
<p>This function unwraps the underlying objects of type <code>Number</code> and <code>OtherNumber</code> that are stored within the <a class="el" href="classTensor.html">Tensor</a> and multiplies them. It returns an unwrapped number of product type.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01912">1912</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a361b2cfdd860d356ad80c91147c76327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361b2cfdd860d356ad80c91147c76327">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division of a tensor of rank 0 by a scalar number.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01933">1933</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab976c32648a69f93416e35b2c6c82800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab976c32648a69f93416e35b2c6c82800">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add two tensors of rank 0.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01949">1949</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a2ed2c7983fc5c58b67291507d41c20d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed2c7983fc5c58b67291507d41c20d0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract two tensors of rank 0.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01966">1966</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad94c55da76e6d429a04c325ec2db311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94c55da76e6d429a04c325ec2db311a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a tensor of general rank with a scalar number from the right.</p>
<p>Only multiplication with a scalar number type (i.e., a floating point number, a complex floating point number, etc.) is allowed, see the documentation of <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> for details.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01991">1991</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aa4635b4d8f14ce045aeec05eaed74ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4635b4d8f14ce045aeec05eaed74ba8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type, OtherNumber &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a tensor of general rank with a scalar number from the left.</p>
<p>Only multiplication with a scalar number type (i.e., a floating point number, a complex floating point number, etc.) is allowed, see the documentation of <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> for details.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02019">2019</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a071fce7ab1078d6407cb42ff790ef0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071fce7ab1078d6407cb42ff790ef0ce">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a tensor of general rank with a scalar number. See the discussion on <a class="el" href="classPoint.html#a25d858964d15e04ff371d8738a17ea33">operator*()</a> above for more information about template arguments and the return type.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02090">2090</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a8406ed86acf24dbf6e3fa6e2c531cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8406ed86acf24dbf6e3fa6e2c531cf5f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two tensors of general rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of both tensors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02108">2108</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="acca33b30cb806b4240462114190ff5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca33b30cb806b4240462114190ff5f1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two tensors of general rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of both tensors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02132">2132</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a7435d412395211da77bfd33a98d86c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7435d412395211da77bfd33a98d86c8e">&#9670;&nbsp;</a></span>schur_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; schur_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Entrywise multiplication of two tensor objects of rank 0 (i.e. the multiplication of two scalar values). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02152">2152</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac8b8b98a183ecfdb74d685655f1a7edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b8b98a183ecfdb74d685655f1a7edd">&#9670;&nbsp;</a></span>schur_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; schur_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Entrywise multiplication of two tensor objects of general rank.</p>
<p>This multiplication is also called "Hadamard-product" (c.f. <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">https://en.wikipedia.org/wiki/Hadamard_product_(matrices)</a>), and generates a new tensor of size &lt;rank, dim&gt;: </p><p class="formulaDsp">
\[ \text{result}_{i, j} = \text{left}_{i, j}\circ \text{right}_{i, j} \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of both tensors. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02181">2181</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad59ec316272a55b8516586404f86075d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad59ec316272a55b8516586404f86075d">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber , typename  = typename std::enable_if&lt;rank_1 &gt;= 1 &amp;&amp; rank_2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OtherNumber ::type ::tensor_type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02232">2232</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9711379deb6b31d5ef98c5aa194e7057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9711379deb6b31d5ef98c5aa194e7057">&#9670;&nbsp;</a></span>contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index_1, int index_2, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic contraction of a pair of indices of two tensors of arbitrary rank: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 2)\) that is the contraction of index <code>index_1</code> of a tensor <code>src1</code> of rank <code>rank_1</code> with the index <code>index_2</code> of a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k} \text{left}_{i_1,\ldots,k,\ldots,i_{r1}} \text{right}_{j_1,\ldots,k,\ldots,j_{r2}} \]
</p>
<p>If for example the first index (<code>index_1==0</code>) of a tensor <code>t1</code> shall be contracted with the third index (<code>index_2==2</code>) of a tensor <code>t2</code>, this function should be invoked as </p><div class="fragment"><div class="line">contract&lt;0, 2&gt;(t1, t2);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The position of the index is counted from 0, i.e., \(0\le\text{index}_i&lt;\text{range}_i\).</dd>
<dd>
In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02288">2288</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3ef2ce44eebfa45884c747b286128555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef2ce44eebfa45884c747b286128555">&#9670;&nbsp;</a></span>double_contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index_1, int index_2, int index_3, int index_4, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 4, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type double_contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic contraction of two pairs of indices of two tensors of arbitrary rank: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 4)\) that is the contraction of index <code>index_1</code> with index <code>index_2</code>, and index <code>index_3</code> with index <code>index_4</code> of a tensor <code>src1</code> of rank <code>rank_1</code> and a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k, l} \text{left}_{i_1,\ldots,k,\ldots,l,\ldots,i_{r1}} \text{right}_{j_1,\ldots,k,\ldots,l\ldots,j_{r2}} \]
</p>
<p>If for example the first index (<code>index_1==0</code>) shall be contracted with the third index (<code>index_2==2</code>), and the second index (<code>index_3==1</code>) with the first index (<code>index_4==0</code>) of a tensor <code>t2</code>, this function should be invoked as </p><div class="fragment"><div class="line">double_contract&lt;0, 2, 1, 0&gt;(t1, t2);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The position of the index is counted from 0, i.e., \(0\le\text{index}_i&lt;\text{range}_i\).</dd>
<dd>
In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02363">2363</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a71d0baf87e7b3d210ee9c0922a4b7f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d0baf87e7b3d210ee9c0922a4b7f9f">&#9670;&nbsp;</a></span>scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar product, or (generalized) Frobenius inner product of two tensors of equal rank: Return a scalar number that is the result of a full contraction of a tensor <code>left</code> and <code>right:</code> </p><p class="formulaDsp">
\[ \sum_{i_1,\ldots,i_r} \text{left}_{i_1,\ldots,i_r} \text{right}_{i_1,\ldots,i_r} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02442">2442</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aeff476b88727f4418ec899ec85471063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff476b88727f4418ec899ec85471063">&#9670;&nbsp;</a></span>contract3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; int, int, typename &gt; class TensorT1, template&lt; int, int, typename &gt; class TensorT2, template&lt; int, int, typename &gt; class TensorT3, int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; T1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T2, T3 &gt;::type &gt;::type contract3 </td>
          <td>(</td>
          <td class="paramtype">const TensorT1&lt; rank_1, dim, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorT2&lt; rank_1+rank_2, dim, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorT3&lt; rank_2, dim, T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Full contraction of three tensors: Return a scalar number that is the result of a full contraction of a tensor <code>left</code> of rank <code>rank_1</code>, a tensor <code>middle</code> of rank \((\text{rank}_1+\text{rank}_2)\) and a tensor <code>right</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \sum_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} \text{left}_{i_1,\ldots,i_{r1}} \text{middle}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} \text{right}_{j_1,\ldots,j_{r2}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>Each of the three input tensors can be either a <a class="el" href="classTensor.html">Tensor</a> or <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02479">2479</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a0b76d52ead3fafce2f9c8e06cd1762ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b76d52ead3fafce2f9c8e06cd1762ba">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The outer product of two tensors of <code>rank_1</code> and <code>rank_2:</code> Returns a tensor of rank \((\text{rank}_1 + \text{rank}_2)\): </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \text{left}_{i_1,\ldots,i_{r1}}\,\text{right}_{j_1,\ldots,j_{r2}.} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02508">2508</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9b0ea33c5eb6c2986072c80d4916599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0ea33c5eb6c2986072c80d4916599b">&#9670;&nbsp;</a></span>cross_product_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; cross_product_2d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the cross product in 2d. This is just a rotation by 90 degrees clockwise to compute the outer normal from a tangential vector. This function is defined for all space dimensions to allow for dimension independent programming (e.g. within switches over the space dimension), but may only be called if the actual dimension of the arguments is two (e.g. from the <code>dim==2</code> case in the switch). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02539">2539</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af8718a0f27d7cfaa0b91464bb81e2c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8718a0f27d7cfaa0b91464bb81e2c28">&#9670;&nbsp;</a></span>cross_product_3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number1 , typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number1, Number2 &gt;::type &gt; cross_product_3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the cross product of 2 vectors in 3d. This function is defined for all space dimensions to allow for dimension independent programming (e.g. within switches over the space dimension), but may only be called if the actual dimension of the arguments is three (e.g. from the <code>dim==3</code> case in the switch). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02564">2564</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3e191fd2cb0ed2b86e5ca58aaedcdd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e191fd2cb0ed2b86e5ca58aaedcdd13">&#9670;&nbsp;</a></span>determinant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a tensor or rank 2. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02598">2598</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab6a5bcd00c2a33b1af85f2ffc2976243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a5bcd00c2a33b1af85f2ffc2976243">&#9670;&nbsp;</a></span>determinant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for dim==1. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02626">2626</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad34b6b774c5a94e2d75219bc1de767f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34b6b774c5a94e2d75219bc1de767f5">&#9670;&nbsp;</a></span>determinant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for dim==2. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02638">2638</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ae9fff6c2d9823b88726460d9bd373a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fff6c2d9823b88726460d9bd373a5b">&#9670;&nbsp;</a></span>determinant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Specialization for dim==3. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02651">2651</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a947dac48d007097defaf2736e4586e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947dac48d007097defaf2736e4586e1d">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02672">2672</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="addae444929c0f639ff2a684d87616220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addae444929c0f639ff2a684d87616220">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the inverse of the given tensor. Since the compiler can perform the return value optimization, and since the size of the return object is known, it is acceptable to return the result by value, rather than by reference as a parameter. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02691">2691</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a2991e0d54a5ae64c50fe9573570c5fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2991e0d54a5ae64c50fe9573570c5fcd">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the transpose of the given tensor. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02778">2778</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a1403b17edbfb509662833ac8f5213f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1403b17edbfb509662833ac8f5213f20">&#9670;&nbsp;</a></span>adjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; adjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the adjugate of the given tensor of rank 2. The adjugate of a tensor \(\mathbf A\) is defined as </p><p class="formulaDsp">
\[ \textrm{adj}\mathbf A \dealcoloneq \textrm{det}\mathbf A \; \mathbf{A}^{-1} \; . \]
</p>
<dl class="section note"><dt>Note</dt><dd>This requires that the tensor is invertible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02809">2809</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a05378f1d72d70a9f08c4f6edab2cbe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05378f1d72d70a9f08c4f6edab2cbe2c">&#9670;&nbsp;</a></span>cofactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; cofactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the cofactor of the given tensor of rank 2. The cofactor of a tensor \(\mathbf A\) is defined as </p><p class="formulaDsp">
\[ \textrm{cof}\mathbf A \dealcoloneq \textrm{det}\mathbf A \; \mathbf{A}^{-T} = \left[ \textrm{adj}\mathbf A \right]^{T} \; . \]
</p>
<dl class="section note"><dt>Note</dt><dd>This requires that the tensor is invertible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02830">2830</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a92a1fd2ad72ff18b882744a2413bca73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a1fd2ad72ff18b882744a2413bca73">&#9670;&nbsp;</a></span>project_onto_orthogonal_tensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; project_onto_orthogonal_tensors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the nearest orthogonal matrix \(\hat {\mathbf A}=\mathbf U \mathbf{V}^T\) by combining the products of the singular value decomposition (SVD) \({\mathbf A}=\mathbf U \mathbf S \mathbf V^T\) for a given input \({\mathbf A}\), effectively replacing \(\mathbf S\) with the identity matrix.</p>
<p>This is a (nonlinear) <a href="https://en.wikipedia.org/wiki/Projection_(mathematics)">projection operation</a> since when applied twice, we have \(\hat{\hat{\mathbf A}}=\hat{\mathbf A}\) as is easy to see. (That is because the SVD of \(\hat {\mathbf A}\) is simply \(\mathbf U \mathbf I \mathbf{V}^T\).) Furthermore, \(\hat {\mathbf A}\) is really an orthogonal matrix because orthogonal matrices have to satisfy \({\hat {\mathbf A}}^T \hat {\mathbf A}={\mathbf I}\), which here implies that </p><p class="formulaDsp">
\begin{align*} {\hat {\mathbf A}}^T \hat {\mathbf A} &amp;= \left(\mathbf U \mathbf{V}^T\right)^T\left(\mathbf U \mathbf{V}^T\right) \\ &amp;= \mathbf V \mathbf{U}^T \mathbf U \mathbf{V}^T \\ &amp;= \mathbf V \left(\mathbf{U}^T \mathbf U\right) \mathbf{V}^T \\ &amp;= \mathbf V \mathbf I \mathbf{V}^T \\ &amp;= \mathbf V \mathbf{V}^T \\ &amp;= \mathbf I \end{align*}
</p>
<p> due to the fact that the \(\mathbf U\) and \(\mathbf V\) factors that come out of the SVD are themselves orthogonal matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The tensor for which to find the closest orthogonal tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Number</td><td>The type used to store the entries of the tensor. Must be either <code>float</code> or <code>double</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>In order to use this function, this program must be linked with the LAPACK library. </dd>
<dd>
<code>A</code> must not be singular. This is because, conceptually, the problem to be solved here is trying to find a matrix \(\hat{\mathbf A}\) that minimizes some kind of distance from \(\mathbf A\) while satisfying the quadratic constraint \({\hat {\mathbf A}}^T \hat {\mathbf A}={\mathbf I}\). This is not so dissimilar to the kind of problem where one wants to find a vector \(\hat{\mathbf x}\in{\mathbb R}^n\) that minimizes the quadratic objective function \(\|\hat {\mathbf x} - \mathbf x\|^2\) for a given \(\mathbf x\) subject to the constraint \(\|\mathbf x\|^2=1\) &ndash; in other words, we are seeking the point \(\hat{\mathbf x}\) on the unit sphere that is closest to \(\mathbf x\). This problem has a solution for all \(\mathbf x\) except if \(\mathbf x=0\). The corresponding condition for the problem we are considering here is that \(\mathbf A\) must not have a zero eigenvalue. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8cc_source.html#l00068">68</a> of file <a class="el" href="tensor_8cc_source.html">tensor.cc</a>.</p>

</div>
</div>
<a id="a93ba01d979880b278cd4b573dd9c653b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ba01d979880b278cd4b573dd9c653b">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number l1_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_1\) norm of the given rank-2 tensor, where \(\|\mathbf T\|_1 = \max_j \sum_i |T_{ij}|\) (maximum of the sums over columns). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02913">2913</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a858195ddbd94c49d6a2cdd447fc5ee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858195ddbd94c49d6a2cdd447fc5ee63">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number linfty_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_\infty\) norm of the given rank-2 tensor, where \(\|\mathbf T\|_\infty = \max_i \sum_j |T_{ij}|\) (maximum of the sums over rows). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02939">2939</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
