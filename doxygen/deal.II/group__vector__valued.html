<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__vector__valued.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Handling vector valued problems</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a>  </div>
  <div class="headertitle">
<div class="title">Handling vector valued problems<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a><a class="el" href="group__feall.html">Finite elements</a> &raquo;  &#124; <a class="el" href="group__feaccess.html">Finite element access/FEValues classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Handling vector valued problems:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__vector__valued.svg" width="690" height="502"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFEValuesViews"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFEValuesViews.html">FEValuesViews</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceFEValuesExtractors"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMask.html">BlockMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classComponentMask.html">ComponentMask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFESystem.html">FESystem&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1Scalar.html">FEValuesViews::Scalar&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1Vector.html">FEValuesViews::Vector&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1SymmetricTensor_3_012_00_01dim_00_01spacedim_01_4.html">FEValuesViews::SymmetricTensor&lt; 2, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFEValuesViews_1_1Tensor_3_012_00_01dim_00_01spacedim_01_4.html">FEValuesViews::Tensor&lt; 2, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1SymmetricTensor.html">FEValuesExtractors::SymmetricTensor&lt; rank &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structFEValuesExtractors_1_1Tensor.html">FEValuesExtractors::Tensor&lt; rank &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlock.html">MatrixBlock&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMatrixBlockVector.html">MatrixBlockVector&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMGMatrixBlockVector.html">MGMatrixBlockVector&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>Vector-valued problems are systems of partial differential equations. These are problems where the solution variable is not a scalar function, but a vector-valued function or a set of functions. This includes, for example: </p><ul>
<li>
The elasticity equation discussed in step-8, step-17, and step-18 in which the solution is the vector-valued displacement at each point. </li>
<li>
The mixed Laplace equation and its extensions discussed in step-20, and step-21 in which the solution is the scalar pressure and the vector-valued velocity at each point. </li>
<li>
The Stokes equation and its extensions discussed in step-22, and step-31 in which again the solution is the scalar pressure and the vector-valued velocity at each point. </li>
<li>
Complex-valued solutions consisting of real and imaginary parts, as discussed for example in step-29. </li>
</ul>
<p>This page gives an overview of how to implement such vector-valued problems easily in deal.II. In particular, it explains the usage of the class <a class="el" href="classFESystem.html">FESystem</a>, which allows us to write code for systems of partial differential very much like we write code for single equations.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.19.html">video lecture 19</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.20.html">video lecture 20</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.html">video lecture 21</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<table class="tutorial" width="50%">
<tr>
<th><b>Table of contents</b> </th></tr>
<tr>
<td width="100%" valign="top"><ol>
<li>
<a class="el" href="group__vector__valued.html#VVExamples">Examples of vector-valued problems</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVFEs">Describing finite element spaces</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVAssembling">Assembling linear systems</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVAlternative">An alternative approach</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVBlockSolvers">Block solvers</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVExtracting">Extracting data from solutions</a> </li>
<li>
<a class="el" href="group__vector__valued.html#VVOutput">Generating graphical output</a> </li>
</ol>
</td></tr>
</table>
<p><a class="anchor" id="VVExamples"></a> </p><h3>Examples of vector-valued problems</h3>
<p>The way one deals systematically with vector-valued problems is not fundamentally different from scalar problems: first, we need a weak (variational) formulation of the problem that takes into account all the solution variables. After we did so, generating the system matrix and solving the linear system follows the same outlines that we are used to already.</p>
<h4>Linear elasticity</h4>
<p>Let us take for example the elasticity problem from step-8 and even simplify it by choosing \(\lambda = 0\) and \(\mu = 1\) to highlight the important concepts. Therefore, let consider the following weak formulation: find \(\mathbf u \in \mathbf V = H^1_0(\Omega; \mathbb R^3)\) such that for all \(\mathbf v\in V\) holds </p><p class="formulaDsp">
\[ a(u,v) \equiv 2\int_{\Omega} \mathbf D\mathbf u : \mathbf D\mathbf v\,dx = \int_\Omega \mathbf f\cdot \mathbf v \,dx. \]
</p>
<p> Here, <b>D</b> denotes the symmetric gradient defined by \(\mathbf Du = \tfrac12 (\nabla \mathbf u + (\nabla \mathbf u)^T)\) and the colon indicates double contraction of two tensors of rank 2 (the Frobenius inner product). This bilinear form looks indeed very much like the bilinear form of the Poisson problem in step-3. The only differences are </p><ol>
<li>
<p class="startli">We replaced the gradient operator by the symmetric gradient; this is actually not a significant difference, and everything said here is true if your replace \(\mathbf D\) by \(\nabla\). Indeed, let us do this to simplify the discussion: </p><p class="formulaDsp">
\[ a(u,v) \equiv \int_{\Omega} \nabla\mathbf u : \nabla\mathbf v\,dx = \int_\Omega \mathbf f\cdot \mathbf v \,dx. \]
</p>
<p> Note though, that this system is not very exciting, since we could solve for the three components of <b>u</b> separately.</p>
<p class="endli"></p>
</li>
<li>
The trial and test functions are now from the space \(H^1_0(\Omega; \mathbb R^3)\), which can be viewed as three copies of the scalar space \(H^1_0(\Omega)\). And this is exactly, how we are going to implement this space below, using <a class="el" href="classFESystem.html">FESystem</a>. </li>
</ol>
<p>But for now, let us look at the system a little more closely. First, let us exploit that <b>u</b>=(<em>u</em><sub>1</sub>,<em>u</em><sub>2</sub>,<em>u</em><sub>3</sub>)<sup>T</sup> and <b>v</b> accordingly. Then, we can write the simplified equation in coordinates as </p><p class="formulaDsp">
\[ a(u,v) = \int_\Omega \bigl(\nabla u_1\cdot \nabla v_1 +\nabla u_2\cdot \nabla v_2+\nabla u_3\cdot \nabla v_3\bigr)\,dx = \int_\Omega \bigl(f_1v_1 + f_2 v_2 + f_3 v_3\bigr)\,dx. \]
</p>
<p> We see, that this is just three copies of the bilinear form of the Laplacian, one applied to each component (this is where the formulation with the \(\mathbf D\) is more exciting, and we want to derive a framework that applies to that one as well). We can make this weak form a system of differential equations again by choosing special test functions: first, choose <b>v</b>=(<em>v</em><sub>1</sub>,0,0)<sup>T</sup>, then <b>v</b>=(0,<em>v</em><sub>2</sub>,0)<sup>T</sup>, and finally <b>v</b>=(0,0,<em>v</em><sub>3</sub>)<sup>T</sup>. writing the outcomes below each other, we obtain the system </p><p class="formulaDsp">
\[ \begin{matrix} (\nabla u_1,\nabla v_1) &amp;&amp;&amp; = (f_1, v_1) \\ &amp; (\nabla u_2,\nabla v_2) &amp;&amp; = (f_2, v_2) \\ &amp;&amp; (\nabla u_3,\nabla v_3) &amp; = (f_3, v_3) \end{matrix} \]
</p>
<p> where we used the standard inner product notation \((\mathbf f,\mathbf g) = \int_\Omega \mathbf f \cdot \mathbf g \,dx\). It is important for our understanding, that we keep in mind that the latter form as a system of PDE is completely equivalent to the original definition of the bilinear form <em>a</em>(<em>u</em>,<em>v</em>), which does not immediately exhibit this system structure. Let us close by writing the full system of the elastic equation with symmetric gradient <b>D</b>: </p><p class="formulaDsp">
\[ \begin{matrix} (\nabla u_1,\nabla v_1) + (\partial_1 u_1,\partial_1 v_1) &amp; (\partial_1 u_2,\partial_2 v_1) &amp; (\partial_1 u_3,\partial_3 v_1) &amp; = (f_1, v_1) \\ (\partial_2 u_1,\partial_1 v_2) &amp; (\nabla u_2,\nabla v_2) + (\partial_2 u_2,\partial_2 v_2) &amp; (\partial_2 u_3,\partial_3 v_2) &amp; = (f_2, v_2) \\ (\partial_3 u_1,\partial_1 v_3) &amp; (\partial_3 u_2,\partial_2 v_3) &amp; (\nabla u_3,\nabla v_3) + (\partial_3 u_3,\partial_3 v_3) &amp; = (f_3, v_3) \end{matrix}. \]
</p>
<p> Very formally, if we believe in operator valued matrices, we can rewrite this in the form <b>v</b><sup>T</sup><b>Au</b> = <b>v</b><sup>T</sup><b>f</b> or </p><p class="formulaDsp">
\[ \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}^T \begin{pmatrix} (\nabla \cdot,\nabla \cdot) + (\partial_1 \cdot,\partial_1 \cdot) &amp; (\partial_1 \cdot,\partial_2 \cdot) &amp; (\partial_1 \cdot,\partial_3 \cdot) \\ (\partial_2 \cdot,\partial_1 \cdot) &amp; (\nabla \cdot,\nabla \cdot) + (\partial_2 \cdot,\partial_2 \cdot) &amp; (\partial_2 \cdot,\partial_3 \cdot) \\ (\partial_3 \cdot,\partial_1 \cdot) &amp; (\partial_3 \cdot,\partial_2 \cdot) &amp; (\nabla \cdot,\nabla \cdot) + (\partial_3 \cdot,\partial_3 \cdot) \end{pmatrix} \begin{pmatrix} u_1 \\ u_2 \\ u_3 \end{pmatrix} = \begin{pmatrix} v_1 \\ v_2 \\ v_3 \end{pmatrix}^T \begin{pmatrix} f_1 \\ f_2 \\ f_3\end{pmatrix} \]
</p>
<h4>Mixed elliptic problems</h4>
<p>Now, let us consider a more complex example, the mixed Laplace equations discussed in step-20 in three dimensions: </p><p class="formulaDsp">
\begin{eqnarray*} \textbf{u} + \nabla p &amp;=&amp; 0, \\ -\textrm{div}\; \textbf{u} &amp;=&amp; f, \end{eqnarray*}
</p>
<p>Here, we have four solution components: the scalar pressure \(p \in L^2(\Omega)\) and the vector-valued velocity \(\mathbf u \in \mathbf V = H^{\text{div}}_0(\Omega)\) with three vector components. Note as important difference to the previous example, that the vector space <b>V</b> is not just simply a copy of three identical spaces/</p>
<p>A systematic way to get a weak or variational form for this and other vector problems is to first consider it as a problem where the operators and solution variables are written in vector and matrix form. For the example, this would read as follows: </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) = \left( \begin{array}{c} \mathbf 0 \\ f \end{array} \right) \end{eqnarray*}
</p>
<p>This makes it clear that the solution </p><p class="formulaDsp">
\begin{eqnarray*} U = \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) \end{eqnarray*}
</p>
<p> indeed has four components. We note that we could change the ordering of the solution components \(\textbf u\) and \(p\) inside \(U\) if we also change columns of the matrix operator.</p>
<p>Next, we need to think about test functions \(V\). We want to multiply both sides of the equation with them, then integrate over \(\Omega\). The result should be a scalar equality. We can achieve this by choosing \(V\) also vector valued as </p><p class="formulaDsp">
\begin{eqnarray*} V = \left( \begin{array}{c} \mathbf v \\ q \end{array} \right). \end{eqnarray*}
</p>
<p>It is convenient to multiply the matrix-vector equation by the test function from the left, since this way we automatically get the correct matrix later on (in the linear system, the matrix is also multiplied from the right with the solution variable, not from the left), whereas if we multiplied from the right then the matrix so assembled is the transpose of the one we really want.</p>
<p>With this in mind, let us multiply by \(V\) and integrate to get the following equation which has to hold for all test functions \(V\): </p><p class="formulaDsp">
\begin{eqnarray*} \int_\Omega \left( \begin{array}{c} \mathbf v \\ q \end{array} \right)^T \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \left( \begin{array}{c} \mathbf u \\ p \end{array} \right) \ dx = \int_\Omega \left( \begin{array}{c} \mathbf v \\ q \end{array} \right)^T \left( \begin{array}{c} \mathbf 0 \\ f \end{array} \right) \ dx, \end{eqnarray*}
</p>
<p> or equivalently: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v, \mathbf u) + (\mathbf v, \nabla p) - (q, \mathrm{div}\ \mathbf u) = (q,f), \end{eqnarray*}
</p>
<p>We get the final form by integrating by part the second term: </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v, \mathbf u) - (\mathrm{div}\ \mathbf v, p) - (q, \mathrm{div}\ \mathbf u) = (q,f) - (\mathbf n\cdot\mathbf v, p)_{\partial\Omega}. \end{eqnarray*}
</p>
<p>It is this form that we will later use in assembling the discrete weak form into a matrix and a right hand side vector: the form in which we have solution and test functions \(U,V\) that each consist of a number of vector components that we can extract.</p>
<p><a class="anchor" id="VVFEs"></a> </p><h3>Describing finite element spaces</h3>
<p>Once we have settled on a bilinear form and a functional setting, we need to find a way to describe the vector-valued finite element spaces from which we draw solution and test functions. This is where the <a class="el" href="classFESystem.html">FESystem</a> class comes in: it composes vector-valued finite element spaces from simpler ones. In the example of the elasticity problem, we need <code>dim</code> copies of the same element, for instance </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> elasticity_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), dim);</div></div><!-- fragment --><p> This will generate a vector valued space of dimension <code>dim</code>, where each component is a continuous bilinear element of type <a class="el" href="classFE__Q.html">FE_Q</a>. It will have <code>dim</code> times as many basis functions as the corresponding <a class="el" href="classFE__Q.html">FE_Q</a>, and each of these basis functions is a basis function of <a class="el" href="classFE__Q.html">FE_Q</a>, lifted into one of the components of the vector.</p>
<p>For the mixed Laplacian, the situation is more complex. First, we have to settle on a pair of discrete spaces \(\mathbf V_h \times Q_h \subset H^{\text{div}}_0(\Omega) \times L^2_0(\Omega)\). One option would be the stable Raviart-Thomas pair </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> rt_element (<a class="code" href="classFE__RaviartThomas.html">FE_RaviartThomas&lt;dim&gt;</a>(1), 1,</div><div class="line">                          <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1),          1);</div></div><!-- fragment --><p> The first element in this system is already a vector valued element of dimension <code>dim</code>, while the second is a regular scalar element.</p>
<p>Alternatively to using the stable Raviart-Thomas pair, we could consider a stabilized formulation for the mixed Laplacian, for instance the LDG method. There, we have the option of using the same spaces for velocity components and pressure, namely </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_convoluted_element_1 (<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), dim+1);</div></div><!-- fragment --><p> This system just has <code>dim+1</code> equal copies of the same discontinuous element, which not really reflects the structure of the system. Therefore, we prefer </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_equal_element (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), dim), 1,</div><div class="line">                                 <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1),                     1);</div></div><!-- fragment --><p> Here, we have a system of two elements, one vector-valued and one scalar, very much like with the <code>rt_element</code>. Indeed, in many codes, the two can be interchanged. This element also allows us easily to switch to an LDG method with lower order approximation in the velocity, namely </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_unequal_element (<a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>(<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), dim), 1,</div><div class="line">                                   <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(2),                     1);</div></div><!-- fragment --><p> It must be pointed out, that this element is different from </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> ldg_convoluted_element_2 (<a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(1), dim,</div><div class="line">                                        <a class="code" href="classFE__DGQ.html">FE_DGQ&lt;dim&gt;</a>(2), 1);</div></div><!-- fragment --><p> While the constructor call is very similar to <code>rt_element</code>, the result actually resembles more <code>ldg_convoluted_element_1</code> in that this element produces <code>dim+1</code> independent components. A more detailed comparison of the resulting <a class="el" href="classFESystem.html">FESystem</a> objects is below.</p>
<h4>Internal structure of <a class="el" href="classFESystem.html">FESystem</a></h4>
<p><a class="el" href="classFESystem.html">FESystem</a> has a few internal variables which reflect the internal structure set up by the constructor. These can then also be used by application programs to give structure to matrix assembling and linear algebra. We give the names and values of these variables for the examples above in the following table: </p><table border="1">
<tr>
<th>System Element </th><th><a class="el" href="classFiniteElementData.html#a4c1c4ca934f26ff463caf35a574e9f14">FiniteElementData::n_blocks()</a> </th><th><a class="el" href="classFiniteElementData.html#a5a698695065333035e493294ce92820e">FiniteElementData::n_components()</a> </th><th><a class="el" href="classFiniteElement.html#ad12fbcc708737aa60fa272d4d3e22aea">FiniteElement::n_base_elements()</a>  </th></tr>
<tr>
<td><code>elasticity_element</code></td><td><code>dim</code></td><td><code>dim</code></td><td>1  </td></tr>
<tr>
<td><code>rt_element</code></td><td>2</td><td><code>dim+1</code></td><td>2  </td></tr>
<tr>
<td><code>ldg_equal_element</code></td><td>2</td><td><code>dim+1</code></td><td>2  </td></tr>
<tr>
<td><code>ldg_convoluted_element_1</code></td><td><code>dim+1</code></td><td><code>dim+1</code></td><td>1  </td></tr>
<tr>
<td><code>ldg_convoluted_element_2</code></td><td><code>dim+1</code></td><td><code>dim+1</code></td><td>2  </td></tr>
</table>
<p>From this table, it is clear that the <a class="el" href="classFESystem.html">FESystem</a> reflects a lot of the structure of the system of differential equations in the cases of the <code>rt_element</code> and the <code>ldg_equal_element</code>, in that we have a vector valued and a scalar variable. On the other hand, the convoluted elements do not have this structure and we have to reconstruct it somehow when assembling systems, as described below.</p>
<p>At this point, it is important to note that nesting of two <a class="el" href="classFESystem.html">FESystem</a> object can give the whole <a class="el" href="classFESystem.html">FESystem</a> a richer structure than just concatenating them. This structure can be exploited by application programs, but is not automatically so.</p>
<p><a class="anchor" id="VVAssembling"></a> </p><h3>Assembling linear systems</h3>
<p>The next step is to assemble the linear system. How to do this for the simple case of a scalar problem has been shown in many tutorial programs, starting with step-3. Here we will show how to do it for vector problems. Corresponding to the different characterizations of weak formulations above and the different system elements created, we have a few options which are outlined below.</p>
<p>The whole concept is probably best explained by showing an example illustrating how the local contribution of a cell to the weak form of above mixed Laplace equations could be assembled.</p>
<h4>A single <a class="el" href="classFEValues.html">FEValues</a> and <a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a></h4>
<p>This is essentially how step-20 does it: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">typename <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div><div class="line">  endc = dof_handler.end();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.reinit (cell);</div><div class="line">    local_matrix = 0;</div><div class="line">    local_rhs = 0;</div><div class="line"></div><div class="line">    right_hand_side.value_list (fe_values.get_quadrature_points(),</div><div class="line">                                rhs_values);</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">        {</div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">            local_matrix(i,j) += (fe_values[velocities].value (i, q) *</div><div class="line">                                  fe_values[velocities].value (j, q)</div><div class="line">                                  -</div><div class="line">                                  fe_values[velocities].divergence (i, q) *</div><div class="line">                                  fe_values[pressure].value (j, q)</div><div class="line">                                  -</div><div class="line">                                  fe_values[pressure].value (i, q) *</div><div class="line">                                  fe_values[velocities].divergence (j, q)) *</div><div class="line">                                  fe_values.JxW(q);</div><div class="line"></div><div class="line">          local_rhs(i) += - fe_values[pressure].value (i, q) *</div><div class="line">                          rhs_values[q] *</div><div class="line">                          fe_values.JxW(q);</div><div class="line">        }</div></div><!-- fragment --><p>So here's what is happening: </p><ul>
<li>
<p class="startli">The first thing we do is to declare "extractors" (see the <a class="el" href="namespaceFEValuesExtractors.html">FEValuesExtractors</a> namespace). These are objects that don't do much except store which components of a vector-valued finite element constitute a single scalar component, or a tensor of rank 1 (i.e. what we call a "physical vector", always consisting of <code>dim</code> components). Here, we declare an object that represents the velocities consisting of <code>dim</code> components starting at component zero, and the extractor for the pressure, which is a scalar component at position <code>dim</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">We then do our usual loop over all cells, shape functions, and quadrature points. In the innermost loop, we compute the local contribution of a pair of shape functions to the global matrix and right hand side vector. Recall that the cell contributions to the bilinear form (i.e. neglecting boundary terms) looked as follows, based on shape functions \(V_i=\left(\begin{array}{c}\mathbf v_i \\ q_i\end{array}\right), V_j=\left(\begin{array}{c}\mathbf v_j \\ q_j\end{array}\right)\): </p><p class="formulaDsp">
\begin{eqnarray*} (\mathbf v_i, \mathbf v_j) - (\mathrm{div}\ \mathbf v_i, q_j) - (q_i, \mathrm{div}\ \mathbf v_j) \end{eqnarray*}
</p>
<p> whereas the implementation looked like this: </p><div class="fragment"><div class="line">local_matrix(i,j) += (fe_values[velocities].value (i, q) *</div><div class="line">                      fe_values[velocities].value (j, q)</div><div class="line">                      -</div><div class="line">                      fe_values[velocities].divergence (i, q) *</div><div class="line">                      fe_values[pressure].value (j, q)</div><div class="line">                      -</div><div class="line">                      fe_values[pressure].value (i, q) *</div><div class="line">                      fe_values[velocities].divergence (j, q)</div><div class="line">                     ) *</div><div class="line">                     fe_values.JxW(q);</div></div><!-- fragment --><p> The similarities are pretty obvious.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Essentially, what happens in above code is this: when you do <code>fe_values[pressure]</code>, a so-called "view" is created, i.e. an object that unlike the full <a class="el" href="classFEValues.html">FEValues</a> object represents not all components of a finite element, but only the one(s) represented by the extractor object <code>pressure</code> or <code>velocities</code>.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">These views can then be asked for information about these individual components. For example, when you write <code>fe_values[pressure].value(i,q)</code> you get the value of the pressure component of the \(i\)th shape function \(V_i\) at the \(q\)th quadrature point. Because the extractor <code>pressure</code> represents a scalar component, the results of the operator <code>fe_values[pressure].value(i,q)</code> is a scalar number. On the other hand, the call <code>fe_values[velocities].value(i,q)</code> would produce the value of a whole set of <code>dim</code> components, which would be of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code>.</p>
<p class="endli"></p>
</li>
<li>
Other things that can be done with views is to ask for the gradient of a particular shape function's components described by an extractor. For example, <code>fe_values[pressure].gradient(i,q)</code> would represent the gradient of the scalar pressure component, which is of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code>, whereas the gradient of the velocities components, <code>fe_values[velocities].gradient(i,q)</code> is a <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim&gt;</code>, i.e. a matrix \(G_{ij}\) that consists of entries \(G_{ij}=\frac{\partial\phi_i}{\partial x_j}\). Finally, both scalar and vector views can be asked for the second derivatives ("Hessians") and vector views can be asked for the symmetric gradient, defined as \(S_{ij}=\frac 12 \left[\frac{\partial\phi_i}{\partial x_j} + \frac{\partial\phi_j}{\partial x_i}\right]\) as well as the divergence \(\sum_{d=0}^{dim-1} \frac{\partial\phi_d}{\partial x_d}\). </li>
</ul>
<p>Other examples of using extractors and views are shown in tutorial programs step-21, step-22, step-31 and several other programs.</p>
<dl class="section note"><dt>Note</dt><dd>In the current context, when we talk about a vector (for example in extracting the velocity components above), we mean the word in the sense physics uses it: it has <code>spacedim</code> components that behave in specific ways under coordinate system transformations. Examples include velocity or displacement fields. This is opposed to how mathematics uses the word "vector" (and how we use this word in other contexts in the library, for example in the <a class="el" href="classVector.html">Vector</a> class), where it really stands for a collection of numbers. An example of this latter use of the word could be the set of concentrations of chemical species in a flame; however, these are really just a collection of scalar variables, since they do not change if the coordinate system is rotated, unlike the components of a velocity vector, and consequently, this <a class="el" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> class should not be used for this case.</dd></dl>
<p><a class="anchor" id="VVAlternative"></a> </p><h3>An alternative approach</h3>
<p>There are situations in which one can optimize the assembly of a matrix or right hand side vector a bit, using knowledge of the finite element in use. Consider, for example, the bilinear form of the elasticity equations which we are concerned with first in step-8:</p>
<p class="formulaDsp">
\[ a({\mathbf u}, {\mathbf v}) = \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_i v_j \right)_\Omega, + \sum_{i,j} \left( \mu \partial_i u_j, \partial_j v_i \right)_\Omega, \]
</p>
<p>Here, \(\mathbf u\) is a vector function with <code>dim</code> components, \(\mathbf v\) the corresponding test function, and \(\lambda,\mu\) are material parameters. Given our discussions above, the obvious way to implement this bilinear form would be as follows, using an extractor object that interprets all <code>dim</code> components of the finite element as single vector, rather than disjoint scalar components:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacements (0);</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">for (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> phi_i_grad</div><div class="line">        = fe_values[displacements].gradient (i,q_point);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_div</div><div class="line">        = fe_values[displacements].divergence (i,q_point);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> phi_j_grad</div><div class="line">            = fe_values[displacements].gradient (j,q_point);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_div</div><div class="line">            = fe_values[displacements].divergence (j,q_point);</div><div class="line"></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j)</div><div class="line">            +=  (lambda_values[q_point] *</div><div class="line">                 phi_i_div * phi_j_div</div><div class="line">                 +</div><div class="line">                 mu_values[q_point] *</div><div class="line">                 <a class="code" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a>(phi_i_grad, phi_j_grad)</div><div class="line">                 +</div><div class="line">                 mu_values[q_point] *</div><div class="line">                 <a class="code" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a>(phi_i_grad, <a class="code" href="classDerivativeForm.html#a3c201452e8dd28e4f5be4a316cb9305f">transpose</a>(phi_j_grad))</div><div class="line">                ) *</div><div class="line">                fe_values.JxW(q_point);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>Now, this is not the code used in step-8. In fact, if one used the above code over the one implemented in that program, it would run about 8 per cent slower. It can be improved (bringing down the penalty to about 4 per cent) by taking a close look at the bilinear form. In fact, we can transform it as follows: </p><p class="formulaDsp">
\begin{eqnarray*} a({\mathbf u}, {\mathbf v}) &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_i v_j \right)_\Omega + \sum_{i,j} \left( \mu \partial_i u_j, \partial_j v_i \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \partial_i u_j, \frac 12[\partial_i v_j + \partial_j v_i] \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \frac 12[\partial_i u_j + \partial_j u_i], \frac 12[\partial_i v_j + \partial_j v_i] \right)_\Omega \\ &amp;=&amp; \left( \lambda \nabla\cdot {\mathbf u}, \nabla\cdot {\mathbf v} \right)_\Omega + 2 \sum_{i,j} \left( \mu \varepsilon(\mathbf u), \varepsilon(\mathbf v) \right)_\Omega, \end{eqnarray*}
</p>
<p> where \(\varepsilon(\mathbf u) = \frac 12 \left([\nabla\mathbf u] + [\nabla\mathbf u]^T\right)\) is the symmetrized gradient. In the second to last step, we used that the scalar product between an arbitrary tensor \(\nabla\mathbf u\) and a symmetric tensor \(\frac 12[\partial_i v_j + \partial_j v_i]\) equals the scalar product of the symmetric part of the former with the second tensor. Using the techniques discussed above, the obvious way to implement this goes like this:</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point=0; q_point&lt;n_q_points; ++q_point)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;dofs_per_cell; ++i)</div><div class="line">    {</div><div class="line">      <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> phi_i_symmgrad</div><div class="line">        = fe_values[displacements].symmetric_gradient (i,q_point);</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> phi_i_div</div><div class="line">        = fe_values[displacements].divergence (i,q_point);</div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;dofs_per_cell; ++j)</div><div class="line">        {</div><div class="line">          <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> phi_j_symmgrad</div><div class="line">            = fe_values[displacements].symmetric_gradient (j,q_point);</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> phi_j_div</div><div class="line">            = fe_values[displacements].divergence (j,q_point);</div><div class="line"></div><div class="line">          <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i,j)</div><div class="line">            +=  (phi_i_div * phi_j_div *</div><div class="line">                 lambda_values[q_point]</div><div class="line">                 +</div><div class="line">                 2 *</div><div class="line">                 (phi_i_symmgrad * phi_j_symmgrad) *</div><div class="line">                 mu_values[q_point]) *</div><div class="line">                fe_values.JxW(q_point);</div><div class="line">        }</div><div class="line">    }</div></div><!-- fragment --><p>So if, again, this is not the code we use in step-8, what do we do there? The answer rests on the finite element we use. In step-8, we use the following element: </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> finite_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), dim);</div></div><!-- fragment --><p> In other words, the finite element we use consists of <code>dim</code> copies of the same scalar element. This is what we call a <a class="el" href="DEALGlossary.html#GlossPrimitive">primitive</a> element: an element that may be vector-valued but where each shape function has exactly one non-zero component. In other words: if the \(x\)-component of a displacement shape function is nonzero, then the \(y\)- and \(z\)-components must be zero and similarly for the other components. What this means is that also derived quantities based on shape functions inherit this sparsity property. For example: the divergence \(\mathrm{div}\ \Phi(x,y,z)=\partial_x\varphi_x(x,y,z) + \partial_y\varphi_y(x,y,z) + \partial_z\varphi_z(x,y,z)\) of a vector-valued shape function \(\Phi(x,y,z)=(\varphi_x(x,y,z), \varphi_y(x,y,z), \varphi_z(x,y,z))^T\) is, in the present case, either \(\mathrm{div}\ \Phi(x,y,z)=\partial_x\varphi_x(x,y,z)\), \(\mathrm{div}\ \Phi(x,y,z)=\partial_y\varphi_y(x,y,z)\), or \(\mathrm{div}\ \Phi(x,y,z)=\partial_z\varphi_z(x,y,z)\), because exactly one of the \(\varphi_\ast\) is nonzero. Knowing this means that we can save a number of computations that, if we were to do them, would only yield zeros to add up.</p>
<p>In a similar vein, if only one component of a shape function is nonzero, then only one row of its gradient \(\nabla\Phi\) is nonzero. What this means for terms like \((\mu \nabla\Phi_i,\nabla\Phi_j)\), where the scalar product between two tensors is defined as \((\tau, \gamma)_\Omega=\int_\Omega \sum_{i,j=1}^d \tau_{ij} \gamma_{ij}\), is that the term is only nonzero if both tensors have their nonzero entries in the same row, which means that the two shape functions have to have their single nonzero component in the same location.</p>
<p>If we use this sort of knowledge, then we can in a first step avoid computing gradient tensors if we can determine up front that their scalar product will be nonzero, in a second step avoid building the entire tensors and only get its nonzero components, and in a final step simplify the scalar product by only considering that index \(i\) for the one nonzero row, rather than multiplying and adding up zeros.</p>
<p>The vehicle for all this is the ability to determine which vector component is going to be nonzero. This information is provided by the <a class="el" href="classFiniteElement.html#a86644fe67824373cd51e9ff7fca94f8c">FiniteElement::system_to_component_index</a> function. What can be done with it, using the example above, is explained in detail in step-8.</p>
<p><a class="anchor" id="VVBlockSolvers"></a> </p><h3>Block solvers</h3>
<p>Using techniques as shown above, it isn't particularly complicated to assemble the linear system, i.e. matrix and right hand side, for a vector-valued problem. However, then it also has to be solved. This is more complicated. Naively, one could just consider the matrix as a whole. For most problems, this matrix is not going to be definite (except for special cases like the elasticity equations covered in step-8 and step-17). It will, often, also not be symmetric. This rather general class of matrices presents problems for iterative solvers: the lack of structural properties prevents the use of most efficient methods and preconditioners. While it can be done, the solution process will therefore most often be slower than necessary.</p>
<p>The answer to this problem is to make use of the structure of the problem. For example, for the mixed Laplace equations discussed above, the operator has the form </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} \mathbf 1 &amp; \nabla \\ -\nabla^T &amp; 0 \end{array} \right) \end{eqnarray*}
</p>
<p>It would be nice if this structure could be recovered in the linear system as well. For example, after discretization, we would like to have a matrix with the following block structure: </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array} \right), \end{eqnarray*}
</p>
<p> where \(M\) represents the mass matrix that results from discretizing the identity operator \(\mathbf 1\) and \(B\) the equivalent of the gradient operator.</p>
<p>By default, this is not what happens, however. Rather, deal.II assigns numbers to degrees of freedom in a rather random manner. Consequently, if you form a vector out of the values of degrees of freedom will not be neatly ordered in a vector like </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{c} U \\ P \end{array} \right). \end{eqnarray*}
</p>
<p> Rather, it will be a permutation of this, with numbers of degrees of freedom corresponding to velocities and pressures intermixed. Consequently, the system matrix will also not have the nice structure mentioned above, but with the same permutation or rows and columns.</p>
<p>What is needed is to re-enumerate degrees of freedom so that velocities come first and pressures last. This can be done using the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> function, as explained in step-20, step-21, step-22, and step-31. After this, at least the degrees of freedom are partitioned properly.</p>
<p>But then we still have to make use of it, i.e. we have to come up with a solver that uses the structure. For example, in step-20, we do a block elimination of the linear system </p><p class="formulaDsp">
\begin{eqnarray*} \left( \begin{array}{cc} M &amp; B \\ B^T &amp; 0 \end{array} \right) \left( \begin{array}{c} U \\ P \end{array} \right) = \left( \begin{array}{c} F \\ G \end{array} \right). \end{eqnarray*}
</p>
<p> What this system means, of course, is </p><p class="formulaDsp">
\begin{eqnarray*} MU + BP &amp;=&amp; F,\\ B^TU &amp;=&amp; G. \end{eqnarray*}
</p>
<p>So, if we multiply the first equation by \(B^TM^{-1}\) and subtract the second from the result, we get </p><p class="formulaDsp">
\begin{eqnarray*} B^TM^{-1}BP &amp;=&amp; B^TM^{-1}F-G. \end{eqnarray*}
</p>
<p>This is an equation that now only contains the pressure variables. If we can solve it, we can in a second step solve for the velocities using </p><p class="formulaDsp">
\begin{eqnarray*} MU = F-BP. \end{eqnarray*}
</p>
<p>This has the advantage that the matrices \(B^TM^{-1}B\) and \(M\) that we have to solve with are both symmetric and positive definite, as opposed to the large whole matrix we had before.</p>
<p>How a solver like this is implemented is explained in more detail in step-20, step-31, and a few other tutorial programs. What we would like to point out here is that we now need a way to extract certain parts of a matrix or vector: if we are to multiply, say, the \(U\) part of the solution vector by the \(M\) part of the global matrix, then we need to have a way to access these parts of the whole.</p>
<p>This is where the <a class="el" href="classBlockVector.html">BlockVector</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>, and similar classes come in. For all practical purposes, then can be used as regular vectors or sparse matrices, i.e. they offer element access, provide the usual vector operations and implement, for example, matrix-vector multiplications. In other words, assembling matrices and right hand sides works in exactly the same way as for the non-block versions. That said, internally they store the elements of vectors and matrices in "blocks"; for example, instead of using one large array, the <a class="el" href="classBlockVector.html">BlockVector</a> class stores it as a set of arrays each of which we call a block. The advantage is that, while the whole thing can be used as a vector, one can also access an individual block which then, again, is a vector with all the vector operations.</p>
<p>To show how to do this, let us consider the second equation \(MU=F-BP\) to be solved above. This can be achieved using the following sequence similar to what we have in step-20: </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double&gt;</a> tmp (solution.block(0).size());</div><div class="line">system_matrix.block(0,1).vmult (tmp, solution.block(1));</div><div class="line">tmp *= -1;</div><div class="line">tmp += system_rhs.block(0);</div><div class="line"></div><div class="line"></div><div class="line"><a class="code" href="classSolverControl.html">SolverControl</a> solver_control (solution.block(0).size(),</div><div class="line">                              1<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a9587d5229555daa5b1fa1ba2f8a40adb">e</a>-8*tmp.l2_norm());</div><div class="line"><a class="code" href="classSolverCG.html">SolverCG&lt;&gt;</a> cg (solver_control, vector_memory);</div><div class="line"></div><div class="line">cg.solve (system_matrix.block(0,0),</div><div class="line">          solution.block(0),</div><div class="line">          tmp,</div><div class="line">          <a class="code" href="classPreconditionIdentity.html">PreconditionIdentity</a>());</div></div><!-- fragment --><p>What's happening here is that we allocate a temporary vector with as many elements as the first block of the solution vector, i.e. the velocity component \(U\), has. We then set this temporary vector equal to the \((0,1)\) block of the matrix, i.e. \(B\), times component 1 of the solution which is the previously computed pressure \(P\). The result is multiplied by \(-1\), and component 0 of the right hand side, \(F\) is added to it. The temporary vector now contains \(F-BP\). The rest of the code snippet simply solves a linear system with \(F-BP\) as right hand side and the \((0,0)\) block of the global matrix, i.e. \(M\). Using block vectors and matrices in this way therefore allows us to quite easily write rather complicated solvers making use of the block structure of a linear system.</p>
<p><a class="anchor" id="VVExtracting"></a> </p><h3>Extracting data from solutions</h3>
<p>Once one has computed a solution, it is often necessary to evaluate it at quadrature points, for example to evaluate nonlinear residuals for the next Newton iteration, to evaluate the finite element residual for error estimators, or to compute the right hand side for the next time step in a time dependent problem.</p>
<p>The way this is done us to again use an <a class="el" href="classFEValues.html">FEValues</a> object to evaluate the shape functions at quadrature points, and with those also the values of a finite element function. For the example of the mixed Laplace problem above, consider the following code after solving: </p><div class="fragment"><div class="line">std::vector&lt;Vector&lt;double&gt; &gt; local_solution_values (n_q_points,</div><div class="line">                                                    <a class="code" href="classVector.html">Vector&lt;double&gt;</a> (dim+1));</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div><div class="line">  endc = dof_handler.end();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.reinit (cell);</div><div class="line"></div><div class="line">    fe_values.get_function_values (solution,</div><div class="line">                                   local_solution_values);</div></div><!-- fragment --><p>After this, the variable <code>local_solution_values</code> is a list of vectors of a length equal to the number of quadrature points we have initialized the <a class="el" href="classFEValues.html">FEValues</a> object with; each of these vectors has <code>dim+1</code> elements containing the values of the <code>dim</code> velocities and the one pressure at a quadrature point.</p>
<p>We can use these values to then construct other things like residuals. However, the construct is a bit awkward. First, we have a <code>std::vector</code> of <code><a class="el" href="classVector.html">Vector</a></code>s, which always looks strange. It is also inefficient because it implies dynamic memory allocation for the outer vector as well as for all the inner vectors. Secondly, maybe we are only interested in the velocities, for example to solve an advection problem in a second stage (as, for example, in step-21 or step-31). In that case, one would have to hand-extract these values like so: </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q=0; q&lt;n_q_points; ++q)</div><div class="line">  {</div><div class="line">    <a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> velocity;</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> d=0; d&lt;dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#a15728437b942dab0b0042eb06a407d2c">d</a>)</div><div class="line">      velocity[d] = local_solution_values[q](d);</div><div class="line"></div><div class="line">    ... <span class="keywordflow">do</span> something with <span class="keyword">this</span> velocity ...</div></div><!-- fragment --><p> Note how we convert from a <a class="el" href="classVector.html">Vector</a> (which is simply a collection of vector elements) into a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> because the velocity is a quantity characterized by <code>dim</code> elements that have certain transformation properties under rotations of the coordinate system.</p>
<p>This code can be written more elegantly and efficiently using code like the following: </p><div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1,dim&gt; &gt; local_velocity_values (n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> velocities (0);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div><div class="line">  endc = dof_handler.end();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.reinit (cell);</div><div class="line"></div><div class="line">    fe_values[velocities].get_function_values (solution,</div><div class="line">                                               local_velocity_values);</div></div><!-- fragment --><p>As a result, we here get the velocities right away, and in the right data type (because we have described, using the extractor, that the first <code>dim</code> components of the finite element belong together, forming a tensor). The code is also more efficient: it requires less dynamic memory allocation because the <a class="el" href="classTensor.html">Tensor</a> class allocates its components as member variables rather than on the heap, and we save cycles because we don't even bother computing the values of the pressure variable at the quadrature points. On the other hand, if we had been interested in only the pressure and not the velocities, then the following code extracting scalar values would have done: </p><div class="fragment"><div class="line">std::vector&lt;double&gt; local_pressure_values (n_q_points);</div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> pressure (dim);</div><div class="line"></div><div class="line"><span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a></div><div class="line">  cell = dof_handler.<a class="code" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">begin_active</a>(),</div><div class="line">  endc = dof_handler.end();</div><div class="line"><span class="keywordflow">for</span> (; cell!=endc; ++cell)</div><div class="line">  {</div><div class="line">    fe_values.reinit (cell);</div><div class="line"></div><div class="line">    fe_values[pressure].get_function_values (solution,</div><div class="line">                                             local_pressure_values);</div></div><!-- fragment --><p>In similar cases, one sometimes needs the gradients or second derivatives of the solution, or of individual scalar or vector components. To get at those of all components of the solution, the functions <a class="el" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">FEValuesBase::get_function_gradients</a> and <a class="el" href="classFEValuesBase.html#ae8f183c9d6da0c7daf9d345e0bc91b0a">FEValuesBase::get_function_hessians</a> are the equivalent of the function <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values</a> used above.</p>
<p>Likewise, to extract the gradients of scalar components, <a class="el" href="classFEValuesViews_1_1Scalar.html#a8073486fd29629a2e6caa56d7be06fff">FEValuesViews::Scalar::get_function_gradients</a> and <a class="el" href="classFEValuesViews_1_1Scalar.html#ad3c3ec313b98641126f8bc291be01256">FEValuesViews::Scalar::get_function_hessians</a> do the job. For vector- (tensor-)valued quantities, there are functions <a class="el" href="classFEValuesViews_1_1Vector.html#aef8071e686d865141962ac094c177e71">FEValuesViews::Vector::get_function_gradients</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#ad610b3f5bb8362178878a354dafed36b">FEValuesViews::Vector::get_function_hessians</a>, and in addition <a class="el" href="classFEValuesViews_1_1Vector.html#ad66f65902c2bb697463c57dfab9842a3">FEValuesViews::Vector::get_function_symmetric_gradients</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#a2f5373200c3fe1ed59d44009719199cd">FEValuesViews::Vector::get_function_divergences</a>.</p>
<p>Moreover, there is a shortcut available in case when only the Laplacians of the solution (which is the trace of the hessians) is needed, usable for both scalar and vector-valued problems as <a class="el" href="classFEValuesViews_1_1Scalar.html#ace2d43a069e46e5af4afdc53a453aa3a">FEValuesViews::Scalar::get_function_laplacians</a> and <a class="el" href="classFEValuesViews_1_1Vector.html#a713d9f3c455c5454dc9803d8eff6f685">FEValuesViews::Vector::get_function_laplacians</a>.</p>
<p><a class="anchor" id="VVOutput"></a> </p><h3>Generating graphical output</h3>
<p>As mentioned above, an <a class="el" href="classFESystem.html">FESystem</a> object may hold multiple vector components, but it doesn't have a notion what they actually mean. As an example, take the object </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> finite_element (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), dim+1);</div></div><!-- fragment --><p> It has <code>dim+1</code> vector components, but what do they mean? Are they the <code>dim</code> components of a velocity vector plus one pressure? Are they the pressure plus the <code>dim</code> velocity components? Or are they a collection of scalars?</p>
<p>The point is that the <a class="el" href="classFESystem.html">FESystem</a> class doesn't care. The <em>interpretation</em> of what the components mean is up to the person who uses the element later, for example in assembling a linear form, or in extracting data solution components for a linearized system in the next Newton step. In almost all cases, this interpretation happens at the place where it is needed.</p>
<p>There is one case where one has to be explicit, however, and that is in generating graphical output. The reason is that many file formats for visualization want data that represents vectors (e.g. velocities, displacements, etc) to be stored separately from scalars (pressures, densities, etc), and there often is no way to group a bunch of scalars into a vector field from within a visualization program.</p>
<p>To achieve this, we need to let the <a class="el" href="classDataOut.html">DataOut</a> class and friends know which components of the <a class="el" href="classFESystem.html">FESystem</a> form vectors (with <code>dim</code> components) and which are scalars. This is shown, for example, in step-22 where we generate output as follows: </p><div class="fragment"><div class="line">std::vector&lt;std::string&gt; solution_names (dim, <span class="stringliteral">&quot;velocity&quot;</span>);</div><div class="line">solution_names.push_back (<span class="stringliteral">&quot;pressure&quot;</span>);</div><div class="line"></div><div class="line">std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt;</div><div class="line">  data_component_interpretation</div><div class="line">  (dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>);</div><div class="line">data_component_interpretation</div><div class="line">  .push_back (<a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>);</div><div class="line"></div><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (dof_handler);</div><div class="line">data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (solution, solution_names,</div><div class="line">                          <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;::type_dof_data</a>,</div><div class="line">                          data_component_interpretation);</div><div class="line">data_out.<a class="code" href="classDataOut.html#ab6b584c378c08f9b7ee4ca474405fed0">build_patches</a> ();</div></div><!-- fragment --><p> In other words, we here create an array of <code>dim+1</code> elements in which we store which elements of the finite element are vectors and which are scalars; the array is filled with <code>dim</code> copies of <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a> and a single trailing element of <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a> . The array is then given as an extra argument to <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> to explain how the data in the given solution vector is to be interpreted. Visualization programs like VisIt and Paraview will then offer to show these <code>dim</code> components as vector fields, rather than as individual scalar fields. </p>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
