<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseDirectUMFPACK.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseDirectUMFPACK Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSparseDirectUMFPACK-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseDirectUMFPACK Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Solvers.html">Linear solver classes</a><a class="el" href="group__LAC.html">Linear algebra classes</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__direct_8h_source.html">deal.II/lac/sparse_direct.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseDirectUMFPACK:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseDirectUMFPACK__inherit__graph.svg" width="175" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a57d3f2a6db0c0adb16f2cdc5d559373a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a57d3f2a6db0c0adb16f2cdc5d559373a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:adb7961d3df78499fd885763482a77ecc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#adb7961d3df78499fd885763482a77ecc">SparseDirectUMFPACK</a> ()</td></tr>
<tr class="separator:adb7961d3df78499fd885763482a77ecc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ec8a55b7640e50ed26446bbf46c0203"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a1ec8a55b7640e50ed26446bbf46c0203">~SparseDirectUMFPACK</a> () override</td></tr>
<tr class="separator:a1ec8a55b7640e50ed26446bbf46c0203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3003428917fd19a55a7b1fec403e3ad5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a3003428917fd19a55a7b1fec403e3ad5">DeclException2</a> (ExcUMFPACKError, std::string, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;UMFPACK routine &quot;&lt;&lt; arg1&lt;&lt; &quot; returned error status &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&lt;&lt; &quot;\&quot;&lt;&lt;(&quot;A complete list of error codes can be found in the file &quot; &quot;&lt;bundled/umfpack/UMFPACK/Include/umfpack.h&gt;.&quot; &quot;\&quot; &quot;That said, the two most common errors that can happen are &quot; &quot;that your matrix cannot be factorized because it is &quot; &quot;rank deficient, and that UMFPACK runs out of memory &quot; &quot;because your problem is too large.&quot; &quot;\&quot; &quot;The first of these cases most often happens if you &quot; &quot;forget terms in your bilinear form necessary to ensure &quot; &quot;that the matrix has full rank, or if your equation has a &quot; &quot;spatially variable coefficient (or nonlinearity) that is &quot; &quot;supposed to be strictly positive but, for whatever &quot; &quot;reasons, is negative or zero. In either case, you probably &quot; &quot;want to check your assembly procedure. Similarly, a &quot; &quot;matrix can be rank deficient if you forgot to apply the &quot; &quot;appropriate boundary conditions. For example, the &quot; &quot;Laplace equation for a problem where only Neumann boundary &quot; &quot;conditions are posed (or where you forget to apply Dirichlet &quot; &quot;boundary conditions) has exactly one eigenvalue <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to zero &quot; &quot;and its rank is therefore deficient by one. Finally, the matrix &quot; &quot;may be rank deficient because you are using a quadrature &quot; &quot;formula with too few quadrature points.&quot; &quot;\&quot; &quot;The other common situation is that you run out of memory. &quot; &quot;On a typical laptop or desktop, it should easily be possible &quot; &quot;to <a class="el" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a> problems with 100,000 unknowns in 2d. If you are &quot; &quot;solving problems with many more unknowns than that, in &quot; &quot;particular if you are in 3d, then you may be running out &quot; &quot;of memory and you will need to consider iterative &quot; &quot;solvers instead of the direct solver employed by &quot; &quot;UMFPACK.&quot;))</td></tr>
<tr class="separator:a3003428917fd19a55a7b1fec403e3ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Setting up a sparse factorization</div></td></tr>
<tr class="memitem:a25b1d3c7dbb88158a76165a4a56a16d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a25b1d3c7dbb88158a76165a4a56a16d6">initialize</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity_pattern)</td></tr>
<tr class="separator:a25b1d3c7dbb88158a76165a4a56a16d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3493095277b2e533c03ced257630a14"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:ab3493095277b2e533c03ced257630a14"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#ab3493095277b2e533c03ced257630a14">factorize</a> (const Matrix &amp;matrix)</td></tr>
<tr class="separator:ab3493095277b2e533c03ced257630a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23a74dd9cac006c9d87c18e5d638076"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:af23a74dd9cac006c9d87c18e5d638076"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#af23a74dd9cac006c9d87c18e5d638076">initialize</a> (const Matrix &amp;matrix, const <a class="el" href="classSparseDirectUMFPACK_1_1AdditionalData.html">AdditionalData</a> additional_data=<a class="el" href="classSparseDirectUMFPACK_1_1AdditionalData.html">AdditionalData</a>())</td></tr>
<tr class="separator:af23a74dd9cac006c9d87c18e5d638076"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions that represent the inverse of a matrix</div></td></tr>
<tr class="memitem:adc154e4830b0e16be265f10a5c8b7103"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;src) const</td></tr>
<tr class="separator:adc154e4830b0e16be265f10a5c8b7103"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47bfdb10626ef319d248a15ad5b4bfe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a47bfdb10626ef319d248a15ad5b4bfe9">vmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;src) const</td></tr>
<tr class="separator:a47bfdb10626ef319d248a15ad5b4bfe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35891c5581473707d1cbc360ae67b89d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a35891c5581473707d1cbc360ae67b89d">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;src) const</td></tr>
<tr class="separator:a35891c5581473707d1cbc360ae67b89d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0988c7a7119f7d1edb6fbfe0936e0c25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a0988c7a7119f7d1edb6fbfe0936e0c25">Tvmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;src) const</td></tr>
<tr class="separator:a0988c7a7119f7d1edb6fbfe0936e0c25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476c31b8baf8b1a8c5fa113376ef206b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a476c31b8baf8b1a8c5fa113376ef206b">m</a> () const</td></tr>
<tr class="separator:a476c31b8baf8b1a8c5fa113376ef206b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab12fbeeaed3b82ef0ebd45eb413d12e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#aab12fbeeaed3b82ef0ebd45eb413d12e">n</a> () const</td></tr>
<tr class="separator:aab12fbeeaed3b82ef0ebd45eb413d12e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions that solve linear systems</div></td></tr>
<tr class="memitem:a713849cd6eeacc629a2b621c19857242"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve</a> (<a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false) const</td></tr>
<tr class="separator:a713849cd6eeacc629a2b621c19857242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf980aea59ea33cf497e679979dcdf6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#adf980aea59ea33cf497e679979dcdf6a">solve</a> (<a class="el" href="classVector.html">Vector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false) const</td></tr>
<tr class="separator:adf980aea59ea33cf497e679979dcdf6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b62341a313440a035bf558c2f3a99a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a44b62341a313440a035bf558c2f3a99a">solve</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false) const</td></tr>
<tr class="separator:a44b62341a313440a035bf558c2f3a99a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb6851ebe76836aa7f5f5b15df511fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a4fb6851ebe76836aa7f5f5b15df511fe">solve</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false) const</td></tr>
<tr class="separator:a4fb6851ebe76836aa7f5f5b15df511fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5481014ce2e160eb5c4fd7fdb2324b"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a8f5481014ce2e160eb5c4fd7fdb2324b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a8f5481014ce2e160eb5c4fd7fdb2324b">solve</a> (const Matrix &amp;matrix, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false)</td></tr>
<tr class="separator:a8f5481014ce2e160eb5c4fd7fdb2324b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11cf43ea9c9628f233e9cf0178cc2ff9"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a11cf43ea9c9628f233e9cf0178cc2ff9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a11cf43ea9c9628f233e9cf0178cc2ff9">solve</a> (const Matrix &amp;matrix, <a class="el" href="classVector.html">Vector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false)</td></tr>
<tr class="separator:a11cf43ea9c9628f233e9cf0178cc2ff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a044f8fa5b6cdf89fb30d410d2fb1b059"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a044f8fa5b6cdf89fb30d410d2fb1b059"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a044f8fa5b6cdf89fb30d410d2fb1b059">solve</a> (const Matrix &amp;matrix, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false)</td></tr>
<tr class="separator:a044f8fa5b6cdf89fb30d410d2fb1b059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85b4d1ded23f1a956443c13b528e0a3d"><td class="memTemplParams" colspan="2">template&lt;class Matrix &gt; </td></tr>
<tr class="memitem:a85b4d1ded23f1a956443c13b528e0a3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a85b4d1ded23f1a956443c13b528e0a3d">solve</a> (const Matrix &amp;matrix, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;rhs_and_solution, const <a class="el" href="classbool.html">bool</a> <a class="el" href="tensor_8h.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a>=false)</td></tr>
<tr class="separator:a85b4d1ded23f1a956443c13b528e0a3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac8ccd9015afa92eff2141cacbba92f27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#ac8ccd9015afa92eff2141cacbba92f27">clear</a> ()</td></tr>
<tr class="separator:ac8ccd9015afa92eff2141cacbba92f27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f08924b9c05dbc4c4794d61ee23fb82"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a8f08924b9c05dbc4c4794d61ee23fb82"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a8f08924b9c05dbc4c4794d61ee23fb82">sort_arrays</a> (const <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a>&lt; number &gt; &amp;)</td></tr>
<tr class="separator:a8f08924b9c05dbc4c4794d61ee23fb82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2aa3b8eefe3c7dab0423e024538a085"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:ab2aa3b8eefe3c7dab0423e024538a085"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#ab2aa3b8eefe3c7dab0423e024538a085">sort_arrays</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;)</td></tr>
<tr class="separator:ab2aa3b8eefe3c7dab0423e024538a085"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89de20908e57f7b8b3761d18441f131d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a89de20908e57f7b8b3761d18441f131d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a89de20908e57f7b8b3761d18441f131d">sort_arrays</a> (const <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;)</td></tr>
<tr class="separator:a89de20908e57f7b8b3761d18441f131d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a2a91f83b5ad44c978a6280756d12ff2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a2a91f83b5ad44c978a6280756d12ff2a">n_rows</a></td></tr>
<tr class="separator:a2a91f83b5ad44c978a6280756d12ff2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9702ef39a47656dbae51121babf736"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#aeb9702ef39a47656dbae51121babf736">n_cols</a></td></tr>
<tr class="separator:aeb9702ef39a47656dbae51121babf736"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5653af4fd4c4ea56e023c17ce31a35ee"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a5653af4fd4c4ea56e023c17ce31a35ee">symbolic_decomposition</a></td></tr>
<tr class="separator:a5653af4fd4c4ea56e023c17ce31a35ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e14cc6b2b73bdc8c61b986d6b790b4f"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a1e14cc6b2b73bdc8c61b986d6b790b4f">numeric_decomposition</a></td></tr>
<tr class="separator:a1e14cc6b2b73bdc8c61b986d6b790b4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c58b38e38cb83ca52bb5bd03f38b57"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a43d3a1573aaa7460bfe43f7a113cf2cf">types::suitesparse_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#ae5c58b38e38cb83ca52bb5bd03f38b57">Ap</a></td></tr>
<tr class="separator:ae5c58b38e38cb83ca52bb5bd03f38b57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1f761291c7aac92194a990a903f2d37"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespacetypes.html#a43d3a1573aaa7460bfe43f7a113cf2cf">types::suitesparse_index</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#af1f761291c7aac92194a990a903f2d37">Ai</a></td></tr>
<tr class="separator:af1f761291c7aac92194a990a903f2d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ed75c631fcff7e91738423d5254dbba"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a7ed75c631fcff7e91738423d5254dbba">Ax</a></td></tr>
<tr class="separator:a7ed75c631fcff7e91738423d5254dbba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e11a30bf1c06ab1a83456e267464353"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#a0e11a30bf1c06ab1a83456e267464353">Az</a></td></tr>
<tr class="separator:a0e11a30bf1c06ab1a83456e267464353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5cd0a5382d602f1068fd3f230e35033"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseDirectUMFPACK.html#ac5cd0a5382d602f1068fd3f230e35033">control</a></td></tr>
<tr class="separator:ac5cd0a5382d602f1068fd3f230e35033"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class provides an interface to the sparse direct solver UMFPACK, which is part of the SuiteSparse library (see <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html">this link</a>). UMFPACK is a set of routines for solving non-symmetric sparse linear systems, Ax=b, using the Unsymmetric-pattern MultiFrontal method and direct sparse LU factorization. Matrices may have symmetric or unsymmetric sparsity patterns, and may have unsymmetric entries. The use of this class is explained in the step-22 and step-29 tutorial programs.</p>
<p>This matrix class implements the usual interface of preconditioners, that is a function initialize(const SparseMatrix&lt;double&gt;&amp;matrix,const <a class="el" href="classSparseDirectUMFPACK_1_1AdditionalData.html">AdditionalData</a>) for initializing and the whole set of <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult()</a> functions common to all matrices. Implemented here are only <a class="el" href="classSparseDirectUMFPACK.html#adc154e4830b0e16be265f10a5c8b7103">vmult()</a> and vmult_add(), which perform multiplication with the inverse matrix. Furthermore, this class provides an older interface, consisting of the functions <a class="el" href="classSparseDirectUMFPACK.html#ab3493095277b2e533c03ced257630a14">factorize()</a> and <a class="el" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve()</a>. Both interfaces are interchangeable.</p>
<dl class="section note"><dt>Note</dt><dd>This class exists if the <a href="http://faculty.cse.tamu.edu/davis/suitesparse.html">UMFPACK</a> interface was not explicitly disabled during configuration.</dd>
<dd>
UMFPACK has its own license, independent of that of deal.II. If you want to use the UMFPACK you have to accept that license. It is linked to from the deal.II ReadMe file. UMFPACK is included courtesy of its author, <a href="http://faculty.cse.tamu.edu/davis/welcome.html">Timothy A. Davis</a>.</dd></dl>
<h4>Instantiations</h4>
<p>There are instantiations of this class for SparseMatrix&lt;double&gt;, SparseMatrix&lt;float&gt;, SparseMatrixEZ&lt;float&gt;, SparseMatrixEZ&lt;double&gt;, BlockSparseMatrix&lt;double&gt;, and BlockSparseMatrix&lt;float&gt;. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00087">87</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a57d3f2a6db0c0adb16f2cdc5d559373a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d3f2a6db0c0adb16f2cdc5d559373a">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">SparseDirectUMFPACK::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00093">93</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adb7961d3df78499fd885763482a77ecc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7961d3df78499fd885763482a77ecc">&#9670;&nbsp;</a></span>SparseDirectUMFPACK()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparseDirectUMFPACK::SparseDirectUMFPACK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. See the documentation of this class for the meaning of the parameters to this function. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00055">55</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a1ec8a55b7640e50ed26446bbf46c0203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ec8a55b7640e50ed26446bbf46c0203">&#9670;&nbsp;</a></span>~SparseDirectUMFPACK()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SparseDirectUMFPACK::~SparseDirectUMFPACK </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00042">42</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a25b1d3c7dbb88158a76165a4a56a16d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25b1d3c7dbb88158a76165a4a56a16d6">&#9670;&nbsp;</a></span>initialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does nothing. It is only here to provide a interface consistent with other sparse direct solvers. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00049">49</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="ab3493095277b2e533c03ced257630a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3493095277b2e533c03ced257630a14">&#9670;&nbsp;</a></span>factorize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::factorize </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Factorize the matrix. This function may be called multiple times for different matrices, after the object of this class has been initialized for a certain sparsity pattern. You may therefore save some computing time if you want to invert several matrices with the same sparsity pattern. However, note that the bulk of the computing time is actually spent in the factorization, so this functionality may not always be of large benefit.</p>
<p>In contrast to the other direct solver classes, the initialization method does nothing. Therefore initialize is not automatically called by this method, when the initialization step has not been performed yet.</p>
<p>This function copies the contents of the matrix into its own storage; the matrix can therefore be deleted after this operation, even if subsequent solves are required. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00214">214</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="af23a74dd9cac006c9d87c18e5d638076"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23a74dd9cac006c9d87c18e5d638076">&#9670;&nbsp;</a></span>initialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::initialize </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseDirectUMFPACK_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>additional_data</em> = <code><a class="el" href="classSparseDirectUMFPACK_1_1AdditionalData.html">AdditionalData</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize memory and call <a class="el" href="classSparseDirectUMFPACK.html#ab3493095277b2e533c03ced257630a14">SparseDirectUMFPACK::factorize</a>. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00755">755</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="adc154e4830b0e16be265f10a5c8b7103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc154e4830b0e16be265f10a5c8b7103">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Preconditioner interface function. Usually, given the source vector, this method returns an approximate solution of <em>Ax = b</em>. As this class provides a wrapper to a direct solver, here it is actually the exact solution (exact within the range of numerical accuracy of course).</p>
<p>In other words, this function actually multiplies with the exact inverse of the matrix, \(A^{-1}\). </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00762">762</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a47bfdb10626ef319d248a15ad5b4bfe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47bfdb10626ef319d248a15ad5b4bfe9">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for block vectors. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00771">771</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a35891c5581473707d1cbc360ae67b89d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35891c5581473707d1cbc360ae67b89d">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but uses the transpose of the matrix, i.e. this function multiplies with \(A^{-T}\). </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00780">780</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a0988c7a7119f7d1edb6fbfe0936e0c25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0988c7a7119f7d1edb6fbfe0936e0c25">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for block vectors </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00790">790</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a476c31b8baf8b1a8c5fa113376ef206b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476c31b8baf8b1a8c5fa113376ef206b">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">SparseDirectUMFPACK::size_type</a> SparseDirectUMFPACK::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the codomain (or range) space. Note that the matrix is of dimension \(m \times n\). </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00798">798</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="aab12fbeeaed3b82ef0ebd45eb413d12e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab12fbeeaed3b82ef0ebd45eb413d12e">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">SparseDirectUMFPACK::size_type</a> SparseDirectUMFPACK::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the domain space. Note that the matrix is of dimension \(m \times n\). </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00805">805</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a713849cd6eeacc629a2b621c19857242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713849cd6eeacc629a2b621c19857242">&#9670;&nbsp;</a></span>solve() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve for a certain right hand side vector. This function may be called multiple times for different right hand side vectors after the matrix has been factorized. This yields substantial savings in computing time, since the actual solution is fast, compared to the factorization of the matrix.</p>
<p>The solution will be returned in place of the right hand side vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">rhs_and_solution</td><td>A vector that contains the right hand side \(b\) of a linear system \(Ax=b\) upon calling this function, and that contains the solution \(x\) of the linear system after calling this function. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">transpose</td><td>If set to true, this function solves the linear \(A^T x = b\) instead of \(Ax=b\).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>You need to call <a class="el" href="classSparseDirectUMFPACK.html#ab3493095277b2e533c03ced257630a14">factorize()</a> before this function can be called. </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00344">344</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="adf980aea59ea33cf497e679979dcdf6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf980aea59ea33cf497e679979dcdf6a">&#9670;&nbsp;</a></span>solve() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but for a complex-valued right hand side and solution vector.</p>
<p>If the matrix that was previously factorized had complex-valued entries, then the <code>rhs_and_solution</code> vector will, upon return from this function, simply contain the solution of the linear system \(Ax=b\). If the matrix was real-valued, then this is also true, but the solution will simply be computed by applying the factorized \(A^{-1}\) to both the real and imaginary parts of the right hand side vector. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00384">384</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a44b62341a313440a035bf558c2f3a99a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b62341a313440a035bf558c2f3a99a">&#9670;&nbsp;</a></span>solve() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for block vectors. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00499">499</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a4fb6851ebe76836aa7f5f5b15df511fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb6851ebe76836aa7f5f5b15df511fe">&#9670;&nbsp;</a></span>solve() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for complex-valued block vectors. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00514">514</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a8f5481014ce2e160eb5c4fd7fdb2324b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5481014ce2e160eb5c4fd7fdb2324b">&#9670;&nbsp;</a></span>solve() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the two functions <a class="el" href="classSparseDirectUMFPACK.html#ab3493095277b2e533c03ced257630a14">factorize()</a> and <a class="el" href="classSparseDirectUMFPACK.html#a713849cd6eeacc629a2b621c19857242">solve()</a> in that order, i.e. perform the whole solution process for the given right hand side vector.</p>
<p>The solution will be returned in place of the right hand side vector. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00540">540</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a11cf43ea9c9628f233e9cf0178cc2ff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11cf43ea9c9628f233e9cf0178cc2ff9">&#9670;&nbsp;</a></span>solve() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for complex-valued solution vectors. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00552">552</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a044f8fa5b6cdf89fb30d410d2fb1b059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a044f8fa5b6cdf89fb30d410d2fb1b059">&#9670;&nbsp;</a></span>solve() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for block vectors. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00576">576</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a85b4d1ded23f1a956443c13b528e0a3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85b4d1ded23f1a956443c13b528e0a3d">&#9670;&nbsp;</a></span>solve() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Matrix &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::solve </td>
          <td>(</td>
          <td class="paramtype">const Matrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; std::complex&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_and_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as before, but for complex-valued block vectors. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00588">588</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a3003428917fd19a55a7b1fec403e3ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3003428917fd19a55a7b1fec403e3ad5">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SparseDirectUMFPACK::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcUMFPACKError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;UMFPACK routine &quot;&lt;&lt; arg1&lt;&lt; &quot; returned error status &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;&lt;&lt; &quot;&lt;&lt;&#160;</td>
          <td class="paramname">&quot;A complete list of error codes can be found in the file &quot; &quot;&lt; bundled/umfpack/UMFPACK/Include/umfpack.h &gt;.&quot; &quot;\&quot; &quot;That said, the two most common errors that can happen are &quot; &quot;that your matrix cannot be factorized because it is &quot; &quot;rank deficient, and that UMFPACK runs out of memory &quot; &quot;because your problem is too large.&quot; &quot;\&quot; &quot;The first of these cases most often happens if you &quot; &quot;forget terms in your bilinear form necessary to ensure &quot; &quot;that the matrix has full rank, or if your equation has a &quot; &quot;spatially variable coefficient(or nonlinearity) that is &quot; &quot;supposed to be strictly positive but, for whatever &quot; &quot;reasons, is negative or zero. In either case, you probably &quot; &quot;want to check your assembly procedure. Similarly, a &quot; &quot;matrix can be rank deficient if you forgot to apply the &quot; &quot;appropriate boundary conditions. For example, the &quot; &quot;Laplace equation for a problem where only Neumann boundary &quot; &quot;conditions are posed(or where you forget to apply Dirichlet &quot; &quot;boundary conditions) has exactly one eigenvalue equal to zero &quot; &quot;and its rank is therefore deficient by one. Finally, the matrix &quot; &quot;may be rank deficient because you are using a quadrature &quot; &quot;formula with too few quadrature points.&quot; &quot;\&quot; &quot;The other common situation is that you run out of memory. &quot; &quot;On a typical laptop or desktop, it should easily be possible &quot; &quot;to solve problems with 100, 000 unknowns in 2d. If you are &quot; &quot;solving problems with many more unknowns than that, in &quot; &quot;particular if you are in 3d, then you may be running out &quot; &quot;of memory and you will need to consider iterative &quot; &quot;solvers instead of the direct solver employed by &quot; &quot;UMFPACK.&quot;&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One of the UMFPack routines threw an error. The error code is included in the output and can be looked up in the UMFPack user manual. The name of the routine is included for reference. </p>

</div>
</div>
<a id="ac8ccd9015afa92eff2141cacbba92f27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ccd9015afa92eff2141cacbba92f27">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Free all memory that hasn't been freed yet. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00068">68</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a8f08924b9c05dbc4c4794d61ee23fb82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f08924b9c05dbc4c4794d61ee23fb82">&#9670;&nbsp;</a></span>sort_arrays() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::sort_arrays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure that the arrays Ai and Ap are sorted in each row. UMFPACK wants it this way. We need to have three versions of this function, one for the usual <a class="el" href="classSparseMatrix.html">SparseMatrix</a>, one for the <a class="el" href="classSparseMatrixEZ.html">SparseMatrixEZ</a>, and one for the <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> classes </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00150">150</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="ab2aa3b8eefe3c7dab0423e024538a085"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2aa3b8eefe3c7dab0423e024538a085">&#9670;&nbsp;</a></span>sort_arrays() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::sort_arrays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00110">110</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a89de20908e57f7b8b3761d18441f131d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89de20908e57f7b8b3761d18441f131d">&#9670;&nbsp;</a></span>sort_arrays() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void SparseDirectUMFPACK::sort_arrays </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__direct_8cc_source.html#l00173">173</a> of file <a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a2a91f83b5ad44c978a6280756d12ff2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a91f83b5ad44c978a6280756d12ff2a">&#9670;&nbsp;</a></span>n_rows</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a> SparseDirectUMFPACK::n_rows</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the range space, i.e., the number of rows of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00364">364</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="aeb9702ef39a47656dbae51121babf736"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9702ef39a47656dbae51121babf736">&#9670;&nbsp;</a></span>n_cols</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseDirectUMFPACK.html#a57d3f2a6db0c0adb16f2cdc5d559373a">size_type</a> SparseDirectUMFPACK::n_cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the domain space, i.e., the number of columns of the matrix. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00370">370</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="a5653af4fd4c4ea56e023c17ce31a35ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5653af4fd4c4ea56e023c17ce31a35ee">&#9670;&nbsp;</a></span>symbolic_decomposition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* SparseDirectUMFPACK::symbolic_decomposition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The UMFPACK routines allocate objects in which they store information about symbolic and numeric values of the decomposition. The actual data type of these objects is opaque, and only passed around as void pointers. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00377">377</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="a1e14cc6b2b73bdc8c61b986d6b790b4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e14cc6b2b73bdc8c61b986d6b790b4f">&#9670;&nbsp;</a></span>numeric_decomposition</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* SparseDirectUMFPACK::numeric_decomposition</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00378">378</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="ae5c58b38e38cb83ca52bb5bd03f38b57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c58b38e38cb83ca52bb5bd03f38b57">&#9670;&nbsp;</a></span>Ap</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a43d3a1573aaa7460bfe43f7a113cf2cf">types::suitesparse_index</a>&gt; SparseDirectUMFPACK::Ap</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The arrays in which we store the data for the solver. These are documented in the descriptions of the umfpack_*_symbolic() and umfpack_*_numeric() functions, but in short:</p><ul>
<li><code>Ap</code> is the array saying which row starts where in <code>Ai</code></li>
<li><code>Ai</code> is the array that stores the column indices of nonzero entries</li>
<li><code>Ax</code> is the array that stores the values of nonzero entries; if the matrix is complex-valued, then it stores the real parts</li>
<li><code>Az</code> is the array that stores the imaginary parts of nonzero entries, and is used only if the matrix is complex-valued. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00415">415</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="af1f761291c7aac92194a990a903f2d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1f761291c7aac92194a990a903f2d37">&#9670;&nbsp;</a></span>Ai</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespacetypes.html#a43d3a1573aaa7460bfe43f7a113cf2cf">types::suitesparse_index</a>&gt; SparseDirectUMFPACK::Ai</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00416">416</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="a7ed75c631fcff7e91738423d5254dbba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ed75c631fcff7e91738423d5254dbba">&#9670;&nbsp;</a></span>Ax</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; SparseDirectUMFPACK::Ax</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00417">417</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="a0e11a30bf1c06ab1a83456e267464353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e11a30bf1c06ab1a83456e267464353">&#9670;&nbsp;</a></span>Az</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; SparseDirectUMFPACK::Az</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00418">418</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<a id="ac5cd0a5382d602f1068fd3f230e35033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5cd0a5382d602f1068fd3f230e35033">&#9670;&nbsp;</a></span>control</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classdouble.html">double</a>&gt; SparseDirectUMFPACK::control</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Control and work arrays for the solver routines. </p>

<p class="definition">Definition at line <a class="el" href="sparse__direct_8h_source.html#l00423">423</a> of file <a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__direct_8h_source.html">sparse_direct.h</a></li>
<li>source/lac/<a class="el" href="sparse__direct_8cc_source.html">sparse_direct.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
