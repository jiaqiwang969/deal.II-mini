<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseVanka.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseVanka&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSparseVanka-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseVanka&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__vanka_8h_source.html">deal.II/lac/sparse_vanka.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseVanka&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseVanka__inherit__graph.svg" width="211" height="112"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:af523ea3caee731b5679560ab716e10cd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:af523ea3caee731b5679560ab716e10cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab78b48bc19c8ed47b648f49bc1dce86f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#ab78b48bc19c8ed47b648f49bc1dce86f">SparseVanka</a> ()</td></tr>
<tr class="separator:ab78b48bc19c8ed47b648f49bc1dce86f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a085f849167d97c47f7bd8e5616403b1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a085f849167d97c47f7bd8e5616403b1d">SparseVanka</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classSparseVanka.html#ab1c1073cd133bb81b5875b341eb32925">selected</a>, const <a class="el" href="classbool.html">bool</a> conserve_memory, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>())</td></tr>
<tr class="separator:a085f849167d97c47f7bd8e5616403b1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada2d29d0432f512fcc10d2c72c8597e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#ada2d29d0432f512fcc10d2c72c8597e8">SparseVanka</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classSparseVanka.html#ab1c1073cd133bb81b5875b341eb32925">selected</a>)</td></tr>
<tr class="separator:ada2d29d0432f512fcc10d2c72c8597e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8efa61d88f54f6d6467c0c78b28a81b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a8efa61d88f54f6d6467c0c78b28a81b7">~SparseVanka</a> ()</td></tr>
<tr class="separator:a8efa61d88f54f6d6467c0c78b28a81b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e2ce1949e40a2f6d09fe4d870670988"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a6e2ce1949e40a2f6d09fe4d870670988">initialize</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;M, const <a class="el" href="classSparseVanka_1_1AdditionalData.html">AdditionalData</a> &amp;additional_data)</td></tr>
<tr class="separator:a6e2ce1949e40a2f6d09fe4d870670988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1113cdacf0fa509b4cf58323c0104e"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9c1113cdacf0fa509b4cf58323c0104e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a9c1113cdacf0fa509b4cf58323c0104e">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:a9c1113cdacf0fa509b4cf58323c0104e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9244a620a91b61ee03f70edbf2e52ba7"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9244a620a91b61ee03f70edbf2e52ba7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a9244a620a91b61ee03f70edbf2e52ba7">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:a9244a620a91b61ee03f70edbf2e52ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1161f72e2921f4cf53584ddddca91665"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a1161f72e2921f4cf53584ddddca91665">m</a> () const</td></tr>
<tr class="separator:a1161f72e2921f4cf53584ddddca91665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41b1fb0a899949cc4b31a61dc386ef9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a41b1fb0a899949cc4b31a61dc386ef9a">n</a> () const</td></tr>
<tr class="separator:a41b1fb0a899949cc4b31a61dc386ef9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ae7569b43f4519137cc98f30ada15e1ee"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae7569b43f4519137cc98f30ada15e1ee"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#ae7569b43f4519137cc98f30ada15e1ee">apply_preconditioner</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *const dof_mask=nullptr) const</td></tr>
<tr class="separator:ae7569b43f4519137cc98f30ada15e1ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a290a70aaffdcb0835b82894bda2dbf32"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a290a70aaffdcb0835b82894bda2dbf32">memory_consumption</a> () const</td></tr>
<tr class="separator:a290a70aaffdcb0835b82894bda2dbf32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a22bf9cb75f1304f8623aa24c2c5bc6cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a22bf9cb75f1304f8623aa24c2c5bc6cf">compute_inverses</a> ()</td></tr>
<tr class="separator:a22bf9cb75f1304f8623aa24c2c5bc6cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68a3571b29d6b2068d66e4f950eeb2bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a68a3571b29d6b2068d66e4f950eeb2bb">compute_inverses</a> (const <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> begin, const <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> end)</td></tr>
<tr class="separator:a68a3571b29d6b2068d66e4f950eeb2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aff37f288ae7f9900f6c22128cf8026"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a2aff37f288ae7f9900f6c22128cf8026">compute_inverse</a> (const <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> row, std::vector&lt; <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> &gt; &amp;local_indices)</td></tr>
<tr class="separator:a2aff37f288ae7f9900f6c22128cf8026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a1e8f09281aaf4fbfbf90093edbf02447"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;, <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a1e8f09281aaf4fbfbf90093edbf02447">matrix</a></td></tr>
<tr class="separator:a1e8f09281aaf4fbfbf90093edbf02447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c1073cd133bb81b5875b341eb32925"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#ab1c1073cd133bb81b5875b341eb32925">selected</a></td></tr>
<tr class="separator:ab1c1073cd133bb81b5875b341eb32925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253f2afee116f7fff25ad542f0cb64b0"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; float &gt;, <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a253f2afee116f7fff25ad542f0cb64b0">inverses</a></td></tr>
<tr class="separator:a253f2afee116f7fff25ad542f0cb64b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1edfa7ce100331a4423d8e2c5133cc08"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a1edfa7ce100331a4423d8e2c5133cc08">_m</a></td></tr>
<tr class="separator:a1edfa7ce100331a4423d8e2c5133cc08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187cb7f6f5003a746ab61627d075a931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a187cb7f6f5003a746ab61627d075a931">_n</a></td></tr>
<tr class="separator:a187cb7f6f5003a746ab61627d075a931"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a124076b34c9c5c998b7d5b64ffb0cfc7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a124076b34c9c5c998b7d5b64ffb0cfc7"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseVanka.html#a124076b34c9c5c998b7d5b64ffb0cfc7">SparseBlockVanka</a></td></tr>
<tr class="separator:a124076b34c9c5c998b7d5b64ffb0cfc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class SparseVanka&lt; number &gt;</h3>

<p>Point-wise Vanka preconditioning. This class does Vanka preconditioning on a point-wise base. Vanka preconditioners are used for saddle point problems like Stokes' problem or problems arising in optimization where Lagrange multipliers occur and the Newton method matrix has a zero block. With these matrices the application of Jacobi or Gauss-Seidel methods is impossible, because some diagonal elements are zero in the rows of the Lagrange multiplier. The approach of Vanka is to solve a small (usually indefinite) system of equations for each Langrange multiplier variable (we will also call the pressure in Stokes' equation a Langrange multiplier since it can be interpreted as such).</p>
<p>Objects of this class are constructed by passing a vector of indices of the degrees of freedom of the Lagrange multiplier. In the actual preconditioning method, these rows are traversed in the order in which the appear in the matrix. Since this is a Gauß-Seidel like procedure, remember to have a good ordering in advance (for transport dominated problems, Cuthill-McKee algorithms are a good means for this, if points on the inflow boundary are chosen as starting points for the renumbering).</p>
<p>For each selected degree of freedom, a local system of equations is built by the degree of freedom itself and all other values coupling immediately, i.e. the set of degrees of freedom considered for the local system of equations for degree of freedom <code>i</code> is <code>i</code> itself and all <code>j</code> such that the element <code>(i,j)</code> is a nonzero entry in the sparse matrix under consideration. The elements <code>(j,i)</code> are not considered. We now pick all matrix entries from rows and columns out of the set of degrees of freedom just described out of the global matrix and put it into a local matrix, which is subsequently inverted. This system may be of different size for each degree of freedom, depending for example on the local neighborhood of the respective node on a computational grid.</p>
<p>The right hand side is built up in the same way, i.e. by copying all entries that coupled with the one under present consideration, but it is augmented by all degrees of freedom coupling with the degrees from the set described above (i.e. the DoFs coupling second order to the present one). The reason for this is, that the local problems to be solved shall have Dirichlet boundary conditions on the second order coupling DoFs, so we have to take them into account but eliminate them before actually solving; this elimination is done by the modification of the right hand side, and in the end these degrees of freedom do not occur in the matrix and solution vector any more at all.</p>
<p>This local system is solved and the values are updated into the destination vector.</p>
<p>Remark: the Vanka method is a non-symmetric preconditioning method.</p>
<h3>Example of Use</h3>
<p>This little example is taken from a program doing parameter optimization. The Lagrange multiplier is the third component of the finite element used. The system is solved by the GMRES method. </p><div class="fragment"><div class="line"><span class="comment">// tag the Lagrange multiplier variable</span></div><div class="line">vector&lt;bool&gt; signature(3);</div><div class="line">signature[0] = signature[1] = <span class="keyword">false</span>;</div><div class="line">signature[2] = <span class="keyword">true</span>;</div><div class="line"></div><div class="line"><span class="comment">// tag all dofs belonging to the Lagrange multiplier</span></div><div class="line">vector&lt;bool&gt; selected_dofs (dof.n_dofs(), <span class="keyword">false</span>);</div><div class="line"><a class="code" href="namespaceDoFTools.html#a45f4d01f1c4c6337e4be6f10a81fbdab">DoFTools::extract_dofs</a>(dof, signature, p_select);</div><div class="line"><span class="comment">// create the Vanka object</span></div><div class="line"><a class="code" href="classSparseVanka.html">SparseVanka&lt;double&gt;</a> vanka (global_matrix, selected_dofs);</div><div class="line"></div><div class="line"><span class="comment">// create the solver</span></div><div class="line"><a class="code" href="classSolverGMRES.html">SolverGMRES&lt;&gt;</a> gmres(control,memory,504);</div><div class="line"></div><div class="line"><span class="comment">// solve</span></div><div class="line">gmres.solve (global_matrix, solution, right_hand_side,</div><div class="line">             vanka);</div></div><!-- fragment --><h4>Implementor's remark</h4>
<p>At present, the local matrices are built up such that the degree of freedom associated with the local Lagrange multiplier is the first one. Thus, usually the upper left entry in the local matrix is zero. It is not clear to me (W.B.) whether this might pose some problems in the inversion of the local matrices. Maybe someone would like to check this.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual). </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00137">137</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="af523ea3caee731b5679560ab716e10cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af523ea3caee731b5679560ab716e10cd">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::<a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare type for container size. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00143">143</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab78b48bc19c8ed47b648f49bc1dce86f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab78b48bc19c8ed47b648f49bc1dce86f">&#9670;&nbsp;</a></span>SparseVanka() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::<a class="el" href="classSparseVanka.html">SparseVanka</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Does nothing.</p>
<p>Call the <a class="el" href="classSparseVanka.html#a6e2ce1949e40a2f6d09fe4d870670988">initialize()</a> function before using this object as preconditioner (<a class="el" href="classSparseVanka.html#a9c1113cdacf0fa509b4cf58323c0104e">vmult()</a>). </p>

</div>
</div>
<a id="a085f849167d97c47f7bd8e5616403b1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085f849167d97c47f7bd8e5616403b1d">&#9670;&nbsp;</a></span>SparseVanka() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::<a class="el" href="classSparseVanka.html">SparseVanka</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>conserve_memory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor which also takes two deprecated inputs.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000054">Deprecated:</a></b></dt><dd>The use of the last two parameters is deprecated. They are currently ignored. </dd></dl>

</div>
</div>
<a id="ada2d29d0432f512fcc10d2c72c8597e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada2d29d0432f512fcc10d2c72c8597e8">&#9670;&nbsp;</a></span>SparseVanka() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::<a class="el" href="classSparseVanka.html">SparseVanka</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Gets the matrix for preconditioning and a bit vector with entries <code>true</code> for all rows to be updated. A reference to this vector will be stored, so it must persist longer than the Vanka object. The same is true for the matrix.</p>
<p>The matrix <code>M</code> which is passed here may or may not be the same matrix for which this object shall act as preconditioner. In particular, it is conceivable that the preconditioner is build up for one matrix once, but is used for subsequent steps in a nonlinear process as well, where the matrix changes in each step slightly. </p>

</div>
</div>
<a id="a8efa61d88f54f6d6467c0c78b28a81b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efa61d88f54f6d6467c0c78b28a81b7">&#9670;&nbsp;</a></span>~SparseVanka()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::~<a class="el" href="classSparseVanka.html">SparseVanka</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. Delete all allocated matrices. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a6e2ce1949e40a2f6d09fe4d870670988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e2ce1949e40a2f6d09fe4d870670988">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseVanka_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>additional_data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the default constructor is used then this function needs to be called before an object of this class is used as preconditioner.</p>
<p>For more detail about possible parameters, see the class documentation and the documentation of the <a class="el" href="classSparseVanka_1_1AdditionalData.html">SparseVanka::AdditionalData</a> class.</p>
<p>After this function is called the preconditioner is ready to be used (using the <code>vmult</code> function of derived classes). </p>

</div>
</div>
<a id="a9c1113cdacf0fa509b4cf58323c0104e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1113cdacf0fa509b4cf58323c0104e">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::vmult&lt; <a class="el" href="classdouble.html">double</a> &gt; </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do the preconditioning. This function takes the residual in <code>src</code> and returns the resulting update vector in <code>dst</code>. </p>

</div>
</div>
<a id="a9244a620a91b61ee03f70edbf2e52ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9244a620a91b61ee03f70edbf2e52ba7">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply transpose preconditioner. This function takes the residual in <code>src</code> and returns the resulting update vector in <code>dst</code>. </p>

</div>
</div>
<a id="a1161f72e2921f4cf53584ddddca91665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1161f72e2921f4cf53584ddddca91665">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the codomain (or range) space. Note that the matrix is of dimension \(m \times n\).</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called if the preconditioner has been initialized. </dd></dl>

</div>
</div>
<a id="a41b1fb0a899949cc4b31a61dc386ef9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41b1fb0a899949cc4b31a61dc386ef9a">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the dimension of the domain space. Note that the matrix is of dimension \(m \times n\).</p>
<dl class="section note"><dt>Note</dt><dd>This function should only be called if the preconditioner has been initialized. </dd></dl>

</div>
</div>
<a id="ae7569b43f4519137cc98f30ada15e1ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7569b43f4519137cc98f30ada15e1ee">&#9670;&nbsp;</a></span>apply_preconditioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::apply_preconditioner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the inverses corresponding to those degrees of freedom that have a <code>true</code> value in <code>dof_mask</code>, to the <code>src</code> vector and move the result into <code>dst</code>. Actually, only values for allowed indices are written to <code>dst</code>, so the application of this function only does what is announced in the general documentation if the given mask sets all values to zero</p>
<p>The reason for providing the mask anyway is that in derived classes we may want to apply the preconditioner to parts of the matrix only, in order to parallelize the application. Then, it is important to only write to some slices of <code>dst</code>, in order to eliminate the dependencies of threads of each other.</p>
<p>If a null pointer is passed instead of a pointer to the <code>dof_mask</code> (as is the default value), then it is assumed that we shall work on all degrees of freedom. This is then equivalent to calling the function with a <code>vector&lt;bool&gt;(n_dofs,true)</code>.</p>
<p>The <code>vmult</code> of this class of course calls this function with a null pointer </p>

</div>
</div>
<a id="a290a70aaffdcb0835b82894bda2dbf32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a290a70aaffdcb0835b82894bda2dbf32">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a22bf9cb75f1304f8623aa24c2c5bc6cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22bf9cb75f1304f8623aa24c2c5bc6cf">&#9670;&nbsp;</a></span>compute_inverses() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::compute_inverses </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverses of all selected diagonal elements. </p>

</div>
</div>
<a id="a68a3571b29d6b2068d66e4f950eeb2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68a3571b29d6b2068d66e4f950eeb2bb">&#9670;&nbsp;</a></span>compute_inverses() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::compute_inverses </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverses at positions in the range <code>[begin,end)</code>. In non-multithreaded mode, <code><a class="el" href="classSparseVanka.html#a22bf9cb75f1304f8623aa24c2c5bc6cf">compute_inverses()</a></code> calls this function with the whole range, but in multithreaded mode, several copies of this function are spawned. </p>

</div>
</div>
<a id="a2aff37f288ae7f9900f6c22128cf8026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aff37f288ae7f9900f6c22128cf8026">&#9670;&nbsp;</a></span>compute_inverse()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::compute_inverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the inverse of the block located at position <code>row</code>. Since the vector is used quite often, it is generated only once in the caller of this function and passed to this function which first clears it. Reusing the vector makes the process significantly faster than in the case where this function re-creates it each time. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a124076b34c9c5c998b7d5b64ffb0cfc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124076b34c9c5c998b7d5b64ffb0cfc7">&#9670;&nbsp;</a></span>SparseBlockVanka</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseBlockVanka.html">SparseBlockVanka</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00362">362</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a1e8f09281aaf4fbfbf90093edbf02447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8f09281aaf4fbfbf90093edbf02447">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;, <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt;number&gt; &gt; <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the matrix. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00302">302</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<a id="ab1c1073cd133bb81b5875b341eb32925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c1073cd133bb81b5875b341eb32925">&#9670;&nbsp;</a></span>selected</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt;* <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::selected</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Indices of those degrees of freedom that we shall work on. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00307">307</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<a id="a253f2afee116f7fff25ad542f0cb64b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253f2afee116f7fff25ad542f0cb64b0">&#9670;&nbsp;</a></span>inverses</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;float&gt;, <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt;number&gt; &gt; &gt; <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::inverses</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of inverse matrices, one for each degree of freedom. Only those elements will be used that are tagged in <code>selected</code>. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00314">314</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<a id="a1edfa7ce100331a4423d8e2c5133cc08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1edfa7ce100331a4423d8e2c5133cc08">&#9670;&nbsp;</a></span>_m</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::_m</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the range space. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00319">319</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<a id="a187cb7f6f5003a746ab61627d075a931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187cb7f6f5003a746ab61627d075a931">&#9670;&nbsp;</a></span>_n</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseVanka.html#af523ea3caee731b5679560ab716e10cd">size_type</a> <a class="el" href="classSparseVanka.html">SparseVanka</a>&lt; number &gt;::_n</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dimension of the domain space. </p>

<p class="definition">Definition at line <a class="el" href="sparse__vanka_8h_source.html#l00324">324</a> of file <a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__vanka_8h_source.html">sparse_vanka.h</a></li>
<li>source/lac/<a class="el" href="sparse__vanka_8cc_source.html">sparse_vanka.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
