<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSymmetricTensor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SymmetricTensor&lt; rank_, dim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classSymmetricTensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SymmetricTensor&lt; rank_, dim, Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__geomprimitives.html">Geometric and other primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="symmetric__tensor_8h_source.html">deal.II/base/symmetric_tensor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SymmetricTensor&lt; rank_, dim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSymmetricTensor__inherit__graph.svg" width="503" height="156"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a9fa884d977d1636b3bb931923bd4fa7e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a9fa884d977d1636b3bb931923bd4fa7e">SymmetricTensor</a> ()=default</td></tr>
<tr class="separator:a9fa884d977d1636b3bb931923bd4fa7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8524acff25f25b2570d0de4d0d861859"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a8524acff25f25b2570d0de4d0d861859"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8524acff25f25b2570d0de4d0d861859">SymmetricTensor</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a8524acff25f25b2570d0de4d0d861859"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b631d97ed5ad31bbf6b40b557d14013"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a1b631d97ed5ad31bbf6b40b557d14013">SymmetricTensor</a> (const Number(&amp;array)[<a class="el" href="classSymmetricTensor.html#ae5104ec92227cb3f7b68b2354604cc77">n_independent_components</a>])</td></tr>
<tr class="separator:a1b631d97ed5ad31bbf6b40b557d14013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7aadcda5d178d16750091dfc72eb7e2"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aa7aadcda5d178d16750091dfc72eb7e2"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa7aadcda5d178d16750091dfc72eb7e2">SymmetricTensor</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;initializer)</td></tr>
<tr class="separator:aa7aadcda5d178d16750091dfc72eb7e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249236a5d8a0875683713047069d6ffd"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a249236a5d8a0875683713047069d6ffd">begin_raw</a> ()</td></tr>
<tr class="separator:a249236a5d8a0875683713047069d6ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dced73a4ce7bda570cccf5bfa537c0"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a82dced73a4ce7bda570cccf5bfa537c0">begin_raw</a> () const</td></tr>
<tr class="separator:a82dced73a4ce7bda570cccf5bfa537c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6a7bc4c83996590c881ecaba94937a"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a2a6a7bc4c83996590c881ecaba94937a">end_raw</a> ()</td></tr>
<tr class="separator:a2a6a7bc4c83996590c881ecaba94937a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e048db0f7abcaf686a078473aca3fbe"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a5e048db0f7abcaf686a078473aca3fbe">end_raw</a> () const</td></tr>
<tr class="separator:a5e048db0f7abcaf686a078473aca3fbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a825d2d07f1722534d9a2cc54f70bab06"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a825d2d07f1722534d9a2cc54f70bab06"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a825d2d07f1722534d9a2cc54f70bab06">operator=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;rhs)</td></tr>
<tr class="separator:a825d2d07f1722534d9a2cc54f70bab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bee0b676bc4cd89e8f22630332fc8e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a35bee0b676bc4cd89e8f22630332fc8e">operator=</a> (const Number &amp;d)</td></tr>
<tr class="separator:a35bee0b676bc4cd89e8f22630332fc8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca6e6399ac2c202fc4b9f62d2d6288b4"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aca6e6399ac2c202fc4b9f62d2d6288b4">operator Tensor&lt; rank_, dim, Number &gt;</a> () const</td></tr>
<tr class="separator:aca6e6399ac2c202fc4b9f62d2d6288b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a9ac4e1ee7dd3dc58f2e44a2276f06"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a03a9ac4e1ee7dd3dc58f2e44a2276f06">operator==</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;) const</td></tr>
<tr class="separator:a03a9ac4e1ee7dd3dc58f2e44a2276f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2ec0ccb3e61cdebe09d2b0c7ef533"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a5ae2ec0ccb3e61cdebe09d2b0c7ef533">operator!=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;) const</td></tr>
<tr class="separator:a5ae2ec0ccb3e61cdebe09d2b0c7ef533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c39f2ba7d3ba369da853623057a2bb1"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9c39f2ba7d3ba369da853623057a2bb1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a9c39f2ba7d3ba369da853623057a2bb1">operator+=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;)</td></tr>
<tr class="separator:a9c39f2ba7d3ba369da853623057a2bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa43df6986849db08996b880f53b276b1"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aa43df6986849db08996b880f53b276b1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa43df6986849db08996b880f53b276b1">operator-=</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;)</td></tr>
<tr class="separator:aa43df6986849db08996b880f53b276b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22000e14747bf11a3c08da12b9483273"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a22000e14747bf11a3c08da12b9483273"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a22000e14747bf11a3c08da12b9483273">operator*=</a> (const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a22000e14747bf11a3c08da12b9483273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e8430b60aeabe3e314d3a7e2eac599d"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a8e8430b60aeabe3e314d3a7e2eac599d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8e8430b60aeabe3e314d3a7e2eac599d">operator/=</a> (const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a8e8430b60aeabe3e314d3a7e2eac599d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d32fae46007b776e8aae3f688c1e00"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a93d32fae46007b776e8aae3f688c1e00">operator-</a> () const</td></tr>
<tr class="separator:a93d32fae46007b776e8aae3f688c1e00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8604f3b216d416f02e64c91293c09b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:aac8604f3b216d416f02e64c91293c09b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result</a>&lt; rank_, 2, dim, Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;s) const</td></tr>
<tr class="separator:aac8604f3b216d416f02e64c91293c09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad956b2ba82ae94632c4696a09c7945cf"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ad956b2ba82ae94632c4696a09c7945cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1double__contraction__result.html">internal::SymmetricTensorAccessors::double_contraction_result</a>&lt; rank_, 4, dim, Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ad956b2ba82ae94632c4696a09c7945cf">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, OtherNumber &gt; &amp;s) const</td></tr>
<tr class="separator:ad956b2ba82ae94632c4696a09c7945cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a040e00b4cdace66b40766727da66c5a5"><td class="memItemLeft" align="right" valign="top">constexpr Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a040e00b4cdace66b40766727da66c5a5">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices)</td></tr>
<tr class="separator:a040e00b4cdace66b40766727da66c5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a009c1eb0505654dd1b7d8a04d71a5a5e"><td class="memItemLeft" align="right" valign="top">constexpr const Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a009c1eb0505654dd1b7d8a04d71a5a5e">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices) const</td></tr>
<tr class="separator:a009c1eb0505654dd1b7d8a04d71a5a5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa182d48f0332242e515d1be588d3d90a"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor</a>&lt; rank_, dim, true, rank_ - 1, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa182d48f0332242e515d1be588d3d90a">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> row) const</td></tr>
<tr class="separator:aa182d48f0332242e515d1be588d3d90a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34369521f1d545942acbde50fdf3315e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classinternal_1_1SymmetricTensorAccessors_1_1Accessor.html">internal::SymmetricTensorAccessors::Accessor</a>&lt; rank_, dim, false, rank_ - 1, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a34369521f1d545942acbde50fdf3315e">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> row)</td></tr>
<tr class="separator:a34369521f1d545942acbde50fdf3315e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ed044383b260e86f28583ec52e877e"><td class="memItemLeft" align="right" valign="top">constexpr const Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a26ed044383b260e86f28583ec52e877e">operator[]</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices) const</td></tr>
<tr class="separator:a26ed044383b260e86f28583ec52e877e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1185dbb78c9d36aa277ae09054574a9"><td class="memItemLeft" align="right" valign="top">constexpr Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ae1185dbb78c9d36aa277ae09054574a9">operator[]</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices)</td></tr>
<tr class="separator:ae1185dbb78c9d36aa277ae09054574a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ac3cd29bc0649f96ccf3841a4d819e"><td class="memItemLeft" align="right" valign="top">constexpr const Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a39ac3cd29bc0649f96ccf3841a4d819e">access_raw_entry</a> (const unsigned <a class="el" href="classint.html">int</a> unrolled_index) const</td></tr>
<tr class="separator:a39ac3cd29bc0649f96ccf3841a4d819e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab16142aa923c731953255f47e44b76c9"><td class="memItemLeft" align="right" valign="top">constexpr Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab16142aa923c731953255f47e44b76c9">access_raw_entry</a> (const unsigned <a class="el" href="classint.html">int</a> unrolled_index)</td></tr>
<tr class="separator:ab16142aa923c731953255f47e44b76c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cac9b857586c6e0ab9029ff406e489e"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a4cac9b857586c6e0ab9029ff406e489e">norm</a> () const</td></tr>
<tr class="separator:a4cac9b857586c6e0ab9029ff406e489e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb2f06a7ed79e1bb61d399068ade43b7"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#adb2f06a7ed79e1bb61d399068ade43b7">clear</a> ()</td></tr>
<tr class="separator:adb2f06a7ed79e1bb61d399068ade43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d59d9bdbe63e714f6f69f20918fc710"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a3d59d9bdbe63e714f6f69f20918fc710"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3d59d9bdbe63e714f6f69f20918fc710">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a3d59d9bdbe63e714f6f69f20918fc710"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a31908e07d65be58d82e6bdd7ad73de2b"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a31908e07d65be58d82e6bdd7ad73de2b">component_to_unrolled_index</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices)</td></tr>
<tr class="separator:a31908e07d65be58d82e6bdd7ad73de2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27b7999b0ff6dc31fbfaf0c0e7a87653"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a27b7999b0ff6dc31fbfaf0c0e7a87653">unrolled_to_component_indices</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a27b7999b0ff6dc31fbfaf0c0e7a87653"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6914a2115b15f141ad165f7b6dc7266a"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6914a2115b15f141ad165f7b6dc7266a">memory_consumption</a> ()</td></tr>
<tr class="separator:a6914a2115b15f141ad165f7b6dc7266a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a647b83d0ce713b53cccdabcb80b289f3"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a647b83d0ce713b53cccdabcb80b289f3">dimension</a> = dim</td></tr>
<tr class="separator:a647b83d0ce713b53cccdabcb80b289f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a051501338c0b78c2bd0db27ba3c74"><td class="memItemLeft" align="right" valign="top">static const unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a66a051501338c0b78c2bd0db27ba3c74">rank</a> = rank_</td></tr>
<tr class="separator:a66a051501338c0b78c2bd0db27ba3c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5104ec92227cb3f7b68b2354604cc77"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ae5104ec92227cb3f7b68b2354604cc77">n_independent_components</a></td></tr>
<tr class="separator:ae5104ec92227cb3f7b68b2354604cc77"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:ae15fdc76bbf8979ea075ce1457c43e52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ae15fdc76bbf8979ea075ce1457c43e52">base_tensor_descriptor</a> = <a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType</a>&lt; rank_, dim, Number &gt;</td></tr>
<tr class="separator:ae15fdc76bbf8979ea075ce1457c43e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f58847e0d945a54b525c70aa59da2e7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a4f58847e0d945a54b525c70aa59da2e7">base_tensor_type</a> = typename base_tensor_descriptor::base_tensor_type</td></tr>
<tr class="separator:a4f58847e0d945a54b525c70aa59da2e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a7998c10e58588d5cfadff9a845b17373"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html#a4f58847e0d945a54b525c70aa59da2e7">base_tensor_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a7998c10e58588d5cfadff9a845b17373">data</a></td></tr>
<tr class="separator:a7998c10e58588d5cfadff9a845b17373"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a3b037cceee7751ec3a9d533d43122274"><td class="memTemplParams" colspan="2">template&lt;int , int , typename &gt; </td></tr>
<tr class="memitem:a3b037cceee7751ec3a9d533d43122274"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3b037cceee7751ec3a9d533d43122274">SymmetricTensor</a></td></tr>
<tr class="separator:a3b037cceee7751ec3a9d533d43122274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ab5ef283a0ddb6b06b1b91f7e163d7"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa8ab5ef283a0ddb6b06b1b91f7e163d7">internal::SymmetricTensorImplementation::Inverse&lt; 2, dim, Number &gt;</a></td></tr>
<tr class="separator:aa8ab5ef283a0ddb6b06b1b91f7e163d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5461e1d5514279cf345d6e6237ec41d"><td class="memItemLeft" align="right" valign="top">struct&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#af5461e1d5514279cf345d6e6237ec41d">internal::SymmetricTensorImplementation::Inverse&lt; 4, dim, Number &gt;</a></td></tr>
<tr class="separator:af5461e1d5514279cf345d6e6237ec41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c20f8401d49caf1f7240509f1810bc2"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a6c20f8401d49caf1f7240509f1810bc2"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6c20f8401d49caf1f7240509f1810bc2">trace</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;d)</td></tr>
<tr class="separator:a6c20f8401d49caf1f7240509f1810bc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f57f08e54e368df236ea89fb4add99d"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a3f57f08e54e368df236ea89fb4add99d"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3f57f08e54e368df236ea89fb4add99d">determinant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;t)</td></tr>
<tr class="separator:a3f57f08e54e368df236ea89fb4add99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a08d01a44371c8902742d56c283926"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a96a08d01a44371c8902742d56c283926"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a96a08d01a44371c8902742d56c283926">deviator</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;t)</td></tr>
<tr class="separator:a96a08d01a44371c8902742d56c283926"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2782a4382d7dece7e38560f5f56e641"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:ae2782a4382d7dece7e38560f5f56e641"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor</a> ()</td></tr>
<tr class="separator:ae2782a4382d7dece7e38560f5f56e641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a566ce211102218813f79b8122e2a6787"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:a566ce211102218813f79b8122e2a6787"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a566ce211102218813f79b8122e2a6787">deviator_tensor</a> ()</td></tr>
<tr class="separator:a566ce211102218813f79b8122e2a6787"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e890348aa219805e84f7d367e098c3"><td class="memTemplParams" colspan="2">template&lt;int dim2, typename Number2 &gt; </td></tr>
<tr class="memitem:ab3e890348aa219805e84f7d367e098c3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim2, Number2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor</a> ()</td></tr>
<tr class="separator:ab3e890348aa219805e84f7d367e098c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a6c9d8cfe285d568676bb6e308146c147"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:a6c9d8cfe285d568676bb6e308146c147"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; <a class="el" href="classSymmetricTensor.html#a66a051501338c0b78c2bd0db27ba3c74">rank</a>, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6c9d8cfe285d568676bb6e308146c147">sum</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; <a class="el" href="classSymmetricTensor.html#a66a051501338c0b78c2bd0db27ba3c74">rank</a>, dim, Number &gt; &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a6c9d8cfe285d568676bb6e308146c147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbfe82642874a4a3b1e666f7276d512b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:abbfe82642874a4a3b1e666f7276d512b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#abbfe82642874a4a3b1e666f7276d512b">operator+</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:abbfe82642874a4a3b1e666f7276d512b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9eafd3162685be6f5991c38a6199bb8"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab9eafd3162685be6f5991c38a6199bb8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab9eafd3162685be6f5991c38a6199bb8">operator-</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:ab9eafd3162685be6f5991c38a6199bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fdc8c6eb5007e04da9b235545dbb96e"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a6fdc8c6eb5007e04da9b235545dbb96e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6fdc8c6eb5007e04da9b235545dbb96e">operator+</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a6fdc8c6eb5007e04da9b235545dbb96e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade6823d7f78f3d0737d360d5a6dc8f90"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ade6823d7f78f3d0737d360d5a6dc8f90"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ade6823d7f78f3d0737d360d5a6dc8f90">operator+</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:ade6823d7f78f3d0737d360d5a6dc8f90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cb478cabb9ad51cffa2b931b96b0fa6"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a2cb478cabb9ad51cffa2b931b96b0fa6"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a2cb478cabb9ad51cffa2b931b96b0fa6">operator-</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a2cb478cabb9ad51cffa2b931b96b0fa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f1d36aa343ad77fdcdd60e5957621af"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a3f1d36aa343ad77fdcdd60e5957621af"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3f1d36aa343ad77fdcdd60e5957621af">operator-</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;left, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a3f1d36aa343ad77fdcdd60e5957621af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c03a03a5fe823733e7af9f7e4267f81"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a7c03a03a5fe823733e7af9f7e4267f81"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a7c03a03a5fe823733e7af9f7e4267f81">determinant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a7c03a03a5fe823733e7af9f7e4267f81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27e65a266c0c962bfa90adbeb35d313"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa27e65a266c0c962bfa90adbeb35d313"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa27e65a266c0c962bfa90adbeb35d313">third_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa27e65a266c0c962bfa90adbeb35d313"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9137b6052702150e8e5b1188d1971906"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a9137b6052702150e8e5b1188d1971906"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a9137b6052702150e8e5b1188d1971906">trace</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;d)</td></tr>
<tr class="separator:a9137b6052702150e8e5b1188d1971906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04efa71ed514a17d8769c21019cca4e8"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a04efa71ed514a17d8769c21019cca4e8"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a04efa71ed514a17d8769c21019cca4e8">first_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a04efa71ed514a17d8769c21019cca4e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1f5794e514a7f53b8073575d4675c84"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aa1f5794e514a7f53b8073575d4675c84"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa1f5794e514a7f53b8073575d4675c84">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;)</td></tr>
<tr class="separator:aa1f5794e514a7f53b8073575d4675c84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a406452573ef4f85351abd4a4bc4c0"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae1a406452573ef4f85351abd4a4bc4c0"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ae1a406452573ef4f85351abd4a4bc4c0">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:ae1a406452573ef4f85351abd4a4bc4c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf0be28be5368b57ee743a74afae2328"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:abf0be28be5368b57ee743a74afae2328"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#abf0be28be5368b57ee743a74afae2328">second_invariant</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:abf0be28be5368b57ee743a74afae2328"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c9cd0a3fecbd58ae133dfdd104f9f9"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a45c9cd0a3fecbd58ae133dfdd104f9f9"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Number, 1 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a45c9cd0a3fecbd58ae133dfdd104f9f9">eigenvalues</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;T)</td></tr>
<tr class="separator:a45c9cd0a3fecbd58ae133dfdd104f9f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae9aa1b6a4dba7eccf55e4e4209a39e"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a3ae9aa1b6a4dba7eccf55e4e4209a39e"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Number, 2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3ae9aa1b6a4dba7eccf55e4e4209a39e">eigenvalues</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;T)</td></tr>
<tr class="separator:a3ae9aa1b6a4dba7eccf55e4e4209a39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea72b50f6a2a250829813fd7ead954c"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aeea72b50f6a2a250829813fd7ead954c"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; Number, 3 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aeea72b50f6a2a250829813fd7ead954c">eigenvalues</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;T)</td></tr>
<tr class="separator:aeea72b50f6a2a250829813fd7ead954c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa18a9d623fcd520f022421fd1d6c7a14"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa18a9d623fcd520f022421fd1d6c7a14"><td class="memTemplItemLeft" align="right" valign="top">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &gt;, std::integral_constant&lt; <a class="el" href="classint.html">int</a>, dim &gt;::value &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;T, const <a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88">SymmetricTensorEigenvectorMethod</a> method=<a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88a65b4954581b684416cb84c7aecbf0482">SymmetricTensorEigenvectorMethod::ql_implicit_shifts</a>)</td></tr>
<tr class="separator:aa18a9d623fcd520f022421fd1d6c7a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace3fa57d53292237b465d0575a788353"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:ace3fa57d53292237b465d0575a788353"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ace3fa57d53292237b465d0575a788353">transpose</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:ace3fa57d53292237b465d0575a788353"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e7fd34dd28fc3f6420068887a939753"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a6e7fd34dd28fc3f6420068887a939753"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a6e7fd34dd28fc3f6420068887a939753">deviator</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a6e7fd34dd28fc3f6420068887a939753"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33cd1a6c91c24a5ca34dfbc43c338d1c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a33cd1a6c91c24a5ca34dfbc43c338d1c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a33cd1a6c91c24a5ca34dfbc43c338d1c">invert</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a33cd1a6c91c24a5ca34dfbc43c338d1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaf1090dbf0551fbd64122055082fad"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a0eaf1090dbf0551fbd64122055082fad"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a0eaf1090dbf0551fbd64122055082fad">invert</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a0eaf1090dbf0551fbd64122055082fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c727eebb2d3d1870cbf4e77a3f45a6b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a8c727eebb2d3d1870cbf4e77a3f45a6b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a8c727eebb2d3d1870cbf4e77a3f45a6b">outer_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t2)</td></tr>
<tr class="separator:a8c727eebb2d3d1870cbf4e77a3f45a6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b2101a1d45267f1fd4664ed178cb636"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a1b2101a1d45267f1fd4664ed178cb636"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a1b2101a1d45267f1fd4664ed178cb636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf6cce115919f046d183a86603c3460c"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:abf6cce115919f046d183a86603c3460c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#abf6cce115919f046d183a86603c3460c">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t, const Number &amp;factor)</td></tr>
<tr class="separator:abf6cce115919f046d183a86603c3460c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9e4986da5cf401499d62712eba3c37b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa9e4986da5cf401499d62712eba3c37b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa9e4986da5cf401499d62712eba3c37b">operator*</a> (const Number &amp;factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa9e4986da5cf401499d62712eba3c37b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f75191f4cdcae990782e6f83ffc0cf"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a66f75191f4cdcae990782e6f83ffc0cf"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a66f75191f4cdcae990782e6f83ffc0cf">operator/</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a66f75191f4cdcae990782e6f83ffc0cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347bf48878316f3405d1693ef12bf38"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim&gt; </td></tr>
<tr class="memitem:a1347bf48878316f3405d1693ef12bf38"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a1347bf48878316f3405d1693ef12bf38">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;t, const <a class="el" href="classdouble.html">double</a> factor)</td></tr>
<tr class="separator:a1347bf48878316f3405d1693ef12bf38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f29408c63a14728ce101b02958f4f3"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim&gt; </td></tr>
<tr class="memitem:ad7f29408c63a14728ce101b02958f4f3"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ad7f29408c63a14728ce101b02958f4f3">operator*</a> (const <a class="el" href="classdouble.html">double</a> factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;t)</td></tr>
<tr class="separator:ad7f29408c63a14728ce101b02958f4f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb639496012bec64ed8d5f045e7d9111"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim&gt; </td></tr>
<tr class="memitem:aeb639496012bec64ed8d5f045e7d9111"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aeb639496012bec64ed8d5f045e7d9111">operator/</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;t, const <a class="el" href="classdouble.html">double</a> factor)</td></tr>
<tr class="separator:aeb639496012bec64ed8d5f045e7d9111"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14ac27fc9ab74d4de531698b492d8de"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab14ac27fc9ab74d4de531698b492d8de"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab14ac27fc9ab74d4de531698b492d8de">scalar_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t2)</td></tr>
<tr class="separator:ab14ac27fc9ab74d4de531698b492d8de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69b3e17cd6ee5502c5a1118ddc751306"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a69b3e17cd6ee5502c5a1118ddc751306"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a69b3e17cd6ee5502c5a1118ddc751306">scalar_product</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t2)</td></tr>
<tr class="separator:a69b3e17cd6ee5502c5a1118ddc751306"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4624be3a3f38c1fad53951437a22e1"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a0b4624be3a3f38c1fad53951437a22e1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a0b4624be3a3f38c1fad53951437a22e1">scalar_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;t2)</td></tr>
<tr class="separator:a0b4624be3a3f38c1fad53951437a22e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07b7c41cb9adfb6a07c0e3824cd7cb8b"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a07b7c41cb9adfb6a07c0e3824cd7cb8b"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a07b7c41cb9adfb6a07c0e3824cd7cb8b">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, OtherNumber &gt; &amp;s)</td></tr>
<tr class="separator:a07b7c41cb9adfb6a07c0e3824cd7cb8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b8985f18da4c5e5285eb50fe0e9c99"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a63b8985f18da4c5e5285eb50fe0e9c99"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a63b8985f18da4c5e5285eb50fe0e9c99">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a63b8985f18da4c5e5285eb50fe0e9c99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a311b5f5b5f0300cccff82ea0a9f0d287"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a311b5f5b5f0300cccff82ea0a9f0d287"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a311b5f5b5f0300cccff82ea0a9f0d287">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, OtherNumber &gt; &amp;s)</td></tr>
<tr class="separator:a311b5f5b5f0300cccff82ea0a9f0d287"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a056f3cc5935e09a867c57e7621d3d903"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a056f3cc5935e09a867c57e7621d3d903"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a056f3cc5935e09a867c57e7621d3d903">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a056f3cc5935e09a867c57e7621d3d903"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7030ec2c90ce924cbe6cbe1f43a9bd2"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab7030ec2c90ce924cbe6cbe1f43a9bd2"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ab7030ec2c90ce924cbe6cbe1f43a9bd2">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;t, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, OtherNumber &gt; &amp;s)</td></tr>
<tr class="separator:ab7030ec2c90ce924cbe6cbe1f43a9bd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afac1f945176731e373edfed09dd3f130"><td class="memTemplParams" colspan="2">template&lt;typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:afac1f945176731e373edfed09dd3f130"><td class="memTemplItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#afac1f945176731e373edfed09dd3f130">double_contract</a> (<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;tmp, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;s, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:afac1f945176731e373edfed09dd3f130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a75bb465d862924f76849afcf6efac4"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a1a75bb465d862924f76849afcf6efac4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a1a75bb465d862924f76849afcf6efac4">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a1a75bb465d862924f76849afcf6efac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3825730970f8dede85b5698f150d50d8"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a3825730970f8dede85b5698f150d50d8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a3825730970f8dede85b5698f150d50d8">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;src1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a3825730970f8dede85b5698f150d50d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21368b7527565a28d154f98622128db1"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a21368b7527565a28d154f98622128db1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a21368b7527565a28d154f98622128db1">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a21368b7527565a28d154f98622128db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6015ed09fffc0b77fc2f2e38a59cf2"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ada6015ed09fffc0b77fc2f2e38a59cf2"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#ada6015ed09fffc0b77fc2f2e38a59cf2">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:ada6015ed09fffc0b77fc2f2e38a59cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5cd683fd58a42e393c546cc4abedeed"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:aa5cd683fd58a42e393c546cc4abedeed"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#aa5cd683fd58a42e393c546cc4abedeed">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:aa5cd683fd58a42e393c546cc4abedeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a351a3d35263baee19d033e5c68bc8539"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a351a3d35263baee19d033e5c68bc8539"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSymmetricTensor.html#a351a3d35263baee19d033e5c68bc8539">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a351a3d35263baee19d033e5c68bc8539"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int rank_, int dim, typename Number&gt;<br />
class SymmetricTensor&lt; rank_, dim, Number &gt;</h3>

<p>Provide a class that stores symmetric tensors of rank 2,4,... efficiently, i.e. only store those off-diagonal elements of the full tensor that are not redundant. For example, for symmetric \(2\times 2\) tensors, this would be the elements 11, 22, and 12, while the element 21 is equal to the 12 element. Within this documentation, second order symmetric tensors are denoted as bold-faced upper-case Latin letters such as \(\mathbf A, \mathbf B, \dots\) or bold-faced Greek letters such as \(\boldsymbol{\varepsilon}\), \(\boldsymbol{\sigma}\). The Cartesian coordinates of a second-order tensor such as \(\mathbf A\) are represented as \(A_{ij}\) where \(i,j\) are indices ranging from 0 to <code>dim-1</code>.</p>
<p>Using this class for symmetric tensors of rank 2 has advantages over matrices in many cases since the dimension is known to the compiler as well as the location of the data. It is therefore possible to produce far more efficient code than for matrices with runtime-dependent dimension. It is also more efficient than using the more general <code><a class="el" href="classTensor.html">Tensor</a></code> class, since fewer elements are stored, and the class automatically makes sure that the tensor represents a symmetric object.</p>
<p>For tensors of higher rank, the savings in storage are even higher. For example for the \(3 \times 3 \times 3 \times 3\) tensors of rank 4, only 36 instead of the full 81 entries have to be stored. These rank 4 tensors are denoted by blackboard-style upper-case Latin letters such as \(\mathbb A\) with components \(\mathcal{A}_{ijkl}\).</p>
<p>While the definition of a symmetric rank-2 tensor is obvious, tensors of rank 4 are considered symmetric if they are operators mapping symmetric rank-2 tensors onto symmetric rank-2 tensors. This so-called minor symmetry of the rank 4 tensor requires that for every set of four indices \(i, j, k, l\), the identity \(\mathcal{C}_{ijkl} = \mathcal{C}_{jikl} = \mathcal{C}_{ijlk}\) holds. However, it does not imply the relation \(\mathcal{C}_{ijkl} = \mathcal{C}_{klij}\). Consequently, symmetric tensors of rank 4 as understood here are only tensors that map symmetric tensors onto symmetric tensors, but they do not necessarily induce a symmetric scalar product \(\mathbf A : \mathbb C : \mathbf B = \mathbf B : \mathbb C : \mathbf A\) or even a positive (semi-)definite form \(\mathbf A : \mathbb C : \mathbf A\), where \(\mathbf A, \mathbf B\) are symmetric rank-2 tensors and the colon indicates the common double-index contraction that acts as a scalar product for symmetric tensors.</p>
<p>Symmetric tensors are most often used in structural and fluid mechanics, where strains and stresses are usually symmetric tensors, and the stress-strain relationship is given by a symmetric rank-4 tensor.</p>
<dl class="section note"><dt>Note</dt><dd>Symmetric tensors only exist with even numbers of indices. In other words, the only objects that you can use are <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a></code>, <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a></code>, etc, but <code>SymmetricTensor&lt;1,dim&gt;</code> and <code>SymmetricTensor&lt;3,dim&gt;</code> do not exist and their use will most likely lead to compiler errors.</dd></dl>
<h3>Accessing elements</h3>
<p>The elements of a tensor \(\mathbb C\) can be accessed using the bracket operator, i.e. for a tensor of rank 4, <code>C[0][1][0][1]</code> accesses the element \(\mathcal{C}_{0101}\). This access can be used for both reading and writing (if the tensor is non-constant at least). You may also perform other operations on it, although that may lead to confusing situations because several elements of the tensor are stored at the same location. For example, for a rank-2 tensor that is assumed to be zero at the beginning, writing <code>A[0][1]+=1; A[1][0]+=1;</code> will lead to the same element being increased by one <em>twice</em>, because even though the accesses use different indices, the elements that are accessed are symmetric and therefore stored at the same location. It may therefore be useful in application programs to restrict operations on individual elements to simple reads or writes. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00668">668</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae15fdc76bbf8979ea075ce1457c43e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae15fdc76bbf8979ea075ce1457c43e52">&#9670;&nbsp;</a></span>base_tensor_descriptor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html#ae15fdc76bbf8979ea075ce1457c43e52">base_tensor_descriptor</a> =  <a class="el" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType</a>&lt;rank_, dim, Number&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A structure that describes properties of the base tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01008">1008</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a4f58847e0d945a54b525c70aa59da2e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f58847e0d945a54b525c70aa59da2e7">&#9670;&nbsp;</a></span>base_tensor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html#a4f58847e0d945a54b525c70aa59da2e7">base_tensor_type</a> =  typename base_tensor_descriptor::base_tensor_type</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Data storage type for a symmetric tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01013">1013</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a9fa884d977d1636b3bb931923bd4fa7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa884d977d1636b3bb931923bd4fa7e">&#9670;&nbsp;</a></span>SymmetricTensor() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Default constructor. Creates a tensor with all entries equal to zero. </p>

</div>
</div>
<a id="a8524acff25f25b2570d0de4d0d861859"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8524acff25f25b2570d0de4d0d861859">&#9670;&nbsp;</a></span>SymmetricTensor() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Generate a symmetric tensor from a general one. Assumes that <code>t</code> is already symmetric, and in debug mode this is in fact checked. Note that no provision is made to assure that the tensor is symmetric only up to round-off error: if the incoming tensor is not exactly symmetric, then an exception is thrown. If you know that incoming tensor is symmetric only up to round-off, then you may want to call the <code><a class="el" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize()</a></code> function first. If you aren't sure, it is good practice to check before calling <code><a class="el" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize()</a></code>.</p>
<p>Because we check for symmetry via a non-constexpr function call, you will have to use the <a class="el" href="classSymmetricTensor.html#a1b2101a1d45267f1fd4664ed178cb636">symmetrize()</a> function in constexpr contexts instead. </p>

</div>
</div>
<a id="a1b631d97ed5ad31bbf6b40b557d14013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b631d97ed5ad31bbf6b40b557d14013">&#9670;&nbsp;</a></span>SymmetricTensor() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const Number(&amp;)&#160;</td>
          <td class="paramname"><em>array</em>[n_independent_components]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A constructor that creates a symmetric tensor from an array holding its independent elements. Using this constructor assumes that the caller knows the order in which elements are stored in symmetric tensors; its use is therefore discouraged, but if you think you want to use it anyway you can query the order of elements using the unrolled_index() function.</p>
<p>This constructor is currently only implemented for symmetric tensors of rank 2.</p>
<p>The size of the array passed is equal to <a class="el" href="classSymmetricTensor.html#ae5104ec92227cb3f7b68b2354604cc77">SymmetricTensor&lt;rank_,dim&gt;::n_independent_components</a>; the reason for using the object from the internal namespace is to work around bugs in some older compilers. </p>

</div>
</div>
<a id="aa7aadcda5d178d16750091dfc72eb7e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7aadcda5d178d16750091dfc72eb7e2">&#9670;&nbsp;</a></span>SymmetricTensor() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor from tensors with different underlying scalar type. This obviously requires that the <code>OtherNumber</code> type is convertible to <code>Number</code>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a249236a5d8a0875683713047069d6ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249236a5d8a0875683713047069d6ffd">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the first element of the underlying storage. </p>

</div>
</div>
<a id="a82dced73a4ce7bda570cccf5bfa537c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dced73a4ce7bda570cccf5bfa537c0">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the first element of the underlying storage. </p>

</div>
</div>
<a id="a2a6a7bc4c83996590c881ecaba94937a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6a7bc4c83996590c881ecaba94937a">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::end_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the element past the end of the underlying storage. </p>

</div>
</div>
<a id="a5e048db0f7abcaf686a078473aca3fbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e048db0f7abcaf686a078473aca3fbe">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::end_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the element past the end of the underlying storage. </p>

</div>
</div>
<a id="a825d2d07f1722534d9a2cc54f70bab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a825d2d07f1722534d9a2cc54f70bab06">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator from symmetric tensors with different underlying scalar type. This obviously requires that the <code>OtherNumber</code> type is convertible to <code>Number</code>. </p>

</div>
</div>
<a id="a35bee0b676bc4cd89e8f22630332fc8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bee0b676bc4cd89e8f22630332fc8e">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a tensor. To avoid confusion with what exactly it means to assign a scalar value to a tensor, zero is the only value allowed for <code>d</code>, allowing the intuitive notation \(\mathbf A = 0\) to reset all elements of the tensor to zero. </p>

</div>
</div>
<a id="aca6e6399ac2c202fc4b9f62d2d6288b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca6e6399ac2c202fc4b9f62d2d6288b4">&#9670;&nbsp;</a></span>operator Tensor< rank_, dim, Number >()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert the present symmetric tensor into a full tensor with the same elements, but using the different storage scheme of full tensors. </p>

</div>
</div>
<a id="a03a9ac4e1ee7dd3dc58f2e44a2276f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03a9ac4e1ee7dd3dc58f2e44a2276f06">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality of two tensors. </p>

</div>
</div>
<a id="a5ae2ec0ccb3e61cdebe09d2b0c7ef533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae2ec0ccb3e61cdebe09d2b0c7ef533">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality of two tensors. </p>

</div>
</div>
<a id="a9c39f2ba7d3ba369da853623057a2bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c39f2ba7d3ba369da853623057a2bb1">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another tensor. </p>

</div>
</div>
<a id="aa43df6986849db08996b880f53b276b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa43df6986849db08996b880f53b276b1">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract another tensor. </p>

</div>
</div>
<a id="a22000e14747bf11a3c08da12b9483273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22000e14747bf11a3c08da12b9483273">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the tensor by <code>factor</code>, i.e. multiply all components by <code>factor</code>. </p>

</div>
</div>
<a id="a8e8430b60aeabe3e314d3a7e2eac599d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e8430b60aeabe3e314d3a7e2eac599d">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the tensor by <code>1/factor</code>. </p>

</div>
</div>
<a id="a93d32fae46007b776e8aae3f688c1e00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d32fae46007b776e8aae3f688c1e00">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unary minus operator. Negate all entries of a tensor. </p>

</div>
</div>
<a id="aac8604f3b216d416f02e64c91293c09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8604f3b216d416f02e64c91293c09b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr internal::SymmetricTensorAccessors:: double_contraction_result&lt;rank_, 2, dim, Number, OtherNumber&gt;::type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Double contraction product between the present symmetric tensor and a tensor of rank 2. For example, if the present object is the symmetric rank-2 tensor \(\mathbf{A}\) and it is multiplied by another symmetric rank-2 tensor \(\mathbf{B}\), then the result is the scalar-product double contraction \(\mathbf A : \mathbf B = \sum_{i,j} A_{ij} B_{ij}\). In this case, the return value evaluates to a single scalar. While it is possible to define other scalar products (and associated induced norms), this one seems to be the most appropriate one.</p>
<p>If the present object is a rank-4 tensor such as \(\mathbb A\), then the result is a rank-2 tensor \(\mathbf C = \mathbb A : \mathbf B\), i.e., the operation contracts over the last two indices of the present object and the indices of the argument, and the result is a tensor of rank 2 ( \(C_{ij} = \sum_{k,l} \mathcal{A}_{ijkl} B_{kl}\)).</p>
<p>Note that the multiplication operator for symmetric tensors is defined to be a double contraction over two indices, while it is defined as a single contraction over only one index for regular <code><a class="el" href="classTensor.html">Tensor</a></code> objects. For symmetric tensors it therefore acts in a way that is commonly denoted by a "colon multiplication" in the mathematical literature.</p>
<p>There are global functions <code>double_contract</code> that do the same work as this operator, but rather than returning the result as a return value, they write it into the first argument to the function. </p>

</div>
</div>
<a id="ad956b2ba82ae94632c4696a09c7945cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad956b2ba82ae94632c4696a09c7945cf">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr internal::SymmetricTensorAccessors:: double_contraction_result&lt;rank_, 4, dim, Number, OtherNumber&gt;::type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Contraction over two indices of the present object with the rank-4 symmetric tensor given as argument. </p>

</div>
</div>
<a id="a040e00b4cdace66b40766727da66c5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a040e00b4cdace66b40766727da66c5a5">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element. </p>

</div>
</div>
<a id="a009c1eb0505654dd1b7d8a04d71a5a5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a009c1eb0505654dd1b7d8a04d71a5a5e">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <code>const</code> reference to the value referred to by the argument. </p>

</div>
</div>
<a id="aa182d48f0332242e515d1be588d3d90a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa182d48f0332242e515d1be588d3d90a">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr internal::SymmetricTensorAccessors:: Accessor&lt;rank_, dim, true, rank_ - 1, Number&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the elements of a row of this symmetric tensor. This function is called for constant tensors. </p>

</div>
</div>
<a id="a34369521f1d545942acbde50fdf3315e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34369521f1d545942acbde50fdf3315e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr internal::SymmetricTensorAccessors:: Accessor&lt;rank_, dim, false, rank_ - 1, Number&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access the elements of a row of this symmetric tensor. This function is called for non-constant tensors. </p>

</div>
</div>
<a id="a26ed044383b260e86f28583ec52e877e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ed044383b260e86f28583ec52e877e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a <code>const</code> reference to the value referred to by the argument.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="ae1185dbb78c9d36aa277ae09054574a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1185dbb78c9d36aa277ae09054574a9">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a read-write reference to the indicated element.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="a39ac3cd29bc0649f96ccf3841a4d819e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ac3cd29bc0649f96ccf3841a4d819e">&#9670;&nbsp;</a></span>access_raw_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::access_raw_entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>unrolled_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to an element according to unrolled index. The function <code>s.access_raw_entry(unrolled_index)</code> does the same as <code>s[s.unrolled_to_component_indices(unrolled_index)]</code>, but more efficiently. </p>

</div>
</div>
<a id="ab16142aa923c731953255f47e44b76c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab16142aa923c731953255f47e44b76c9">&#9670;&nbsp;</a></span>access_raw_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number&amp; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::access_raw_entry </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>unrolled_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Access to an element according to unrolled index. The function <code>s.access_raw_entry(unrolled_index)</code> does the same as <code>s[s.unrolled_to_component_indices(unrolled_index)]</code>, but more efficiently. </p>

</div>
</div>
<a id="a4cac9b857586c6e0ab9029ff406e489e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cac9b857586c6e0ab9029ff406e489e">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::real_type <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Frobenius-norm of a tensor, i.e. the square root of the sum of squares of all entries. This norm is induced by the scalar product defined above for two symmetric tensors. Note that it includes <em>all</em> entries of the tensor, counting symmetry, not only the unique ones (for example, for rank-2 tensors, this norm includes adding up the squares of upper right as well as lower left entries, not just one of them, although they are equal for symmetric tensors). </p>

</div>
</div>
<a id="a31908e07d65be58d82e6bdd7ad73de2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31908e07d65be58d82e6bdd7ad73de2b">&#9670;&nbsp;</a></span>component_to_unrolled_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::component_to_unrolled_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classTensor.html">Tensor</a> objects can be unrolled by simply pasting all elements into one long vector, but for this an order of elements has to be defined. For symmetric tensors, this function returns which index within the range <code>[0,n_independent_components)</code> the given entry in a symmetric tensor has. </p>

</div>
</div>
<a id="a27b7999b0ff6dc31fbfaf0c0e7a87653"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27b7999b0ff6dc31fbfaf0c0e7a87653">&#9670;&nbsp;</a></span>unrolled_to_component_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classTableIndices.html">TableIndices</a>&lt;rank_&gt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::unrolled_to_component_indices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The opposite of the previous function: given an index \(i\) in the unrolled form of the tensor, return what set of indices \((k,l)\) (for rank-2 tensors) or \((k,l,m,n)\) (for rank-4 tensors) corresponds to it. </p>

</div>
</div>
<a id="adb2f06a7ed79e1bb61d399068ade43b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb2f06a7ed79e1bb61d399068ade43b7">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all values to zero.</p>
<p>Note that this is partly inconsistent with the semantics of the <code><a class="el" href="classSymmetricTensor.html#adb2f06a7ed79e1bb61d399068ade43b7">clear()</a></code> member functions of the standard library containers and of several other classes within deal.II, which not only reset the values of stored elements to zero, but release all memory and return the object into a virginial state. However, since the size of objects of the present type is determined by its template parameters, resizing is not an option, and indeed the state where all elements have a zero value is the state right after construction of such an object. </p>

</div>
</div>
<a id="a6914a2115b15f141ad165f7b6dc7266a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6914a2115b15f141ad165f7b6dc7266a">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a3d59d9bdbe63e714f6f69f20918fc710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d59d9bdbe63e714f6f69f20918fc710">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a3b037cceee7751ec3a9d533d43122274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b037cceee7751ec3a9d533d43122274">&#9670;&nbsp;</a></span>SymmetricTensor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int , int , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01022">1022</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa8ab5ef283a0ddb6b06b1b91f7e163d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ab5ef283a0ddb6b06b1b91f7e163d7">&#9670;&nbsp;</a></span>internal::SymmetricTensorImplementation::Inverse< 2, dim, Number ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct internal::SymmetricTensorImplementation:: Inverse&lt; 2, dim, Number &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01052">1052</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="af5461e1d5514279cf345d6e6237ec41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5461e1d5514279cf345d6e6237ec41d">&#9670;&nbsp;</a></span>internal::SymmetricTensorImplementation::Inverse< 4, dim, Number ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend struct internal::SymmetricTensorImplementation:: Inverse&lt; 4, dim, Number &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01055">1055</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a6c20f8401d49caf1f7240509f1810bc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c20f8401d49caf1f7240509f1810bc2">&#9670;&nbsp;</a></span>trace <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number2 trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f57f08e54e368df236ea89fb4add99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f57f08e54e368df236ea89fb4add99d">&#9670;&nbsp;</a></span>determinant <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number2 determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96a08d01a44371c8902742d56c283926"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a08d01a44371c8902742d56c283926">&#9670;&nbsp;</a></span>deviator <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2, dim2, Number2&gt; deviator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim2, Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2782a4382d7dece7e38560f5f56e641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2782a4382d7dece7e38560f5f56e641">&#9670;&nbsp;</a></span>unit_symmetric_tensor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; unit_symmetric_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a unit symmetric tensor of rank 2, i.e., the \(\text{dim}\times\text{dim}\) identity matrix \(\mathbf I\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03276">3276</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a566ce211102218813f79b8122e2a6787"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a566ce211102218813f79b8122e2a6787">&#9670;&nbsp;</a></span>deviator_tensor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; deviator_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of rank 4 that, when multiplied by a symmetric rank 2 tensor \(\mathbf T\) returns the deviator \(\text{dev}\ \mathbf T\). It is the operator representation of the linear deviator operator \(\mathbb P\), also known as the volumetric projection tensor, calculated as: </p><p class="formulaDsp">
\begin{align*} \mathbb{P} &amp;=\mathbb{I} -\frac{1}{\text{dim}} \mathbf I \otimes \mathbf I \\ \mathcal{P}_{ijkl} &amp;= \frac 12 \left(\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk} \right) - \frac{1}{\text{dim}} \delta_{ij} \delta_{kl} \end{align*}
</p>
<p>For every tensor <code>T</code>, there holds the identity <code>deviator&lt;dim,Number&gt;(T) == <a class="el" href="classSymmetricTensor.html#a566ce211102218813f79b8122e2a6787">deviator_tensor&lt;dim,Number&gt;()</a> * T</code>, up to numerical round-off. </p><p class="formulaDsp">
\[ \text{dev}\mathbf T = \mathbb P : \mathbf T \]
</p>
<dl class="section note"><dt>Note</dt><dd>The reason this operator representation is provided is to simplify taking derivatives of the deviatoric part of tensors: <p class="formulaDsp">
\[ \frac{\partial \text{dev}\mathbf{T}}{\partial \mathbf T} = \mathbb P. \]
</p>
 </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03304">3304</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab3e890348aa219805e84f7d367e098c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e890348aa219805e84f7d367e098c3">&#9670;&nbsp;</a></span>identity_tensor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int dim2, typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; identity_tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the fourth-order symmetric identity tensor \(\mathbb I\) which maps symmetric second-order tensors, such as \(\mathbf A\), to themselves. </p><p class="formulaDsp">
\[ \mathbb I : \mathbf A = \mathbf A \]
</p>
<p>Note that this tensor, even though it is the identity, has a somewhat funny form, and in particular does not only consist of zeros and ones. For example, for <code>dim=2</code>, the identity tensor has all zero entries except for </p><p class="formulaDsp">
\[ \mathcal{I}_{0000} = \mathcal{I}_{1111} = 1 \]
</p>
 <p class="formulaDsp">
\[ \mathcal{I}_{0101} = \mathcal{I}_{0110} = \mathcal{I}_{1001} = \mathcal{I}_{1010} = \frac 12. \]
</p>
<p> In index notation, we can write the general form </p><p class="formulaDsp">
\[ \mathcal{I}_{ijkl} = \frac 12 \left( \delta_{ik} \delta_{jl} + \delta_{il} \delta_{jl} \right). \]
</p>
<p> To see why this factor of \(1 / 2\) is necessary, consider computing \(\mathbf A= \mathbb I : \mathbf B\). For the element \(A_{01}\) we have \(A_{01} = \mathcal{I}_{0100} B_{00} + \mathcal{I}_{0111} B_{11} + \mathcal{I}_{0101} B_{01} + \mathcal{I}_{0110} B_{10}\). On the other hand, we need to have \(A_{01} = B_{01}\), and symmetry implies \(B_{01}=B_{10}\), leading to \(A_{01} = (\mathcal{I}_{0101} + \mathcal{I}_{0110}) B_{01}\), or, again by symmetry, \(\mathcal{I}_{0101} = \mathcal{I}_{0110} = \frac 12\). Similar considerations hold for the three-dimensional case.</p>
<p>This issue is also explained in the introduction to step-44. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03332">3332</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a6c9d8cfe285d568676bb6e308146c147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c9d8cfe285d568676bb6e308146c147">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; <a class="el" href="classSymmetricTensor.html#a66a051501338c0b78c2bd0db27ba3c74">rank</a>, dim, Number &gt; sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; <a class="el" href="classSymmetricTensor.html#a66a051501338c0b78c2bd0db27ba3c74">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an MPI sum of the entries of a symmetric tensor. </p>

</div>
</div>
<a id="abbfe82642874a4a3b1e666f7276d512b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbfe82642874a4a3b1e666f7276d512b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two symmetric tensors of equal rank. The result is another <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> that has a number type that is compatible with the operation.</p>
<p>If possible (e.g. when <code>Number</code> and <code>OtherNumber</code> are of the same type, or if the result of <code>Number() + OtherNumber()</code> is another <code>Number</code>), you should use <code>operator+=</code> instead since this does not require the creation of a temporary variable. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02574">2574</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab9eafd3162685be6f5991c38a6199bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9eafd3162685be6f5991c38a6199bb8">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two symmetric tensors of equal rank. The result is another <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> that has a number type that is compatible with the operation.</p>
<p>If possible (e.g. when <code>Number</code> and <code>OtherNumber</code> are of the same type, or if the result of <code>Number() - OtherNumber()</code> is another <code>Number</code>), you should use <code>operator-=</code> instead since this does not require the creation of a temporary variable. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02599">2599</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a6fdc8c6eb5007e04da9b235545dbb96e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fdc8c6eb5007e04da9b235545dbb96e">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> and a general <a class="el" href="classTensor.html">Tensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02619">2619</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ade6823d7f78f3d0737d360d5a6dc8f90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade6823d7f78f3d0737d360d5a6dc8f90">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of a general <a class="el" href="classTensor.html">Tensor</a> with a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02636">2636</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a2cb478cabb9ad51cffa2b931b96b0fa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cb478cabb9ad51cffa2b931b96b0fa6">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of a general <a class="el" href="classTensor.html">Tensor</a> from a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02653">2653</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a3f1d36aa343ad77fdcdd60e5957621af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1d36aa343ad77fdcdd60e5957621af">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of a <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> from a general <a class="el" href="classTensor.html">Tensor</a> of equal rank. The result is a general <a class="el" href="classTensor.html">Tensor</a> that has a number type that is compatible with the operation. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02670">2670</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a7c03a03a5fe823733e7af9f7e4267f81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c03a03a5fe823733e7af9f7e4267f81">&#9670;&nbsp;</a></span>determinant() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a rank 2 symmetric tensor. The determinant is also commonly referred to as the third invariant of rank-2 tensors.</p>
<p>For a one-dimensional tensor, the determinant equals the only element and is therefore equivalent to the trace.</p>
<p>For greater notational simplicity, there is also a <code><a class="el" href="classSymmetricTensor.html#aa27e65a266c0c962bfa90adbeb35d313">third_invariant()</a></code> function that returns the determinant of a tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02693">2693</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa27e65a266c0c962bfa90adbeb35d313"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa27e65a266c0c962bfa90adbeb35d313">&#9670;&nbsp;</a></span>third_invariant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number third_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a rank 2 symmetric tensor. This function therefore computes the same value as the <code><a class="el" href="classSymmetricTensor.html#a3f57f08e54e368df236ea89fb4add99d">determinant()</a></code> functions and is only provided for greater notational simplicity (since there are also functions <a class="el" href="classSymmetricTensor.html#a04efa71ed514a17d8769c21019cca4e8">first_invariant()</a> and <a class="el" href="classSymmetricTensor.html#aa1f5794e514a7f53b8073575d4675c84">second_invariant()</a>). </p><p class="formulaDsp">
\[ I_3 (\mathbf A) = III (\mathbf A) = \det (\mathbf A) \]
</p>
 
<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02733">2733</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a9137b6052702150e8e5b1188d1971906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9137b6052702150e8e5b1188d1971906">&#9670;&nbsp;</a></span>trace() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries. The trace is the first invariant of a rank-2 tensor. </p><p class="formulaDsp">
\[ \text{tr} \mathbf A = \sum_i A_{ii} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02751">2751</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a04efa71ed514a17d8769c21019cca4e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04efa71ed514a17d8769c21019cca4e8">&#9670;&nbsp;</a></span>first_invariant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number first_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the trace of a rank 2 symmetric tensor. This function therefore computes the same value as the <code><a class="el" href="classSymmetricTensor.html#a6c20f8401d49caf1f7240509f1810bc2">trace()</a></code> functions and is only provided for greater notational simplicity (since there are also functions <a class="el" href="classSymmetricTensor.html#aa1f5794e514a7f53b8073575d4675c84">second_invariant()</a> and <a class="el" href="classSymmetricTensor.html#aa27e65a266c0c962bfa90adbeb35d313">third_invariant()</a>). </p><p class="formulaDsp">
\[ I_1 (\mathbf A) = I (\mathbf A) = \text{tr} \mathbf A = \sum_i A_{ii} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02773">2773</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa1f5794e514a7f53b8073575d4675c84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1f5794e514a7f53b8073575d4675c84">&#9670;&nbsp;</a></span>second_invariant() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant of a tensor \(\mathbf A\) is defined as \(I_2 (\mathbf A) = II(\mathbf A) = \frac 12 \left[ (\text{tr} \mathbf A)^2 - \text{tr} (\mathbf{A}^2) \right]\).</p>
<p>For the kind of arguments to this function, i.e., a rank-2 tensor of size 1, the result is simply zero. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02792">2792</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ae1a406452573ef4f85351abd4a4bc4c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a406452573ef4f85351abd4a4bc4c0">&#9670;&nbsp;</a></span>second_invariant() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant of a tensor \(\mathbf A\) is defined as \(I_2 (\mathbf A) = II(\mathbf A) = \frac 12 \left[ (\text{tr} \mathbf A)^2 - \text{tr} (\mathbf{A}^2) \right]\).</p>
<p>For the kind of arguments to this function, i.e., a symmetric rank-2 tensor of size 2, the result is (counting indices starting at one) \(I_2(\mathbf A) = II(\mathbf A) = \frac 12 \left[ (A_{11} + A_{22})^2 - (A_{11}^2+2 A_{12}^2+ A_{22}^2) \right] = A_{11} A_{22} - A_{12}^2\). As expected, for the \(2\times 2\) symmetric tensors this function handles, this equals the determinant of the tensor. (This is so because for \(2\times 2\) symmetric tensors, there really are only two invariants, so the second and third invariant are the same; the determinant is the third invariant.) </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02819">2819</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="abf0be28be5368b57ee743a74afae2328"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf0be28be5368b57ee743a74afae2328">&#9670;&nbsp;</a></span>second_invariant() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number second_invariant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the second invariant of a tensor of rank 2. The second invariant of a tensor \(\mathbf A\) is defined as \(I_2 (\mathbf A) = II(\mathbf A) = \frac 12 \left[ (\text{tr} \mathbf A)^2 - \text{tr} (\mathbf{A}^2) \right]\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l02836">2836</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a45c9cd0a3fecbd58ae133dfdd104f9f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c9cd0a3fecbd58ae133dfdd104f9f9">&#9670;&nbsp;</a></span>eigenvalues() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Number, 1 &gt; eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the eigenvalues of a symmetric \(1 \times 1\) tensor. The (single) entry of the tensor is, of course, equal to the (single) eigenvalue. </p>

</div>
</div>
<a id="a3ae9aa1b6a4dba7eccf55e4e4209a39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae9aa1b6a4dba7eccf55e4e4209a39e">&#9670;&nbsp;</a></span>eigenvalues() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Number, 2 &gt; eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the eigenvalues of a symmetric \(2\times 2\) tensor. The array of eigenvalues is sorted in descending order.</p>
<p>For \(2\times 2\) tensors, the eigenvalues of tensor \(\mathbf T\) are the roots of <a href="https://en.wikipedia.org/wiki/Eigenvalue_algorithm#2.C3.972_matrices">the characteristic polynomial</a> \(0 = \lambda^2 - \lambda\;\text{tr}\mathbf{T} + \det \mathbf{T}\) as given by \(\lambda_1, \lambda_2 = \frac{1}{2} \left[ \text{tr} \mathbf{T} \pm \sqrt{(\text{tr} \mathbf{T})^2 - 4 \det \mathbf{T}} \right]\).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithm employed here determines the eigenvalues by computing the roots of the characteristic polynomial. In the case that there exists a common root (the eigenvalues are equal), the computation is <a href="https://scicomp.stackexchange.com/q/23686">subject to round-off errors</a> of order \(\sqrt{\epsilon}\). As an alternative, the <a class="el" href="classSymmetricTensor.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors()</a> function provides a more robust, but costly, method to compute the eigenvalues of a symmetric tensor. </dd></dl>

</div>
</div>
<a id="aeea72b50f6a2a250829813fd7ead954c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea72b50f6a2a250829813fd7ead954c">&#9670;&nbsp;</a></span>eigenvalues() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; Number, 3 &gt; eigenvalues </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the eigenvalues of a symmetric \(3\times 3\) tensor. The array of eigenvalues is sorted in descending order.</p>
<p>For \(3\times 3\) tensors, the eigenvalues of tensor \(\mathbf T\) are the roots of <a href="https://en.wikipedia.org/wiki/Eigenvalue_algorithm#3.C3.973_matrices">the characteristic polynomial</a> \(0 = \lambda^3 - \lambda^2\;\text{tr}\mathbf T - \frac{1}{2} \lambda \left[\text{tr}(\mathbf{T}^2) - (\text{tr}\mathbf T)^2\right] - \det \mathbf T\).</p>
<dl class="section warning"><dt>Warning</dt><dd>The algorithm employed here determines the eigenvalues by computing the roots of the characteristic polynomial. In the case that there exists a common root (the eigenvalues are equal), the computation is <a href="https://scicomp.stackexchange.com/q/23686">subject to round-off errors</a> of order \(\sqrt{\epsilon}\). As an alternative, the <a class="el" href="classSymmetricTensor.html#aa18a9d623fcd520f022421fd1d6c7a14">eigenvectors()</a> function provides a more robust, but costly, method to compute the eigenvalues of a symmetric tensor. </dd></dl>

</div>
</div>
<a id="aa18a9d623fcd520f022421fd1d6c7a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa18a9d623fcd520f022421fd1d6c7a14">&#9670;&nbsp;</a></span>eigenvectors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt; std::pair&lt; Number, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &gt;, std::integral_constant&lt; <a class="el" href="classint.html">int</a>, dim &gt;::value &gt; eigenvectors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88">SymmetricTensorEigenvectorMethod</a>&#160;</td>
          <td class="paramname"><em>method</em> = <code><a class="el" href="symmetric__tensor_8h.html#ac535cfc6fdfc0e23150b97e877e44e88a65b4954581b684416cb84c7aecbf0482">SymmetricTensorEigenvectorMethod::ql_implicit_shifts</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the eigenvalues and eigenvectors of a real-valued rank-2 symmetric tensor \(\mathbf T\). The array of matched eigenvalue and eigenvector pairs is sorted in descending order (determined by the eigenvalues).</p>
<p>The specialized algorithms utilized in computing the eigenvectors are presented in </p><div class="fragment"><div class="line">@article{Kopp2008,</div><div class="line">  title       = {Efficient numerical diagonalization of hermitian 3x3</div><div class="line">                 matrices},</div><div class="line">  author      = {Kopp, J.},</div><div class="line">  journal     = {International Journal of Modern Physics C},</div><div class="line">  year        = {2008},</div><div class="line">  volume      = {19},</div><div class="line">  number      = {3},</div><div class="line">  pages       = {523--548},</div><div class="line">  doi         = {10.1142/S0129183108012303},</div><div class="line">  eprinttype  = {arXiv},</div><div class="line">  eprint      = {physics/0610206v3},</div><div class="line">  eprintclass = {physics.comp-ph},</div><div class="line">  url         =</div><div class="line">{https://www.mpi-hd.mpg.de/personalhomes/globes/3x3/index.html}</div><div class="line">}</div></div><!-- fragment --> 
</div>
</div>
<a id="ace3fa57d53292237b465d0575a788353"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace3fa57d53292237b465d0575a788353">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the transpose of the given symmetric tensor. Since we are working with symmetric objects, the transpose is of course the same as the original tensor. This function mainly exists for compatibility with the <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03241">3241</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a6e7fd34dd28fc3f6420068887a939753"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e7fd34dd28fc3f6420068887a939753">&#9670;&nbsp;</a></span>deviator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; deviator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the deviator of a symmetric tensor, which is defined as \(\text{dev} \mathbf T = \mathbf T - \frac{1}{\text{dim}} \text{tr}\mathbf T \; \mathbf I\), where \(\mathbf I\) is the identity operator. This quantity equals the original tensor minus its contractive or dilative component and refers to the shear in, for example, elasticity. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03260">3260</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a33cd1a6c91c24a5ca34dfbc43c338d1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33cd1a6c91c24a5ca34dfbc43c338d1c">&#9670;&nbsp;</a></span>invert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invert a symmetric rank-2 tensor.</p>
<dl class="section note"><dt>Note</dt><dd>If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03367">3367</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a0eaf1090dbf0551fbd64122055082fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaf1090dbf0551fbd64122055082fad">&#9670;&nbsp;</a></span>invert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Invert a symmetric rank-4 tensor. Since symmetric rank-4 tensors are mappings from and to symmetric rank-2 tensors, they can have an inverse.</p>
<p>If a tensor is not invertible, then the result is unspecified, but will likely contain the results of a division by zero or a very small number at the very least. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03387">3387</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a8c727eebb2d3d1870cbf4e77a3f45a6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c727eebb2d3d1870cbf4e77a3f45a6b">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the tensor of rank 4 that is the outer product of the two tensors given as arguments, i.e. the result \(\mathbb A = \mathbf{T}_1 \otimes \mathbf{T}_2\) satisfies \(\mathbb A : \mathbf B = (\mathbf{T}_2 : \mathbf B) \mathbf{T}_1\) for all symmetric tensors \(\mathbf B\). In index notation </p><p class="formulaDsp">
\[ \mathcal{A}_{ijkl} = (T_1)_{ij} (T_2)_{kl} \]
</p>
<p>For example, the deviator tensor \(\mathbb P = \mathbb I - \frac{1}{\text{dim}} \mathbf I \otimes \mathbf I\) can be computed as <code><a class="el" href="classSymmetricTensor.html#ab3e890348aa219805e84f7d367e098c3">identity_tensor&lt;dim&gt;()</a> - 1/d * outer_product (<a class="el" href="classSymmetricTensor.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor&lt;dim&gt;()</a>, <a class="el" href="classSymmetricTensor.html#ae2782a4382d7dece7e38560f5f56e641">unit_symmetric_tensor&lt;dim&gt;()</a>)</code>, since the (double) contraction with the unit tensor yields the trace of a symmetric tensor ( \(\mathbf I : \mathbf B = \text{tr} \mathbf B\)). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03418">3418</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1b2101a1d45267f1fd4664ed178cb636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2101a1d45267f1fd4664ed178cb636">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; symmetrize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the symmetrized version of a full rank-2 tensor, i.e. \(\text{sym}\mathbf A = \frac 12 \left(\mathbf A + \mathbf{A}^T\right)\), as a symmetric rank-2 tensor. This is the version for general dimensions. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03444">3444</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="abf6cce115919f046d183a86603c3460c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf6cce115919f046d183a86603c3460c">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the right. This version of the operator is used if the scalar has the same data type as is used to store the elements of the symmetric tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03468">3468</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa9e4986da5cf401499d62712eba3c37b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9e4986da5cf401499d62712eba3c37b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the left. This version of the operator is used if the scalar has the same data type as is used to store the elements of the symmetric tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03486">3486</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a66f75191f4cdcae990782e6f83ffc0cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66f75191f4cdcae990782e6f83ffc0cf">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a symmetric tensor of general rank by a scalar. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03575">3575</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1347bf48878316f3405d1693ef12bf38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1347bf48878316f3405d1693ef12bf38">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the right. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03594">3594</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ad7f29408c63a14728ce101b02958f4f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f29408c63a14728ce101b02958f4f3">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor of general rank with a scalar from the left. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03611">3611</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aeb639496012bec64ed8d5f045e7d9111"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb639496012bec64ed8d5f045e7d9111">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a symmetric tensor of general rank by a scalar. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03627">3627</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab14ac27fc9ab74d4de531698b492d8de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14ac27fc9ab74d4de531698b492d8de">&#9670;&nbsp;</a></span>scalar_product() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product \(\mathbf A: \mathbf B=\sum_{i,j} A_{ij}B_{ij}\) between two tensors \(\mathbf A, \mathbf B\) of rank 2. In the current case where both arguments are symmetric tensors, this is equivalent to calling the expression <code>A*B</code> which uses <code><a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a></code>. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03645">3645</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a69b3e17cd6ee5502c5a1118ddc751306"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69b3e17cd6ee5502c5a1118ddc751306">&#9670;&nbsp;</a></span>scalar_product() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product \(\mathbf A: \mathbf B=\sum_{i,j} A_{ij}B_{ij}\) between two tensors \(\mathbf A, \mathbf B\) of rank 2. We don't use <code>operator*</code> for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor. For example, if <code>B</code> is a <a class="el" href="classTensor.html">Tensor</a>, calling <code>A*B</code> (instead of <code>scalar_product(A,B)</code>) provides \((\mathbf A \cdot\mathbf B)_{ij}=\sum_k A_{ik}B_{kj}\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03668">3668</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a0b4624be3a3f38c1fad53951437a22e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4624be3a3f38c1fad53951437a22e1">&#9670;&nbsp;</a></span>scalar_product() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the scalar product \(\mathbf A:\mathbf B=\sum_{i,j} A_{ij}B_{ij}\) between two tensors \(\mathbf A, \mathbf B\) of rank 2. We don't use <code>operator*</code> for this operation since the product between two tensors is usually assumed to be the contraction over the last index of the first tensor and the first index of the second tensor. For example, if <code>A</code> is a <a class="el" href="classTensor.html">Tensor</a>, calling <code>A*B</code> (instead of <code>scalar_product(A,B)</code>) provides \((\mathbf A \cdot\mathbf B)_{ij}=\sum_k A_{ik}B_{kj}\). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03695">3695</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a07b7c41cb9adfb6a07c0e3824cd7cb8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07b7c41cb9adfb6a07c0e3824cd7cb8b">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03717">3717</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a63b8985f18da4c5e5285eb50fe0e9c99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b8985f18da4c5e5285eb50fe0e9c99">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 1, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03742">3742</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a311b5f5b5f0300cccff82ea0a9f0d287"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a311b5f5b5f0300cccff82ea0a9f0d287">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03767">3767</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a056f3cc5935e09a867c57e7621d3d903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a056f3cc5935e09a867c57e7621d3d903">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 2, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03797">3797</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ab7030ec2c90ce924cbe6cbe1f43a9bd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7030ec2c90ce924cbe6cbe1f43a9bd2">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03827">3827</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="afac1f945176731e373edfed09dd3f130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afac1f945176731e373edfed09dd3f130">&#9670;&nbsp;</a></span>double_contract() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr void double_contract </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>tmp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, 3, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Double contraction between a rank-4 and a rank-2 symmetric tensor, resulting in the symmetric tensor of rank 2 that is given as first argument to this function. This operation is the symmetric tensor analogon of a matrix-vector multiplication.</p>
<p>This function does the same as <a class="el" href="classSymmetricTensor.html#aac8604f3b216d416f02e64c91293c09b">SymmetricTensor::operator*()</a>. It should not be used, however, since the member operator has knowledge of the actual data storage format and is at least 2 orders of magnitude faster. This function mostly exists for compatibility purposes with the general <a class="el" href="classTensor.html">Tensor</a> class. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03858">3858</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a1a75bb465d862924f76849afcf6efac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a75bb465d862924f76849afcf6efac4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply a symmetric rank-2 tensor (i.e., a matrix) by a rank-1 tensor (i.e., a vector). The result is a rank-1 tensor (i.e., a vector). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03882">3882</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a3825730970f8dede85b5698f150d50d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3825730970f8dede85b5698f150d50d8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply a rank-1 tensor (i.e., a vector) by a symmetric rank-2 tensor (i.e., a matrix). The result is a rank-1 tensor (i.e., a vector). </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03901">3901</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a21368b7527565a28d154f98622128db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21368b7527565a28d154f98622128db1">&#9670;&nbsp;</a></span>operator*() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dot product (single contraction) for tensors: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 2)\) that is the contraction of the last index of a tensor <code>src1</code> of rank <code>rank_1</code> with the first index of a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k} \text{left}_{i_1,\ldots,i_{r1}, k} \text{right}_{k, j_1,\ldots,j_{r2}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>As one operand is a <a class="el" href="classTensor.html">Tensor</a>, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>, which does the double contraction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03938">3938</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ada6015ed09fffc0b77fc2f2e38a59cf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6015ed09fffc0b77fc2f2e38a59cf2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::tensor_type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The dot product (single contraction) for tensors: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 2)\) that is the contraction of the last index of a tensor <code>src1</code> of rank <code>rank_1</code> with the first index of a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k} \text{left}_{i_1,\ldots,i_{r1}, k} \text{right}_{k, j_1,\ldots,j_{r2}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>As one operand is a <a class="el" href="classTensor.html">Tensor</a>, the multiplication operator only performs a contraction over a single pair of indices. This is in contrast to the multiplication operator for <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>, which does the double contraction. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03974">3974</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="aa5cd683fd58a42e393c546cc4abedeed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5cd683fd58a42e393c546cc4abedeed">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for symmetric tensors of rank 2. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03993">3993</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a351a3d35263baee19d033e5c68bc8539"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a351a3d35263baee19d033e5c68bc8539">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 4, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for symmetric tensors of rank 4. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. No special amends are made to represents the symmetry in the output, for example by outputting only the unique entries. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l04020">4020</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a647b83d0ce713b53cccdabcb80b289f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a647b83d0ce713b53cccdabcb80b289f3">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a way to get the dimension of an object without explicit knowledge of it's data type. Implementation is this way instead of providing a function <code><a class="el" href="classSymmetricTensor.html#a647b83d0ce713b53cccdabcb80b289f3">dimension()</a></code> because now it is possible to get the dimension at compile time without the expansion and preevaluation of an inlined function; the compiler may therefore produce more efficient code and you may use this value to declare other data types. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00681">681</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a66a051501338c0b78c2bd0db27ba3c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a051501338c0b78c2bd0db27ba3c74">&#9670;&nbsp;</a></span>rank</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::rank = rank_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publish the rank of this tensor to the outside world. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00686">686</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="ae5104ec92227cb3f7b68b2354604cc77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5104ec92227cb3f7b68b2354604cc77">&#9670;&nbsp;</a></span>n_independent_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::n_independent_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="structinternal_1_1SymmetricTensorAccessors_1_1StorageType.html">internal::SymmetricTensorAccessors::StorageType&lt;rank_, dim, Number&gt;</a>::</div><div class="line">      n_independent_components</div></div><!-- fragment --><p>An integer denoting the number of independent components that fully describe a symmetric tensor. In \(d\) space dimensions, this number equals \(\frac 12 (d^2+d)\) for symmetric tensors of rank 2. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l00693">693</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a7998c10e58588d5cfadff9a845b17373"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7998c10e58588d5cfadff9a845b17373">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html#a4f58847e0d945a54b525c70aa59da2e7">base_tensor_type</a> <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The place where we store the data of the tensor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l01018">1018</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a></li>
<li>include/deal.II/base/<a class="el" href="mpi_8h_source.html">mpi.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
