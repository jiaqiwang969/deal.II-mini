<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceVectorTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: VectorTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VectorTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceVectorTools_1_1EvaluationFlags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html">EvaluationFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a69967cb7a148a7169963126249213db1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> { <br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27">mean</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357">L1_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1ab711e0a460000489addc7aa59878d2">Hdiv_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930">W1p_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3">W1p_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619">W1infty_norm</a>
<br />
 }</td></tr>
<tr class="separator:a69967cb7a148a7169963126249213db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0966d7adbacddce3ba37790a604e49f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af0966d7adbacddce3ba37790a604e49f">DeclExceptionMsg</a> (ExcPointNotAvailableHere, &quot;The given point is inside a cell of a &quot; &quot;<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> that is not &quot; &quot;locally owned by this processor.&quot;)</td></tr>
<tr class="separator:af0966d7adbacddce3ba37790a604e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad6eceb6cbeaa505baf7f938289bbde"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a1ad6eceb6cbeaa505baf7f938289bbde"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a1ad6eceb6cbeaa505baf7f938289bbde">point_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;evaluation_points, <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:a1ad6eceb6cbeaa505baf7f938289bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb22a97ffc83df35caf11dbd4e336cc"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6cb22a97ffc83df35caf11dbd4e336cc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6cb22a97ffc83df35caf11dbd4e336cc">point_values</a> (const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:a6cb22a97ffc83df35caf11dbd4e336cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada37fd09d8be1b9ed9bb12d698f8ee4"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:aada37fd09d8be1b9ed9bb12d698f8ee4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::gradient_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aada37fd09d8be1b9ed9bb12d698f8ee4">point_gradients</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;evaluation_points, <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:aada37fd09d8be1b9ed9bb12d698f8ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5febf52b3f767d8e276e2c02d0ea0662"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a5febf52b3f767d8e276e2c02d0ea0662"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::gradient_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5febf52b3f767d8e276e2c02d0ea0662">point_gradients</a> (const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:a5febf52b3f767d8e276e2c02d0ea0662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a69e6aa423a32d296440d1fa4bf4cac"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:a6a69e6aa423a32d296440d1fa4bf4cac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6a69e6aa423a32d296440d1fa4bf4cac">create_boundary_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; 1, 1 &gt; &amp;, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; 1, 1 &gt; &amp;, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 0 &gt; &amp;, const <a class="el" href="classFunction.html">Function</a>&lt; 1 &gt; &amp;, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;)</td></tr>
<tr class="separator:a6a69e6aa423a32d296440d1fa4bf4cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cddbcbf0e162ab79a605827d39ddfb"><td class="memTemplParams" colspan="2">template&lt;&gt; </td></tr>
<tr class="memitem:af3cddbcbf0e162ab79a605827d39ddfb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af3cddbcbf0e162ab79a605827d39ddfb">create_boundary_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; 1, 2 &gt; &amp;, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; 1, 2 &gt; &amp;, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 0 &gt; &amp;, const <a class="el" href="classFunction.html">Function</a>&lt; 2 &gt; &amp;, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;)</td></tr>
<tr class="separator:af3cddbcbf0e162ab79a605827d39ddfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">内插和投影</div></td></tr>
<tr class="memitem:af27ac28c698a9ed0199faed50a204538"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:af27ac28c698a9ed0199faed50a204538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:af27ac28c698a9ed0199faed50a204538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316c2741c61a2b7f0372c9dbb69b7c88"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a316c2741c61a2b7f0372c9dbb69b7c88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a316c2741c61a2b7f0372c9dbb69b7c88">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a316c2741c61a2b7f0372c9dbb69b7c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff02b67200d44ba712eb004fe7e8208"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afff02b67200d44ba712eb004fe7e8208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afff02b67200d44ba712eb004fe7e8208">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afff02b67200d44ba712eb004fe7e8208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9045591cffcf0c8a06b583e6563510e2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a9045591cffcf0c8a06b583e6563510e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a9045591cffcf0c8a06b583e6563510e2">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a9045591cffcf0c8a06b583e6563510e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c6fe2f772b09e2bfbb95ff6e49aa28"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aa9c6fe2f772b09e2bfbb95ff6e49aa28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa9c6fe2f772b09e2bfbb95ff6e49aa28">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:aa9c6fe2f772b09e2bfbb95ff6e49aa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad4dbef1b304b170be0362b0590ada1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afad4dbef1b304b170be0362b0590ada1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afad4dbef1b304b170be0362b0590ada1">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afad4dbef1b304b170be0362b0590ada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5e6b9de5ad09eb5009075618f08eb129">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6e975950cd122b6a2924b1ecd4ec60"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a7d6e975950cd122b6a2924b1ecd4ec60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7d6e975950cd122b6a2924b1ecd4ec60">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a7d6e975950cd122b6a2924b1ecd4ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5255de72726a1fa50c4653ce59e6a438"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5255de72726a1fa50c4653ce59e6a438"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5255de72726a1fa50c4653ce59e6a438">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga5255de72726a1fa50c4653ce59e6a438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0ffb5d4bd09003cd869b00573cf1d6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aaa0ffb5d4bd09003cd869b00573cf1d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aaa0ffb5d4bd09003cd869b00573cf1d6">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:aaa0ffb5d4bd09003cd869b00573cf1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39e86be1bee406512895d2b0377da87"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaa39e86be1bee406512895d2b0377da87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa39e86be1bee406512895d2b0377da87">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaa39e86be1bee406512895d2b0377da87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf2f61567fa003b5448fce53e0eec4b79">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa5117bc6324d18df70c9cb86442b88"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a5aa5117bc6324d18df70c9cb86442b88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:a5aa5117bc6324d18df70c9cb86442b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52d603a67047f73226b2e9653bffcf1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:af52d603a67047f73226b2e9653bffcf1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af52d603a67047f73226b2e9653bffcf1">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:af52d603a67047f73226b2e9653bffcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63c020c0782c918a8c43972285bfd2f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ac63c020c0782c918a8c43972285bfd2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac63c020c0782c918a8c43972285bfd2f">project_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:ac63c020c0782c918a8c43972285bfd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb559352c78982c7d36b444d0024720e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:acb559352c78982c7d36b444d0024720e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#acb559352c78982c7d36b444d0024720e">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:acb559352c78982c7d36b444d0024720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga32a2c72e6d0bc19fb346d51767e48c89">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf550f1f801988790bf89c099e7ff2fb0">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190b302dc1ee7c89727c94c083d132d2"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number &gt; </td></tr>
<tr class="memitem:ga190b302dc1ee7c89727c94c083d132d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga190b302dc1ee7c89727c94c083d132d2">project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:ga190b302dc1ee7c89727c94c083d132d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d845992528893a53ad7f37a15d0aaa"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number &gt; </td></tr>
<tr class="memitem:gac0d845992528893a53ad7f37a15d0aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac0d845992528893a53ad7f37a15d0aaa">project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gac0d845992528893a53ad7f37a15d0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8ab38430250535a694205a7372f5a7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaac8ab38430250535a694205a7372f5a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaac8ab38430250535a694205a7372f5a7">project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:gaac8ab38430250535a694205a7372f5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff48f8eaf46c5618b95eefa23081449e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaff48f8eaf46c5618b95eefa23081449e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaff48f8eaf46c5618b95eefa23081449e">project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gaff48f8eaf46c5618b95eefa23081449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga54fdd3b0f9e4e4ad02cf932901bd0659">compute_nonzero_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d16c332aaa652e8905a6f48208e4500"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga0d16c332aaa652e8905a6f48208e4500"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">compute_no_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga0d16c332aaa652e8905a6f48208e4500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b73118e3a950d33515ae649b9014d04"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga1b73118e3a950d33515ae649b9014d04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1b73118e3a950d33515ae649b9014d04">compute_nonzero_tangential_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga1b73118e3a950d33515ae649b9014d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad396065c624ae6c5d843e22fb75c3c36"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gad396065c624ae6c5d843e22fb75c3c36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gad396065c624ae6c5d843e22fb75c3c36">compute_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8cc.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:gad396065c624ae6c5d843e22fb75c3c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761f008bdeb7d94a69205ae824deefad"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a761f008bdeb7d94a69205ae824deefad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">interpolate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a761f008bdeb7d94a69205ae824deefad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fa653b9e16be54bda225e64f9b2b56"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a34fa653b9e16be54bda225e64f9b2b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a34fa653b9e16be54bda225e64f9b2b56">interpolate</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a34fa653b9e16be54bda225e64f9b2b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b68e11070496fcaf6c2389f088d09c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a32b68e11070496fcaf6c2389f088d09c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a32b68e11070496fcaf6c2389f088d09c">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a32b68e11070496fcaf6c2389f088d09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5e3af70a47cedfaf361cf5c621e94e3d">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_2, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;transfer, const InVector &amp;data_1, OutVector &amp;data_2)</td></tr>
<tr class="separator:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf179d7bbaec3bede8e732aadedc51b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:afbf179d7bbaec3bede8e732aadedc51b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afbf179d7bbaec3bede8e732aadedc51b">interpolate_based_on_material_id</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::map&lt; <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; *&gt; &amp;function_map, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afbf179d7bbaec3bede8e732aadedc51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4807a032b164d00ae06adb8cfb2c9d1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ac4807a032b164d00ae06adb8cfb2c9d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac4807a032b164d00ae06adb8cfb2c9d1">interpolate_to_different_mesh</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classVectorType.html">VectorType</a> &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, <a class="el" href="classVectorType.html">VectorType</a> &amp;u2)</td></tr>
<tr class="separator:ac4807a032b164d00ae06adb8cfb2c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad7ee745dc25e8699e893df7ebdb668"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:abad7ee745dc25e8699e893df7ebdb668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abad7ee745dc25e8699e893df7ebdb668">interpolate_to_different_mesh</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classVectorType.html">VectorType</a> &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, <a class="el" href="classVectorType.html">VectorType</a> &amp;u2)</td></tr>
<tr class="separator:abad7ee745dc25e8699e893df7ebdb668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b116f0b923f29ca6121890ec19b61"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ac48b116f0b923f29ca6121890ec19b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac48b116f0b923f29ca6121890ec19b61">interpolate_to_different_mesh</a> (const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;intergridmap, const <a class="el" href="classVectorType.html">VectorType</a> &amp;u1, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, <a class="el" href="classVectorType.html">VectorType</a> &amp;u2)</td></tr>
<tr class="separator:ac48b116f0b923f29ca6121890ec19b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b404bf03cb2a742b290421cc2789fe"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ac6b404bf03cb2a742b290421cc2789fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q_boundary=(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:ac6b404bf03cb2a742b290421cc2789fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25affd2b8b4fc818c0e45ec8b6e9c4b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ae25affd2b8b4fc818c0e45ec8b6e9c4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae25affd2b8b4fc818c0e45ec8b6e9c4b">project</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q_boundary=(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:ae25affd2b8b4fc818c0e45ec8b6e9c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1392cfa47cf2c315bf049bf626962152"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a1392cfa47cf2c315bf049bf626962152"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a1392cfa47cf2c315bf049bf626962152">project</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q_boundary=<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt;(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:a1392cfa47cf2c315bf049bf626962152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55c7e03374966532e28a5273aa89c45"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aa55c7e03374966532e28a5273aa89c45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa55c7e03374966532e28a5273aa89c45">project</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q_boundary=<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt;(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:aa55c7e03374966532e28a5273aa89c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a13e948e1296dbfdfc297167e4fd5a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a51a13e948e1296dbfdfc297167e4fd5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a51a13e948e1296dbfdfc297167e4fd5a">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const std::function&lt; typename VectorType::value_type(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;func, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_result)</td></tr>
<tr class="separator:a51a13e948e1296dbfdfc297167e4fd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78e1c7322a3c5bea31ac2ca7a7bb9b8"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType &gt; </td></tr>
<tr class="memitem:af78e1c7322a3c5bea31ac2ca7a7bb9b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af78e1c7322a3c5bea31ac2ca7a7bb9b8">project</a> (std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt; data, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const unsigned <a class="el" href="classint.html">int</a> n_q_points_1d, const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;func, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_result, const unsigned <a class="el" href="classint.html">int</a> fe_component=0)</td></tr>
<tr class="separator:af78e1c7322a3c5bea31ac2ca7a7bb9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51734bccfad4ad25857252845ca6bd26"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType &gt; </td></tr>
<tr class="memitem:a51734bccfad4ad25857252845ca6bd26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a51734bccfad4ad25857252845ca6bd26">project</a> (std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt; data, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;func, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_result, const unsigned <a class="el" href="classint.html">int</a> fe_component=0)</td></tr>
<tr class="separator:a51734bccfad4ad25857252845ca6bd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">函数的评估和错误</div></td></tr>
<tr class="memitem:a676190d2c897ac5da68a9c460fa95832"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a676190d2c897ac5da68a9c460fa95832"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a676190d2c897ac5da68a9c460fa95832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01703fa0d91ed6404009757680886d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a8d01703fa0d91ed6404009757680886d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a8d01703fa0d91ed6404009757680886d">integrate_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a8d01703fa0d91ed6404009757680886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4da3324bbce54d7c12dd54c59dd915"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:aec4da3324bbce54d7c12dd54c59dd915"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aec4da3324bbce54d7c12dd54c59dd915">integrate_difference</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:aec4da3324bbce54d7c12dd54c59dd915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0900dfa36831d4fa6d4225b8e98cfcda"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0900dfa36831d4fa6d4225b8e98cfcda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a0900dfa36831d4fa6d4225b8e98cfcda">integrate_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a0900dfa36831d4fa6d4225b8e98cfcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eb62d70953182dcc2b15c4e14dd533"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector &gt; </td></tr>
<tr class="memitem:a21eb62d70953182dcc2b15c4e14dd533"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const InVector &amp;cellwise_error, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a21eb62d70953182dcc2b15c4e14dd533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbaf531bea9d2ef9ca82f04866b9c16"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:afcbaf531bea9d2ef9ca82f04866b9c16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afcbaf531bea9d2ef9ca82f04866b9c16">point_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;value)</td></tr>
<tr class="separator:afcbaf531bea9d2ef9ca82f04866b9c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078534e0dfc25a7893805fc1385da132"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a078534e0dfc25a7893805fc1385da132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a078534e0dfc25a7893805fc1385da132">point_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a078534e0dfc25a7893805fc1385da132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8de1f957b6308a56aed2d6dfeb21d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a82b8de1f957b6308a56aed2d6dfeb21d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a82b8de1f957b6308a56aed2d6dfeb21d">point_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;value)</td></tr>
<tr class="separator:a82b8de1f957b6308a56aed2d6dfeb21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbcaff67fab590cd068d8ef2ea276f3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aacbcaff67fab590cd068d8ef2ea276f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aacbcaff67fab590cd068d8ef2ea276f3">point_gradient</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;value)</td></tr>
<tr class="separator:aacbcaff67fab590cd068d8ef2ea276f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72dcb595cc262bec07ca5c81614586f"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:af72dcb595cc262bec07ca5c81614586f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af72dcb595cc262bec07ca5c81614586f">point_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:af72dcb595cc262bec07ca5c81614586f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151ef408e4ffee595cb32f5a4791f54e"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a151ef408e4ffee595cb32f5a4791f54e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a151ef408e4ffee595cb32f5a4791f54e">point_gradient</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a151ef408e4ffee595cb32f5a4791f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf62ca21c24dbb459266851cb234e8bf"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:abf62ca21c24dbb459266851cb234e8bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abf62ca21c24dbb459266851cb234e8bf">point_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;exact_solution, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:abf62ca21c24dbb459266851cb234e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07907666e2000a6e8a6c0118f5d82b9f"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a07907666e2000a6e8a6c0118f5d82b9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a07907666e2000a6e8a6c0118f5d82b9f">point_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;exact_solution, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a07907666e2000a6e8a6c0118f5d82b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd358e9b110ccbf4a7f76796d206b9c7"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:acd358e9b110ccbf4a7f76796d206b9c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:acd358e9b110ccbf4a7f76796d206b9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be5c7eed52308898dfaad91c4cff204"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a7be5c7eed52308898dfaad91c4cff204"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7be5c7eed52308898dfaad91c4cff204">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a7be5c7eed52308898dfaad91c4cff204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a1c99072ea425f33b06d908b6f4283"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a23a1c99072ea425f33b06d908b6f4283"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a23a1c99072ea425f33b06d908b6f4283">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a23a1c99072ea425f33b06d908b6f4283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ff65fecfdbbad09b3a00386db15ee3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a79ff65fecfdbbad09b3a00386db15ee3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a79ff65fecfdbbad09b3a00386db15ee3">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a79ff65fecfdbbad09b3a00386db15ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b651e28ef8eb4312ea9ebcea5b33a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a363b651e28ef8eb4312ea9ebcea5b33a"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a363b651e28ef8eb4312ea9ebcea5b33a">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a363b651e28ef8eb4312ea9ebcea5b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47630457753055506858a8e835333054"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a47630457753055506858a8e835333054"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a47630457753055506858a8e835333054">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a47630457753055506858a8e835333054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afcb40e50d2fa4807762faefed206f5e3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:afcb40e50d2fa4807762faefed206f5e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afcb40e50d2fa4807762faefed206f5e3">get_position_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dh, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afcb40e50d2fa4807762faefed206f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8e3037188b85efb319cb065750da59"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6d8e3037188b85efb319cb065750da59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6d8e3037188b85efb319cb065750da59">get_position_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dh, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a6d8e3037188b85efb319cb065750da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a55601b2b4f2e6476619f22096116c0e4"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a55601b2b4f2e6476619f22096116c0e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a55601b2b4f2e6476619f22096116c0e4">subtract_mean_value</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;v, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;p_select={})</td></tr>
<tr class="separator:a55601b2b4f2e6476619f22096116c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">右手边的组装</div></td></tr>
<tr class="memitem:ac4e531baa71a5183079fd2083aa7d723"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4e531baa71a5183079fd2083aa7d723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ac4e531baa71a5183079fd2083aa7d723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369225280698a8689572f9caddc2412"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae369225280698a8689572f9caddc2412"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae369225280698a8689572f9caddc2412">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ae369225280698a8689572f9caddc2412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e81ddddb11735de517c05bc902a99"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a824e81ddddb11735de517c05bc902a99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a824e81ddddb11735de517c05bc902a99">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a824e81ddddb11735de517c05bc902a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67e7a53f39ce8f5068506dd86c17e3f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab67e7a53f39ce8f5068506dd86c17e3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ab67e7a53f39ce8f5068506dd86c17e3f">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ab67e7a53f39ce8f5068506dd86c17e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eca4da3f3af9262d01075c5144d0bf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a64eca4da3f3af9262d01075c5144d0bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a64eca4da3f3af9262d01075c5144d0bf">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a64eca4da3f3af9262d01075c5144d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d299da4539b9a5cc794d60a1f376a3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae6d299da4539b9a5cc794d60a1f376a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae6d299da4539b9a5cc794d60a1f376a3">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ae6d299da4539b9a5cc794d60a1f376a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e325333a138893e181da47f29ac680a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6e325333a138893e181da47f29ac680a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">create_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:a6e325333a138893e181da47f29ac680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf70c57cf6f92f1a7b0d73b130f0afa"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:adbf70c57cf6f92f1a7b0d73b130f0afa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#adbf70c57cf6f92f1a7b0d73b130f0afa">create_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:adbf70c57cf6f92f1a7b0d73b130f0afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166be0312d664eca59fcc7582676e112"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a166be0312d664eca59fcc7582676e112"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a166be0312d664eca59fcc7582676e112">create_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:a166be0312d664eca59fcc7582676e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac5162116a1d96e72483cfdb17a968"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a84ac5162116a1d96e72483cfdb17a968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a84ac5162116a1d96e72483cfdb17a968">create_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:a84ac5162116a1d96e72483cfdb17a968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac928341ce5b22e8285cf867122e92ef7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ac928341ce5b22e8285cf867122e92ef7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac928341ce5b22e8285cf867122e92ef7">create_boundary_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:ac928341ce5b22e8285cf867122e92ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb19571d249869eaf25b03b29f655d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6bb19571d249869eaf25b03b29f655d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6bb19571d249869eaf25b03b29f655d8">create_boundary_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a6bb19571d249869eaf25b03b29f655d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c044f24808972ceeceb105c945a694"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ad9c044f24808972ceeceb105c945a694"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad9c044f24808972ceeceb105c945a694">create_boundary_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:ad9c044f24808972ceeceb105c945a694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331275c1c2ebfe58daa7d3beef974b55"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a331275c1c2ebfe58daa7d3beef974b55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a331275c1c2ebfe58daa7d3beef974b55">create_boundary_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a331275c1c2ebfe58daa7d3beef974b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>提供一个命名空间，提供对向量的一些操作。其中包括标准向量的组合，有限元解和连续函数之差的积分，连续函数对有限元空间的插值和投影以及其他操作。</p>
<dl class="section note"><dt>Note</dt><dd>几乎所有的函数都有两个版本，一个需要明确的Mapping参数，一个不需要。第二个版本通常用一个隐含的 \(Q_1\) 参数来调用第一个版本（即用一个MappingQGeneric(1)类型的参数）。如果你打算让你的代码使用一个不同于（双/三）线性的映射，那么你需要调用应该使用<b>with</b>映射参数的函数。</dd></dl>
<h3>Description of operations</h3>
<p>这个方法集合提供了以下操作。 </p><ul>
<li>
插值：将向量中的每个自由度分配为作为参数给出的函数的值。这等于说，所产生的有限元函数（与输出向量同构）在所有试验函数的支持点都有精确的函数值。试算函数的支持点是其值等于1的点，例如，对于线性试算函数，支持点是一个元素的四个角。因此，这个函数依赖于一个假设，即使用有限元，其自由度是函数值（Lagrange元），而不是梯度、法向导数、二次导数等（Hermite元、Quintic Argyris元等）。 要创建的向量的某些值被设置两次甚至更多，这似乎是不可避免的。原因是我们必须在所有单元格上循环，并获得位于其上的每个试用函数的函数值。这也适用于位于面和角上的函数，因此我们要访问不止一次。虽然设置向量中的值不是一个昂贵的操作，但考虑到必须调用一个虚拟函数，对给定函数的评估可能是昂贵的。 </li>
<li>
投影：计算给定函数对有限元空间的<em>L</em><sup>2</sup>投影，即如果<em>f</em> ]是要投影的函数，计算<em>V<sub>h</sub></em>中的<em>f<sub>h</sub></em>，使(<em>f<sub>h</sub></em>, <em>v<sub>h</sub></em>)=(<em>f</em>, <em>v<sub>h</sub></em>)对所有离散测试函数<em>v<sub>h</sub></em>。这是通过线性方程组<em> M v = f</em>的解来实现的，其中<em>M</em>是质量矩阵 \(m_{ij} = \int_\Omega \phi_i(x) \phi_j(x) dx\) 和 \(f_i = \int_\Omega f(x) \phi_i(x) dx\) 。那么解向量 \(v\) 就是投影<em>f<sub>h</sub></em>的节点表示。project()函数在 <a class="el" href="step_21.html">step-21</a> 和 <a class="el" href="step_23.html">step-23</a> 教程中使用。 为了得到正确的结果，可能需要正确处理边界条件。下面列出了一些可能需要这样做的情况。 如果需要，可以通过<em>L</em><sup>2</sup>将给定函数的迹线投影到局限于域的边界的有限元空间来完成，然后利用这些信息，用 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> 函数从整个域的质量矩阵中消除边界节点。函数的轨迹向边界的投影是通过 <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values()</a> （见下文）函数完成的，该函数是用边界函数地图 std::map&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt;调用的，其中所有边界指标从零到 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>-1 (<a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> 用于其他目的，见三角类文档）指向要投影的函数。对边界的投影是使用给project()函数的边界上的第二个正交公式来进行的。第一个正交公式被用来计算右手边和质量矩阵的数字正交。 通常不需要先对边界值进行投影，然后从全局方程组中消除它们。如果你想对投影函数的边界值实施特殊的限制，例如在时间相关的问题中，这可能是必要的：你可能想投影初始值，但需要与后来的边界值保持一致。由于后者是在每个时间步骤中投射到边界上的，所以我们有必要在将初始值投射到整个域之前，也投射初始值的边界值。 很明显，这两种投影方案的结果是不同的。通常，当先投射到边界时，原始函数和投射到整个域上的差值的<em>L</em><sup>2</sup>-norm会更大（已观察到5个因子），而在边界上积分的误差的<em>L</em><sup>2</sup>-norm当然应该更少。如果不进行对边界的投影，相反的情况也应该成立。 选择是否需要先向边界投影是通过传递给函数的<code>project_to_boundary_first</code>标志完成的。 如果给出 <code>false</code> ，则忽略面的额外正交公式。 你应该注意的是，如果不要求向边界投影，一个边界值为零的函数在投影后可能不会有边界值为零。对于这种特别重要的情况有一个标志，它告诉函数在各自的边界部分强制执行零边界值。由于强制零边界值也可以通过投影达到，但使用其他方法获得更经济，如果设置了 <code>enforce_zero_boundary</code> 标志， <code>project_to_boundary_first</code> 标志将被忽略。 线性系统的求解目前是用简单的CG方法完成的，没有预处理，也没有多重网格。这显然不是太有效，但在许多情况下是足够的，而且容易实现。这个细节在未来可能会改变。 </li>
<li>
创建右手边的向量。create_right_hand_side() 函数计算向量 \(f_i = \int_\Omega f(x) \phi_i(x) dx\) 。这与取右手边的 <code>MatrixCreator::create_*</code> 函数所做的相同，但不需要组装矩阵。 </li>
<li>
创建点源的右手边向量。create_point_source_vector() 函数计算向量 \(F_i = \int_\Omega \delta(x-x_0) \phi_i(x) dx\) 。 </li>
<li>
创建边界右手向量。create_boundary_right_hand_side()函数计算向量 \(f_i = \int_{\partial\Omega} g(x) \phi_i(x) dx\) 。这是在拉普拉斯方程或其他二阶算子中具有不均匀的诺伊曼边界值时，边界力的右手边贡献。这个函数还需要一个可选的参数，表示积分应扩展到边界的哪些部分。如果使用默认参数，它将应用于所有边界。 </li>
<li>
边界值的插值。 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> 函数接收一个边界节点及其数值的列表。你可以通过使用interpolate_boundary_values()函数对边界函数进行内插来得到这样一个列表。要使用它，你必须指定一对边界指标（类型为 <code><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a></code>; 详见三角形类文档中的章节）和表示具有该边界指标的边界面上的节点的Dirichlet边界值的相应函数列表。 通常，所有其他的边界条件，如不均匀的Neumann值或混合边界条件都在弱式计算中处理。因此，没有尝试将这些纳入矩阵和矢量的组装过程中。 在这个函数中，边界值是插值的，也就是说，一个节点被赋予了边界函数的点值。在某些情况下，可能需要使用边界函数的L2投影或任何其他方法。为此，我们参考了下面的project_boundary_values()函数。 你应该知道，边界函数可以在面的内部的节点上进行评估。然而，这些节点不需要在真正的边界上，而是在由单元格到实际单元格的映射所代表的边界的近似上。由于这种映射在大多数情况下不是面的精确映射，边界函数是在不在边界上的点上评估的，你应该确保返回的值在某种意义上是合理的。 在1d中，情况有点不同，因为那里的面（即顶点）没有边界指标。我们假定，如果在边界函数列表中给出了边界指标0，那么左边的边界点将被插值，而右边的边界点则与地图中的边界指标1相关。然后，各自的边界函数在各自的边界点的地方被评估。 </li>
<li>
边界值的投影。project_boundary_values()函数的作用类似于interpolate_boundary_values()函数，除了它不是通过内插得到边界节点的节点值，而是通过<em>L</em><sup>2</sup>函数的轨迹投影到边界上。 投射发生在所有具有边界指标的边界部分，这些边界指标列在边界函数的地图 (std::map&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt;中。这些边界部分可能是连续的，也可能不是。对于这些边界部分，使用 <a class="el" href="namespaceMatrixCreator.html#aca36dde8ca70713334dcf438642c6a1f">MatrixTools::create_boundary_mass_matrix()</a> 函数组装质量矩阵，以及适当的右手边。然后用一个简单的CG方法（没有预设条件）来解决所产生的方程组，在大多数情况下，这对目前的目的是足够的。 </li>
<li>
计算错误。函数 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> 可以计算给定的（连续）参考函数和不同规范的有限元解之间的误差。积分使用给定的正交公式进行，并假定给定的有限元对象等于用于计算解决方案的对象。 结果被存储在一个向量中（命名为 <code>difference</code>), ，其中每个条目等于一个单元上的差值的给定规范。当用 <code>begin_active</code> 开始并用<code>++</code>操作符推广时，条目的顺序与 <code>cell_iterator</code> 相同。 这个数据，每个活动单元一个数字，可以通过 <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> 函数直接传递给DataOut类来产生图形输出。最后，可以使用 <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a>. 函数将 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> 中每个单元的输出插值到有限元场的结点上。 目前，有可能从每个单元的差值中计算出以下数值。 <code>mean</code>, <code>L1_norm</code>, <code>L2_norm</code>, <code>Linfty_norm</code>, <code>H1_seminorm</code> 和 <code>H1_norm</code>, 见 <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>. 对于平均差值，计算参考函数减去数值解，而不是反过来。 某一单元格上的差值的无穷大准则返回正交公式参数给出的正交点上的差值的最大绝对值。这在某些情况下并不是一个很好的近似值，因为例如高斯正交公式并不评估单元格的端点或角点的差。在这种情况下，你可能想选择一个有更多正交点的正交公式，或者选择一个有另一种正交点分布的正交公式。你还应该考虑到有限元在某些点上的超融合特性：例如在一维中，标准的有限元方法是一种拼合方法，应该在节点点上返回精确值。因此，梯形规则应该总是返回一个消失的L-无穷大误差。相反，在二维中，最大的L-无穷大误差应该位于顶点或单元的中心，这使得使用辛普森正交法则是合理的。另一方面，在高斯积分点可能会出现超融合。这些例子不是作为经验法则，而是想说明，使用错误的正交公式可能会显示出明显错误的结果，应该注意选择正确的公式。 <em>H</em><sup>1</sup>半正则是<em>L</em><sup>2</sup>差值梯度的准则。全<em>H</em><sup>1</sup>规范的平方是seminorm的平方与<em>L</em><sup>2</sup>规范的平方之和。 为了得到全局<em>L<sup>1</sup></em>的误差，你必须对 <code>difference</code>, 中的条目进行求和，例如使用 <a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">Vector::l1_norm()</a> 函数。 对于全局<em>L</em><sup>2</sup>差值，你必须将各条目的平方相加，然后取和的根，例如使用 <a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">Vector::l2_norm()</a>. 这两个操作代表向量的<em>l</em><sub>1</sub>和<em>l</em><sub>2</sub>规范，但你不需要取每个条目的绝对值，因为单元格规范已经是正的了。 要得到全局平均差，只需像上面那样将各元素相加。要得到 \(L_\infty\) 准则，取向量元素的最大值，例如，使用 <a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">Vector::linfty_norm()</a> 函数。 对于全局<em>H</em><sup>1</sup>规范和半规范，与<em>L</em><sup>2</sup>规范的规则相同：计算细胞误差向量的<em>l</em><sub>2</sub>规范。 注意，在一维的情况下，如果你要求一个需要计算梯度的规范，那么所提供的函数会自动沿曲线投影，并且只计算梯度的切向部分的差值，因为无论如何都没有关于梯度的法向部分的信息。 </li>
</ul>
<p>所有函数都使用上次自由度分布在三角形上时给DoFHandler对象的有限元。另外，如果需要访问描述边界确切形式的对象，则访问存储在三角剖分对象中的指针。</p>
<dl class="section note"><dt>Note</dt><dd>这个模板的实例化提供给一些矢量类型，特别是<code><a class="el" href="classVector.html">Vector</a>&lt;float&gt;, <a class="el" href="classVector.html">Vector</a>&lt;double&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;float&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;double&gt;</code>；其他的可以在应用代码中生成（见手册中 <a class="el" href="Instantiations.html">Template instantiations</a> 部分）。 </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69967cb7a148a7169963126249213db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69967cb7a148a7169963126249213db1">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>表示哪个规范/积分将由 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> 函数在每个单元格上计算，而 <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a> 则是针对整个域。 让 \(f:\Omega \rightarrow \mathbb{R}^c\) 是一个具有 \(c\) 分量的有限元函数，其中 \(c\) 分量由 \(f_c\) 表示， \(\hat{f}\) 是参考函数（ <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a>的 <code>fe_function</code> 和 <code>exact_solution</code> 参数）。让 \(e_c = \hat{f}_c - f_c\) 为二者之间的差异或误差。此外，让 \(w:\Omega \rightarrow \mathbb{R}^c\) 为 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a>的 <code>weight</code> 函数，如果没有提供，则假定它等于1。最后，让 \(p\) 为 <code>exponent</code> 的参数（对于 \(L_p\) -norms）。 在下文中，我们用 \(E_K\) 表示在单元格 \(K\) 上通过 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> 计算的局部误差，而 \(E\) 是通过 <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a> 计算的全局误差。请注意，积分是以通常的方式用正交法进行近似的。 </p><p class="formulaDsp">
\[ \int_A f(x) dx \approx \sum_q f(x_q) \omega_q. \]
</p>
<p> 同样，对于一个单元上的上位数 \(T\) : </p><p class="formulaDsp">
\[ \sup_{x\in T} |f(x)| dx \approx \max_q |f(x_q)|. \]
</p>
<p> 。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27"></a>mean&#160;</td><td class="fielddoc"><p>函数或函数之差在每个单元格上进行积分 \(K\) : </p><p class="formulaDsp">
\[ E_K = \int_K \sum_c (\hat{f}_c - f_c) \, w_c = \int_K \sum_c e_c \, w_c \]
</p>
<p> 并求和得到 </p><p class="formulaDsp">
\[ E = \sum_K E_K = \int_\Omega \sum_c (\hat{f}_c - f_c) \, w_c \]
</p>
<p> 或对于 \(w \equiv 1\) : </p><p class="formulaDsp">
\[ E = \int_\Omega (\hat{f} - f) = \int_\Omega e. \]
</p>
<p> 注意：这与通常所说的函数的平均值不同，是 \(\frac{1}{|\Omega|}\) 的一个因素。要计算平均值，你也可以使用compute_mean_value()。最后，注意符号：如果 \(\hat{f}=0\) ，这将计算 \(f\) 的平均值的负数。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357"></a>L1_norm&#160;</td><td class="fielddoc"><p>函数的绝对值被整合。 </p><p class="formulaDsp">
\[ E_K = \int_K \sum_c |e_c| \, w_c \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \sum_K E_K = \int_\Omega \sum_c |e_c| w_c, \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \| e \|_{L^1}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e"></a>L2_norm&#160;</td><td class="fielddoc"><p>函数的平方被整合，结果的平方根在每个单元格上被计算出来。 </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \sum_c e_c^2 \, w_c } \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c e_c^2 \, w_c } \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \sqrt{ \int_\Omega e^2 } = \| e \|_{L^2} \]
</p>
<p>。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6"></a>Lp_norm&#160;</td><td class="fielddoc"><p>对 \(p\) 的绝对值进行整合，在每个单元格上计算 \(p\) 的根。指数 \(p\) 是 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> 和 compute_mean_value() 的 <code>指数参数。</code> </p><p class="formulaDsp">
\[ E_K = \left( \int_K \sum_c |e_c|^p \, w_c \right)^{1/p} \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \left( \sum_K E_K^p \right)^{1/p} \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \| e \|_{L^p}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4"></a>Linfty_norm&#160;</td><td class="fielddoc"><p>的最大绝对值的函数。 </p><p class="formulaDsp">
\[ E_K = \sup_K \max_c |e_c| \, w_c \]
</p>
<p> 和 </p><p class="formulaDsp">
\[ E = \max_K E_K = \sup_\Omega \max_c |e_c| \, w_c \]
</p>
<p> 或者，对于 \(w \equiv 1\) : </p><p class="formulaDsp">
\[ E = \sup_\Omega \|e\|_\infty = \| e \|_{L^\infty}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f"></a>H1_seminorm&#160;</td><td class="fielddoc"><p>#L2_norm的梯度。 </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \sum_c (\nabla e_c)^2 \, w_c } \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c (\nabla e_c)^2 \, w_c } \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \| \nabla e \|_{L^2}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a1ab711e0a460000489addc7aa59878d2"></a>Hdiv_seminorm&#160;</td><td class="fielddoc"><p>#L2_norm的向量场的发散。函数 \(f\) 预计有 \(c \geq \text{dim}\) 个分量，第一个 <code>dim</code> 将被用来计算发散。 </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \left( \sum_c \frac{\partial e_c}{\partial x_c} \, \sqrt{w_c} \right)^2 } \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \left( \sum_c \frac{\partial e_c}{\partial x_c} \, \sqrt{w_c} \right)^2 } \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \| \nabla \cdot e \|_{L^2}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c"></a>H1_norm&#160;</td><td class="fielddoc"><p>这个规范的平方是::L2_norm的平方加上::H1_seminorm的平方。 </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \sum_c (e_c^2 + (\nabla e_c)^2) \, w_c } \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c (e_c^2 + (\nabla e_c)^2) \, w_c } \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \left( \| e \|_{L^2}^2 + \| \nabla e \|_{L^2}^2 \right)^{1/2}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930"></a>W1p_seminorm&#160;</td><td class="fielddoc"><p>#Lp_norm的梯度。 </p><p class="formulaDsp">
\[ E_K = \left( \int_K \sum_c |\nabla e_c|^p \, w_c \right)^{1/p} \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \left( \sum_K E_K^p \right)^{1/p} = \left( \int_\Omega \sum_c |\nabla e_c|^p \, w_c \right)^{1/p} \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \| \nabla e \|_{L^p}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3"></a>W1p_norm&#160;</td><td class="fielddoc"><p>与::H1_norm相同，但使用&lt;i&gt;L<sup>p</sup>。 </p><p class="formulaDsp">
\[ E_K = \left( \int_K \sum_c (|e_c|^p + |\nabla e_c|^p) \, w_c \right)^{1/p} \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \left( \sum_K E_K^p \right)^{1/p} = \left( \int_\Omega \sum_c (|e_c|^p + |\nabla e_c|^p) \, w_c \right)^{1/p} \]
</p>
<p>，或者，对于 \(w \equiv 1\) : </p><p class="formulaDsp">
\[ E = \left( \| e \|_{L^p}^p + \| \nabla e \|_{L^p}^p \right)^{1/p}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418"></a>W1infty_seminorm&#160;</td><td class="fielddoc"><p>#梯度的Linfty_norm。 </p><p class="formulaDsp">
\[ E_K = \sup_K \max_c |\nabla e_c| \, w_c \]
</p>
<p>和 </p><p class="formulaDsp">
\[ E = \max_K E_K = \sup_\Omega \max_c |\nabla e_c| \, w_c \]
</p>
<p>或者，对于 \(w \equiv 1\) ： </p><p class="formulaDsp">
\[ E = \| \nabla e \|_{L^\infty}. \]
</p>
<p> 。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619"></a>W1infty_norm&#160;</td><td class="fielddoc"><p>＃Linfty_norm和＃W1infty_seminorm之和。 </p><p class="formulaDsp">
\[ E_K = \sup_K \max_c |e_c| \, w_c + \sup_K \max_c |\nabla e_c| \, w_c. \]
</p>
<p> 全局规范没有在compute_global_error()中实现，因为不可能从值中计算出全局规范的总和 \(E_K\) 。作为一种变通方法，你可以分别计算全局的::Linfty_norm和::W1infty_seminorm，然后将它们相加，得到（与 \(w \equiv 1\) ）。 </p><p class="formulaDsp">
\[ E = \| e \|_{L^\infty} + \| \nabla e \|_{L^\infty}. \]
</p>
 </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vector__tools__common_8h_source.html#l00043">43</a> of file <a class="el" href="vector__tools__common_8h_source.html">vector_tools_common.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af27ac28c698a9ed0199faed50a204538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27ac28c698a9ed0199faed50a204538">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算对应于施加Dirichlet边界条件的解决方案的约束。 这个函数通过在边界周围插值，创建一个受迪里希特边界条件约束的自由度地图，以及要分配给它们的相应数值。对于边界上的每个自由度，如果它的索引已经存在于 <code>boundary_values</code> 中，那么它的边界值将被覆盖，否则将在 <code>boundary_values</code>. 中插入一个具有适当索引和边界值的新条目。 参数 <code>function_map</code> 提供了一个由该函数处理的边界指标列表和相应的边界值函数。 该图的键对应于面的编号 <code>boundary_id</code> 。 <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> 是这个键的非法值，因为它是为内部面保留的。关于如何用非空地图使用这个参数的例子，请看 <a class="el" href="step_16.html">step-16</a> 的教程程序。 最后一个参数 <code>component_mask</code> 中的标志表示有限元空间的哪些部分应被插值。如果保留默认值（即一个空数组），所有组件都被插值。如果它与默认值不同，则假定条目数等于边界函数和有限元中的分量数，给定边界函数中的那些分量将被用于在分量掩码中设置的相应标志。另见 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> 。 举个例子，假设你正在求解2d中的斯托克斯方程，变量为 \((u,v,p)\) ，你只想插值速度的边界值，那么分量掩码应该对应于 <code>(true,true,false)</code> 。 </p><dl class="section note"><dt>Note</dt><dd>无论是否指定了分量掩码， <code>function_map</code> 中函数的分量数必须与 <code>dof</code>. 使用的有限元的分量数一致。 ] 换句话说，对于上面的例子，你需要提供一个有3个分量（两个速度和压力）的Function对象，尽管你只对其中的前两个感兴趣。 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a>然后会调用这个函数，在每个插值点获得3个值的向量，但只取前两个，舍弃第三个。换句话说，你可以自由地在 <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function::vector_value</a>, 返回的向量的第三个分量中返回你喜欢的东西，但Function对象必须说明它有3个分量。 如果使用的有限元的形状函数在一个以上的分量中是非零的（用deal.II的话说：它们是非原始的），那么这些分量目前不能用于内插边界值。 因此，与这些非正则形状函数的分量相对应的分量掩码中的元素必须是 <code>false</code>. 更多信息请参见该命名空间的一般文档。 </dd>
<dd>
当求解带有边界条件的偏微分方程 \(u|_{\partial\Omega}=g\) （或边界的部分*）时，那么这个边界条件一般不能用 \(u_h|_{\partial\Omega}=g\) 形式的有限元准确满足。这是因为函数 \(g\) 一般不是多项式，而 \(u_h|_{\partial\Omega}\) 在位于边界的网格的每个面上都是*项多项式。换句话说，一般来说，不可能施加*这样的边界条件；然而，可以*做的是施加 <p class="formulaDsp">
\[ u_h|_{\partial\Omega}=I_h^{\partial\Omega} g, \]
</p>
，其中 \(I_h^{\partial\Omega} g\) 是一个函数，在位于边界的有限元空间的每个节点上等于 \(g\) ，并且在两者之间是片断多项式。换句话说， \(I_h^{\partial\Omega}\) 是一个内插算子*， \(I_h^{\partial\Omega} g\) 是内插的边界值</dd></dl>
<p>&ndash;因此而得名。使用 \(I_h^{\partial\Omega} g\) 而不是 \(g\) 作为边界值会带来一个额外的误差（与使用正交引入一个额外的误差相比，能够准确计算弱形式的积分）。在大多数情况下，这个额外的误差与有限元方法中的其他误差项相同，尽管在测量 \(L^2\) 准则中的误差时有一些微妙的差别。关于一些细节，请参见 <b>[Bartels2004]</b> 。 </p><dl class="section note"><dt>Note</dt><dd>使用内插法的一个替代方法， <p class="formulaDsp">
\[ u_h|_{\partial\Omega}=I_h^{\partial\Omega} g \]
</p>
是使用边界值 \(g\) 对边界上的有限元空间的投影*： <p class="formulaDsp">
\[ u_h|_{\partial\Omega}=\Pi_h^{\partial\Omega} g. \]
</p>
 投影可以使用project_boundary_values()函数。使用投影可能有一些理论上的优势（参见 <b>[Bartels2004]</b> ），但有一个实际的缺点，即计算投影比计算插值要昂贵得多，因为后者可以一次完成一个面，而投影则需要解决整个边界上的问题。另一方面，插值只适用于 "节点式
"有限元空间（如FE_Q，但不包括FE_Q_Hierarchical），而投影则始终适用。 </dd></dl>

</div>
</div>
<a id="a316c2741c61a2b7f0372c9dbb69b7c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316c2741c61a2b7f0372c9dbb69b7c88">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像之前的函数一样，但采取一个映射集合，以配合具有hp能力的DoFHandler对象。 </p>

</div>
</div>
<a id="afff02b67200d44ba712eb004fe7e8208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff02b67200d44ba712eb004fe7e8208">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面的函数一样，但只取一对边界指标和相应的边界函数。同样的评论适用于前面的函数，特别是关于组件掩码的使用和函数对象的要求大小。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a9045591cffcf0c8a06b583e6563510e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9045591cffcf0c8a06b583e6563510e2">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像之前的函数一样，但要取一个映射集合，以配合具有hp-capabilities的DoFHandler对象。 </p>

</div>
</div>
<a id="aa9c6fe2f772b09e2bfbb95ff6e49aa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c6fe2f772b09e2bfbb95ff6e49aa28">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用另一个interpolate_boundary_values()函数，见上文，使用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 与前一个函数的注释相同，特别是关于组件掩码的使用和函数对象的要求大小。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="afad4dbef1b304b170be0362b0590ada1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad4dbef1b304b170be0362b0590ada1">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用另一个interpolate_boundary_values()函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 与前一个函数的评论相同，特别是关于使用分量掩码和函数对象的要求大小。 </p>

</div>
</div>
<a id="a7d6e975950cd122b6a2924b1ecd4ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6e975950cd122b6a2924b1ecd4ec60">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但要取一个映射集合，以配合具有hp-capabilities的DoFHandler对象。 </p>

</div>
</div>
<a id="aaa0ffb5d4bd09003cd869b00573cf1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0ffb5d4bd09003cd869b00573cf1d6">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像之前的函数一样，但要取一个映射集合，以配合具有hp-capabilities的DoFHandler对象。 </p>

</div>
</div>
<a id="a5aa5117bc6324d18df70c9cb86442b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa5117bc6324d18df70c9cb86442b88">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>投射一个函数或一组函数到域的边界。 换句话说，计算以下问题的解决方案：找到 \(u_h \in V_h\) （其中 \(V_h\) 是由该函数的DoFHandler参数所代表的有限元空间），以便 </p><p class="formulaDsp">
\begin{align*} \int_{\Gamma} \varphi_i u_h = \sum_{k \in {\cal K}} \int_{\Gamma_k} \varphi_i f_k, \qquad \forall \varphi_i \in V_h \end{align*}
</p>
<p> 其中 \(\Gamma = \bigcup_{k \in {\cal K}} \Gamma_k\) , \(\Gamma_k \subset \partial\Omega\) , \(\cal K\) 是指数集， \(f_k\) 是该函数的函数图参数 <code>boundary_values</code> 所代表的相应边界函数，积分用正交法求值。这个问题在内部有一个非唯一的解决方案，但对于边界部分的自由度， \(\Gamma\) ，它是定义良好的，我们对其进行积分。 \(u_h|_\Gamma\) 的值，即这个函数沿边界的自由度的节点值，就是这个函数所计算的。 如果这个函数与 \(H_{div}\) 符合的有限元空间一起使用，则会计算出一个不同的问题的解决方案，即。找到 \(\vec{u}_h \in V_h \subset H(\text{div}; \Omega)\) ，以便 </p><p class="formulaDsp">
\begin{align*} \int_{\Gamma} (\vec{\varphi}_i \cdot \vec{n}) (\vec{u}_h \cdot \vec{n}) = \sum_{k \in {\cal K}} \int_{\Gamma_k} (\vec{\varphi}_i \cdot \vec{n}) (\vec{f}_k \cdot \vec{n}), \qquad \forall \vec{\varphi_i} \in V_h, \end{align*}
</p>
<p> 其中 \(\vec{n}\) 是一个外向法向量。 如果与 \(H_\text{curl}\) 符合的元素一起使用，这个函数会抛出一个异常，所以应该使用project_boundary_values_curl_conforming_l2()来代替。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">映射</td><td>将用于沿边界整合所需的转换的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>描述有限元空间和自由度编号的DoFHandler。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_functions</td><td>从边界指标到函数指针的映射，这些函数描述了边界上标有该边界指标的那些部分的期望值（见 <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">边界指标</a> ）。 投影只发生在边界的那些部分，这些部分的指标在这个地图中被代表。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>用于计算质量矩阵和投影的右手边所需的积分的面正交。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundary_values</td><td>这个函数的结果。它是一个包含边界上所有自由度指数的地图（如 <code>boundary_functions</code>) 中的边界部分所涵盖的，以及该自由度的计算dof值。对于边界上的每个自由度，如果它的索引已经存在于 <code>boundary_values</code> 中，那么它的边界值将被覆盖，否则将在 <code>boundary_values</code>. 中插入一个具有适当索引和边界值的新条目。 ] component_mapping 有时，将一个矢量值函数投射到有限元空间的一部分是很方便的（例如，将一个 <code>dim</code> 分量的函数投射到斯托克斯问题的 <code>dim+1</code> 分量DoFHandler的速度分量）。为了允许这一点，这个参数允许分量被重新映射。如果矢量不是空的，它必须为 <code>dof</code>. 中使用的有限元的每个矢量分量有一个条目，这个条目是 <code>boundary_functions</code> 中的分量编号，应该用于 <code>dof</code>. 中的这个分量。 默认情况下，不应用重新映射。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>使用投影*而不是边界值的插值*，在实践中没有什么区别。也就是说，计算投影的计算成本要高得多，因为它需要解决一个耦合边界上所有未知数的问题，而内插法则是一次只计算一个面。另一方面，插值只适用于 "节点型
"有限元空间（如FE_Q，但不包括FE_Q_Hierarchical），而投影则始终适用。(关于一些更多的理论考虑，见上面第一个interpolate_boundary_values()函数的文档)。 </dd></dl>

</div>
</div>
<a id="af52d603a67047f73226b2e9653bffcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52d603a67047f73226b2e9653bffcf1">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用project_boundary_values()函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="ac63c020c0782c918a8c43972285bfd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63c020c0782c918a8c43972285bfd2f">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但有hp-capabilities。 </p>

</div>
</div>
<a id="acb559352c78982c7d36b444d0024720e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb559352c78982c7d36b444d0024720e">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用project_boundary_values()函数，见上文，使用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="af0966d7adbacddce3ba37790a604e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0966d7adbacddce3ba37790a604e49f">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorTools::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotAvailableHere&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The given point is inside a cell of a &quot; &quot;<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> that is not &quot; &quot;locally owned by this processor.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a1ad6eceb6cbeaa505baf7f938289bbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad6eceb6cbeaa505baf7f938289bbde">&#9670;&nbsp;</a></span>point_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::value_type&gt; VectorTools::point_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个（分布式）解决方案向量 <code>vector</code>, 评估由 <code>evaluation_points</code>. 指定的（任意甚至是远程）点的值 </p><dl class="section warning"><dt>Warning</dt><dd>这是一个集体调用，需要由通信器的所有处理器执行。 </dd></dl>

</div>
</div>
<a id="a6cb22a97ffc83df35caf11dbd4e336cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb22a97ffc83df35caf11dbd4e336cc">&#9670;&nbsp;</a></span>point_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::value_type&gt; VectorTools::point_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个（分布式）解决方案向量 <code>vector</code>, ，评估由 <code>cache</code> 指定的点的值，这些点可能是由上述函数设置的。 </p><dl class="section note"><dt>Note</dt><dd>细化/粗化/重新分区导致缓存无效，因此必须再次调用上述函数。 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>这是一个集体调用，需要由通信器中的所有处理器来执行。 </dd></dl>

</div>
</div>
<a id="aada37fd09d8be1b9ed9bb12d698f8ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada37fd09d8be1b9ed9bb12d698f8ee4">&#9670;&nbsp;</a></span>point_gradients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::gradient_type&gt; VectorTools::point_gradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个（分布式）解决方案向量 <code>vector</code>, 评估由 <code>evaluation_points</code>. 指定的（任意的甚至是遥远的）点的梯度。 </p>

</div>
</div>
<a id="a5febf52b3f767d8e276e2c02d0ea0662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5febf52b3f767d8e276e2c02d0ea0662">&#9670;&nbsp;</a></span>point_gradients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::gradient_type&gt; VectorTools::point_gradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个（分布式）解向量 <code>vector</code>, ，评估由 <code>cache</code> 指定的点的梯度，这可能是由上述函数设置的。 </p><dl class="section note"><dt>Note</dt><dd>细化/粗化/重新划分导致缓存无效，因此必须再次调用上述函数。 </dd></dl>

</div>
</div>
<a id="a676190d2c897ac5da68a9c460fa95832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676190d2c897ac5da68a9c460fa95832">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算有限元解的单元误差。 对作为连续函数对象的参考函数和有限元函数之间的差异进行积分。这个函数的结果是向量 <code>difference</code> ，包含三角形的每个活动单元 \(K\) 的一个值。这个向量 \(d\) 的每个值都等于 </p><p class="formulaDsp">
\begin{align*} d_K = \| u-u_h \|_X \end{align*}
</p>
<p> 其中 \(X\) 表示选择的规范， \(u\) 表示精确解。 假设函数 <code>exact_solution的分量数与</code> <code>dof</code>. 使用的有限元的分量数一致。 为了计算有限元解的全局误差准则，使用 <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a> 与用该函数计算的输出向量。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">映射</td><td>在积分差分时使用的映射 \(u-u_h\) 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>描述解向量所在的有限元空间的DoFHandler对象。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>代表数值逼近的节点值的向量 \(u_h\) 。这个向量需要对应于 <code>dof</code>. 所代表的有限元空间 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact_solution</td><td>用于计算误差的精确解。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">difference</td><td>如上所述计算的值 \(d_K\) 的向量。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>用来近似上述积分的正交公式。注意有些正交公式在积分中比其他公式更有用 \(u-u_h\) 。例如，已知 \(Q_1\) 对拉普拉斯方程精确解 \(u\) 的近似 \(u_h\) 在对应于QGauss(2)对象的2D单元的4个高斯点（或3D的8个点）上特别精确（实际上是超融合，即精确到高阶）。因此，由于QGauss(2)公式只对这些特定点上的两个解进行评估，选择这个正交公式可能表明误差远远小于实际情况。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">法线</td><td>上面显示的应该计算的法线 \(X\) 。如果规范是 NormType::Hdiv_seminorm, ，那么调用此函数的有限元需要至少有dim向量分量，分歧将在第一个div分量上计算。例如，这对用于混合拉普拉斯方程（ <a class="el" href="step_20.html">step-20</a> ）和斯托克斯方程（ <a class="el" href="step_22.html">step-22</a> ）的有限元有效。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">权重</td><td>附加参数 <code>weight</code> 允许评估加权规范。 权重函数可以是标量的，在域中为所有分量平等地建立一个空间上的可变权重。例如，这可用于只对域的部分进行积分。 权重函数也可以是矢量值的，有和有限元一样多的成分。然后，不同的分量得到不同的权重。一个典型的应用是当只计算与一个或一个解变量子集有关的误差时，在这种情况下，其他组件的权重值等于零。ComponentSelectFunction类对这一目的特别有用，因为它提供了这样一个 "屏蔽
"权重。该权重函数被期望为正值，但负值不会被过滤。这个函数的默认值是一个空指针，被解释为 "没有加权函数"，即在整个域中，所有向量成分的权重统一为1。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">指数</td><td>这个值表示在计算 \(L^p\) -norms和 \(W^{1,p}\) -norms时使用的 \(p\) 。如果选择了 NormType::Lp_norm, NormType::W1p_norm, 或 NormType::W1p_seminorm 以外的 <code>norm</code> ，该值会被忽略。 更多信息请参见该命名空间的一般文档。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8d01703fa0d91ed6404009757680886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01703fa0d91ed6404009757680886d">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> 函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="aec4da3324bbce54d7c12dd54c59dd915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4da3324bbce54d7c12dd54c59dd915">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的hp相同。 </p>

</div>
</div>
<a id="a0900dfa36831d4fa6d4225b8e98cfcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0900dfa36831d4fa6d4225b8e98cfcda">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> 函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="a21eb62d70953182dcc2b15c4e14dd533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eb62d70953182dcc2b15c4e14dd533">&#9670;&nbsp;</a></span>compute_global_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::compute_global_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>cellwise_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在每个有<code><a class="el" href="namespaceinternal_1_1TriangulationImplementation.html#a3344398031a9e10cb9eef0784f8da1be">tria.n_active_cells()</a></code>项的单元格上取一个错误向量 <code>cellwise_error</code> ，并返回由 <code>norm</code>. 给出的全局错误。 <code>cellwise_error</code> 向量通常是由 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> 产生的输出，你通常希望为 <code>norm</code> ]的值与你在 <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>. 中使用的值相同。如果给定的三角形是 <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, 中不对应于本地拥有的单元格的条目被假定为0.0，并使用MPI进行并行还原以计算全局误差。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>与 <code>cellwise_error</code>. 中的条目相对应的活动单元的三角形 </td></tr>
    <tr><td class="paramname">cellwise_error</td><td>每个活动单元的误差矢量。 </td></tr>
    <tr><td class="paramname">norm</td><td>要计算的规范类型。 </td></tr>
    <tr><td class="paramname">exponent</td><td>用于 \(L^p\) -norms和 \(W^{1,p}\) -norms的指数 \(p\) 。如果选择 <code>norm</code> 以外的 NormType::Lp_norm, NormType::W1p_norm, 或 NormType::W1p_seminorm ，该值会被忽略。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>为Vector&lt;double&gt;和Vector&lt;float&gt;类型实例化。 </dd></dl>

</div>
</div>
<a id="a761f008bdeb7d94a69205ae824deefad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761f008bdeb7d94a69205ae824deefad">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>function</code> 在支持点的内插到由给定DoFHandler参数初始化的Triangulation和FiniteElement对象描述的有限元空间。假设 <code>function</code> 的分量数与 <code>dof</code>. 使用的有限元的分量数相匹配。注意，你可能要在事后用空间 <code>dof</code> 的悬空节点调用<code>hanging_nodes.distribution(vec)</code>，以便使结果再次连续。 更多信息请参见该命名空间的一般文档。 </p>

</div>
</div>
<a id="a34fa653b9e16be54bda225e64f9b2b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fa653b9e16be54bda225e64f9b2b56">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但在hp-context中。 </p>

</div>
</div>
<a id="a32b68e11070496fcaf6c2389f088d09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b68e11070496fcaf6c2389f088d09c">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim,spacedim&gt;(1)</code>. 调用上面的 <code><a class="el" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">interpolate()</a></code> 函数。 </p>

</div>
</div>
<a id="a5e3af70a47cedfaf361cf5c621e94e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3af70a47cedfaf361cf5c621e94e3d">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>data_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>data_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对不同的有限元空间进行插值。从 <code>dof_1</code> 代表的FE空间到FE空间 <code>dof_2</code>. 上的向量 <code>data_2</code> 执行向量 <code>data_1</code> 的插值（假设是重影，见 <a class="el" href="DEALGlossary.html#GlossGhostedVector">GlossGhostedVector</a> ），每个单元上的插值由矩阵 <code>transfer</code>. 表示，迄今为止，弯曲的边界被忽略了。 请注意，你可能要在之后调用<code>hanging_nodes.distribution(data_2)</code>与空间 <code>dof_2</code> 中的悬挂节点，以使结果再次连续。 </p><dl class="section note"><dt>Note</dt><dd>这个模板的实例化提供给一些矢量类型（见命名空间的一般文档），但只有InVector和OutVector的同一个矢量。其他组合必须通过手工实例化。 </dd></dl>

</div>
</div>
<a id="afbf179d7bbaec3bede8e732aadedc51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf179d7bbaec3bede8e732aadedc51b">&#9670;&nbsp;</a></span>interpolate_based_on_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_based_on_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数是该系列中第一个interpolate()函数的一种概括或修改。它将一组函数插值到由DoFHandler参数定义的有限元空间上，根据每个单元的材料ID（见 <a class="el" href="DEALGlossary.html#GlossMaterialId">GlossMaterialId</a> ）来决定在每个单元上使用哪个函数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>用来确定要评估函数的支持点位置的映射。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>用Triangulation和FiniteElement对象初始化的DoFHandler，它定义了有限元空间。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_map</td><td>A std::map 反映了那些应该被内插的单元上的材料ID与要内插到有限元空间上的函数之间的对应关系。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>全局有限元向量，保存内插值的输出。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>应被内插的组件的掩码。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>如果算法遇到一个单元，其材料ID没有列在给定的 <code>function_map</code>, 中，那么 <code>dst</code> 将不会在输出向量的各自自由度中被更新。例如，如果 <code>dst</code> 被初始化为零，那么在调用此函数后，那些对应于遗漏的材料ID的零将仍然保留在 <code>dst</code> 中。 </dd>
<dd>
位于不同材料id的单元之间的面的自由度将由在本函数中实现的各单元循环中最后调用的单元获得其值。由于单元格的顺序在某种程度上是任意的，你无法控制它。然而，如果你想控制单元格被访问的顺序，让我们看一下下面的例子。让 <code>u</code> 是一个感兴趣的变量，它被一些CG有限元所近似。让 <code>0</code>, <code>1</code> 和 <code>2</code> 为三角形上的单元的材料id。让0：0.0，1：1.0，2：2.0是你想传递给这个函数的整个 <code>function_map</code> ，其中 <code>key</code> 是材料ID， <code>value</code> 是 <code>u</code>. 的值 通过使用整个 <code>function_map</code> ，你并不真正知道哪些值会被分配给面的DoF。另一方面，如果你把整个 <code>function_map分成三个较小的独立对象0：0</code>.0和1：1.0以及2：2.0，并对这个函数进行三次不同的调用，分别传递这些对象（顺序取决于你想在单元间得到什么），那么后面的每次调用将重写前一次的单元间 <code>dofs。</code> </dd></dl>

</div>
</div>
<a id="ac4807a032b164d00ae06adb8cfb2c9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4807a032b164d00ae06adb8cfb2c9d1">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>dof1-function</code> <code>u1</code> 到 <code>dof2-function</code> <code>u2</code>, 的插值，其中 <code>dof1</code> 和 <code>dof2</code> 代表具有共同粗网格的不同三角形。 dof1和dof2需要具有相同的有限元离散化。 请注意，对于有悬挂节点的网格上的连续元素（即局部细化网格），这个函数并不能给出预期的输出。 事实上，由于局部单元插值的原因，所产生的输出矢量不一定尊重悬空节点的连续性要求。 对于这种情况（有悬挂节点的网格上的连续元素），请使用带有额外AffineConstraints参数的interpolate_to_different_mesh函数，见下文，或者通过调用悬挂节点约束对象的 <code><a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a></code> 函数使场符合要求。 </p><dl class="section note"><dt>Note</dt><dd>这个函数与 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, 一起工作，但只有在两个网格的平行分区相同的情况下（见 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a1bcfd814692ed67b8c57e84b042158ad">parallel::distributed::Triangulation&lt;dim&gt;::no_automatic_repartitioning</a> 标志）。 </dd></dl>

</div>
</div>
<a id="abad7ee745dc25e8699e893df7ebdb668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad7ee745dc25e8699e893df7ebdb668">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>dof1-function</code> <code>u1</code> 到 <code>dof2-function</code> <code>u2</code>, 的插值，其中 <code>dof1</code> 和 <code>dof2</code> 代表具有共同粗网格的不同三角形。Dof1和Dof2需要具有相同的有限元离散化。 <code>constraints</code> 是对应于 <code>dof2的悬挂节点约束对象。当插值到具有悬挂节点的网格（局部细化网格）上的连续元素时，这个对象特别重要。</code> 没有它</p>
<ul>
<li>由于单元格内插的原因</li>
<li>产生的输出矢量不一定尊重悬挂节点的连续性要求。 </li>
</ul>

</div>
</div>
<a id="ac48b116f0b923f29ca6121890ec19b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48b116f0b923f29ca6121890ec19b61">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>intergridmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述函数相同，但直接接受InterGridMap对象作为参数。对于同时插值几个向量很有用。 <code>intergridmap</code> 必须通过 <a class="el" href="classInterGridMap.html#a9e9ed6c30b05d6ff93587e5306122bc2">InterGridMap::make_mapping</a> 从源DoFHandler指向目的DoFHandler进行初始化。 </p>

</div>
</div>
<a id="afcb40e50d2fa4807762faefed206f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb40e50d2fa4807762faefed206f5e3">&#9670;&nbsp;</a></span>get_position_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::get_position_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>几何插值 给定一个至少包含一个间隔向量场的DoFHandler，这个函数在FE_Q()有限元的支持点上插值三角图，该有限元的度数与所需组件的度数相同。 曲线流形得到尊重，产生的VectorType将是几何上一致的。产生的映射保证在FE_Q()有限元的支持点上是插值的，其程度与所需组件的程度相同。 如果底层有限元是FE_Q(1)^spacedim，那么产生的 <code>VectorType</code> 是三角结构顶点的有限元场表示。 可选的ComponentMask参数可以用来指定FiniteElement的哪些组件来描述几何。如果在构造时没有指定掩码，那么将使用默认的构造掩码，这将被解释为假设FiniteElement的第一个`spacedim'分量来代表问题的几何形状。 这个函数只对指定组件是原始的FiniteElements实现。 </p>

</div>
</div>
<a id="a6d8e3037188b85efb319cb065750da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8e3037188b85efb319cb065750da59">&#9670;&nbsp;</a></span>get_position_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::get_position_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述函数类似，但也以 <code>mapping</code> 为参数。 如果映射的度数低于DoFHandler <code>dh</code>, 中有限元素的度数，这将在流形指定的真实几何之间引入一个额外的近似值，但更重要的是它允许为不保留顶点位置的映射（如欧拉映射）填充位置向量。 </p>

</div>
</div>
<a id="a55601b2b4f2e6476619f22096116c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55601b2b4f2e6476619f22096116c0e4">&#9670;&nbsp;</a></span>subtract_mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::subtract_mean_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_select</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>均值运算 从一个向量中减去（代数）均值。 这个函数最经常被用作斯托克斯的均值过滤器。 在斯托克斯方程中，速度只有Dirichlet边界的压力只确定到一个常数。这个函数允许减去压力的平均值。它通常在预处理程序中调用，并产生平均值为零的更新。平均值是按照输入矢量给出的自由度值的平均值计算的；它们不以单元面积为权重，也就是说，平均值被计算为 \(\sum_i v_i\) ，而不是 \(\int_\Omega v(x) = \int_\Omega \sum_i v_i \phi_i(x)\) 。然而，后者可以从 VectorTools::compute_mean_function, 中得到。 除了对向量 <code>v</code> 进行操作外，该函数还需要一个布尔掩码 <code>p_select</code> ，该掩码对向量的每个元素都有一个真条目，对这些元素将计算出平均值并随后减去。该参数用于表示解向量中与压力相对应的分量，而避免触及向量的所有其他分量，如速度分量。(但是请注意，该掩码不是对解向量 <code>v</code> 可能与之相关的有限元的向量分量进行操作的 <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ；相反，它是对整个向量的掩码，而不参考向量元素的含义)。 布尔掩码 <code>p_select</code> 有一个空矢量作为默认值，这将被解释为选择所有矢量元素，因此，减去整个矢量上的代数平均值。如果要处理整个向量，这允许在没有布尔掩码的情况下调用这个函数。 </p><dl class="section note"><dt>Note</dt><dd>在使用这个函数过滤掉一个算子的内核的情况下（例如由常数压力组成的斯托克斯算子的空空间），这个函数只对空空间确实由矢量组成的有限元素有意义 \((1,1,\ldots,1)^T\) 。例如，对于通常的拉格朗日元素就是这种情况，所有形状函数的总和等于恒一的函数。然而，对于其他一些函数则不然：例如，对于FE_DGP元素（Stokes离散中压力的另一个有效选择），每个单元上的第一个形状函数是常数，而更多的元素与它正交（在参考单元上）；因此，所有形状函数之和不等于一，与常数模式相关的向量也不等于 \((1,1,\ldots,1)^T\) 。对于这样的元素，在减去平均值时，必须使用不同的程序。 </dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>这个函数只能用于分布式向量类，前提是布尔掩码为空，即选择整个向量。 </dd></dl>

</div>
</div>
<a id="afcbaf531bea9d2ef9ca82f04866b9c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbaf531bea9d2ef9ca82f04866b9c16">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由给定DoFHandler和节点向量在给定点定义的可能是矢量值的有限元函数，并通过最后一个参数返回该函数的（矢量）梯度。 这是一个使用单元格边界的Q1映射来调用其他point_gradient()函数的包装函数。 这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评估点相匹配的点，然后在那里评估形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看看 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。</dd></dl>
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果找到的点所在的单元格不是本地拥有的，会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于处于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a078534e0dfc25a7893805fc1385da132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078534e0dfc25a7893805fc1385da132">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由给定DoFHandler和节点向量在给定点定义的标量有限元函数，并返回这个函数的梯度。 与另一个同名的函数相比，这是一个使用Q1映射的单元格的包装函数。 这个函数不是特别便宜。这是因为它首先需要找到一个给定的点在哪个单元格中，然后在参考单元格上找到与给定的评估点相匹配的点，然后评估那里的形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看一下 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。</dd></dl>
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果找到的点所在的单元格不是本地拥有的，会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a82b8de1f957b6308a56aed2d6dfeb21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b8de1f957b6308a56aed2d6dfeb21d">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由给定DoFHandler和节点向量在给定点定义的可能是矢量值的有限元函数，并通过最后一个参数返回这个函数的梯度。 与另一个同名的函数相比，这个函数使用一个任意的映射进行评估。 这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评价点相匹配的点，然后在那里评价形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看一下 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="aacbcaff67fab590cd068d8ef2ea276f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbcaff67fab590cd068d8ef2ea276f3">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果找到的点所在的单元格不是本地拥有的，会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="af72dcb595cc262bec07ca5c81614586f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72dcb595cc262bec07ca5c81614586f">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由给定DoFHandler和节点向量在给定点定义的标量有限元函数，并返回这个函数的梯度。 与另一个同名的函数相比，这个函数使用一个任意的映射进行评估。 这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评价点相匹配的点，然后在那里评价形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看一下 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a151ef408e4ffee595cb32f5a4791f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151ef408e4ffee595cb32f5a4791f54e">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果找到的点所在的单元格不是本地拥有的，会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的梯度，这取决于该点是在哪个单元中找到的。因为对于大多数元素来说，梯度从一个单元到另一个单元都是不连续的，所以对于单元边界上的点或接近单元边界的点，你会得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="ac4e531baa71a5183079fd2083aa7d723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e531baa71a5183079fd2083aa7d723">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在点 <code>p</code>. 处为点源创建一个右手边矢量 换句话说，它创建一个矢量 \(F\) ，以便 \(F_i = \int_\Omega \delta(x-p) \varphi_i(x) dx\) 其中 \(\varphi_i\) 是 <code>dof_handler</code> 描述的形状函数， <code>p</code> 是delta函数所在的点。给定的 <code>rhs_vector</code> 矢量的事先内容被删除。这个函数是针对标量有限元的情况。 这个函数通常在这两种情况下使用。</p>
<ul>
<li>假设你想多次解决同一类问题，用不同的右手边或系数的值，然后每次都在同一点上评估解。你可以通过在每次解题后调用 <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value()</a> 来实现，或者你可以意识到在某一点 \(p\) 评估解 \(u_h\) ，你可以像这样重新安排操作。 <p class="formulaDsp">
\begin{align*} u_h(p) &amp;= \sum_j U_j \varphi_j(p) = \sum_j U_j F_j \\ &amp;= U \cdot F \end{align*}
</p>
 与上面定义的向量。换句话说，只需一个向量-向量的乘积就可以实现点的评估，而向量 \(F\) 可以一次性计算出来，并在每次求解时重复使用，而不必每次都要翻阅网格，找出点 \(p\) 所在的单元（以及单元中的哪个位置）。</li>
<li>如果你想计算你要解决的问题的格林函数，这个函数也很有用。这是因为格林函数 \(G(x,p)\) 的定义为 <p class="formulaDsp">
\begin{align*} L G(x,p) &amp;= \delta(x-p) \end{align*}
</p>
 其中 \(L\) 是你问题的微分算子。离散版本需要计算右手边的向量 \(F_i = \int_\Omega \varphi_i(x) \delta(x-p)\) ，这正是由当前函数计算的向量。 虽然可能与记录这个函数所做的<em>what</em>无关，但值得注意的是，delta函数在现实中并不存在，因此，使用这个函数并不能模拟任何真实情况。这是因为，没有一个真实的物体能够将无限大的力密度集中在领域的一个无限小的部分（相反，所有真实的设备都会将力分散在一个有限的区域内）；也不可能在单个点上测量值（但所有的测量值都会以某种方式在小区域内取平均值）。只有当这个区域非常小，以至于不能被任何网格所解决时，用一个具有相同的整体力或灵敏度的delta函数的方式来建模才有意义。另一方面，用delta函数模拟的情况可能更有成效，那就是点源的电动势；在这种情况下，已知解有一个对数奇点（在2D中）或一个 \(\frac{1}{r}\) 奇点（在3D中），这两个奇点都不受约束。 在数学上，使用delta函数通常会导致精确的解，而在数值上得到的近似解并不收敛。这是因为，以拉普拉斯方程为例，精确解和数值解之间的误差可以用以下表达式来限定 <p class="formulaDsp">
\begin{align*} \| u-u_h \|_{L_2} \le C h \| \nabla u \|_{L_2} \end{align*}
</p>
 但当在右侧使用delta函数时，项 \(\| \nabla u \|_{L_2} = |u|_{H^1}\) 不是有限的。这可以通过使用拉普拉斯方程 \(-\Delta u = f\) 的解的先验约束看出，该约束指出 \(|u|_{H^1} \le \|f\|_{H^{-1}}\) 。 当使用delta函数作为右手时， \(f(x)=\delta(x-p)\) ，我们需要取delta函数的 \(H^{-1}\) 规范，然而这不是有限的，因为 \(\delta(\cdot-p) \not\in H^{-1}\) 。 所有这些的结果是，拉普拉斯方程的精确解在右手边有一个delta函数</li>
</ul>
<p>&ndash;即<em>Green's function</em>。</p>
<p>在 \(p\) 处有一个奇点，这个奇点非常强，不能用有限元解来解决，因此有限元近似值不能以任何通常的准则收敛于精确解。 所有这些对于所有其他二阶偏微分方程在二维或更高维度的情况也是如此。(因为在二维或更高维度上， \(H^1\) 函数不一定是连续的，因此，delta函数不在对偶空间 \(H^{-1}\) 中) 。 </p>

</div>
</div>
<a id="ae369225280698a8689572f9caddc2412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae369225280698a8689572f9caddc2412">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像前面的函数一样，但对hp-对象而言。 </p>

</div>
</div>
<a id="a824e81ddddb11735de517c05bc902a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824e81ddddb11735de517c05bc902a99">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用create_point_source_vector()函数，见上文，有一个隐含的默认 \(Q_1\) 映射对象。 注意，如果你的DoFHandler使用了0以外的任何活动FE索引，那么你需要调用上面的函数，为每个活动FE索引提供一个映射对象。 </p>

</div>
</div>
<a id="ab67e7a53f39ce8f5068506dd86c17e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67e7a53f39ce8f5068506dd86c17e3f">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为点 <code>p</code>. 处的点源创建右手向量 这个函数的变化是为了解决恰好有二维分量的向量值问题（它也适用于有多于二维分量的问题，在这种情况下只需考虑形状函数的第一个二维分量）。它计算出一个对应于强迫函数的右手边，该强迫函数等于德尔塔函数乘以一个给定的方向。换句话说，它创建了一个向量 \(F\) ，以便 \(F_i = \int_\Omega [\mathbf d \delta(x-p)] \cdot \varphi_i(x) dx\) 。这里要注意， \(\varphi_i\) 是一个矢量值的函数。 \(\mathbf d\) 是源项 \(\mathbf d \delta(x-p)\) 的给定方向，对应于要传递给该函数的 <code>方向参数。</code> 给定的 <code>rhs_vector</code> 矢量的先前内容被删除。 关于delta函数的使用，请参见第一个create_point_source_vector()变量的讨论。 </p>

</div>
</div>
<a id="a64eca4da3f3af9262d01075c5144d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64eca4da3f3af9262d01075c5144d0bf">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是针对hp-objects。 </p>

</div>
</div>
<a id="ae6d299da4539b9a5cc794d60a1f376a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d299da4539b9a5cc794d60a1f376a3">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为矢量值的有限元调用create_point_source_vector()函数，见上文，有一个隐含的默认 \(Q_1\) 映射对象。 注意，如果你的DoFHandler使用了零以外的任何活动FE索引，那么你需要调用上面的函数，为每个活动FE索引提供一个映射对象。 </p>

</div>
</div>
<a id="abf62ca21c24dbb459266851cb234e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf62ca21c24dbb459266851cb234e8bf">&#9670;&nbsp;</a></span>point_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>点误差评估。找到包含给定点的第一个单元，并计算一个（可能是矢量值的）有限元函数和一个连续函数（具有与有限元一样多的矢量分量）在该点的差值。 这是一个使用Q1映射的单元格边界的封装函数，用于调用其他point_difference()函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd></dl>

</div>
</div>
<a id="a07907666e2000a6e8a6c0118f5d82b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07907666e2000a6e8a6c0118f5d82b9f">&#9670;&nbsp;</a></span>point_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>点的错误评估。找到包含给定点的第一个单元，并计算一个（可能是矢量值的）有限元函数和一个连续函数（具有与有限元一样多的矢量分量）在该点的差值。 与另一个同名的函数相比，这个函数使用一个任意的映射来评估差异。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd></dl>

</div>
</div>
<a id="acd358e9b110ccbf4a7f76796d206b9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd358e9b110ccbf4a7f76796d206b9c7">&#9670;&nbsp;</a></span>point_value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的点 <code>点评估一个由给定的DoFHandler和节点矢量</code> <code>fe_function</code> 定义的可能是矢量值的有限元函数，并通过最后一个参数返回这个函数的（矢量）值。 这个函数对点被评估的单元格使用 \(Q_1\) -映射。如果你需要使用不同的映射来评估（例如，当使用弯曲的边界时），请使用接受映射的point_difference()函数。 这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评估点相匹配的点，然后评估那里的形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看一下 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。</dd></dl>
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a7be5c7eed52308898dfaad91c4cff204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be5c7eed52308898dfaad91c4cff204">&#9670;&nbsp;</a></span>point_value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section note"><dt>Note</dt><dd>如果找到的点所在的单元格不是本地拥有的，会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于处于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。</dd></dl>
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于处于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a23a1c99072ea425f33b06d908b6f4283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a1c99072ea425f33b06d908b6f4283">&#9670;&nbsp;</a></span>point_value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由给定的DoFHandler和节点向量 <code>fe_function</code> 在给定点 <code>点定义的可能是矢量值的有限元函数，并通过最后一个参数返回该函数的（矢量）值。</code> 与另一个同名的函数相比，这个函数使用一个任意的映射来评估点值。 这个函数不是特别便宜。这是因为它首先需要找到给定的点在哪个单元格中，然后在参考单元格上找到与给定的评估点相匹配的点，然后评估那里的形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看一下 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a79ff65fecfdbbad09b3a00386db15ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ff65fecfdbbad09b3a00386db15ee3">&#9670;&nbsp;</a></span>point_value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于位于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a363b651e28ef8eb4312ea9ebcea5b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363b651e28ef8eb4312ea9ebcea5b33a">&#9670;&nbsp;</a></span>point_value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>评估由给定的DoFHandler和节点向量 <code>fe_function</code> 在给定点 <code>point</code>, 定义的标量有限元函数，并返回这个函数的值。 与另一个同名的函数相比，这个函数使用一个任意的映射来评估差异。 这个函数不是特别便宜。这是因为它首先需要找到给定点所在的单元格，然后在参考单元格上找到与给定评估点相匹配的点，然后评估那里的形状函数。你可能不想用这个函数来评估<em>many</em>点的解。对于这种应用，FEFieldFunction类至少提供了一些优化。另一方面，如果你想在同一个点上评估<em>many solutions</em>，你可能想看一下 <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> 函数。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然这只能在一定的数字公差内完成。 因此，对于处于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="a47630457753055506858a8e835333054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47630457753055506858a8e835333054">&#9670;&nbsp;</a></span>point_value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述hp的情况相同。 </p><dl class="section note"><dt>Note</dt><dd>如果发现点所在的单元格不是本地拥有的，就会抛出一个 VectorTools::ExcPointNotAvailableHere 类型的异常。 </dd>
<dd>
这个函数需要找到一个点所在的单元格，当然，这只能在一定的数字公差内完成。 因此，对于处于或接近单元边界的点，你可能会在这里或那里得到有限元场的值，这取决于该点是在哪个单元中找到的。如果有限元场是连续的，这并不重要（在相同的公差内）。另一方面，如果使用的有限元是<em>not</em>连续的，那么你会在单元格的边界上或接近边界的地方得到不可预测的值，正如人们在试图评估不连续函数的点值时所期望的那样。 </dd></dl>

</div>
</div>
<a id="ac6b404bf03cb2a742b290421cc2789fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b404bf03cb2a742b290421cc2789fe">&#9670;&nbsp;</a></span>project() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>function</code> 对有限元空间的投影。换句话说，给定一个函数 \(f(\mathbf x)\) ，当前函数计算一个有限元函数 \(f_h(\mathbf x)=\sum_j F_j \varphi_j(\mathbf x)\) ，其特征是节点值 \(F\) 的（输出）矢量满足方程 </p><p class="formulaDsp">
\begin{align*} (\varphi_i, f_h)_\Omega = (\varphi_i,f)_\Omega \end{align*}
</p>
<p> 对于所有测试函数 \(\varphi_i\) 。这需要解决一个涉及质量矩阵的线性系统，因为上面的方程等同于线性系统 </p><p class="formulaDsp">
\begin{align*} \sum_j (\varphi_i, \varphi_j)_\Omega F_j = (\varphi_i,f)_\Omega \end{align*}
</p>
<p> 这也可以写成 \(MF = \Phi\) 与 \(M_{ij} = (\varphi_i, \varphi_j)_\Omega\) 和 \(\Phi_i = (\varphi_i,f)_\Omega\) 。 默认情况下， \(f_h\) 的边界值不需要也没有强加，但是这个函数有一些可选的参数，允许强加零边界值，或者在第一步，以类似于上面的方式将 \(f\) 的边界值投影到网格边界的有限元空间上，然后用这些值作为 \(f_h\) 的强加边界值。这个函数的参数排序是这样的：如果你不想先投影到边界，你不需要给出第二个正交公式（类型为<code>正交&lt;dim-1&gt;</code>，用于计算矩阵和边界值投影的右手边），但如果你想这样做，你必须这样做。 如果满足以下条件，则使用MatrixFree实现。</p>
<ul>
<li><code>enforce_zero_boundary</code> 是假的。</li>
<li><code>project_to_boundary_first</code> 是假的。</li>
<li>FiniteElement是由MatrixFree类支持的。</li>
<li>FiniteElement的组件少于5个</li>
<li>FiniteElement的度数小于9。</li>
<li>dim==spacedim 在这种情况下，这个函数使用给定的正交公式执行数值正交，用于右手边的积分 \(\Phi_i\) ，而QGauss(fe_degree+2)对象被用于质量算子。因此，你应该确保给定的正交公式对于创建右手边是足够精确的。 否则，只支持串行三角计算，质量矩阵使用 MatrixTools::create_mass_matrix. 组装，然后给定的正交规则用于矩阵和右手边。 因此，你应该确保给定的正交公式也足以用来创建质量矩阵。特别是，正交公式的度数必须足够高，以确保质量矩阵是可逆的。例如，如果你使用的是FE_Q(k)元素，那么矩阵项 \(M_{ij}\) 的积分在每个变量中都是多项式度数 \(2k\) ，你需要一个在每个坐标方向都有 \(k+1\) 点的高斯正交公式来确保 \(M\) 是可倒的。 更多信息请参见该命名空间的一般文档。 在1d中，边界正交公式的默认值是一个无效的对象，因为在1d中不会发生边界上的积分。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>要使用的映射对象。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>描述投射到的有限元空间的DoFHandler，对应于 <code>vec</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">约束</td><td>在组装质量矩阵时使用的约束，通常在你有悬挂节点时需要。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">正交</td><td>要用于组装质量矩阵的正交公式。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>投射到有限元空间的函数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>投射的函数将被存储在输出向量中。这个向量必须已经被初始化，并且不能有鬼魂元素。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce_zero_boundary</td><td>如果为真， <code>vec</code> 将有零边界条件。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_boundary</td><td>如果 <code>project_to_boundary_first</code> 为真，将使用正交规则。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">project_to_boundary_first</td><td>如果为真，在投射函数的内部之前执行对边界的投射。 </td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

</div>
</div>
<a id="ae25affd2b8b4fc818c0e45ec8b6e9c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25affd2b8b4fc818c0e45ec8b6e9c4b">&#9670;&nbsp;</a></span>project() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用上面的project()函数，使用<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="a1392cfa47cf2c315bf049bf626962152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1392cfa47cf2c315bf049bf626962152">&#9670;&nbsp;</a></span>project() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但有hp-capabilities。 </p>

</div>
</div>
<a id="aa55c7e03374966532e28a5273aa89c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55c7e03374966532e28a5273aa89c45">&#9670;&nbsp;</a></span>project() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用上面的project()函数，使用一个 \(Q_1\) 映射对象的集合，即使用 <a class="el" href="structhp_1_1StaticMappingQ1.html#a3951f29e14b906691298a07c932fe809">hp::StaticMappingQ1::mapping_collection</a>. 。 </p>

</div>
</div>
<a id="a51a13e948e1296dbfdfc297167e4fd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a13e948e1296dbfdfc297167e4fd5a">&#9670;&nbsp;</a></span>project() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; typename VectorType::value_type(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述标量值正交数据的投影相同。 用户提供的函数应该根据单元格迭代器和正交数在正交点返回一个值，当然也应该与提供的 <code>quadrature</code> 对象一致，该对象将被用来组装右手边。 这个函数可以和lambdas一起使用。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a></div><div class="line">(mapping,</div><div class="line">dof_handler,</div><div class="line">constraints,</div><div class="line">quadrature_formula,</div><div class="line">[&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp; cell,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q)</div><div class="line"></div><div class="line">-&gt; <span class="keywordtype">double</span></div><div class="line">{</div><div class="line"> <span class="keywordflow">return</span> qp_data.get_data(cell)[q]-&gt;density;</div><div class="line">},</div><div class="line">field);</div></div><!-- fragment --><p> 其中 <code>qp_data</code> 是一个CellDataStorage对象，它存储正交点数据。 </p>

</div>
</div>
<a id="af78e1c7322a3c5bea31ac2ca7a7bb9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78e1c7322a3c5bea31ac2ca7a7bb9b8">&#9670;&nbsp;</a></span>project() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_q_points_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述标量值MatrixFree正交数据的投影相同。 用户提供的函数 <code>func</code> 应根据单元格号和正交点号在正交点返回一个VectorizedArray值，并应与 <code>n_q_points_1d</code>. 一致。这个函数可以与lambdas一起使用。 </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a></div><div class="line">(matrix_free_data,</div><div class="line">constraints,</div><div class="line">3,</div><div class="line">[&amp;] (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell,</div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q)</div><div class="line"></div><div class="line">-&gt; <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a></div><div class="line">{</div><div class="line"> <span class="keywordflow">return</span> qp_data(cell,q);</div><div class="line">},</div><div class="line">field);</div></div><!-- fragment --><p> 其中 <code>qp_data</code> 是一个类型为Table&lt;2, <a class="el" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a>&gt;的对象，它存储正交点数据。 <code>fe_component</code> 允许额外指定使用 <code>data</code> 的哪个组件，如果它是用 <code>std::vector&lt;const <a class="el" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>*&gt;</code>构造的。它将在内部用于FEEvaluation对象的构造器。 </p>

</div>
</div>
<a id="a51734bccfad4ad25857252845ca6bd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51734bccfad4ad25857252845ca6bd26">&#9670;&nbsp;</a></span>project() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但对于<code>n_q_points_1d = matrix_free.get_dof_handler().get_fe().degree+1</code>。 </p>

</div>
</div>
<a id="a6e325333a138893e181da47f29ac680a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e325333a138893e181da47f29ac680a">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个右手边的向量。先前给定的 <code>rhs_vector</code> 向量的内容被删除。 更多信息请参见该命名空间的一般文档。 </p>

</div>
</div>
<a id="adbf70c57cf6f92f1a7b0d73b130f0afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf70c57cf6f92f1a7b0d73b130f0afa">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用create_right_hand_side()函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. 。 </p>

</div>
</div>
<a id="a166be0312d664eca59fcc7582676e112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166be0312d664eca59fcc7582676e112">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的一组函数一样，但是针对hp-objects。 </p>

</div>
</div>
<a id="a84ac5162116a1d96e72483cfdb17a968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac5162116a1d96e72483cfdb17a968">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像以前的一组函数，但对hp-objects而言。 </p>

</div>
</div>
<a id="ac928341ce5b22e8285cf867122e92ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac928341ce5b22e8285cf867122e92ef7">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从边界力创建一个右手边的向量。之前给定的 <code>rhs_vector</code> 矢量的内容被删除。 更多信息请参见该命名空间的一般文档。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a6bb19571d249869eaf25b03b29f655d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb19571d249869eaf25b03b29f655d8">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用create_boundary_right_hand_side()函数，见上文，<code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> &lt;dim&gt;(1)</code>. </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的术语条目</a> </dd></dl>

</div>
</div>
<a id="ad9c044f24808972ceeceb105c945a694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c044f24808972ceeceb105c945a694">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数集相同，但用于hp-objects。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a331275c1c2ebfe58daa7d3beef974b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331275c1c2ebfe58daa7d3beef974b55">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>调用create_boundary_right_hand_side()函数，见上文，用一个Q1映射作为集合。因此，这个函数只有在使用中的唯一活跃的FE指标为0时才会起作用。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">关于边界指标的词汇条目</a> </dd></dl>

</div>
</div>
<a id="a6a69e6aa423a32d296440d1fa4bf4cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a69e6aa423a32d296440d1fa4bf4cac">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; 1, 1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; 1 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__tools__rhs_8cc_source.html#l00028">28</a> of file <a class="el" href="vector__tools__rhs_8cc_source.html">vector_tools_rhs.cc</a>.</p>

</div>
</div>
<a id="af3cddbcbf0e162ab79a605827d39ddfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cddbcbf0e162ab79a605827d39ddfb">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; 1, 2 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; 1, 2 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; 0 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="vector__tools__rhs_8cc_source.html#l00042">42</a> of file <a class="el" href="vector__tools__rhs_8cc_source.html">vector_tools_rhs.cc</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
