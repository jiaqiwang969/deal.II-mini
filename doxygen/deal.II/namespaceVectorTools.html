<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceVectorTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: VectorTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">VectorTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceVectorTools_1_1EvaluationFlags"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html">EvaluationFlags</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a69967cb7a148a7169963126249213db1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> { <br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27">mean</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357">L1_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1ab711e0a460000489addc7aa59878d2">Hdiv_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a>, 
<br />
&#160;&#160;<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930">W1p_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3">W1p_norm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a>, 
<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619">W1infty_norm</a>
<br />
 }</td></tr>
<tr class="separator:a69967cb7a148a7169963126249213db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af0966d7adbacddce3ba37790a604e49f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af0966d7adbacddce3ba37790a604e49f">DeclExceptionMsg</a> (ExcPointNotAvailableHere, &quot;The given point is inside a cell of a &quot; &quot;<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> that is not &quot; &quot;locally owned by this processor.&quot;)</td></tr>
<tr class="separator:af0966d7adbacddce3ba37790a604e49f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ad6eceb6cbeaa505baf7f938289bbde"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a1ad6eceb6cbeaa505baf7f938289bbde"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a1ad6eceb6cbeaa505baf7f938289bbde">point_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;evaluation_points, <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:a1ad6eceb6cbeaa505baf7f938289bbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cb22a97ffc83df35caf11dbd4e336cc"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6cb22a97ffc83df35caf11dbd4e336cc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6cb22a97ffc83df35caf11dbd4e336cc">point_values</a> (const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:a6cb22a97ffc83df35caf11dbd4e336cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aada37fd09d8be1b9ed9bb12d698f8ee4"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:aada37fd09d8be1b9ed9bb12d698f8ee4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::gradient_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aada37fd09d8be1b9ed9bb12d698f8ee4">point_gradients</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;evaluation_points, <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:aada37fd09d8be1b9ed9bb12d698f8ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5febf52b3f767d8e276e2c02d0ea0662"><td class="memTemplParams" colspan="2">template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a5febf52b3f767d8e276e2c02d0ea0662"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt; n_components, dim &gt;::gradient_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5febf52b3f767d8e276e2c02d0ea0662">point_gradients</a> (const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;cache, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a> flags=<a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a>)</td></tr>
<tr class="separator:a5febf52b3f767d8e276e2c02d0ea0662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Interpolation and projection</div></td></tr>
<tr class="memitem:af27ac28c698a9ed0199faed50a204538"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:af27ac28c698a9ed0199faed50a204538"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:af27ac28c698a9ed0199faed50a204538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a316c2741c61a2b7f0372c9dbb69b7c88"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a316c2741c61a2b7f0372c9dbb69b7c88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a316c2741c61a2b7f0372c9dbb69b7c88">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a316c2741c61a2b7f0372c9dbb69b7c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff02b67200d44ba712eb004fe7e8208"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afff02b67200d44ba712eb004fe7e8208"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afff02b67200d44ba712eb004fe7e8208">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afff02b67200d44ba712eb004fe7e8208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9045591cffcf0c8a06b583e6563510e2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a9045591cffcf0c8a06b583e6563510e2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a9045591cffcf0c8a06b583e6563510e2">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a9045591cffcf0c8a06b583e6563510e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9c6fe2f772b09e2bfbb95ff6e49aa28"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aa9c6fe2f772b09e2bfbb95ff6e49aa28"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa9c6fe2f772b09e2bfbb95ff6e49aa28">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:aa9c6fe2f772b09e2bfbb95ff6e49aa28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afad4dbef1b304b170be0362b0590ada1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:afad4dbef1b304b170be0362b0590ada1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afad4dbef1b304b170be0362b0590ada1">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afad4dbef1b304b170be0362b0590ada1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5e6b9de5ad09eb5009075618f08eb129">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga5e6b9de5ad09eb5009075618f08eb129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6e975950cd122b6a2924b1ecd4ec60"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a7d6e975950cd122b6a2924b1ecd4ec60"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7d6e975950cd122b6a2924b1ecd4ec60">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a7d6e975950cd122b6a2924b1ecd4ec60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5255de72726a1fa50c4653ce59e6a438"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga5255de72726a1fa50c4653ce59e6a438"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga5255de72726a1fa50c4653ce59e6a438">interpolate_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:ga5255de72726a1fa50c4653ce59e6a438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa0ffb5d4bd09003cd869b00573cf1d6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aaa0ffb5d4bd09003cd869b00573cf1d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aaa0ffb5d4bd09003cd869b00573cf1d6">interpolate_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:aaa0ffb5d4bd09003cd869b00573cf1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa39e86be1bee406512895d2b0377da87"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaa39e86be1bee406512895d2b0377da87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaa39e86be1bee406512895d2b0377da87">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;boundary_function, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaa39e86be1bee406512895d2b0377da87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf2f61567fa003b5448fce53e0eec4b79">interpolate_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:gaf2f61567fa003b5448fce53e0eec4b79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aa5117bc6324d18df70c9cb86442b88"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a5aa5117bc6324d18df70c9cb86442b88"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:a5aa5117bc6324d18df70c9cb86442b88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af52d603a67047f73226b2e9653bffcf1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:af52d603a67047f73226b2e9653bffcf1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af52d603a67047f73226b2e9653bffcf1">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:af52d603a67047f73226b2e9653bffcf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63c020c0782c918a8c43972285bfd2f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ac63c020c0782c918a8c43972285bfd2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac63c020c0782c918a8c43972285bfd2f">project_boundary_values</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:ac63c020c0782c918a8c43972285bfd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb559352c78982c7d36b444d0024720e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:acb559352c78982c7d36b444d0024720e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#acb559352c78982c7d36b444d0024720e">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:acb559352c78982c7d36b444d0024720e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga32a2c72e6d0bc19fb346d51767e48c89">project_boundary_values</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:ga32a2c72e6d0bc19fb346d51767e48c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaf550f1f801988790bf89c099e7ff2fb0">project_boundary_values</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_function, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:gaf550f1f801988790bf89c099e7ff2fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga190b302dc1ee7c89727c94c083d132d2"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number &gt; </td></tr>
<tr class="memitem:ga190b302dc1ee7c89727c94c083d132d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga190b302dc1ee7c89727c94c083d132d2">project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:ga190b302dc1ee7c89727c94c083d132d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac0d845992528893a53ad7f37a15d0aaa"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number &gt; </td></tr>
<tr class="memitem:gac0d845992528893a53ad7f37a15d0aaa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gac0d845992528893a53ad7f37a15d0aaa">project_boundary_values_curl_conforming_l2</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, number &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gac0d845992528893a53ad7f37a15d0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaac8ab38430250535a694205a7372f5a7"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaac8ab38430250535a694205a7372f5a7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaac8ab38430250535a694205a7372f5a7">project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;mapping)</td></tr>
<tr class="separator:gaac8ab38430250535a694205a7372f5a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaff48f8eaf46c5618b95eefa23081449e"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:gaff48f8eaf46c5618b95eefa23081449e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gaff48f8eaf46c5618b95eefa23081449e">project_boundary_values_div_conforming</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, dim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const <a class="el" href="classFunction.html">Function</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;boundary_function, const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> boundary_component, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, dim &gt; &amp;mapping_collection=<a class="el" href="structhp_1_1StaticMappingQ1.html">hp::StaticMappingQ1</a>&lt; dim &gt;::mapping_collection)</td></tr>
<tr class="separator:gaff48f8eaf46c5618b95eefa23081449e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga54fdd3b0f9e4e4ad02cf932901bd0659">compute_nonzero_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga54fdd3b0f9e4e4ad02cf932901bd0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d16c332aaa652e8905a6f48208e4500"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga0d16c332aaa652e8905a6f48208e4500"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">compute_no_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga0d16c332aaa652e8905a6f48208e4500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1b73118e3a950d33515ae649b9014d04"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga1b73118e3a950d33515ae649b9014d04"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#ga1b73118e3a950d33515ae649b9014d04">compute_nonzero_tangential_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&gt; &amp;function_map, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:ga1b73118e3a950d33515ae649b9014d04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad396065c624ae6c5d843e22fb75c3c36"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gad396065c624ae6c5d843e22fb75c3c36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__constraints.html#gad396065c624ae6c5d843e22fb75c3c36">compute_normal_flux_constraints</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> first_vector_component, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids, <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints, const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping=(<a class="el" href="namespaceReferenceCells.html#a6dcaf877381d5bc2639da69a586ee9d4">ReferenceCells::get_hypercube</a>&lt; dim &gt;() .template <a class="el" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>&lt; dim, spacedim &gt;()))</td></tr>
<tr class="separator:gad396065c624ae6c5d843e22fb75c3c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a761f008bdeb7d94a69205ae824deefad"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a761f008bdeb7d94a69205ae824deefad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">interpolate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a761f008bdeb7d94a69205ae824deefad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34fa653b9e16be54bda225e64f9b2b56"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a34fa653b9e16be54bda225e64f9b2b56"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a34fa653b9e16be54bda225e64f9b2b56">interpolate</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a34fa653b9e16be54bda225e64f9b2b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b68e11070496fcaf6c2389f088d09c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a32b68e11070496fcaf6c2389f088d09c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a32b68e11070496fcaf6c2389f088d09c">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a32b68e11070496fcaf6c2389f088d09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a5e3af70a47cedfaf361cf5c621e94e3d">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_2, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;transfer, const InVector &amp;data_1, OutVector &amp;data_2)</td></tr>
<tr class="separator:a5e3af70a47cedfaf361cf5c621e94e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf179d7bbaec3bede8e732aadedc51b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:afbf179d7bbaec3bede8e732aadedc51b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afbf179d7bbaec3bede8e732aadedc51b">interpolate_based_on_material_id</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::map&lt; <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; *&gt; &amp;function_map, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afbf179d7bbaec3bede8e732aadedc51b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4807a032b164d00ae06adb8cfb2c9d1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ac4807a032b164d00ae06adb8cfb2c9d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac4807a032b164d00ae06adb8cfb2c9d1">interpolate_to_different_mesh</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classVectorType.html">VectorType</a> &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, <a class="el" href="classVectorType.html">VectorType</a> &amp;u2)</td></tr>
<tr class="separator:ac4807a032b164d00ae06adb8cfb2c9d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad7ee745dc25e8699e893df7ebdb668"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:abad7ee745dc25e8699e893df7ebdb668"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abad7ee745dc25e8699e893df7ebdb668">interpolate_to_different_mesh</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classVectorType.html">VectorType</a> &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, <a class="el" href="classVectorType.html">VectorType</a> &amp;u2)</td></tr>
<tr class="separator:abad7ee745dc25e8699e893df7ebdb668"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac48b116f0b923f29ca6121890ec19b61"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ac48b116f0b923f29ca6121890ec19b61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac48b116f0b923f29ca6121890ec19b61">interpolate_to_different_mesh</a> (const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;intergridmap, const <a class="el" href="classVectorType.html">VectorType</a> &amp;u1, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, <a class="el" href="classVectorType.html">VectorType</a> &amp;u2)</td></tr>
<tr class="separator:ac48b116f0b923f29ca6121890ec19b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b404bf03cb2a742b290421cc2789fe"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ac6b404bf03cb2a742b290421cc2789fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q_boundary=(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:ac6b404bf03cb2a742b290421cc2789fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae25affd2b8b4fc818c0e45ec8b6e9c4b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ae25affd2b8b4fc818c0e45ec8b6e9c4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae25affd2b8b4fc818c0e45ec8b6e9c4b">project</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q_boundary=(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:ae25affd2b8b4fc818c0e45ec8b6e9c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1392cfa47cf2c315bf049bf626962152"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a1392cfa47cf2c315bf049bf626962152"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a1392cfa47cf2c315bf049bf626962152">project</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q_boundary=<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt;(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:a1392cfa47cf2c315bf049bf626962152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa55c7e03374966532e28a5273aa89c45"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aa55c7e03374966532e28a5273aa89c45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aa55c7e03374966532e28a5273aa89c45">project</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;function, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec, const <a class="el" href="classbool.html">bool</a> enforce_zero_boundary=false, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q_boundary=<a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt;(dim &gt; 1 ? <a class="el" href="classQGauss.html">QGauss</a>&lt; dim - 1 &gt;(2) :<a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt;(0)), const <a class="el" href="classbool.html">bool</a> project_to_boundary_first=false)</td></tr>
<tr class="separator:aa55c7e03374966532e28a5273aa89c45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a13e948e1296dbfdfc297167e4fd5a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a51a13e948e1296dbfdfc297167e4fd5a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a51a13e948e1296dbfdfc297167e4fd5a">project</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const std::function&lt; typename VectorType::value_type(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;func, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_result)</td></tr>
<tr class="separator:a51a13e948e1296dbfdfc297167e4fd5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af78e1c7322a3c5bea31ac2ca7a7bb9b8"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType &gt; </td></tr>
<tr class="memitem:af78e1c7322a3c5bea31ac2ca7a7bb9b8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af78e1c7322a3c5bea31ac2ca7a7bb9b8">project</a> (std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt; data, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const unsigned <a class="el" href="classint.html">int</a> n_q_points_1d, const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;func, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_result, const unsigned <a class="el" href="classint.html">int</a> fe_component=0)</td></tr>
<tr class="separator:af78e1c7322a3c5bea31ac2ca7a7bb9b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51734bccfad4ad25857252845ca6bd26"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType &gt; </td></tr>
<tr class="memitem:a51734bccfad4ad25857252845ca6bd26"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a51734bccfad4ad25857252845ca6bd26">project</a> (std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt; data, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints, const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;func, <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_result, const unsigned <a class="el" href="classint.html">int</a> fe_component=0)</td></tr>
<tr class="separator:a51734bccfad4ad25857252845ca6bd26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Evaluation of functions and errors</div></td></tr>
<tr class="memitem:a676190d2c897ac5da68a9c460fa95832"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a676190d2c897ac5da68a9c460fa95832"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a676190d2c897ac5da68a9c460fa95832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d01703fa0d91ed6404009757680886d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a8d01703fa0d91ed6404009757680886d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a8d01703fa0d91ed6404009757680886d">integrate_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a8d01703fa0d91ed6404009757680886d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4da3324bbce54d7c12dd54c59dd915"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:aec4da3324bbce54d7c12dd54c59dd915"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aec4da3324bbce54d7c12dd54c59dd915">integrate_difference</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:aec4da3324bbce54d7c12dd54c59dd915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0900dfa36831d4fa6d4225b8e98cfcda"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0900dfa36831d4fa6d4225b8e98cfcda"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a0900dfa36831d4fa6d4225b8e98cfcda">integrate_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const InVector &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;exact_solution, OutVector &amp;difference, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *weight=nullptr, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a0900dfa36831d4fa6d4225b8e98cfcda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21eb62d70953182dcc2b15c4e14dd533"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector &gt; </td></tr>
<tr class="memitem:a21eb62d70953182dcc2b15c4e14dd533"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const InVector &amp;cellwise_error, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;norm, const <a class="el" href="classdouble.html">double</a> exponent=2.)</td></tr>
<tr class="separator:a21eb62d70953182dcc2b15c4e14dd533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbaf531bea9d2ef9ca82f04866b9c16"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:afcbaf531bea9d2ef9ca82f04866b9c16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afcbaf531bea9d2ef9ca82f04866b9c16">point_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;value)</td></tr>
<tr class="separator:afcbaf531bea9d2ef9ca82f04866b9c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a078534e0dfc25a7893805fc1385da132"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a078534e0dfc25a7893805fc1385da132"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a078534e0dfc25a7893805fc1385da132">point_gradient</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a078534e0dfc25a7893805fc1385da132"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82b8de1f957b6308a56aed2d6dfeb21d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a82b8de1f957b6308a56aed2d6dfeb21d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a82b8de1f957b6308a56aed2d6dfeb21d">point_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;value)</td></tr>
<tr class="separator:a82b8de1f957b6308a56aed2d6dfeb21d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacbcaff67fab590cd068d8ef2ea276f3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aacbcaff67fab590cd068d8ef2ea276f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aacbcaff67fab590cd068d8ef2ea276f3">point_gradient</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;value)</td></tr>
<tr class="separator:aacbcaff67fab590cd068d8ef2ea276f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72dcb595cc262bec07ca5c81614586f"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:af72dcb595cc262bec07ca5c81614586f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#af72dcb595cc262bec07ca5c81614586f">point_gradient</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:af72dcb595cc262bec07ca5c81614586f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151ef408e4ffee595cb32f5a4791f54e"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a151ef408e4ffee595cb32f5a4791f54e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a151ef408e4ffee595cb32f5a4791f54e">point_gradient</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a151ef408e4ffee595cb32f5a4791f54e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf62ca21c24dbb459266851cb234e8bf"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:abf62ca21c24dbb459266851cb234e8bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#abf62ca21c24dbb459266851cb234e8bf">point_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;exact_solution, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:abf62ca21c24dbb459266851cb234e8bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07907666e2000a6e8a6c0118f5d82b9f"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a07907666e2000a6e8a6c0118f5d82b9f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a07907666e2000a6e8a6c0118f5d82b9f">point_difference</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;exact_solution, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;difference, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a07907666e2000a6e8a6c0118f5d82b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd358e9b110ccbf4a7f76796d206b9c7"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:acd358e9b110ccbf4a7f76796d206b9c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:acd358e9b110ccbf4a7f76796d206b9c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7be5c7eed52308898dfaad91c4cff204"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a7be5c7eed52308898dfaad91c4cff204"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a7be5c7eed52308898dfaad91c4cff204">point_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a7be5c7eed52308898dfaad91c4cff204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23a1c99072ea425f33b06d908b6f4283"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a23a1c99072ea425f33b06d908b6f4283"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a23a1c99072ea425f33b06d908b6f4283">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a23a1c99072ea425f33b06d908b6f4283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ff65fecfdbbad09b3a00386db15ee3"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a79ff65fecfdbbad09b3a00386db15ee3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a79ff65fecfdbbad09b3a00386db15ee3">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point, <a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;value)</td></tr>
<tr class="separator:a79ff65fecfdbbad09b3a00386db15ee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b651e28ef8eb4312ea9ebcea5b33a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a363b651e28ef8eb4312ea9ebcea5b33a"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a363b651e28ef8eb4312ea9ebcea5b33a">point_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a363b651e28ef8eb4312ea9ebcea5b33a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47630457753055506858a8e835333054"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:a47630457753055506858a8e835333054"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a47630457753055506858a8e835333054">point_value</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classVectorType.html">VectorType</a> &amp;fe_function, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;point)</td></tr>
<tr class="separator:a47630457753055506858a8e835333054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:afcb40e50d2fa4807762faefed206f5e3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:afcb40e50d2fa4807762faefed206f5e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#afcb40e50d2fa4807762faefed206f5e3">get_position_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dh, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:afcb40e50d2fa4807762faefed206f5e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8e3037188b85efb319cb065750da59"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6d8e3037188b85efb319cb065750da59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6d8e3037188b85efb319cb065750da59">get_position_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dh, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;mask=<a class="el" href="classComponentMask.html">ComponentMask</a>())</td></tr>
<tr class="separator:a6d8e3037188b85efb319cb065750da59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a55601b2b4f2e6476619f22096116c0e4"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a55601b2b4f2e6476619f22096116c0e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a55601b2b4f2e6476619f22096116c0e4">subtract_mean_value</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;v, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;p_select={})</td></tr>
<tr class="separator:a55601b2b4f2e6476619f22096116c0e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad086eb08b8424fd7c853e389a3978a9a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:ad086eb08b8424fd7c853e389a3978a9a"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classVectorType.html">VectorType</a> &amp;v, const unsigned <a class="el" href="classint.html">int</a> component)</td></tr>
<tr class="separator:ad086eb08b8424fd7c853e389a3978a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed4db7abc1e8c2ac5e814fe802a8a73a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename VectorType , int spacedim&gt; </td></tr>
<tr class="memitem:aed4db7abc1e8c2ac5e814fe802a8a73a"><td class="memTemplItemLeft" align="right" valign="top">VectorType::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#aed4db7abc1e8c2ac5e814fe802a8a73a">compute_mean_value</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, const <a class="el" href="classVectorType.html">VectorType</a> &amp;v, const unsigned <a class="el" href="classint.html">int</a> component)</td></tr>
<tr class="separator:aed4db7abc1e8c2ac5e814fe802a8a73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Assembling of right hand sides</div></td></tr>
<tr class="memitem:ac4e531baa71a5183079fd2083aa7d723"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac4e531baa71a5183079fd2083aa7d723"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ac4e531baa71a5183079fd2083aa7d723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae369225280698a8689572f9caddc2412"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae369225280698a8689572f9caddc2412"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae369225280698a8689572f9caddc2412">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ae369225280698a8689572f9caddc2412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a824e81ddddb11735de517c05bc902a99"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a824e81ddddb11735de517c05bc902a99"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a824e81ddddb11735de517c05bc902a99">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a824e81ddddb11735de517c05bc902a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67e7a53f39ce8f5068506dd86c17e3f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab67e7a53f39ce8f5068506dd86c17e3f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ab67e7a53f39ce8f5068506dd86c17e3f">create_point_source_vector</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ab67e7a53f39ce8f5068506dd86c17e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64eca4da3f3af9262d01075c5144d0bf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a64eca4da3f3af9262d01075c5144d0bf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a64eca4da3f3af9262d01075c5144d0bf">create_point_source_vector</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:a64eca4da3f3af9262d01075c5144d0bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6d299da4539b9a5cc794d60a1f376a3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae6d299da4539b9a5cc794d60a1f376a3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ae6d299da4539b9a5cc794d60a1f376a3">create_point_source_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;p, const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;direction, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector)</td></tr>
<tr class="separator:ae6d299da4539b9a5cc794d60a1f376a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e325333a138893e181da47f29ac680a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6e325333a138893e181da47f29ac680a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">create_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:a6e325333a138893e181da47f29ac680a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf70c57cf6f92f1a7b0d73b130f0afa"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:adbf70c57cf6f92f1a7b0d73b130f0afa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#adbf70c57cf6f92f1a7b0d73b130f0afa">create_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:adbf70c57cf6f92f1a7b0d73b130f0afa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a166be0312d664eca59fcc7582676e112"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a166be0312d664eca59fcc7582676e112"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a166be0312d664eca59fcc7582676e112">create_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:a166be0312d664eca59fcc7582676e112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84ac5162116a1d96e72483cfdb17a968"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a84ac5162116a1d96e72483cfdb17a968"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a84ac5162116a1d96e72483cfdb17a968">create_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt;())</td></tr>
<tr class="separator:a84ac5162116a1d96e72483cfdb17a968"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac928341ce5b22e8285cf867122e92ef7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ac928341ce5b22e8285cf867122e92ef7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ac928341ce5b22e8285cf867122e92ef7">create_boundary_right_hand_side</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:ac928341ce5b22e8285cf867122e92ef7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bb19571d249869eaf25b03b29f655d8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6bb19571d249869eaf25b03b29f655d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a6bb19571d249869eaf25b03b29f655d8">create_boundary_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a6bb19571d249869eaf25b03b29f655d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c044f24808972ceeceb105c945a694"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:ad9c044f24808972ceeceb105c945a694"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#ad9c044f24808972ceeceb105c945a694">create_boundary_right_hand_side</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:ad9c044f24808972ceeceb105c945a694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331275c1c2ebfe58daa7d3beef974b55"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a331275c1c2ebfe58daa7d3beef974b55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceVectorTools.html#a331275c1c2ebfe58daa7d3beef974b55">create_boundary_right_hand_side</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs_vector, const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;boundary_ids=std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt;())</td></tr>
<tr class="separator:a331275c1c2ebfe58daa7d3beef974b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide a namespace which offers some operations on vectors. Among these are assembling of standard vectors, integration of the difference of a finite element solution and a continuous function, interpolations and projections of continuous functions to the finite element space and other operations.</p>
<dl class="section note"><dt>Note</dt><dd>There exist two versions of almost all functions, one that takes an explicit <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> argument and one that does not. The second one generally calls the first with an implicit \(Q_1\) argument (i.e., with an argument of kind <a class="el" href="classMappingQGeneric.html">MappingQGeneric(1)</a>). If your intend your code to use a different mapping than a (bi-/tri-)linear one, then you need to call the functions <b>with</b> mapping argument should be used.</dd></dl>
<h3>Description of operations</h3>
<p>This collection of methods offers the following operations: </p><ul>
<li>
<p class="startli">Interpolation: assign each degree of freedom in the vector to be the value of the function given as argument. This is identical to saying that the resulting finite element function (which is isomorphic to the output vector) has exact function values in all support points of trial functions. The support point of a trial function is the point where its value equals one, e.g. for linear trial functions the support points are four corners of an element. This function therefore relies on the assumption that a finite element is used for which the degrees of freedom are function values (Lagrange elements) rather than gradients, normal derivatives, second derivatives, etc (Hermite elements, quintic Argyris element, etc.).</p>
<p>It seems inevitable that some values of the vector to be created are set twice or even more than that. The reason is that we have to loop over all cells and get the function values for each of the trial functions located thereon. This applies also to the functions located on faces and corners which we thus visit more than once. While setting the value in the vector is not an expensive operation, the evaluation of the given function may be, taking into account that a virtual function has to be called.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Projection: compute the <em>L</em><sup>2</sup>-projection of the given function onto the finite element space, i.e. if <em>f</em> is the function to be projected, compute <em>f<sub>h</sub></em> in <em>V<sub>h</sub></em> such that (<em>f<sub>h</sub></em>,<em>v<sub>h</sub></em>)=(<em>f</em>,<em>v<sub>h</sub></em>) for all discrete test functions <em>v<sub>h</sub></em>. This is done through the solution of the linear system of equations <em> M v = f</em> where <em>M</em> is the mass matrix \(m_{ij} = \int_\Omega \phi_i(x) \phi_j(x) dx\) and \(f_i = \int_\Omega f(x) \phi_i(x) dx\). The solution vector \(v\) then is the nodal representation of the projection <em>f<sub>h</sub></em>. The <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a> functions are used in the step-21 and step-23 tutorial programs.</p>
<p>In order to get proper results, it be may necessary to treat boundary conditions right. Below are listed some cases where this may be needed. If needed, this is done by <em>L</em><sup>2</sup>-projection of the trace of the given function onto the finite element space restricted to the boundary of the domain, then taking this information and using it to eliminate the boundary nodes from the mass matrix of the whole domain, using the <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> function. The projection of the trace of the function to the boundary is done with the <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">VectorTools::project_boundary_values()</a> (see below) function, which is called with a map of boundary functions std::map&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt; in which all boundary indicators from zero to <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a>-1 (<a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is used for other purposes, see the <a class="el" href="classTriangulation.html">Triangulation</a> class documentation) point to the function to be projected. The projection to the boundary takes place using a second quadrature formula on the boundary given to the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a> function. The first quadrature formula is used to compute the right hand side and for numerical quadrature of the mass matrix.</p>
<p>The projection of the boundary values first, then eliminating them from the global system of equations is not needed usually. It may be necessary if you want to enforce special restrictions on the boundary values of the projected function, for example in time dependent problems: you may want to project the initial values but need consistency with the boundary values for later times. Since the latter are projected onto the boundary in each time step, it is necessary that we also project the boundary values of the initial values, before projecting them to the whole domain.</p>
<p>Obviously, the results of the two schemes for projection are different. Usually, when projecting to the boundary first, the <em>L</em><sup>2</sup>-norm of the difference between original function and projection over the whole domain will be larger (factors of five have been observed) while the <em>L</em><sup>2</sup>-norm of the error integrated over the boundary should of course be less. The reverse should also hold if no projection to the boundary is performed.</p>
<p>The selection whether the projection to the boundary first is needed is done with the <code>project_to_boundary_first</code> flag passed to the function. If <code>false</code> is given, the additional quadrature formula for faces is ignored.</p>
<p>You should be aware of the fact that if no projection to the boundary is requested, a function with zero boundary values may not have zero boundary values after projection. There is a flag for this especially important case, which tells the function to enforce zero boundary values on the respective boundary parts. Since enforced zero boundary values could also have been reached through projection, but are more economically obtain using other methods, the <code>project_to_boundary_first</code> flag is ignored if the <code>enforce_zero_boundary</code> flag is set.</p>
<p>The solution of the linear system is presently done using a simple CG method without preconditioning and without multigrid. This is clearly not too efficient, but sufficient in many cases and simple to implement. This detail may change in the future.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of right hand side vectors: The <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">create_right_hand_side()</a> function computes the vector \(f_i = \int_\Omega f(x) \phi_i(x) dx\). This is the same as what the <code>MatrixCreator::create_*</code> functions which take a right hand side do, but without assembling a matrix.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of right hand side vectors for point sources: The <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">create_point_source_vector()</a> function computes the vector \(F_i = \int_\Omega \delta(x-x_0) \phi_i(x) dx\).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Creation of boundary right hand side vectors: The <a class="el" href="namespaceVectorTools.html#ac928341ce5b22e8285cf867122e92ef7">create_boundary_right_hand_side()</a> function computes the vector \(f_i = \int_{\partial\Omega} g(x) \phi_i(x) dx\). This is the right hand side contribution of boundary forces when having inhomogeneous Neumann boundary values in Laplace's equation or other second order operators. This function also takes an optional argument denoting over which parts of the boundary the integration shall extend. If the default argument is used, it is applied to all boundaries.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Interpolation of boundary values: The <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> function takes a list of boundary nodes and their values. You can get such a list by interpolation of a boundary function using the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a> function. To use it, you have to specify a list of pairs of boundary indicators (of type <code><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a></code>; see the section in the documentation of the <a class="el" href="classTriangulation.html">Triangulation</a> class for more details) and the according functions denoting the Dirichlet boundary values of the nodes on boundary faces with this boundary indicator.</p>
<p>Usually, all other boundary conditions, such as inhomogeneous Neumann values or mixed boundary conditions are handled in the weak formulation. No attempt is made to include these into the process of matrix and vector assembly therefore.</p>
<p>Within this function, boundary values are interpolated, i.e. a node is given the point value of the boundary function. In some cases, it may be necessary to use the L2-projection of the boundary function or any other method. For this purpose we refer to the <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values()</a> function below.</p>
<p>You should be aware that the boundary function may be evaluated at nodes on the interior of faces. These, however, need not be on the true boundary, but rather are on the approximation of the boundary represented by the mapping of the unit cell to the real cell. Since this mapping will in most cases not be the exact one at the face, the boundary function is evaluated at points which are not on the boundary and you should make sure that the returned values are reasonable in some sense anyway.</p>
<p>In 1d the situation is a bit different since there faces (i.e. vertices) have no boundary indicator. It is assumed that if the boundary indicator zero is given in the list of boundary functions, the left boundary point is to be interpolated while the right boundary point is associated with the boundary index 1 in the map. The respective boundary functions are then evaluated at the place of the respective boundary point.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Projection of boundary values: The <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values()</a> function acts similar to the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a> function, apart from the fact that it does not get the nodal values of boundary nodes by interpolation but rather through the <em>L</em><sup>2</sup>-projection of the trace of the function to the boundary.</p>
<p>The projection takes place on all boundary parts with boundary indicators listed in the map (std::map&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt;) of boundary functions. These boundary parts may or may not be continuous. For these boundary parts, the mass matrix is assembled using the <a class="el" href="namespaceMatrixCreator.html#aca36dde8ca70713334dcf438642c6a1f">MatrixTools::create_boundary_mass_matrix()</a> function, as well as the appropriate right hand side. Then the resulting system of equations is solved using a simple CG method (without preconditioning), which is in most cases sufficient for the present purpose.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Computing errors: The function <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> performs the calculation of the error between a given (continuous) reference function and the finite element solution in different norms. The integration is performed using a given quadrature formula and assumes that the given finite element objects equals that used for the computation of the solution.</p>
<p>The result is stored in a vector (named <code>difference</code>), where each entry equals the given norm of the difference on a cell. The order of entries is the same as a <code>cell_iterator</code> takes when started with <code>begin_active</code> and promoted with the <code>++</code> operator.</p>
<p>This data, one number per active cell, can be used to generate graphical output by directly passing it to the <a class="el" href="classDataOut.html">DataOut</a> class through the <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector</a> function. Alternatively, the global error can be computed using <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a>. Finally, the output per cell from <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> can be interpolated to the nodal points of a finite element field using the <a class="el" href="namespaceDoFTools.html#a952f50bcd4f8fbb09924626ecc60c605">DoFTools::distribute_cell_to_dof_vector</a> function.</p>
<p>Presently, there is the possibility to compute the following values from the difference, on each cell: <code>mean</code>, <code>L1_norm</code>, <code>L2_norm</code>, <code>Linfty_norm</code>, <code>H1_seminorm</code> and <code>H1_norm</code>, see <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>. For the mean difference value, the reference function minus the numerical solution is computed, not the other way round.</p>
<p>The infinity norm of the difference on a given cell returns the maximum absolute value of the difference at the quadrature points given by the quadrature formula parameter. This will in some cases not be too good an approximation, since for example the Gauss quadrature formulae do not evaluate the difference at the end or corner points of the cells. You may want to choose a quadrature formula with more quadrature points or one with another distribution of the quadrature points in this case. You should also take into account the superconvergence properties of finite elements in some points: for example in 1D, the standard finite element method is a collocation method and should return the exact value at nodal points. Therefore, the trapezoidal rule should always return a vanishing L-infinity error. Conversely, in 2D the maximum L-infinity error should be located at the vertices or at the center of the cell, which would make it plausible to use the Simpson quadrature rule. On the other hand, there may be superconvergence at Gauss integration points. These examples are not intended as a rule of thumb, rather they are thought to illustrate that the use of the wrong quadrature formula may show a significantly wrong result and care should be taken to chose the right formula.</p>
<p>The <em>H</em><sup>1</sup> seminorm is the <em>L</em><sup>2</sup> norm of the gradient of the difference. The square of the full <em>H</em><sup>1</sup> norm is the sum of the square of seminorm and the square of the <em>L</em><sup>2</sup> norm.</p>
<p>To get the global <em>L<sup>1</sup></em> error, you have to sum up the entries in <code>difference</code>, e.g. using <a class="el" href="classVector.html#aeaa8fc05dd5a8a8f9560a5de096ebb4e">Vector::l1_norm()</a> function. For the global <em>L</em><sup>2</sup> difference, you have to sum up the squares of the entries and take the root of the sum, e.g. using <a class="el" href="classVector.html#a8ee1b8309a7a9ecf109c8a7116733ef8">Vector::l2_norm()</a>. These two operations represent the <em>l</em><sub>1</sub> and <em>l</em><sub>2</sub> norms of the vectors, but you need not take the absolute value of each entry, since the cellwise norms are already positive.</p>
<p>To get the global mean difference, simply sum up the elements as above. To get the \(L_\infty\) norm, take the maximum of the vector elements, e.g. using the <a class="el" href="classVector.html#a9f6b7f7afb05aaff7e1ab8f9942b6dae">Vector::linfty_norm()</a> function.</p>
<p>For the global <em>H</em><sup>1</sup> norm and seminorm, the same rule applies as for the <em>L</em><sup>2</sup> norm: compute the <em>l</em><sub>2</sub> norm of the cell error vector.</p>
<p class="endli">Note that, in the codimension one case, if you ask for a norm that requires the computation of a gradient, then the provided function is automatically projected along the curve, and the difference is only computed on the tangential part of the gradient, since no information is available on the normal component of the gradient anyway. </p>
</li>
</ul>
<p>All functions use the finite element given to the <a class="el" href="classDoFHandler.html">DoFHandler</a> object the last time that the degrees of freedom were distributed over the triangulation. Also, if access to an object describing the exact form of the boundary is needed, the pointer stored within the triangulation object is accessed.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for some vector types, in particular <code><a class="el" href="classVector.html">Vector</a>&lt;float&gt;, <a class="el" href="classVector.html">Vector</a>&lt;double&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;float&gt;, <a class="el" href="classBlockVector.html">BlockVector</a>&lt;double&gt;</code>; others can be generated in application code (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual). </dd></dl>
</div><h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a69967cb7a148a7169963126249213db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69967cb7a148a7169963126249213db1">&#9670;&nbsp;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Denote which norm/integral is to be computed by the <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> function on each cell and <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a> for the whole domain. Let \(f:\Omega \rightarrow \mathbb{R}^c\) be a finite element function with \(c\) components where component \(c\) is denoted by \(f_c\) and \(\hat{f}\) be the reference function (the <code>fe_function</code> and <code>exact_solution</code> arguments to <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a>). Let \(e_c = \hat{f}_c - f_c\) be the difference or error between the two. Further, let \(w:\Omega \rightarrow \mathbb{R}^c\) be the <code>weight</code> function of <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a>, which is assumed to be equal to one if not supplied. Finally, let \(p\) be the <code>exponent</code> argument (for \(L_p\)-norms).</p>
<p>In the following,we denote by \(E_K\) the local error computed by <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> on cell \(K\), whereas \(E\) is the global error computed by <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a>. Note that integrals are approximated by quadrature in the usual way: </p><p class="formulaDsp">
\[ \int_A f(x) dx \approx \sum_q f(x_q) \omega_q. \]
</p>
<p> Similarly for suprema over a cell \(T\): </p><p class="formulaDsp">
\[ \sup_{x\in T} |f(x)| dx \approx \max_q |f(x_q)|. \]
</p>
 <table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a485d4198c1f422388b80cadb98af1f27"></a>mean&#160;</td><td class="fielddoc"><p>The function or difference of functions is integrated on each cell \(K\): </p><p class="formulaDsp">
\[ E_K = \int_K \sum_c (\hat{f}_c - f_c) \, w_c = \int_K \sum_c e_c \, w_c \]
</p>
<p> and summed up to get </p><p class="formulaDsp">
\[ E = \sum_K E_K = \int_\Omega \sum_c (\hat{f}_c - f_c) \, w_c \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \int_\Omega (\hat{f} - f) = \int_\Omega e. \]
</p>
<p>Note: This differs from what is typically known as the mean of a function by a factor of \(\frac{1}{|\Omega|}\). To compute the mean you can also use <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value()</a>. Finally, pay attention to the sign: if \(\hat{f}=0\), this will compute the negative of the mean of \(f\). </p>
</td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a8a97c0127bcfceec1fefbd0ad5839357"></a>L1_norm&#160;</td><td class="fielddoc"><p>The absolute value of the function is integrated: </p><p class="formulaDsp">
\[ E_K = \int_K \sum_c |e_c| \, w_c \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \sum_K E_K = \int_\Omega \sum_c |e_c| w_c, \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \| e \|_{L^1}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e"></a>L2_norm&#160;</td><td class="fielddoc"><p>The square of the function is integrated and the square root of the result is computed on each cell: </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \sum_c e_c^2 \, w_c } \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c e_c^2 \, w_c } \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \sqrt{ \int_\Omega e^2 } = \| e \|_{L^2} \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6"></a>Lp_norm&#160;</td><td class="fielddoc"><p>The absolute value to the \(p\)-th power is integrated and the \(p\)-th root is computed on each cell. The exponent \(p\) is the <code>exponent</code> argument of <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> and <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value()</a>: </p><p class="formulaDsp">
\[ E_K = \left( \int_K \sum_c |e_c|^p \, w_c \right)^{1/p} \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \left( \sum_K E_K^p \right)^{1/p} \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \| e \|_{L^p}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4"></a>Linfty_norm&#160;</td><td class="fielddoc"><p>The maximum absolute value of the function: </p><p class="formulaDsp">
\[ E_K = \sup_K \max_c |e_c| \, w_c \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \max_K E_K = \sup_\Omega \max_c |e_c| \, w_c \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \sup_\Omega \|e\|_\infty = \| e \|_{L^\infty}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f"></a>H1_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> of the gradient: </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \sum_c (\nabla e_c)^2 \, w_c } \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c (\nabla e_c)^2 \, w_c } \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \| \nabla e \|_{L^2}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a1ab711e0a460000489addc7aa59878d2"></a>Hdiv_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> of the divergence of a vector field. The function \(f\) is expected to have \(c \geq \text{dim}\) components and the first <code>dim</code> will be used to compute the divergence: </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \left( \sum_c \frac{\partial e_c}{\partial x_c} \, \sqrt{w_c} \right)^2 } \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \left( \sum_c \frac{\partial e_c}{\partial x_c} \, \sqrt{w_c} \right)^2 } \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \| \nabla \cdot e \|_{L^2}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c"></a>H1_norm&#160;</td><td class="fielddoc"><p>The square of this norm is the square of the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1aa3903caf348e2d5dc54d1b49e15c1e8e">L2_norm</a> plus the square of the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a1048f76e7fb0aea6e654ff1cf036a65f">H1_seminorm</a>: </p><p class="formulaDsp">
\[ E_K = \sqrt{ \int_K \sum_c (e_c^2 + (\nabla e_c)^2) \, w_c } \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \sqrt{\sum_K E_K^2} = \sqrt{ \int_\Omega \sum_c (e_c^2 + (\nabla e_c)^2) \, w_c } \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \left( \| e \|_{L^2}^2 + \| \nabla e \|_{L^2}^2 \right)^{1/2}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1aa24d2a903e0841b2d6794e3329a69930"></a>W1p_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1abbc2c7f8863e60f4ac6a6128c06676f6">Lp_norm</a> of the gradient: </p><p class="formulaDsp">
\[ E_K = \left( \int_K \sum_c |\nabla e_c|^p \, w_c \right)^{1/p} \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \left( \sum_K E_K^p \right)^{1/p} = \left( \int_\Omega \sum_c |\nabla e_c|^p \, w_c \right)^{1/p} \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \| \nabla e \|_{L^p}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a619be0eb2626ecbb804b545b1618d6c3"></a>W1p_norm&#160;</td><td class="fielddoc"><p>The same as the <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a6a4df2311989608627aa7bff3898fd3c">H1_norm</a> but using <em>L<sup>p</sup></em>: </p><p class="formulaDsp">
\[ E_K = \left( \int_K \sum_c (|e_c|^p + |\nabla e_c|^p) \, w_c \right)^{1/p} \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \left( \sum_K E_K^p \right)^{1/p} = \left( \int_\Omega \sum_c (|e_c|^p + |\nabla e_c|^p) \, w_c \right)^{1/p} \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \left( \| e \|_{L^p}^p + \| \nabla e \|_{L^p}^p \right)^{1/p}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418"></a>W1infty_seminorm&#160;</td><td class="fielddoc"><p><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> of the gradient: </p><p class="formulaDsp">
\[ E_K = \sup_K \max_c |\nabla e_c| \, w_c \]
</p>
<p> and </p><p class="formulaDsp">
\[ E = \max_K E_K = \sup_\Omega \max_c |\nabla e_c| \, w_c \]
</p>
<p> or, for \(w \equiv 1\): </p><p class="formulaDsp">
\[ E = \| \nabla e \|_{L^\infty}. \]
</p>
 </td></tr>
<tr><td class="fieldname"><a id="a69967cb7a148a7169963126249213db1a694dcdb8213d64925e9be0fa90cc7619"></a>W1infty_norm&#160;</td><td class="fielddoc"><p>The sum of <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> and <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a>: </p><p class="formulaDsp">
\[ E_K = \sup_K \max_c |e_c| \, w_c + \sup_K \max_c |\nabla e_c| \, w_c. \]
</p>
<p> The global norm is not implemented in <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">compute_global_error()</a>, because it is impossible to compute the sum of the global norms from the values \(E_K\). As a work-around, you can compute the global <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">Linfty_norm</a> and <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1af043345075b417b8613b1dd242297418">W1infty_seminorm</a> separately and then add them to get (with \(w \equiv 1\)): </p><p class="formulaDsp">
\[ E = \| e \|_{L^\infty} + \| \nabla e \|_{L^\infty}. \]
</p>
 </td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="vector__tools__common_8h_source.html#l00053">53</a> of file <a class="el" href="vector__tools__common_8h_source.html">vector_tools_common.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="af27ac28c698a9ed0199faed50a204538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27ac28c698a9ed0199faed50a204538">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute constraints on the solution that corresponds to the imposition of Dirichlet boundary conditions. This function creates a map of degrees of freedom subject to Dirichlet boundary conditions and the corresponding values to be assigned to them, by interpolation around the boundary. For each degree of freedom at the boundary, if its index already exists in <code>boundary_values</code> then its boundary value will be overwritten, otherwise a new entry with proper index and boundary value for this degree of freedom will be inserted into <code>boundary_values</code>.</p>
<p>The parameter <code>function_map</code> provides a list of boundary indicators to be handled by this function and corresponding boundary value functions. The keys of this map correspond to the number <code>boundary_id</code> of the face. <a class="el" href="namespacenumbers.html#a4e5d3fa25689151c833ba46dcc96fa5b">numbers::internal_face_boundary_id</a> is an illegal value for this key since it is reserved for interior faces. For an example of how to use this argument with a non-empty map, see the step-16 tutorial program.</p>
<p>The flags in the last parameter, <code>component_mask</code> denote which components of the finite element space shall be interpolated. If it is left as specified by the default value (i.e. an empty array), all components are interpolated. If it is different from the default value, it is assumed that the number of entries equals the number of components in the boundary functions and the finite element, and those components in the given boundary function will be used for which the respective flag was set in the component mask. See also <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a>. As an example, assume that you are solving the Stokes equations in 2d, with variables \((u,v,p)\) and that you only want to interpolate boundary values for the velocity, then the component mask should correspond to <code>(true,true,false)</code>.</p>
<dl class="section note"><dt>Note</dt><dd>Whether a component mask has been specified or not, the number of components of the functions in <code>function_map</code> must match that of the finite element used by <code>dof</code>. In other words, for the example above, you need to provide a <a class="el" href="classFunction.html">Function</a> object that has 3 components (the two velocities and the pressure), even though you are only interested in the first two of them. <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a> will then call this function to obtain a vector of 3 values at each interpolation point but only take the first two and discard the third. In other words, you are free to return whatever you like in the third component of the vector returned by <a class="el" href="classFunction.html#ae316ebc05d21989d573024f8a23c49cb">Function::vector_value</a>, but the <a class="el" href="classFunction.html">Function</a> object must state that it has 3 components.</dd></dl>
<p>If the finite element used has shape functions that are non-zero in more than one component (in deal.II speak: they are non-primitive), then these components can presently not be used for interpolating boundary values. Thus, the elements in the component mask corresponding to the components of these non-primitive shape functions must be <code>false</code>.</p>
<p>See the general documentation of this namespace for more information.</p>
<dl class="section note"><dt>Note</dt><dd>When solving a partial differential equation with boundary conditions \(u|_{\partial\Omega}=g\) (or on <em>parts</em> of the boundary), then this boundary condition is in general not satisfiable exactly using finite elements in the form \(u_h|_{\partial\Omega}=g\). That is because the function \(g\) is generally not a polynomial, whereas \(u_h|_{\partial\Omega}\) <em>is</em> a polynomial on each face of the mesh that is located at the boundary. In other words, it is in general not possible to <em>impose</em> such boundary condition; what one <em>can</em> do, however, is to impose <p class="formulaDsp">
\[ u_h|_{\partial\Omega}=I_h^{\partial\Omega} g, \]
</p>
 where \(I_h^{\partial\Omega} g\) is a function that equals \(g\) at each node of the finite element space located on the boundary, and is piecewise polynomial in between. In other words, \(I_h^{\partial\Omega}\) is an <em>interpolation operator</em> and \(I_h^{\partial\Omega} g\) are the interpolated boundary values &ndash; thus the name. The use of \(I_h^{\partial\Omega} g\) instead of \(g\) as boundary values imposes an additional error (in the same spirit as using quadrature introduces an additional error compared to being able to compute the integrals of the weak form exactly). In most cases, this additional error is of the same order as the other error terms in the finite element method, though there are some subtle differences when measuring the error in the \(L^2\) norm. For some details, see <b>[Bartels2004]</b> .</dd>
<dd>
An alternative to using the interpolant, <p class="formulaDsp">
\[ u_h|_{\partial\Omega}=I_h^{\partial\Omega} g \]
</p>
 is to use the <em>projection</em> of the boundary values \(g\) onto the finite element space on the boundary: <p class="formulaDsp">
\[ u_h|_{\partial\Omega}=\Pi_h^{\partial\Omega} g. \]
</p>
 The projection is available using the <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values()</a> function. Using the projection may have some theoretical advantages (see again <b>[Bartels2004]</b>) but has the practical disadvantage that computing the projection is far more expensive than computing the interpolation because the latter can be done one face at a time whereas the projection requires the solution of a problem on the entire boundary. On the other hand, interpolation is only possible for "nodal" finite element spaces (such as <a class="el" href="classFE__Q.html">FE_Q</a>, but not <a class="el" href="classFE__Q__Hierarchical.html">FE_Q_Hierarchical</a>), whereas the projection is always possible. </dd></dl>

</div>
</div>
<a id="a316c2741c61a2b7f0372c9dbb69b7c88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a316c2741c61a2b7f0372c9dbb69b7c88">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but take a mapping collection to go with <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities. </p>

</div>
</div>
<a id="afff02b67200d44ba712eb004fe7e8208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff02b67200d44ba712eb004fe7e8208">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but taking only one pair of boundary indicator and corresponding boundary function. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a9045591cffcf0c8a06b583e6563510e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9045591cffcf0c8a06b583e6563510e2">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but take a mapping collection to go with <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities. </p>

</div>
</div>
<a id="aa9c6fe2f772b09e2bfbb95ff6e49aa28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9c6fe2f772b09e2bfbb95ff6e49aa28">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="afad4dbef1b304b170be0362b0590ada1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afad4dbef1b304b170be0362b0590ada1">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. The same comments apply as for the previous function, in particular about the use of the component mask and the requires size of the function object. </p>

</div>
</div>
<a id="a7d6e975950cd122b6a2924b1ecd4ec60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6e975950cd122b6a2924b1ecd4ec60">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but take a mapping collection to go with <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities. </p>

</div>
</div>
<a id="aaa0ffb5d4bd09003cd869b00573cf1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa0ffb5d4bd09003cd869b00573cf1d6">&#9670;&nbsp;</a></span>interpolate_boundary_values() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>boundary_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but take a mapping collection to go with <a class="el" href="classDoFHandler.html">DoFHandler</a> objects with hp-capabilities. </p>

</div>
</div>
<a id="a5aa5117bc6324d18df70c9cb86442b88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aa5117bc6324d18df70c9cb86442b88">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project a function or a set of functions to the boundary of the domain. In other words, compute the solution of the following problem: Find \(u_h \in V_h\) (where \(V_h\) is the finite element space represented by the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument of this function) so that </p><p class="formulaDsp">
\begin{align*} \int_{\Gamma} \varphi_i u_h = \sum_{k \in {\cal K}} \int_{\Gamma_k} \varphi_i f_k, \qquad \forall \varphi_i \in V_h \end{align*}
</p>
<p> where \(\Gamma = \bigcup_{k \in {\cal K}} \Gamma_k\), \(\Gamma_k \subset \partial\Omega\), \(\cal K\) is the set of indices and \(f_k\) the corresponding boundary functions represented in the function map argument <code>boundary_values</code> to this function, and the integrals are evaluated by quadrature. This problem has a non-unique solution in the interior, but it is well defined for the degrees of freedom on the part of the boundary, \(\Gamma\), for which we do the integration. The values of \(u_h|_\Gamma\), i.e., the nodal values of the degrees of freedom of this function along the boundary, are then what is computed by this function.</p>
<p>In case this function is used with \(H_{div}\) conforming finite element space, the solution of a different problem is computed, namely: Find \(\vec{u}_h \in V_h \subset H(\text{div}; \Omega)\) so that </p><p class="formulaDsp">
\begin{align*} \int_{\Gamma} (\vec{\varphi}_i \cdot \vec{n}) (\vec{u}_h \cdot \vec{n}) = \sum_{k \in {\cal K}} \int_{\Gamma_k} (\vec{\varphi}_i \cdot \vec{n}) (\vec{f}_k \cdot \vec{n}), \qquad \forall \vec{\varphi_i} \in V_h, \end{align*}
</p>
<p> where \(\vec{n}\) is an outward normal vector.</p>
<p>This function throws an exception if used with \(H_\text{curl}\) conforming elements, so the <a class="el" href="group__constraints.html#ga190b302dc1ee7c89727c94c083d132d2">project_boundary_values_curl_conforming_l2()</a> should be used instead.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping that will be used in the transformations necessary to integrate along the boundary. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> that describes the finite element space and the numbering of degrees of freedom. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">boundary_functions</td><td>A map from boundary indicators to pointers to functions that describe the desired values on those parts of the boundary marked with this boundary indicator (see <a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Boundary indicator</a>). The projection happens on only those parts of the boundary whose indicators are represented in this map. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The face quadrature used in the integration necessary to compute the mass matrix and right hand side of the projection. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">boundary_values</td><td>The result of this function. It is a map containing all indices of degrees of freedom at the boundary (as covered by the boundary parts in <code>boundary_functions</code>) and the computed dof value for this degree of freedom. For each degree of freedom at the boundary, if its index already exists in <code>boundary_values</code> then its boundary value will be overwritten, otherwise a new entry with proper index and boundary value for this degree of freedom will be inserted into <code>boundary_values</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mapping</td><td>It is sometimes convenient to project a vector-valued function onto only parts of a finite element space (for example, to project a function with <code>dim</code> components onto the velocity components of a <code>dim+1</code> component <a class="el" href="classDoFHandler.html">DoFHandler</a> for a Stokes problem). To allow for this, this argument allows components to be remapped. If the vector is not empty, it has to have one entry for each vector component of the finite element used in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Using the <em>projection</em> rather than the <em>interpolation</em> of boundary values makes relatively little difference in practice. That said, it is far more computationally expensive to compute projections because the require the solution of a problem that couples all unknowns on the boundary, whereas interpolation works on one face at a time. On the other hand, interpolation is only possible for "nodal" finite element spaces (such as <a class="el" href="classFE__Q.html">FE_Q</a>, but not <a class="el" href="classFE__Q__Hierarchical.html">FE_Q_Hierarchical</a>), whereas the projection is always possible. (For some more theoretical considerations, see the documentation of the first <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">interpolate_boundary_values()</a> function above.) </dd></dl>

</div>
</div>
<a id="af52d603a67047f73226b2e9653bffcf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af52d603a67047f73226b2e9653bffcf1">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. </p>

</div>
</div>
<a id="ac63c020c0782c918a8c43972285bfd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63c020c0782c918a8c43972285bfd2f">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but with hp-capabilities. </p>

</div>
</div>
<a id="acb559352c78982c7d36b444d0024720e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb559352c78982c7d36b444d0024720e">&#9670;&nbsp;</a></span>project_boundary_values() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a5aa5117bc6324d18df70c9cb86442b88">project_boundary_values()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. </p>

</div>
</div>
<a id="af0966d7adbacddce3ba37790a604e49f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0966d7adbacddce3ba37790a604e49f">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">VectorTools::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotAvailableHere&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The given point is inside a cell of a &quot; &quot;<a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> that is not &quot; &quot;locally owned by this processor.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a1ad6eceb6cbeaa505baf7f938289bbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ad6eceb6cbeaa505baf7f938289bbde">&#9670;&nbsp;</a></span>point_values() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::value_type&gt; VectorTools::point_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (distributed) solution vector <code>vector</code>, evaluate the values at the (arbitrary and even remote) points specified by <code>evaluation_points</code>.</p>
<dl class="section warning"><dt>Warning</dt><dd>This is a collective call that needs to be executed by all processors in the communicator. </dd></dl>

</div>
</div>
<a id="a6cb22a97ffc83df35caf11dbd4e336cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cb22a97ffc83df35caf11dbd4e336cc">&#9670;&nbsp;</a></span>point_values() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::value_type&gt; VectorTools::point_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (distributed) solution vector <code>vector</code>, evaluate the values at the points specified by <code>cache</code> which might have been set up by the above function.</p>
<dl class="section note"><dt>Note</dt><dd>Refinement/coarsening/repartitioning leads to the invalidation of the cache so that the above function has to be called again.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This is a collective call that needs to be executed by all processors in the communicator. </dd></dl>

</div>
</div>
<a id="aada37fd09d8be1b9ed9bb12d698f8ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aada37fd09d8be1b9ed9bb12d698f8ee4">&#9670;&nbsp;</a></span>point_gradients() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::gradient_type&gt; VectorTools::point_gradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>evaluation_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (distributed) solution vector <code>vector</code>, evaluate the gradients at the (arbitrary and even remote) points specified by <code>evaluation_points</code>. </p>

</div>
</div>
<a id="a5febf52b3f767d8e276e2c02d0ea0662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5febf52b3f767d8e276e2c02d0ea0662">&#9670;&nbsp;</a></span>point_gradients() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int n_components, int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename <a class="el" href="classFEPointEvaluation.html">FEPointEvaluation</a>&lt;n_components, dim&gt;::gradient_type&gt; VectorTools::point_gradients </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">Utilities::MPI::RemotePointEvaluation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>cache</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffd">EvaluationFlags::EvaluationFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffdacc8b05748569f308550a239dc5b14396">EvaluationFlags::avg</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (distributed) solution vector <code>vector</code>, evaluate the gradients at the points specified by <code>cache</code> which might have been set up by the above function.</p>
<dl class="section note"><dt>Note</dt><dd>Refinement/coarsening/repartitioning leads to the invalidation of the cache so that the above function has to be called again. </dd></dl>

</div>
</div>
<a id="a676190d2c897ac5da68a9c460fa95832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a676190d2c897ac5da68a9c460fa95832">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the cellwise error of the finite element solution. Integrate the difference between a reference function which is given as a continuous function object, and a finite element function. The result of this function is the vector <code>difference</code> that contains one value per active cell \(K\) of the triangulation. Each of the values of this vector \(d\) equals </p><p class="formulaDsp">
\begin{align*} d_K = \| u-u_h \|_X \end{align*}
</p>
<p> where \(X\) denotes the norm chosen and \(u\) represents the exact solution.</p>
<p>It is assumed that the number of components of the function <code>exact_solution</code> matches that of the finite element used by <code>dof</code>.</p>
<p>To compute a global error norm of a finite element solution, use <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a> with the output vector computed with this function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping that is used when integrating the difference \(u-u_h\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> object that describes the finite element space in which the solution vector lives. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_function</td><td>A vector with nodal values representing the numerical approximation \(u_h\). This vector needs to correspond to the finite element space represented by <code>dof</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exact_solution</td><td>The exact solution that is used to compute the error. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">difference</td><td>The vector of values \(d_K\) computed as above. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q</td><td>The quadrature formula used to approximate the integral shown above. Note that some quadrature formulas are more useful than other in integrating \(u-u_h\). For example, it is known that the \(Q_1\) approximation \(u_h\) to the exact solution \(u\) of a Laplace equation is particularly accurate (in fact, superconvergent, i.e. accurate to higher order) at the 4 Gauss points of a cell in 2d (or 8 points in 3d) that correspond to a <a class="el" href="classQGauss.html">QGauss(2)</a> object. Consequently, because a <a class="el" href="classQGauss.html">QGauss(2)</a> formula only evaluates the two solutions at these particular points, choosing this quadrature formula may indicate an error far smaller than it actually is. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">norm</td><td>The norm \(X\) shown above that should be computed. If the norm is NormType::Hdiv_seminorm, then the finite element on which this function is called needs to have at least dim vector components, and the divergence will be computed on the first div components. This works, for example, on the finite elements used for the mixed Laplace (step-20) and the Stokes equations (step-22). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>The additional argument <code>weight</code> allows to evaluate weighted norms. The weight function may be scalar, establishing a spatially variable weight in the domain for all components equally. This may be used, for instance, to only integrate over parts of the domain. The weight function may also be vector-valued, with as many components as the finite element: Then, different components get different weights. A typical application is when the error with respect to only one or a subset of the solution variables is to be computed, in which case the other components would have weight values equal to zero. The <a class="el" href="classComponentSelectFunction.html">ComponentSelectFunction</a> class is particularly useful for this purpose as it provides such a "mask" weight. The weight function is expected to be positive, but negative values are not filtered. The default value of this function, a null pointer, is interpreted as "no weighting function", i.e., weight=1 in the whole domain for all vector components uniformly. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">exponent</td><td>This value denotes the \(p\) used in computing \(L^p\)-norms and \(W^{1,p}\)-norms. The value is ignored if a <code>norm</code> other than NormType::Lp_norm, NormType::W1p_norm, or NormType::W1p_seminorm is chosen.</td></tr>
  </table>
  </dd>
</dl>
<p>See the general documentation of this namespace for more information.</p>
<dl class="section note"><dt>Note</dt><dd>If the integration here happens over the cells of a parallel::distribute::Triangulation object, then this function computes the vector elements \(d_K\) for an output vector with as many cells as there are active cells of the triangulation object of the current processor. However, not all active cells are in fact locally owned: some may be ghost or artificial cells (see <a class="el" href="DEALGlossary.html#GlossGhostCell">here</a> and <a class="el" href="DEALGlossary.html#GlossArtificialCell">here</a>). The vector computed will, in the case of a distributed triangulation, contain zeros for cells that are not locally owned. As a consequence, in order to compute the <em>global</em> \(L_2\) error (for example), the errors from different processors need to be combined, see <a class="el" href="namespaceVectorTools.html#a21eb62d70953182dcc2b15c4e14dd533">VectorTools::compute_global_error()</a>.</dd></dl>
<p>Instantiations for this template are provided for some vector types (see the general documentation of the namespace), but only for InVectors as in the documentation of the namespace, OutVector only <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and Vector&lt;float&gt;. </p>

</div>
</div>
<a id="a8d01703fa0d91ed6404009757680886d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d01703fa0d91ed6404009757680886d">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="aec4da3324bbce54d7c12dd54c59dd915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4da3324bbce54d7c12dd54c59dd915">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp. </p>

</div>
</div>
<a id="a0900dfa36831d4fa6d4225b8e98cfcda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0900dfa36831d4fa6d4225b8e98cfcda">&#9670;&nbsp;</a></span>integrate_difference() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::integrate_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; *&#160;</td>
          <td class="paramname"><em>weight</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">integrate_difference()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a21eb62d70953182dcc2b15c4e14dd533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21eb62d70953182dcc2b15c4e14dd533">&#9670;&nbsp;</a></span>compute_global_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> VectorTools::compute_global_error </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>cellwise_error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">NormType</a> &amp;&#160;</td>
          <td class="paramname"><em>norm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>exponent</em> = <code>2.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a <a class="el" href="classVector.html">Vector</a> <code>cellwise_error</code> of errors on each cell with <code>tria.n_active_cells()</code> entries and return the global error as given by <code>norm</code>.</p>
<p>The <code>cellwise_error</code> vector is typically an output produced by <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a> and you normally want to supply the same value for <code>norm</code> as you used in <a class="el" href="namespaceVectorTools.html#a676190d2c897ac5da68a9c460fa95832">VectorTools::integrate_difference()</a>.</p>
<p>If the given <a class="el" href="classTriangulation.html">Triangulation</a> is a <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a>, entries in <code>cellwise_error</code> that do not correspond to locally owned cells are assumed to be 0.0 and a parallel reduction using MPI is done to compute the global error.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tria</td><td>The <a class="el" href="classTriangulation.html">Triangulation</a> with active cells corresponding with the entries in <code>cellwise_error</code>. </td></tr>
    <tr><td class="paramname">cellwise_error</td><td><a class="el" href="classVector.html">Vector</a> of errors on each active cell. </td></tr>
    <tr><td class="paramname">norm</td><td>The type of norm to compute. </td></tr>
    <tr><td class="paramname">exponent</td><td>The exponent \(p\) to use for \(L^p\)-norms and \(W^{1,p}\)-norms. The value is ignored if a <code>norm</code> other than NormType::Lp_norm, NormType::W1p_norm, or NormType::W1p_seminorm is chosen.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Instantiated for type <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">Vector&lt;double&gt;</a> and Vector&lt;float&gt;. </dd></dl>

</div>
</div>
<a id="a761f008bdeb7d94a69205ae824deefad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a761f008bdeb7d94a69205ae824deefad">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of <code>function</code> at the support points to the finite element space described by the <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> object with which the given <a class="el" href="classDoFHandler.html">DoFHandler</a> argument is initialized. It is assumed that the number of components of <code>function</code> matches that of the finite element used by <code>dof</code>.</p>
<p>Note that you may have to call <code>hanging_nodes.distribute(vec)</code> with the hanging nodes from space <code>dof</code> afterwards, to make the result continuous again.</p>
<p>See the general documentation of this namespace for further information. </p>

</div>
</div>
<a id="a34fa653b9e16be54bda225e64f9b2b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34fa653b9e16be54bda225e64f9b2b56">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but in an hp-context. </p>

</div>
</div>
<a id="a32b68e11070496fcaf6c2389f088d09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b68e11070496fcaf6c2389f088d09c">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <code><a class="el" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">interpolate()</a></code> function above with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim,spacedim&gt;(1)</code>. </p>

</div>
</div>
<a id="a5e3af70a47cedfaf361cf5c621e94e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e3af70a47cedfaf361cf5c621e94e3d">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>transfer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>data_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>data_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Interpolate different finite element spaces. The interpolation of vector <code>data_1</code> (which is assumed to be ghosted, see <a class="el" href="DEALGlossary.html#GlossGhostedVector">GlossGhostedVector</a>) is executed from the FE space represented by <code>dof_1</code> to the vector <code>data_2</code> on FE space <code>dof_2</code>. The interpolation on each cell is represented by the matrix <code>transfer</code>. Curved boundaries are neglected so far.</p>
<p>Note that you may have to call <code>hanging_nodes.distribute(data_2)</code> with the hanging nodes from space <code>dof_2</code> afterwards, to make the result continuous again.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for some vector types (see the general documentation of the namespace), but only the same vector for InVector and OutVector. Other combinations must be instantiated by hand. </dd></dl>

</div>
</div>
<a id="afbf179d7bbaec3bede8e732aadedc51b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf179d7bbaec3bede8e732aadedc51b">&#9670;&nbsp;</a></span>interpolate_based_on_material_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_based_on_material_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>function_map</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function is a kind of generalization or modification of the very first <a class="el" href="namespaceVectorTools.html#a761f008bdeb7d94a69205ae824deefad">interpolate()</a> function in the series. It interpolates a set of functions onto the finite element space defined by the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument, where the determination which function to use on each cell is made based on the material id (see <a class="el" href="DEALGlossary.html#GlossMaterialId">GlossMaterialId</a>) of each cell.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping to use to determine the location of support points at which the functions are to be evaluated. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td><a class="el" href="classDoFHandler.html">DoFHandler</a> initialized with <a class="el" href="classTriangulation.html">Triangulation</a> and <a class="el" href="classFiniteElement.html">FiniteElement</a> objects and that defines the finite element space. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function_map</td><td>A std::map reflecting the correspondence between material ids on those cells on which something should be interpolated, and the functions to be interpolated onto the finite element space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The global finie element vector holding the output of the interpolated values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">component_mask</td><td>A mask of components that shall be interpolated.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>If the algorithm encounters a cell whose material id is not listed in the given <code>function_map</code>, then <code>dst</code> will not be updated in the respective degrees of freedom of the output vector. For example, if <code>dst</code> was initialized to zero, then those zeros which correspond to the missed material ids will still remain in <code>dst</code> after calling this function.</dd>
<dd>
Degrees of freedom located on faces between cells of different material ids will get their value by that cell which was called last in the respective loop over cells implemented in this function. Since the order of cells is somewhat arbitrary, you cannot control it. However, if you want to have control over the order in which cells are visited, let us take a look at the following example: Let <code>u</code> be a variable of interest which is approximated by some CG finite element. Let <code>0</code>, <code>1</code> and <code>2</code> be material ids of cells on the triangulation. Let 0: 0.0, 1: 1.0, 2: 2.0 be the whole <code>function_map</code> that you want to pass to this function, where <code>key</code> is a material id and <code>value</code> is a value of <code>u</code>. By using the whole <code>function_map</code> you do not really know which values will be assigned to the face DoFs. On the other hand, if you split the whole <code>function_map</code> into three smaller independent objects 0: 0.0 and 1: 1.0 and 2: 2.0 and make three distinct calls of this function passing each of these objects separately (the order depends on what you want to get between cells), then each subsequent call will rewrite the intercell <code>dofs</code> of the previous one. </dd></dl>

</div>
</div>
<a id="ac4807a032b164d00ae06adb8cfb2c9d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4807a032b164d00ae06adb8cfb2c9d1">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of a <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>, where <code>dof1</code> and <code>dof2</code> represent different triangulations with a common coarse grid.</p>
<p>dof1 and dof2 need to have the same finite element discretization.</p>
<p>Note that for continuous elements on grids with hanging nodes (i.e. locally refined grids) this function does not give the expected output. Indeed, the resulting output vector does not necessarily respect continuity requirements at hanging nodes, due to local cellwise interpolation.</p>
<p>For this case (continuous elements on grids with hanging nodes), please use the interpolate_to_different_mesh function with an additional <a class="el" href="classAffineConstraints.html">AffineConstraints</a> argument, see below, or make the field conforming yourself by calling the <code><a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">AffineConstraints::distribute</a></code> function of your hanging node constraints object.</p>
<dl class="section note"><dt>Note</dt><dd>This function works with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, but only if the parallel partitioning is the same for both meshes (see the <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html#a0f5f69b2f422595604c9317ea7f15c13a1bcfd814692ed67b8c57e84b042158ad">parallel::distributed::Triangulation&lt;dim&gt;::no_automatic_repartitioning</a> flag). </dd></dl>

</div>
</div>
<a id="abad7ee745dc25e8699e893df7ebdb668"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad7ee745dc25e8699e893df7ebdb668">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of a <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>, where <code>dof1</code> and <code>dof2</code> represent different triangulations with a common coarse grid.</p>
<p>dof1 and dof2 need to have the same finite element discretization.</p>
<p><code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particularly important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids): Without it - due to cellwise interpolation - the resulting output vector does not necessarily respect continuity requirements at hanging nodes. </p>

</div>
</div>
<a id="ac48b116f0b923f29ca6121890ec19b61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac48b116f0b923f29ca6121890ec19b61">&#9670;&nbsp;</a></span>interpolate_to_different_mesh() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::interpolate_to_different_mesh </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classInterGridMap.html">InterGridMap</a>&lt; <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>intergridmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same function as above, but takes an <a class="el" href="classInterGridMap.html">InterGridMap</a> object directly as a parameter. Useful for interpolating several vectors at the same time.</p>
<p><code>intergridmap</code> has to be initialized via <a class="el" href="classInterGridMap.html#a9e9ed6c30b05d6ff93587e5306122bc2">InterGridMap::make_mapping</a> pointing from a source <a class="el" href="classDoFHandler.html">DoFHandler</a> to a destination <a class="el" href="classDoFHandler.html">DoFHandler</a>. </p>

</div>
</div>
<a id="afcb40e50d2fa4807762faefed206f5e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcb40e50d2fa4807762faefed206f5e3">&#9670;&nbsp;</a></span>get_position_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::get_position_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Geometrical interpolation Given a <a class="el" href="classDoFHandler.html">DoFHandler</a> containing at least a spacedim vector field, this function interpolates the <a class="el" href="classTriangulation.html">Triangulation</a> at the support points of a <a class="el" href="classFE__Q.html">FE_Q()</a> finite element of the same degree as the degree of the required components.</p>
<p>Curved manifold are respected, and the resulting VectorType will be geometrically consistent. The resulting map is guaranteed to be interpolatory at the support points of a <a class="el" href="classFE__Q.html">FE_Q()</a> finite element of the same degree as the degree of the required components.</p>
<p>If the underlying finite element is an <a class="el" href="classFE__Q.html">FE_Q(1)</a>^spacedim, then the resulting <code>VectorType</code> is a finite element field representation of the vertices of the <a class="el" href="classTriangulation.html">Triangulation</a>.</p>
<p>The optional <a class="el" href="classComponentMask.html">ComponentMask</a> argument can be used to specify what components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> to use to describe the geometry. If no mask is specified at construction time, then a default-constructed mask is used, which is then interpreted as saying that the first <code>spacedim</code> components of the <a class="el" href="classFiniteElement.html">FiniteElement</a> are assumed to represent the geometry of the problem.</p>
<p>This function is only implemented for FiniteElements where the specified components are primitive. </p>

</div>
</div>
<a id="a6d8e3037188b85efb319cb065750da59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8e3037188b85efb319cb065750da59">&#9670;&nbsp;</a></span>get_position_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::get_position_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the above function but also taking <code>mapping</code> as argument. This will introduce an additional approximation between the true geometry specified by the manifold if the degree of the mapping is lower than the degree of the finite element in the <a class="el" href="classDoFHandler.html">DoFHandler</a> <code>dh</code>, but more importantly it allows to fill location vectors for mappings that do not preserve vertex locations (like Eulerian mappings). </p>

</div>
</div>
<a id="a55601b2b4f2e6476619f22096116c0e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55601b2b4f2e6476619f22096116c0e4">&#9670;&nbsp;</a></span>subtract_mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::subtract_mean_value </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_select</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value operations Subtract the (algebraic) mean value from a vector.</p>
<p>This function is most frequently used as a mean-value filter for Stokes: The pressure in Stokes' equations with only Dirichlet boundaries for the velocities is only determined up to a constant. This function allows to subtract the mean value of the pressure. It is usually called in a preconditioner and generates updates with mean value zero. The mean value is computed as the mean value of the degrees of freedom values as given by the input vector; they are not weighted by the area of cells, i.e. the mean is computed as \(\sum_i v_i\), rather than as \(\int_\Omega v(x) = \int_\Omega \sum_i v_i \phi_i(x)\). The latter can be obtained from the VectorTools::compute_mean_function, however.</p>
<p>Apart from the vector <code>v</code> to operate on, this function takes a boolean mask <code>p_select</code> that has a true entry for every element of the vector for which the mean value shall be computed and later subtracted. The argument is used to denote which components of the solution vector correspond to the pressure, and avoid touching all other components of the vector, such as the velocity components. (Note, however, that the mask is not a <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> operating on the vector components of the finite element the solution vector <code>v</code> may be associated with; rather, it is a mask on the entire vector, without reference to what the vector elements mean.)</p>
<p>The boolean mask <code>p_select</code> has an empty vector as default value, which will be interpreted as selecting all vector elements, hence, subtracting the algebraic mean value on the whole vector. This allows to call this function without a boolean mask if the whole vector should be processed.</p>
<dl class="section note"><dt>Note</dt><dd>In the context of using this function to filter out the kernel of an operator (such as the null space of the Stokes operator that consists of the constant pressures), this function only makes sense for finite elements for which the null space indeed consists of the vector \((1,1,\ldots,1)^T\). This is the case for example for the usual Lagrange elements where the sum of all shape functions equals the function that is constant one. However, it is not true for some other functions: for example, for the <a class="el" href="classFE__DGP.html">FE_DGP</a> element (another valid choice for the pressure in Stokes discretizations), the first shape function on each cell is constant while further elements are \(L_2\) orthogonal to it (on the reference cell); consequently, the sum of all shape functions is not equal to one, and the vector that is associated with the constant mode is not equal to \((1,1,\ldots,1)^T\). For such elements, a different procedure has to be used when subtracting the mean value.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This function can only be used for distributed vector classes provided the boolean mask is empty, i.e. selecting the whole vector. </dd></dl>

</div>
</div>
<a id="ad086eb08b8424fd7c853e389a3978a9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad086eb08b8424fd7c853e389a3978a9a">&#9670;&nbsp;</a></span>compute_mean_value() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::compute_mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the mean value of one component of the solution.</p>
<p>This function integrates the chosen component over the whole domain and returns the result, i.e. it computes \(\frac{1}{|\Omega|}\int_\Omega [u_h(x)]_c \; dx\) where \(c\) is the vector component and \(u_h\) is the function representation of the nodal vector given as fourth argument. The integral is evaluated numerically using the quadrature formula given as third argument.</p>
<p>This function is used in the "Possibilities for extensions" part of the results section of step-3.</p>
<dl class="section note"><dt>Note</dt><dd>The function is most often used when solving a problem whose solution is only defined up to a constant, for example a pure Neumann problem or the pressure in a Stokes or Navier-Stokes problem. In both cases, subtracting the mean value as computed by the current function, from the nodal vector does not generally yield the desired result of a finite element function with mean value zero. In fact, it only works for Lagrangian elements. For all other elements, you will need to compute the mean value and subtract it right inside the evaluation routine. </dd></dl>

</div>
</div>
<a id="aed4db7abc1e8c2ac5e814fe802a8a73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed4db7abc1e8c2ac5e814fe802a8a73a">&#9670;&nbsp;</a></span>compute_mean_value() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::compute_mean_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the other <a class="el" href="namespaceVectorTools.html#ad086eb08b8424fd7c853e389a3978a9a">compute_mean_value()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="afcbaf531bea9d2ef9ca82f04866b9c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbaf531bea9d2ef9ca82f04866b9c16">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the (vector) gradient of this function through the last argument.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#afcbaf531bea9d2ef9ca82f04866b9c16">point_gradient()</a> function.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions.</dd></dl>
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a078534e0dfc25a7893805fc1385da132"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a078534e0dfc25a7893805fc1385da132">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the gradient of this function.</p>
<p>Compared with the other function of the same name, this is a wrapper function using a Q1-mapping for cells.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions.</dd></dl>
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a82b8de1f957b6308a56aed2d6dfeb21d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82b8de1f957b6308a56aed2d6dfeb21d">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the gradients of this function through the last argument.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping for evaluation.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="aacbcaff67fab590cd068d8ef2ea276f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacbcaff67fab590cd068d8ef2ea276f3">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim, typename VectorType::value_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="af72dcb595cc262bec07ca5c81614586f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72dcb595cc262bec07ca5c81614586f">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector at the given point, and return the gradient of this function.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping for evaluation.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a151ef408e4ffee595cb32f5a4791f54e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151ef408e4ffee595cb32f5a4791f54e">&#9670;&nbsp;</a></span>point_gradient() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim, typename VectorType::value_type&gt; VectorTools::point_gradient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the gradient of the finite element field either here or there, depending on which cell the point is found in. Since the gradient is, for most elements, discontinuous from one cell or the other, you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="ac4e531baa71a5183079fd2083aa7d723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e531baa71a5183079fd2083aa7d723">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector for a point source at point <code>p</code>. In other words, it creates a vector \(F\) so that \(F_i = \int_\Omega \delta(x-p) \varphi_i(x) dx\) where \(\varphi_i\) are the shape functions described by <code>dof_handler</code> and <code>p</code> is the point at which the delta function is located. Prior content of the given <code>rhs_vector</code> vector is deleted. This function is for the case of a scalar finite element.</p>
<p>This function is typically used in one of these two contexts:</p><ul>
<li>Let's say you want to solve the same kind of problems many times over, with different values for right hand sides or coefficients, and then evaluate the solution at the same point every time. You could do this by calling <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value()</a> after each solve, or you could realize that to evaluate the solution \(u_h\) at a point \(p\), you could rearrange operations like this: <p class="formulaDsp">
\begin{align*} u_h(p) &amp;= \sum_j U_j \varphi_j(p) = \sum_j U_j F_j \\ &amp;= U \cdot F \end{align*}
</p>
 with the vector as defined above. In other words, point evaluation can be achieved with just a single vector-vector product, and the vector \(F\) can be computed once and for all and reused for each solve, without having to go through the mesh every time to find out which cell (and where in the cell) the point \(p\) is located.</li>
<li>This function is also useful if you wanted to compute the Green's function for the problem you are solving. This is because the Green's function \(G(x,p)\) is defined by <p class="formulaDsp">
\begin{align*} L G(x,p) &amp;= \delta(x-p) \end{align*}
</p>
 where \(L\) is the differential operator of your problem. The discrete version then requires computing the right hand side vector \(F_i = \int_\Omega \varphi_i(x) \delta(x-p)\), which is exactly the vector computed by the current function.</li>
</ul>
<p>While maybe not relevant for documenting <em>what</em> this function does, it may be interesting to note that delta functions do not exist in reality, and consequently, using this function does not model any real situation. This is, because no real object is able to focus an infinite force density at an infinitesimally small part of the domain (rather, all real devices will spread out the force over a finite area); nor is it possible to measure values at individual points (but all measurements will somehow be averaged over small areas). Only if this area is so small that it cannot be resolved by any mesh does it make sense to model the situation in a way that uses a delta function with the same overall force or sensitivity. On the other hand, a situation that is probably more fruitfully simulated with a delta function is the electric potential of a point source; in this case, the solution is known to have a logarithmic singularity (in 2d) or a \(\frac{1}{r}\) singularity (in 3d), neither of which is bounded.</p>
<p>Mathematically, the use of delta functions typically leads to exact solutions to which the numerically obtained, approximate solution does not converge. This is because, taking the Laplace equation as an example, the error between exact and numerical solution can be bounded by the expression </p><p class="formulaDsp">
\begin{align*} \| u-u_h \|_{L_2} \le C h \| \nabla u \|_{L_2} \end{align*}
</p>
<p> but when using a delta function on the right hand side, the term \(\| \nabla u \|_{L_2} = |u|_{H^1}\) is not finite. This can be seen by using the a-priori bound for solutions of the Laplace equation \(-\Delta u = f\) that states that \(|u|_{H^1} \le \|f\|_{H^{-1}}\). When using a delta function as right hand side, \(f(x)=\delta(x-p)\), one would need to take the \(H^{-1}\) norm of a delta function, which however is not finite because \(\delta(\cdot-p) \not\in H^{-1}\).</p>
<p>The consequence of all of this is that the exact solution of the Laplace equation with a delta function on the right hand side &ndash; i.e., the <em>Green's function</em> &ndash; has a singularity at \(p\) that is so strong that it cannot be resolved by a finite element solution, and consequently finite element approximations do not converge towards the exact solution in any of the usual norms.</p>
<p>All of this is also the case for all of the other usual second-order partial differential equations in dimensions two or higher. (Because in dimension two and higher, \(H^1\) functions are not necessarily continuous, and consequently the delta function is not in the dual space \(H^{-1}\).) </p>

</div>
</div>
<a id="ae369225280698a8689572f9caddc2412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae369225280698a8689572f9caddc2412">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but for hp-objects. </p>

</div>
</div>
<a id="a824e81ddddb11735de517c05bc902a99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a824e81ddddb11735de517c05bc902a99">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">create_point_source_vector()</a> function, see above, with an implied default \(Q_1\) mapping object.</p>
<p>Note that if your <a class="el" href="classDoFHandler.html">DoFHandler</a> uses any active FE index other than zero, then you need to call the function above that provides a mapping object for each active FE index. </p>

</div>
</div>
<a id="ab67e7a53f39ce8f5068506dd86c17e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67e7a53f39ce8f5068506dd86c17e3f">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector for a point source at point <code>p</code>. This variation of the function is meant for vector-valued problems with exactly dim components (it will also work for problems with more than dim components, and in this case simply consider only the first dim components of the shape functions). It computes a right hand side that corresponds to a forcing function that is equal to a delta function times a given direction. In other words, it creates a vector \(F\) so that \(F_i = \int_\Omega [\mathbf d \delta(x-p)] \cdot \varphi_i(x) dx\). Note here that \(\varphi_i\) is a vector-valued function. \(\mathbf d\) is the given direction of the source term \(\mathbf d \delta(x-p)\) and corresponds to the <code>direction</code> argument to be passed to this function.</p>
<p>Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the discussion of the first <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">create_point_source_vector()</a> variant for more on the use of delta functions. </p>

</div>
</div>
<a id="a64eca4da3f3af9262d01075c5144d0bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64eca4da3f3af9262d01075c5144d0bf">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous function, but for hp-objects. </p>

</div>
</div>
<a id="ae6d299da4539b9a5cc794d60a1f376a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d299da4539b9a5cc794d60a1f376a3">&#9670;&nbsp;</a></span>create_point_source_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_point_source_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">create_point_source_vector()</a> function for vector-valued finite elements, see above, with an implied default \(Q_1\) mapping object.</p>
<p>Note that if your <a class="el" href="classDoFHandler.html">DoFHandler</a> uses any active FE index other than zero, then you need to call the function above that provides a mapping object for each active FE index. </p>

</div>
</div>
<a id="abf62ca21c24dbb459266851cb234e8bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf62ca21c24dbb459266851cb234e8bf">&#9670;&nbsp;</a></span>point_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPoint.html">Point</a> error evaluation. Find the first cell containing the given point and compute the difference of a (possibly vector-valued) finite element function and a continuous function (with as many vector components as the finite element) at this point.</p>
<p>This is a wrapper function using a Q1-mapping for cell boundaries to call the other <a class="el" href="namespaceVectorTools.html#abf62ca21c24dbb459266851cb234e8bf">point_difference()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

</div>
</div>
<a id="a07907666e2000a6e8a6c0118f5d82b9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07907666e2000a6e8a6c0118f5d82b9f">&#9670;&nbsp;</a></span>point_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>exact_solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classPoint.html">Point</a> error evaluation. Find the first cell containing the given point and compute the difference of a (possibly vector-valued) finite element function and a continuous function (with as many vector components as the finite element) at this point.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown. </dd></dl>

</div>
</div>
<a id="acd358e9b110ccbf4a7f76796d206b9c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd358e9b110ccbf4a7f76796d206b9c7">&#9670;&nbsp;</a></span>point_value() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector <code>fe_function</code> at the given point <code>point</code>, and return the (vector) value of this function through the last argument.</p>
<p>This function uses a \(Q_1\)-mapping for the cell the point is evaluated in. If you need to evaluate using a different mapping (for example when using curved boundaries), use the <a class="el" href="namespaceVectorTools.html#abf62ca21c24dbb459266851cb234e8bf">point_difference()</a> function that takes a mapping.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions.</dd></dl>
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a7be5c7eed52308898dfaad91c4cff204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7be5c7eed52308898dfaad91c4cff204">&#9670;&nbsp;</a></span>point_value() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector <code>fe_function</code> at the given point <code>point</code>, and return the value of this function.</p>
<p>This function uses a Q1-mapping for the cell the point is evaluated in. If you need to evaluate using a different mapping (for example when using curved boundaries), use the <a class="el" href="namespaceVectorTools.html#abf62ca21c24dbb459266851cb234e8bf">point_difference()</a> function that takes a mapping.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<p>This function is used in the "Possibilities for extensions" part of the results section of step-3.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions.</dd></dl>
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a23a1c99072ea425f33b06d908b6f4283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23a1c99072ea425f33b06d908b6f4283">&#9670;&nbsp;</a></span>point_value() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a possibly vector-valued finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector <code>fe_function</code> at the given point <code>point</code>, and return the (vector) value of this function through the last argument.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the point value.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a79ff65fecfdbbad09b3a00386db15ee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ff65fecfdbbad09b3a00386db15ee3">&#9670;&nbsp;</a></span>point_value() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a363b651e28ef8eb4312ea9ebcea5b33a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363b651e28ef8eb4312ea9ebcea5b33a">&#9670;&nbsp;</a></span>point_value() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate a scalar finite element function defined by the given <a class="el" href="classDoFHandler.html">DoFHandler</a> and nodal vector <code>fe_function</code> at the given point <code>point</code>, and return the value of this function.</p>
<p>Compared with the other function of the same name, this function uses an arbitrary mapping to evaluate the difference.</p>
<p>This function is not particularly cheap. This is because it first needs to find which cell a given point is in, then find the point on the reference cell that matches the given evaluation point, and then evaluate the shape functions there. You probably do not want to use this function to evaluate the solution at <em>many</em> points. For this kind of application, the FEFieldFunction class offers at least some optimizations. On the other hand, if you want to evaluate <em>many solutions</em> at the same point, you may want to look at the <a class="el" href="namespaceVectorTools.html#ac4e531baa71a5183079fd2083aa7d723">VectorTools::create_point_source_vector()</a> function.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="a47630457753055506858a8e835333054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47630457753055506858a8e835333054">&#9670;&nbsp;</a></span>point_value() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">VectorType::value_type VectorTools::point_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>fe_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>point</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above for hp.</p>
<dl class="section note"><dt>Note</dt><dd>If the cell in which the point is found is not locally owned, an exception of type VectorTools::ExcPointNotAvailableHere is thrown.</dd>
<dd>
This function needs to find the cell within which a point lies, and this can only be done up to a certain numerical tolerance of course. Consequently, for points that are on, or close to, the boundary of a cell, you may get the value of the finite element field either here or there, depending on which cell the point is found in. This does not matter (to within the same tolerance) if the finite element field is continuous. On the other hand, if the finite element in use is <em>not</em> continuous, then you will get unpredictable values for points on or close to the boundary of the cell, as one would expect when trying to evaluate point values of discontinuous functions. </dd></dl>

</div>
</div>
<a id="ac6b404bf03cb2a742b290421cc2789fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b404bf03cb2a742b290421cc2789fe">&#9670;&nbsp;</a></span>project() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the projection of <code>function</code> to the finite element space. In other words, given a function \(f(\mathbf x)\), the current function computes a finite element function \(f_h(\mathbf x)=\sum_j F_j \varphi_j(\mathbf x)\) characterized by the (output) vector of nodal values \(F\) that satisfies the equation </p><p class="formulaDsp">
\begin{align*} (\varphi_i, f_h)_\Omega = (\varphi_i,f)_\Omega \end{align*}
</p>
<p> for all test functions \(\varphi_i\). This requires solving a linear system involving the mass matrix since the equation above is equivalent to the linear system </p><p class="formulaDsp">
\begin{align*} \sum_j (\varphi_i, \varphi_j)_\Omega F_j = (\varphi_i,f)_\Omega \end{align*}
</p>
<p> which can also be written as \(MF = \Phi\) with \(M_{ij} = (\varphi_i, \varphi_j)_\Omega\) and \(\Phi_i = (\varphi_i,f)_\Omega\).</p>
<p>By default, no boundary values for \(f_h\) are needed nor imposed, but there are optional parameters to this function that allow imposing either zero boundary values or, in a first step, to project the boundary values of \(f\) onto the finite element space on the boundary of the mesh in a similar way to above, and then using these values as the imposed boundary values for \(f_h\). The ordering of arguments to this function is such that you need not give a second quadrature formula (of type <code><a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt;</code> and used for the computation of the matrix and right hand side for the projection of boundary values) if you don't want to project to the boundary first, but that you must if you want to do so.</p>
<p>A <a class="el" href="classMatrixFree.html">MatrixFree</a> implementation is used if the following conditions are met:</p><ul>
<li><code>enforce_zero_boundary</code> is false,</li>
<li><code>project_to_boundary_first</code> is false,</li>
<li>the <a class="el" href="classFiniteElement.html">FiniteElement</a> is supported by the <a class="el" href="classMatrixFree.html">MatrixFree</a> class,</li>
<li>the <a class="el" href="classFiniteElement.html">FiniteElement</a> has less than five components</li>
<li>the degree of the <a class="el" href="classFiniteElement.html">FiniteElement</a> is less than nine.</li>
<li>dim==spacedim</li>
</ul>
<p>In this case, this function performs numerical quadrature using the given quadrature formula for integration of the right hand side \(\Phi_i\) while a <a class="el" href="classQGauss.html">QGauss</a>(fe_degree+2) object is used for the mass operator. You should therefore make sure that the given quadrature formula is sufficiently accurate for creating the right-hand side.</p>
<p>Otherwise, only serial Triangulations are supported and the mass matrix is assembled using MatrixTools::create_mass_matrix. The given quadrature rule is then used for both the matrix and the right-hand side. You should therefore make sure that the given quadrature formula is also sufficient for creating the mass matrix. In particular, the degree of the quadrature formula must be sufficiently high to ensure that the mass matrix is invertible. For example, if you are using a <a class="el" href="classFE__Q.html">FE_Q(k)</a> element, then the integrand of the matrix entries \(M_{ij}\) is of polynomial degree \(2k\) in each variable, and you need a Gauss quadrature formula with \(k+1\) points in each coordinate direction to ensure that \(M\) is invertible.</p>
<p>See the general documentation of this namespace for further information.</p>
<p>In 1d, the default value of the boundary quadrature formula is an invalid object since integration on the boundary doesn't happen in 1d.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>The mapping object to use. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> the describes the finite element space to project into and that corresponds to <code>vec</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">constraints</td><td>Constraints to be used when assembling the mass matrix, typically needed when you have hanging nodes. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">quadrature</td><td>The quadrature formula to be used for assembling the mass matrix. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">function</td><td>The function to project into the finite element space. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vec</td><td>The output vector where the projected function will be stored in. This vector is required to be already initialized and must not have ghost elements. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">enforce_zero_boundary</td><td>If true, <code>vec</code> will have zero boundary conditions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">q_boundary</td><td><a class="el" href="classQuadrature.html">Quadrature</a> rule to be used if <code>project_to_boundary_first</code> is true. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">project_to_boundary_first</td><td>If true, perform a projection on the boundary before projecting the interior of the function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae25affd2b8b4fc818c0e45ec8b6e9c4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae25affd2b8b4fc818c0e45ec8b6e9c4b">&#9670;&nbsp;</a></span>project() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code>(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a> function above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a1392cfa47cf2c315bf049bf626962152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1392cfa47cf2c315bf049bf626962152">&#9670;&nbsp;</a></span>project() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but with hp-capabilities. </p>

</div>
</div>
<a id="aa55c7e03374966532e28a5273aa89c45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa55c7e03374966532e28a5273aa89c45">&#9670;&nbsp;</a></span>project() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>enforce_zero_boundary</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q_boundary</em> = <code><a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(dim&#160;&gt;&#160;1&#160;?&#160;<a class="el" href="classQGauss.html">QGauss</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(2)&#160;:<a class="el" href="classQuadrature.html">Quadrature</a>&lt;&#160;dim&#160;-&#160;1&#160;&gt;(0))</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>project_to_boundary_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">project()</a> function above, with a collection of \(Q_1\) mapping objects, i.e., with <a class="el" href="structhp_1_1StaticMappingQ1.html#ac1d092bffd54aafcbba55819d40cd516">hp::StaticMappingQ1::mapping_collection</a>. </p>

</div>
</div>
<a id="a51a13e948e1296dbfdfc297167e4fd5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a13e948e1296dbfdfc297167e4fd5a">&#9670;&nbsp;</a></span>project() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; typename VectorType::value_type(const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above for projection of scalar-valued quadrature data. The user provided function should return a value at the quadrature point based on the cell iterator and quadrature number and of course should be consistent with the provided <code>quadrature</code> object, which will be used to assemble the right-hand-side.</p>
<p>This function can be used with lambdas: </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a></div><div class="line">(mapping,</div><div class="line"> dof_handler,</div><div class="line"> constraints,</div><div class="line"> quadrature_formula,</div><div class="line"> [&amp;] (<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;::active_cell_iterator</a> &amp; cell,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q) -&gt; <span class="keywordtype">double</span></div><div class="line"> {</div><div class="line">   <span class="keywordflow">return</span> qp_data.get_data(cell)[q]-&gt;density;</div><div class="line"> },</div><div class="line"> field);</div></div><!-- fragment --><p> where <code>qp_data</code> is a <a class="el" href="classCellDataStorage.html">CellDataStorage</a> object, which stores quadrature point data. </p>

</div>
</div>
<a id="af78e1c7322a3c5bea31ac2ca7a7bb9b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af78e1c7322a3c5bea31ac2ca7a7bb9b8">&#9670;&nbsp;</a></span>project() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_q_points_1d</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The same as above for projection of scalar-valued <a class="el" href="classMatrixFree.html">MatrixFree</a> quadrature data. The user provided function <code>func</code> should return a <a class="el" href="classVectorizedArray.html">VectorizedArray</a> value at the quadrature point based on the cell number and quadrature number and should be consistent with the <code>n_q_points_1d</code>.</p>
<p>This function can be used with lambdas: </p><div class="fragment"><div class="line"><a class="code" href="namespaceVectorTools.html#ac6b404bf03cb2a742b290421cc2789fe">VectorTools::project</a></div><div class="line">(matrix_free_data,</div><div class="line"> constraints,</div><div class="line"> 3,</div><div class="line"> [&amp;] (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cell,</div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q) -&gt; <a class="code" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a></div><div class="line"> {</div><div class="line">   <span class="keywordflow">return</span> qp_data(cell,q);</div><div class="line"> },</div><div class="line"> field);</div></div><!-- fragment --><p> where <code>qp_data</code> is a an object of type <a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classVectorizedArray.html">VectorizedArray&lt;double&gt;</a> &gt;, which stores quadrature point data.</p>
<p><code>fe_component</code> allow to additionally specify which component of <code>data</code> to use in case it was constructed with an <code>std::vector&lt;const <a class="el" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a>*&gt;</code>. It will be used internally in constructor of <a class="el" href="classFEEvaluation.html">FEEvaluation</a> object. </p>

</div>
</div>
<a id="a51734bccfad4ad25857252845ca6bd26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51734bccfad4ad25857252845ca6bd26">&#9670;&nbsp;</a></span>project() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::project </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classMatrixFree.html">MatrixFree</a>&lt; dim, typename VectorType::value_type, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;&gt;&gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; typename VectorType::value_type &gt;(const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>fe_component</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for <code>n_q_points_1d = matrix_free.get_dof_handler().get_fe().degree+1</code>. </p>

</div>
</div>
<a id="a6e325333a138893e181da47f29ac680a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e325333a138893e181da47f29ac680a">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this namespace for further information. </p>

</div>
</div>
<a id="adbf70c57cf6f92f1a7b0d73b130f0afa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf70c57cf6f92f1a7b0d73b130f0afa">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">create_right_hand_side()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a166be0312d664eca59fcc7582676e112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166be0312d664eca59fcc7582676e112">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp-objects. </p>

</div>
</div>
<a id="a84ac5162116a1d96e72483cfdb17a968"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84ac5162116a1d96e72483cfdb17a968">&#9670;&nbsp;</a></span>create_right_hand_side() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;typename&#160;VectorType::value_type&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the previous set of functions, but for hp-objects. </p>

</div>
</div>
<a id="ac928341ce5b22e8285cf867122e92ef7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac928341ce5b22e8285cf867122e92ef7">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a right hand side vector from boundary forces. Prior content of the given <code>rhs_vector</code> vector is deleted.</p>
<p>See the general documentation of this namespace for further information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a6bb19571d249869eaf25b03b29f655d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bb19571d249869eaf25b03b29f655d8">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac928341ce5b22e8285cf867122e92ef7">create_boundary_right_hand_side()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="ad9c044f24808972ceeceb105c945a694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9c044f24808972ceeceb105c945a694">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the set of functions above, but for hp-objects.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
<a id="a331275c1c2ebfe58daa7d3beef974b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331275c1c2ebfe58daa7d3beef974b55">&#9670;&nbsp;</a></span>create_boundary_right_hand_side() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void VectorTools::create_boundary_right_hand_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename VectorType::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_ids</em> = <code>std::set&lt;&#160;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceVectorTools.html#ac928341ce5b22e8285cf867122e92ef7">create_boundary_right_hand_side()</a> function, see above, with a single Q1 mapping as collection. This function therefore will only work if the only active FE index in use is zero.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBoundaryIndicator">Glossary entry on boundary indicators</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
