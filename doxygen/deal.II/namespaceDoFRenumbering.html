<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceDoFRenumbering.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DoFRenumbering Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">DoFRenumbering Namespace Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceDoFRenumbering_1_1boost"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering_1_1boost.html">boost</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDoFRenumbering_1_1CompareDownstream.html">CompareDownstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structDoFRenumbering_1_1ComparePointwiseDownstream.html">ComparePointwiseDownstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a68651164485490b86d901d9ae1fbfc3b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a68651164485490b86d901d9ae1fbfc3b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">Cuthill_McKee</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classbool.html">bool</a> reversed_numbering=false, const <a class="el" href="classbool.html">bool</a> use_constraints=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:a68651164485490b86d901d9ae1fbfc3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62153bd40c8a242a4a0402002e99a3c7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a62153bd40c8a242a4a0402002e99a3c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a62153bd40c8a242a4a0402002e99a3c7">compute_Cuthill_McKee</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;, const <a class="el" href="classbool.html">bool</a> reversed_numbering=false, const <a class="el" href="classbool.html">bool</a> use_constraints=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;(), const unsigned <a class="el" href="classint.html">int</a> level=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a62153bd40c8a242a4a0402002e99a3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1243df7ce3208d2ca78c0112add515fb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a1243df7ce3208d2ca78c0112add515fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a1243df7ce3208d2ca78c0112add515fb">Cuthill_McKee</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classbool.html">bool</a> reversed_numbering=false, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;starting_indices=std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt;())</td></tr>
<tr class="separator:a1243df7ce3208d2ca78c0112add515fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7005d8a167ec52dd396565d937dc4bfe"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7005d8a167ec52dd396565d937dc4bfe">DeclExceptionMsg</a> (ExcDoFHandlerNotInitialized, &quot;The <a class="el" href="classDoFHandler.html">DoFHandler</a> on which this function should work has not &quot; &quot;been initialized, i.e., it doesn't appear that DoF indices &quot; &quot;have been distributed on it.&quot;)</td></tr>
<tr class="separator:ga7005d8a167ec52dd396565d937dc4bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga99f2014cc912b772cc8adc8ac8f6518e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga99f2014cc912b772cc8adc8ac8f6518e">DeclException0</a> (ExcInvalidComponentOrder)</td></tr>
<tr class="separator:ga99f2014cc912b772cc8adc8ac8f6518e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83637b63307643d565ed0a550c29c9e5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga83637b63307643d565ed0a550c29c9e5">DeclException0</a> (ExcNotDGFEM)</td></tr>
<tr class="separator:ga83637b63307643d565ed0a550c29c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Component-wise numberings</div></td></tr>
<tr class="memitem:a52c1941406d1ce2937e29a46edf111f4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a52c1941406d1ce2937e29a46edf111f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a52c1941406d1ce2937e29a46edf111f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9315230617717d06eabec3dd2974d34b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9315230617717d06eabec3dd2974d34b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a9315230617717d06eabec3dd2974d34b">component_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component=std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;())</td></tr>
<tr class="separator:a9315230617717d06eabec3dd2974d34b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac61f09a14f968390471319bffd280f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename CellIterator &gt; </td></tr>
<tr class="memitem:a5ac61f09a14f968390471319bffd280f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a5ac61f09a14f968390471319bffd280f">compute_component_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const CellIterator &amp;start, const typename <a class="el" href="structidentity.html">identity</a>&lt; CellIterator &gt;::type &amp;end, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;target_component, const <a class="el" href="classbool.html">bool</a> is_level_operation)</td></tr>
<tr class="separator:a5ac61f09a14f968390471319bffd280f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Block-wise numberings</div></td></tr>
<tr class="memitem:a658593cab0e93a92a7d8ce0ffe086518"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a658593cab0e93a92a7d8ce0ffe086518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">block_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a658593cab0e93a92a7d8ce0ffe086518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5a402d98753ac352ad8b9abaad32ad"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8b5a402d98753ac352ad8b9abaad32ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a8b5a402d98753ac352ad8b9abaad32ad">block_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a8b5a402d98753ac352ad8b9abaad32ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6d683f395aa69974e33cc9de333b337"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </td></tr>
<tr class="memitem:af6d683f395aa69974e33cc9de333b337"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#af6d683f395aa69974e33cc9de333b337">compute_block_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const ITERATOR &amp;start, const ENDITERATOR &amp;end, <a class="el" href="classbool.html">bool</a> is_level_operation)</td></tr>
<tr class="separator:af6d683f395aa69974e33cc9de333b337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Various cell-wise numberings</div></td></tr>
<tr class="memitem:a410cb640ec086808d4c56dd4e4873048"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a410cb640ec086808d4c56dd4e4873048"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a410cb640ec086808d4c56dd4e4873048">hierarchical</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a410cb640ec086808d4c56dd4e4873048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2cf3d3b9898ad1549e54e675f2a0368"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae2cf3d3b9898ad1549e54e675f2a0368"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ae2cf3d3b9898ad1549e54e675f2a0368">cell_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:ae2cf3d3b9898ad1549e54e675f2a0368"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a54863943d7a88d72b902ecb9acb878"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a8a54863943d7a88d72b902ecb9acb878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a8a54863943d7a88d72b902ecb9acb878">compute_cell_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;inverse_renumbering, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:a8a54863943d7a88d72b902ecb9acb878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab496b6f78c564f105ae1ffb3795bff0d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab496b6f78c564f105ae1ffb3795bff0d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ab496b6f78c564f105ae1ffb3795bff0d">cell_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::level_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:ab496b6f78c564f105ae1ffb3795bff0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abba88de0b297f531636c58ba11ec002e"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:abba88de0b297f531636c58ba11ec002e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#abba88de0b297f531636c58ba11ec002e">compute_cell_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;inverse_renumbering, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::level_cell_iterator &gt; &amp;cell_order)</td></tr>
<tr class="separator:abba88de0b297f531636c58ba11ec002e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Directional numberings</div></td></tr>
<tr class="memitem:a59c1a183ef6288e6bb061eb738b84380"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a59c1a183ef6288e6bb061eb738b84380"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering=false)</td></tr>
<tr class="separator:a59c1a183ef6288e6bb061eb738b84380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5175d4f7fb7256d3f5e21dcc3d722cb4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5175d4f7fb7256d3f5e21dcc3d722cb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a5175d4f7fb7256d3f5e21dcc3d722cb4">downstream</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering=false)</td></tr>
<tr class="separator:a5175d4f7fb7256d3f5e21dcc3d722cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2b93380cd0b30720d0f717014de53a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ade2b93380cd0b30720d0f717014de53a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ade2b93380cd0b30720d0f717014de53a">compute_downstream</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;reverse, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering)</td></tr>
<tr class="separator:ade2b93380cd0b30720d0f717014de53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f0ded43e49e9c4f9f3baf8dfa5b8c4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a43f0ded43e49e9c4f9f3baf8dfa5b8c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a43f0ded43e49e9c4f9f3baf8dfa5b8c4">compute_downstream</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;reverse, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> dof_wise_renumbering)</td></tr>
<tr class="separator:a43f0ded43e49e9c4f9f3baf8dfa5b8c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce6d387bdabdc5d76ab4b20bfaf0e8a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9ce6d387bdabdc5d76ab4b20bfaf0e8a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a9ce6d387bdabdc5d76ab4b20bfaf0e8a">clockwise_dg</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classbool.html">bool</a> counter=false)</td></tr>
<tr class="separator:a9ce6d387bdabdc5d76ab4b20bfaf0e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f0e7ccfd629f1adbf166ed8462812e6"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7f0e7ccfd629f1adbf166ed8462812e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a7f0e7ccfd629f1adbf166ed8462812e6">clockwise_dg</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classbool.html">bool</a> counter=false)</td></tr>
<tr class="separator:a7f0e7ccfd629f1adbf166ed8462812e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcbf634039e5423bcfbb7d681893d4a1"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:afcbf634039e5423bcfbb7d681893d4a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#afcbf634039e5423bcfbb7d681893d4a1">compute_clockwise_dg</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;<a class="el" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, const <a class="el" href="classbool.html">bool</a> counter)</td></tr>
<tr class="separator:afcbf634039e5423bcfbb7d681893d4a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Selective and random numberings</div></td></tr>
<tr class="memitem:a7879b1de6248876edccd07c9b37d84c8"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7879b1de6248876edccd07c9b37d84c8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a7879b1de6248876edccd07c9b37d84c8">sort_selected_dofs_back</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a7879b1de6248876edccd07c9b37d84c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a443837e68de5c74cd84475034852aa2b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a443837e68de5c74cd84475034852aa2b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a443837e68de5c74cd84475034852aa2b">sort_selected_dofs_back</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a443837e68de5c74cd84475034852aa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75f87d18ed80be13c45de0d788b1c23c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a75f87d18ed80be13c45de0d788b1c23c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a75f87d18ed80be13c45de0d788b1c23c">compute_sort_selected_dofs_back</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs)</td></tr>
<tr class="separator:a75f87d18ed80be13c45de0d788b1c23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4f7cfab2fb42abd2688222e5f22f168"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae4f7cfab2fb42abd2688222e5f22f168"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#ae4f7cfab2fb42abd2688222e5f22f168">compute_sort_selected_dofs_back</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;selected_dofs, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:ae4f7cfab2fb42abd2688222e5f22f168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd608826acd7c01f91db401a3728e25"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:abbd608826acd7c01f91db401a3728e25"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:abbd608826acd7c01f91db401a3728e25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a78965e22bac673e147b79483b37418"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3a78965e22bac673e147b79483b37418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a3a78965e22bac673e147b79483b37418">random</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a3a78965e22bac673e147b79483b37418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50a045f2a1b63ecb6fdc95e037e278cb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a50a045f2a1b63ecb6fdc95e037e278cb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a50a045f2a1b63ecb6fdc95e037e278cb">compute_random</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a50a045f2a1b63ecb6fdc95e037e278cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a126f17ce3959e408e25dfacaef517273"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a126f17ce3959e408e25dfacaef517273"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a126f17ce3959e408e25dfacaef517273">compute_random</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a126f17ce3959e408e25dfacaef517273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Numberings based on cell attributes</div></td></tr>
<tr class="memitem:a166d0082503ec2b8d9c560222b48f9d2"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a166d0082503ec2b8d9c560222b48f9d2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a166d0082503ec2b8d9c560222b48f9d2">subdomain_wise</a> (<a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a166d0082503ec2b8d9c560222b48f9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07eb2394e83abb813590338409650103"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a07eb2394e83abb813590338409650103"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceDoFRenumbering.html#a07eb2394e83abb813590338409650103">compute_subdomain_wise</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;new_dof_indices, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a07eb2394e83abb813590338409650103"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Implementation of a number of renumbering algorithms for the degrees of freedom on a triangulation. The functions in this namespace compute new indices for each degree of freedom of a <a class="el" href="classDoFHandler.html">DoFHandler</a> object, and then call <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs()</a>.</p>
<h3>Cuthill-McKee like algorithms</h3>
<p>Within this class, the Cuthill-McKee algorithm is implemented. It starts at a degree of freedom, searches the other DoFs for those which are coupled with the one we started with and numbers these in a certain way. It then finds the second level of DoFs, namely those that couple with those of the previous level (which were those that coupled with the initial DoF) and numbers these. And so on. For the details of the algorithm, especially the numbering within each level, please see H. R. Schwarz: "Methode der finiten
Elemente". The reverse Cuthill-McKee algorithm does the same job, but numbers all elements in the reverse order.</p>
<p>These algorithms have one major drawback: they require a good starting point, i.e. the degree of freedom index that will get a new index of zero. The renumbering functions therefore allow the caller to specify such an initial DoF, e.g. by exploiting knowledge of the actual topology of the domain. It is also possible to give several starting indices, which may be used to simulate a simple upstream numbering (by giving the inflow dofs as starting values) or to make preconditioning faster (by letting the Dirichlet boundary indices be starting points).</p>
<p>If no starting index is given, one is chosen automatically, namely one with the smallest coordination number (the coordination number is the number of other dofs this dof couples with). This dof is usually located on the boundary of the domain. There is, however, large ambiguity in this when using the hierarchical meshes used in this library, since in most cases the computational domain is not approximated by tilting and deforming elements and by plugging together variable numbers of elements at vertices, but rather by hierarchical refinement. There is therefore a large number of dofs with equal coordination numbers. The renumbering algorithms will therefore not give optimal results.</p>
<p>In the book of Schwarz (H.R.Schwarz: Methode der finiten Elemente), it is advised to test many starting points, if possible all with the smallest coordination number and also those with slightly higher numbers. However, this seems only possible for meshes with at most several dozen or a few hundred elements found in small engineering problems of the early 1980s (the second edition was published in 1984), but certainly not with those used in this library, featuring several 10,000 to a few 100,000 elements.</p>
<h4>Implementation of renumbering schemes</h4>
<p>The renumbering algorithms need quite a lot of memory, since they have to store for each dof with which other dofs it couples. This is done using a <a class="el" href="classSparsityPattern.html">SparsityPattern</a> object used to store the sparsity pattern of matrices. It is not useful for the user to do anything between distributing the dofs and renumbering, i.e. the calls to <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> and <a class="el" href="classDoFHandler.html#a44e80b846cf60a8671969ce90ae3625b">DoFHandler::renumber_dofs</a> should follow each other immediately. If you try to create a sparsity pattern or anything else in between, these will be invalid afterwards.</p>
<p>The renumbering may take care of dof-to-dof couplings only induced by eliminating constraints. In addition to the memory consumption mentioned above, this also takes quite some computational time, but it may be switched off upon calling the <code>renumber_dofs</code> function. This will then give inferior results, since knots in the graph (representing dofs) are not found to be neighbors even if they would be after condensation.</p>
<p>The renumbering algorithms work on a purely algebraic basis, due to the isomorphism between the graph theoretical groundwork underlying the algorithms and binary matrices (matrices of which the entries are binary values) represented by the sparsity patterns. In special, the algorithms do not try to exploit topological knowledge (e.g. corner detection) to find appropriate starting points. This way, however, they work in arbitrary space dimension.</p>
<p>If you want to give starting points, you may give a list of dof indices which will form the first step of the renumbering. The dofs of the list will be consecutively numbered starting with zero, i.e. this list is not renumbered according to the coordination number of the nodes. Indices not in the allowed range are deleted. If no index is allowed, the algorithm will search for its own starting point.</p>
<h4>Results of renumbering</h4>
<p>The renumbering schemes mentioned above do not lead to optimal results. However, after all there is no algorithm that accomplishes this within reasonable time. There are situations where the lack of optimality even leads to worse results than with the original, crude, levelwise numbering scheme; one of these examples is a mesh of four cells of which always those cells are refined which are neighbors to the center (you may call this mesh a `zoom in' mesh). In one such example the bandwidth was increased by about 50 per cent.</p>
<p>In most other cases, the bandwidth is reduced significantly. The reduction is the better the less structured the grid is. With one grid where the cells were refined according to a random driven algorithm, the bandwidth was reduced by a factor of six.</p>
<p>Using the constraint information usually leads to reductions in bandwidth of 10 or 20 per cent, but may for some very unstructured grids also lead to an increase. You have to weigh the decrease in your case with the time spent to use the constraint information, which usually is several times longer than the `pure' renumbering algorithm.</p>
<p>In almost all cases, the renumbering scheme finds a corner to start with. Since there is more than one corner in most grids and since even an interior degree of freedom may be a better starting point, giving the starting point by the user may be a viable way if you have a simple scheme to derive a suitable point (e.g. by successively taking the third child of the cell top left of the coarsest level, taking its third vertex and the dof index thereof, if you want the top left corner vertex). If you do not know beforehand what your grid will look like (e.g. when using adaptive algorithms), searching a best starting point may be difficult, however, and in many cases will not justify the effort.</p>
<h3>Component-wise and block-wise numberings</h3>
<p>For finite elements composed of several base elements using the <a class="el" href="classFESystem.html">FESystem</a> class, or for elements which provide several components themselves, it may be of interest to sort the DoF indices by component. This will then bring out the block matrix structure, since otherwise the degrees of freedom are numbered cell-wise without taking into account that they may belong to different components. For example, one may want to sort degree of freedom for a Stokes discretization so that we first get all velocities and then all the pressures so that the resulting matrix naturally decomposes into a \(2\times 2\) system.</p>
<p>This kind of numbering may be obtained by calling the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> function of this class. Since it does not touch the order of indices within each component, it may be worthwhile to first renumber using the Cuthill- McKee or a similar algorithm and afterwards renumbering component-wise. This will bring out the matrix structure and additionally have a good numbering within each block.</p>
<p>The <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> function allows not only to honor enumeration based on vector components, but also allows to group together vector components into "blocks" using a defaulted argument to the various <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise()</a> functions (see <a class="el" href="DEALGlossary.html#GlossComponent">GlossComponent</a> vs <a class="el" href="DEALGlossary.html#GlossBlock">GlossBlock</a> for a description of the difference). The blocks designated through this argument may, but do not have to be, equal to the blocks that the finite element reports. For example, a typical Stokes element would be </p><div class="fragment"><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a> stokes_fe (<a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(2), dim,   <span class="comment">// dim velocities</span></div><div class="line">                         <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>(1), 1);    <span class="comment">// one pressure</span></div></div><!-- fragment --><p> This element has <code>dim+1</code> vector components and equally many blocks. However, one may want to consider the velocities as one logical block so that all velocity degrees of freedom are enumerated the same way, independent of whether they are \(x\)- or \(y\)-velocities. This is done, for example, in step-20 and step-22 as well as several other tutorial programs.</p>
<p>On the other hand, if you really want to use block structure reported by the finite element itself (a case that is often the case if you have finite elements that have multiple vector components, e.g. the <a class="el" href="classFE__RaviartThomas.html">FE_RaviartThomas</a> or <a class="el" href="classFE__Nedelec.html">FE_Nedelec</a> elements) then you can use the <a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">DoFRenumbering::block_wise</a> instead of the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> functions.</p>
<h3>Cell-wise numbering</h3>
<p>Given an ordered vector of cells, the function <a class="el" href="namespaceDoFRenumbering.html#ae2cf3d3b9898ad1549e54e675f2a0368">cell_wise()</a> sorts the degrees of freedom such that degrees on earlier cells of this vector will occur before degrees on later cells.</p>
<p>This rule produces a well-defined ordering for discontinuous Galerkin methods (<a class="el" href="classFE__DGP.html">FE_DGP</a>, <a class="el" href="classFE__DGQ.html">FE_DGQ</a>). For continuous methods, we use the additional rule that each degree of freedom is ordered according to the first cell in the ordered vector it belongs to.</p>
<p>Applications of this scheme are <a class="el" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream()</a> and clock_wise_dg(). The first orders the cells according to a downstream direction and then applies <a class="el" href="namespaceDoFRenumbering.html#ae2cf3d3b9898ad1549e54e675f2a0368">cell_wise()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For DG elements, the internal numbering in each cell remains unaffected. This cannot be guaranteed for continuous elements anymore, since degrees of freedom shared with an earlier cell will be accounted for by the other cell.</dd></dl>
<h3>Random renumbering</h3>
<p>The <a class="el" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random()</a> function renumbers degrees of freedom randomly. This function is probably seldom of use, except to check the dependence of solvers (iterative or direct ones) on the numbering of the degrees of freedom.</p>
<h3>A comparison of reordering strategies</h3>
<p>As a benchmark of comparison, let us consider what the different sparsity patterns produced by the various algorithms when using the \(Q_2^d\times Q_1\) element combination typically employed in the discretization of Stokes equations, when used on the mesh obtained in step-22 after one adaptive mesh refinement in 3d. The space dimension together with the coupled finite element leads to a rather dense system matrix with, on average around 180 nonzero entries per row. After applying each of the reordering strategies shown below, the degrees of freedom are also sorted using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise</a> into velocity and pressure groups; this produces the \(2\times 2\) block structure seen below with the large velocity-velocity block at top left, small pressure-pressure block at bottom right, and coupling blocks at top right and bottom left.</p>
<p>The goal of reordering strategies is to improve the preconditioner. In step-22 we use a <a class="el" href="classSparseILU.html">SparseILU</a> to preconditioner for the velocity-velocity block at the top left. The quality of the preconditioner can then be measured by the number of CG iterations required to solve a linear system with this block. For some of the reordering strategies below we record this number for adaptive refinement cycle 3, with 93176 degrees of freedom; because we solve several linear systems with the same matrix in the Schur complement, the average number of iterations is reported. The lower the number the better the preconditioner and consequently the better the renumbering of degrees of freedom is suited for this task. We also state the run-time of the program, in part determined by the number of iterations needed, for the first 4 cycles on one of our machines. Note that the reported times correspond to the run time of the entire program, not just the affected solver; if a program runs twice as fast with one particular ordering than with another one, then this means that the actual solver is actually several times faster.</p>
<table class="doxtable">
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_original.png" alt="reorder_sparsity_step_31_original.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_random.png" alt="reorder_sparsity_step_31_random.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_deal_cmk.png" alt="reorder_sparsity_step_31_deal_cmk.png"/>
</div>
   </td></tr>
<tr>
<td><p class="starttd">Enumeration as produced by deal.II's <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a> function and no further reordering apart from the component-wise one.</p>
<p class="endtd">With this renumbering, we needed an average of 92.2 iterations for the testcase outlined above, and a runtime of 7min53s.  </p>
</td><td><p class="starttd">Random enumeration as produced by applying <a class="el" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">DoFRenumbering::random</a> after calling <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>. This enumeration produces nonzero entries in matrices pretty much everywhere, appearing here as an entirely unstructured matrix.</p>
<p class="endtd">With this renumbering, we needed an average of 71 iterations for the testcase outlined above, and a runtime of 10min55s. The longer runtime despite less iterations compared to the default ordering may be due to the fact that computing and applying the ILU requires us to jump back and forth all through memory due to the lack of localization of matrix entries around the diagonal; this then leads to many cache misses and consequently bad timings.  </p>
</td><td><p class="starttd">Cuthill-McKee enumeration as produced by calling the deal.II implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">DoFRenumbering::Cuthill_McKee</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>.</p>
<p>With this renumbering, we needed an average of 57.3 iterations for the testcase outlined above, and a runtime of 6min10s.   </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_boost_cmk.png" alt="reorder_sparsity_step_31_boost_cmk.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_boost_king.png" alt="reorder_sparsity_step_31_boost_king.png"/>
</div>
  </td><td><div class="image">
<img src="reorder_sparsity_step_31_boost_md.png" alt="reorder_sparsity_step_31_boost_md.png"/>
</div>
   </td></tr>
<tr>
<td><p class="starttd">Cuthill- McKee enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a408e819ea167bc557d5789ffe9b3f521">DoFRenumbering::boost::Cuthill_McKee</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>.</p>
<p class="endtd">With this renumbering, we needed an average of 51.7 iterations for the testcase outlined above, and a runtime of 5min52s.  </p>
</td><td><p class="starttd">King enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#a76fd1dc3212aeeca4294c358248e46d5">DoFRenumbering::boost::king_ordering</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>. The sparsity pattern appears denser than with BOOST's Cuthill-McKee algorithm; however, this is only an illusion: the number of nonzero entries is the same, they are simply not as well clustered.</p>
<p class="endtd">With this renumbering, we needed an average of 51.0 iterations for the testcase outlined above, and a runtime of 5min03s. Although the number of iterations is only slightly less than with BOOST's Cuthill-McKee implementation, runtime is significantly less. This, again, may be due to cache effects. As a consequence, this is the algorithm best suited to the testcase, and is in fact used in step-22.  </p>
</td><td><p class="starttd">Minimum degree enumeration as produced by calling the BOOST implementation of the algorithm provided by <a class="el" href="namespaceDoFRenumbering_1_1boost.html#ad76b30cdbf840d335784b8ce1c112892">DoFRenumbering::boost::minimum_degree</a> after <a class="el" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">DoFHandler::distribute_dofs</a>. The minimum degree algorithm does not attempt to minimize the bandwidth of a matrix but to minimize the amount of fill-in a LU decomposition would produce, i.e. the number of places in the matrix that would be occupied by elements of an LU decomposition that are not already occupied by elements of the original matrix. The resulting sparsity pattern obviously has an entirely different structure than the ones produced by algorithms trying to minimize the bandwidth.</p>
<p>With this renumbering, we needed an average of 58.9 iterations for the testcase outlined above, and a runtime of 6min11s.  </p>
<p class="endtd"></p>
</td></tr>
<tr>
<td><div class="image">
<img src="reorder_sparsity_step_31_downstream.png" alt="reorder_sparsity_step_31_downstream.png"/>
</div>
  </td><td></td><td></td></tr>
<tr>
<td><p class="starttd">Downstream enumeration using <a class="el" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">DoFRenumbering::downstream</a> using a direction that points diagonally through the domain.</p>
<p class="endtd">With this renumbering, we needed an average of 90.5 iterations for the testcase outlined above, and a runtime of 7min05s.  </p>
</td><td></td><td></td></tr>
</table>
<h3><a class="el" href="classMultigrid.html">Multigrid</a> DoF numbering</h3>
<p>Most of the algorithms listed above also work on multigrid degree of freedom numberings. Refer to the actual function declarations to get more information on this. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a68651164485490b86d901d9ae1fbfc3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68651164485490b86d901d9ae1fbfc3b">&#9670;&nbsp;</a></span>Cuthill_McKee() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_constraints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;&#160;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom according to the Cuthill-McKee method, possibly using the reverse numbering scheme.</p>
<p>See the general documentation of this class for details on the different methods.</p>
<p>As an example of the results of this algorithm, take a look at the comparison of various algorithms in the documentation of the <a class="el" href="namespaceDoFRenumbering.html">DoFRenumbering</a> namespace.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> object to work on. </td></tr>
    <tr><td class="paramname">reversed_numbering</td><td>Whether to use the original Cuthill-McKee algorithm, or to reverse the ordering. </td></tr>
    <tr><td class="paramname">use_constraints</td><td>Whether or not to use hanging node constraints in determining the reordering of degrees of freedom. </td></tr>
    <tr><td class="paramname">starting_indices</td><td>A set of degrees of freedom that form the first level of renumbered degrees of freedom. If the set is empty, then a single starting entry is chosen automatically among those that have the smallest number of others that couple with it.</td></tr>
  </table>
  </dd>
</dl>
<h4>Operation in parallel </h4>
<p>If the given <a class="el" href="classDoFHandler.html">DoFHandler</a> uses a distributed triangulation (i.e., if dof_handler.locally_owned() is not the complete index set), the renumbering is performed on each processor's degrees of freedom individually, without any communication between processors. In other words, the resulting renumbering is an attempt at minimizing the bandwidth of <em>each diagonal block of the matrix corresponding to one processor</em> separately, without making an attempt at minimizing the bandwidth of the global matrix. Furthermore, the renumbering reuses exactly the same set of DoF indices that each processor used before. In other words, if the previous numbering of DoFs on one processor used a contiguous range of DoF indices, then so will the DoFs on that processor after the renumbering, and they will occupy the same range. The same is true if the previous numbering of DoFs on a processor consisted of a number of index ranges or single indices: after renumbering, the locally owned DoFs on that processor will use the exact same indices, just in a different order.</p>
<p>In addition, if the <a class="el" href="classDoFHandler.html">DoFHandler</a> is built on a parallel triangulation, then on every processor, the starting indices for renumbering need to be a (possibly empty) subset of the <a class="el" href="DEALGlossary.html#GlossLocallyActiveDof">locally active degrees of freedom</a>. In general, these starting indices will be different on each processor (unless of course you pass an empty list as is the default), and each processor will use them as starting indices for the local renumbering on that processor.</p>
<p>The starting indices must be locally active degrees of freedom, but the function will only renumber the locally owned subset of the locally owned DoFs. The function accepts starting indices from the largest set of locally active degrees of freedom because a typical renumbering operation with this function starts with indices that are located on the boundary &ndash; in the case of the current function, that would be the boundary between processor subdomains. Since the degrees of freedom that are located on subdomain interfaces may be owned by either one of the two processors that own the adjacent subdomains, it is not always easy to identify starting indices that are locally owned. On the other hand, all degrees of freedom on subdomain interfaces are locally active, and so the function accepts them as starting indices even though it can only renumber them on a given processor if they are also locally owned. </p>

</div>
</div>
<a id="a62153bd40c8a242a4a0402002e99a3c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62153bd40c8a242a4a0402002e99a3c7">&#9670;&nbsp;</a></span>compute_Cuthill_McKee()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_constraints</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;&#160;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">Cuthill_McKee()</a> function. This function does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> DoFs but only returns the renumbering vector.</p>
<p>If a valid level is passed as parameter, the renumbering vector for this grid level is returned. See the <a class="el" href="namespaceDoFRenumbering.html#a68651164485490b86d901d9ae1fbfc3b">Cuthill_McKee()</a> function for an explanation of the other arguments. </p>

</div>
</div>
<a id="a1243df7ce3208d2ca78c0112add515fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1243df7ce3208d2ca78c0112add515fb">&#9670;&nbsp;</a></span>Cuthill_McKee() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::Cuthill_McKee </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reversed_numbering</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>starting_indices</em> = <code>std::vector&lt;&#160;<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom according to the Cuthill-McKee method, eventually using the reverse numbering scheme, in this case for a multigrid numbering of degrees of freedom.</p>
<p>You can give a triangulation level to which this function is to be applied. Since with a level-wise numbering there are no hanging nodes, no constraints can be used, so the respective parameter of the previous function is omitted.</p>
<p>See the general documentation of this class for details on the different methods. </p>

</div>
</div>
<a id="a52c1941406d1ce2937e29a46edf111f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c1941406d1ce2937e29a46edf111f4">&#9670;&nbsp;</a></span>component_wise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector component. The numbering within each component is not touched, so a degree of freedom with index \(i\), belonging to some component, and another degree of freedom with index \(j\) belonging to the same component will be assigned new indices \(n(i)\) and \(n(j)\) with \(n(i)&lt;n(j)\) if \(i&lt;j\) and \(n(i)&gt;n(j)\) if \(i&gt;j\).</p>
<p>You can specify that the components are ordered in a different way than suggested by the <a class="el" href="classFESystem.html">FESystem</a> object you use. To this end, set up the vector <code>target_component</code> such that the entry at index <code>i</code> denotes the number of the target component for dofs with component <code>i</code> in the <a class="el" href="classFESystem.html">FESystem</a>. Naming the same target component more than once is possible and results in a blocking of several components into one. This is discussed in step-22. If you omit this argument, the same order as given by the finite element is used.</p>
<p>If one of the base finite elements from which the global finite element under consideration here, is a non-primitive one, i.e. its shape functions have more than one non-zero component, then it is not possible to associate these degrees of freedom with a single vector component. In this case, they are associated with the first vector component to which they belong.</p>
<p>For finite elements with only one component, or a single non-primitive base element, this function is the identity operation. </p>

</div>
</div>
<a id="a9315230617717d06eabec3dd2974d34b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9315230617717d06eabec3dd2974d34b">&#9670;&nbsp;</a></span>component_wise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::component_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em> = <code>std::vector&lt;&#160;unsigned&#160;<a class="el" href="classint.html">int</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by component. It does the same thing as the above function, only that it does this for one single level of a multilevel discretization. The non-multigrid part of the <a class="el" href="classDoFHandler.html">DoFHandler</a> is not touched. </p>

</div>
</div>
<a id="a5ac61f09a14f968390471319bffd280f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ac61f09a14f968390471319bffd280f">&#9670;&nbsp;</a></span>compute_component_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename CellIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> DoFRenumbering::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellIterator &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; CellIterator &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>target_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_level_operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">component_wise()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a id="a658593cab0e93a92a7d8ce0ffe086518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658593cab0e93a92a7d8ce0ffe086518">&#9670;&nbsp;</a></span>block_wise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector block. The numbering within each block is not touched, so a degree of freedom with index \(i\), belonging to some block, and another degree of freedom with index \(j\) belonging to the same block will be assigned new indices \(n(i)\) and \(n(j)\) with \(n(i)&lt;n(j)\) if \(i&lt;j\) and \(n(i)&gt;n(j)\) if \(i&gt;j\).</p>
<dl class="section note"><dt>Note</dt><dd>This function only succeeds if each of the elements in the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> attached to the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument has exactly the same number of blocks (see <a class="el" href="DEALGlossary.html#GlossBlock">the glossary</a> for more information). Note that this is not always given: while the <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> class ensures that all of its elements have the same number of vector components, they need not have the same number of blocks. At the same time, this function here needs to match individual blocks across elements and therefore requires that elements have the same number of blocks and that subsequent blocks in one element have the same meaning as in another element. </dd></dl>

</div>
</div>
<a id="a8b5a402d98753ac352ad8b9abaad32ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5a402d98753ac352ad8b9abaad32ad">&#9670;&nbsp;</a></span>block_wise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::block_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the degrees of freedom by vector block. It does the same thing as the above function, only that it does this for one single level of a multilevel discretization. The non-multigrid part of the <a class="el" href="classDoFHandler.html">DoFHandler</a> is not touched. </p>

</div>
</div>
<a id="af6d683f395aa69974e33cc9de333b337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d683f395aa69974e33cc9de333b337">&#9670;&nbsp;</a></span>compute_block_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class ITERATOR , class ENDITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> DoFRenumbering::compute_block_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ITERATOR &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ENDITERATOR &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_level_operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a658593cab0e93a92a7d8ce0ffe086518">block_wise()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a id="a410cb640ec086808d4c56dd4e4873048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410cb640ec086808d4c56dd4e4873048">&#9670;&nbsp;</a></span>hierarchical()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::hierarchical </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees cell by cell by traversing the cells in <a class="el" href="DEALGlossary.html#GlossZOrder">Z order</a>.</p>
<p>There are two reasons to use this function:</p><ul>
<li>It produces a predictable ordering of degrees of freedom that is independent of how exactly you arrived at a mesh. In particular, in general the order of cells of a mesh depends on the order in which cells were marked for refinement and coarsening during the refinement cycles the mesh has undergone. On the other hand, the z-order of cells is independent of the mesh's history, and so yields a predictable DoF numbering.</li>
<li>For meshes based on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, the <a class="el" href="DEALGlossary.html#GlossLocallyOwnedCell">locally owned cells</a> of each MPI process are contiguous in Z order. That means that numbering degrees of freedom by visiting cells in Z order yields <a class="el" href="DEALGlossary.html#GlossLocallyOwnedDof">locally owned DoF indices</a> that consist of contiguous ranges for each process. This is also true for the default ordering of DoFs on such triangulations, but the default ordering creates an enumeration that also depends on how many processors participate in the mesh, whereas the one generated by this function enumerates the degrees of freedom on a particular cell with indices that will be the same regardless of how many processes the mesh is split up between.</li>
</ul>
<p>For meshes based on <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>, the situation is more complex. Here, the set of locally owned cells is determined by a partitioning algorithm (selected by passing an object of type <a class="el" href="classparallel_1_1shared_1_1Triangulation.html#a686a3453dfec098eb64d1510aa1716e1">parallel::shared::Triangulation::Settings</a> to the constructor of the triangulation), and in general these partitioning algorithms may assign cells to <a class="el" href="DEALGlossary.html#GlossSubdomainId">subdomains</a> based on decisions that may have nothing to do with the Z order. (Though it is possible to select these flags in a way so that partitioning uses the Z order.) As a consequence, the cells of one subdomain are not contiguous in Z order, and if one renumbered degrees of freedom based on the Z order of cells, one would generally end up with DoF indices that on each processor do not form a contiguous range. This is often inconvenient (for example, because PETSc cannot store vectors and matrices for which the locally owned set of indices is not contiguous), and consequently this function uses the following algorithm for <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> objects:</p><ul>
<li>It determines how many degrees of freedom each processor owns. This is an invariant under renumbering, and consequently we can use how many DoFs each processor owns at the beginning of the current function. Let us call this number \(n_P\) for processor \(P\).</li>
<li>It determines for each processor a contiguous range of new DoF indices \([b_P,e_P)\) so that \(e_P-b_P=n_P\), \(b_0=0\), and \(b_P=e_{P-1}\).</li>
<li>It traverses the <em>locally owned cells</em> in Z order and renumbers the locally owned degrees of freedom on these cells so that the new numbers fit within the interval \([b_P,e_P)\). In other words, the <em>locally owned degrees of freedom</em> on each processor are sorted according to the Z order of the locally owned cells they are on, but this property may not hold globally, across cells. This is because the partitioning algorithm may have decided that, for example, processor 0 owns a cell that comes <em>later</em> in Z order than one of the cells assigned to processor 1. On the other hand, the algorithm described above assigns the degrees of freedom on this cell <em>earlier</em> indices than all of the indices owned by processor 1.</li>
</ul>
<dl class="section note"><dt>Note</dt><dd>This function generates an ordering that is independent of the previous numbering of degrees of freedom. In other words, any information that may have been produced by a previous call to a renumbering function is ignored. </dd></dl>

</div>
</div>
<a id="ae2cf3d3b9898ad1549e54e675f2a0368"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2cf3d3b9898ad1549e54e675f2a0368">&#9670;&nbsp;</a></span>cell_wise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::cell_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber degrees of freedom by cell. The function takes a vector of cell iterators (which needs to list <em>all</em> locally owned active cells of the DoF handler objects) and will give degrees of freedom new indices based on where in the given list of cells the cell is on which the degree of freedom is located. Degrees of freedom that exist at the interface between two or more cells will be numbered when they are encountered first.</p>
<p>Degrees of freedom that are encountered first on the same cell retain their original ordering before the renumbering step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose degrees of freedom are to be renumbered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_order</td><td>A vector that contains the order of the cells that defines the order in which degrees of freedom should be renumbered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>for serial triangulation <code>cell_order</code> must have size <code>dof_handler.get_triangulation().n_active_cells()</code>, whereas in case of parallel triangulation its size should be <a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">parallel::TriangulationBase::n_locally_owned_active_cells()</a>. Every active cell iterator of that triangulation needs to be present in <code>cell_order</code> exactly once. </dd></dl>

</div>
</div>
<a id="a8a54863943d7a88d72b902ecb9acb878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a54863943d7a88d72b902ecb9acb878">&#9670;&nbsp;</a></span>compute_cell_wise() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_cell_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a renumbering of degrees of freedom by cell. The function takes a vector of cell iterators (which needs to list <em>all</em> locally owned active cells of the DoF handler objects) and will give degrees of freedom new indices based on where in the given list of cells the cell is on which the degree of freedom is located. Degrees of freedom that exist at the interface between two or more cells will be numbered when they are encountered first.</p>
<p>Degrees of freedom that are encountered first on the same cell retain their original ordering before the renumbering step.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">renumbering</td><td>A vector of length <code>dof_handler.n_locally_owned_dofs()</code> that contains for each degree of freedom (in their current numbering) their future DoF index. This vector therefore presents a (very particular) <em>permutation</em> of the current DoF indices. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">inverse_renumbering</td><td>The reverse of the permutation returned in the previous argument. In case of <a class="el" href="classparallel_1_1TriangulationBase.html">parallel::TriangulationBase</a> the inverse is within locally owned DoFs. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>The <a class="el" href="classDoFHandler.html">DoFHandler</a> whose degrees of freedom are to be renumbered. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">cell_order</td><td>A vector that contains the order of the cells that defines the order in which degrees of freedom should be renumbered.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>for serial triangulation <code>cell_order</code> must have size <code>dof_handler.get_triangulation().n_active_cells()</code>, whereas in case of parallel triangulation its size should be <a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">parallel::TriangulationBase::n_locally_owned_active_cells()</a>. Every active cell iterator of that triangulation needs to be present in <code>cell_order</code> exactly once. </dd></dl>
<dl class="section post"><dt>Postcondition</dt><dd>For each <code>i</code> between zero and <code>dof_handler.n_locally_owned_dofs()</code>, the condition <code>renumbering[inverse_renumbering[i]] == dof_handler.locally_owned_dofs().nth_index_in_set(i)</code> will hold. </dd></dl>

</div>
</div>
<a id="ab496b6f78c564f105ae1ffb3795bff0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab496b6f78c564f105ae1ffb3795bff0d">&#9670;&nbsp;</a></span>cell_wise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::cell_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::level_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the other <a class="el" href="namespaceDoFRenumbering.html#ae2cf3d3b9898ad1549e54e675f2a0368">cell_wise()</a> function, but for one level of a multilevel enumeration of degrees of freedom. </p>

</div>
</div>
<a id="abba88de0b297f531636c58ba11ec002e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba88de0b297f531636c58ba11ec002e">&#9670;&nbsp;</a></span>compute_cell_wise() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_cell_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::level_cell_iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the other <a class="el" href="namespaceDoFRenumbering.html#a8a54863943d7a88d72b902ecb9acb878">compute_cell_wise()</a> function, but for one level of a multilevel enumeration of degrees of freedom. </p>

</div>
</div>
<a id="a59c1a183ef6288e6bb061eb738b84380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c1a183ef6288e6bb061eb738b84380">&#9670;&nbsp;</a></span>downstream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Downstream numbering with respect to a constant flow direction. If the additional argument <code>dof_wise_renumbering</code> is set to <code>false</code>, the numbering is performed cell-wise, otherwise it is performed based on the location of the support points.</p>
<p>The cells are sorted such that the centers of cells numbered higher are further downstream with respect to the constant vector <code>direction</code> than the centers of cells numbered lower. Even if this yields a downstream numbering with respect to the flux on the edges for fairly general grids, this might not be guaranteed for all meshes.</p>
<p>If the <code>dof_wise_renumbering</code> argument is set to <code>false</code>, this function produces a downstream ordering of the mesh cells and calls <a class="el" href="namespaceDoFRenumbering.html#ae2cf3d3b9898ad1549e54e675f2a0368">cell_wise()</a>. Therefore, the output only makes sense for Discontinuous Galerkin Finite Elements (all degrees of freedom have to be associated with the interior of the cell in that case) in that case.</p>
<p>If <code>dof_wise_renumbering</code> is set to <code>true</code>, the degrees of freedom are renumbered based on the support point location of the individual degrees of freedom (obviously, the finite element needs to define support points for this to work). The numbering of points with the same position in downstream location (e.g. those parallel to the flow direction, or several dofs within a <a class="el" href="classFESystem.html">FESystem</a>) will be unaffected. </p>

</div>
</div>
<a id="a5175d4f7fb7256d3f5e21dcc3d722cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5175d4f7fb7256d3f5e21dcc3d722cb4">&#9670;&nbsp;</a></span>downstream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::downstream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise downstream numbering with respect to a constant flow direction on one level of a multigrid hierarchy. See the other function with the same name. </p>

</div>
</div>
<a id="ade2b93380cd0b30720d0f717014de53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2b93380cd0b30720d0f717014de53a">&#9670;&nbsp;</a></span>compute_downstream() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_downstream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the set of renumbering indices needed by the <a class="el" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a id="a43f0ded43e49e9c4f9f3baf8dfa5b8c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f0ded43e49e9c4f9f3baf8dfa5b8c4">&#9670;&nbsp;</a></span>compute_downstream() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_downstream </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>dof_wise_renumbering</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the set of renumbering indices needed by the <a class="el" href="namespaceDoFRenumbering.html#a59c1a183ef6288e6bb061eb738b84380">downstream()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a id="a9ce6d387bdabdc5d76ab4b20bfaf0e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce6d387bdabdc5d76ab4b20bfaf0e8a">&#9670;&nbsp;</a></span>clockwise_dg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::clockwise_dg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>counter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise clockwise numbering.</p>
<p>This function produces a (counter)clockwise ordering of the mesh cells with respect to the hub <code>center</code> and calls <a class="el" href="namespaceDoFRenumbering.html#ae2cf3d3b9898ad1549e54e675f2a0368">cell_wise()</a>. Therefore, it only works with Discontinuous Galerkin Finite Elements, i.e. all degrees of freedom have to be associated with the interior of the cell. </p>

</div>
</div>
<a id="a7f0e7ccfd629f1adbf166ed8462812e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f0e7ccfd629f1adbf166ed8462812e6">&#9670;&nbsp;</a></span>clockwise_dg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::clockwise_dg </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>counter</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cell-wise clockwise numbering on one level of a multigrid hierarchy. See the other function with the same name. </p>

</div>
</div>
<a id="afcbf634039e5423bcfbb7d681893d4a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcbf634039e5423bcfbb7d681893d4a1">&#9670;&nbsp;</a></span>compute_clockwise_dg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_clockwise_dg </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>center</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>counter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a9ce6d387bdabdc5d76ab4b20bfaf0e8a">clockwise_dg()</a> functions. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a id="a7879b1de6248876edccd07c9b37d84c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7879b1de6248876edccd07c9b37d84c8">&#9670;&nbsp;</a></span>sort_selected_dofs_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort those degrees of freedom which are tagged with <code>true</code> in the <code>selected_dofs</code> array to the back of the DoF numbers. The sorting is stable, i.e. the relative order within the tagged degrees of freedom is preserved, as is the relative order within the untagged ones.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom. </dd></dl>

</div>
</div>
<a id="a443837e68de5c74cd84475034852aa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a443837e68de5c74cd84475034852aa2b">&#9670;&nbsp;</a></span>sort_selected_dofs_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort those degrees of freedom which are tagged with <code>true</code> in the <code>selected_dofs</code> array on the level <code>level</code> to the back of the DoF numbers. The sorting is stable, i.e. the relative order within the tagged degrees of freedom is preserved, as is the relative order within the untagged ones.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom on the given level. </dd></dl>

</div>
</div>
<a id="a75f87d18ed80be13c45de0d788b1c23c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f87d18ed80be13c45de0d788b1c23c">&#9670;&nbsp;</a></span>compute_sort_selected_dofs_back() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a7879b1de6248876edccd07c9b37d84c8">sort_selected_dofs_back()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom. </dd></dl>

</div>
</div>
<a id="ae4f7cfab2fb42abd2688222e5f22f168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4f7cfab2fb42abd2688222e5f22f168">&#9670;&nbsp;</a></span>compute_sort_selected_dofs_back() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_sort_selected_dofs_back </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>selected_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function computes the renumbering vector on each level needed by the <a class="el" href="namespaceDoFRenumbering.html#a7879b1de6248876edccd07c9b37d84c8">sort_selected_dofs_back()</a> function. Does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but only computes the renumbering and returns the renumbering vector.</p>
<dl class="section pre"><dt>Precondition</dt><dd>The <code>selected_dofs</code> array must have as many elements as the <code>dof_handler</code> has degrees of freedom on the given level. </dd></dl>

</div>
</div>
<a id="abbd608826acd7c01f91db401a3728e25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abbd608826acd7c01f91db401a3728e25">&#9670;&nbsp;</a></span>random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom in a random way. The result of this function is repeatable in that two runs of the same program will yield the same result. This is achieved by creating a new random number generator with a fixed seed every time this function is entered. In particular, the function therefore does not rely on an external random number generator for which it would matter how often it has been called before this function (or, for that matter, whether other threads running concurrently to this function also draw random numbers). </p>

</div>
</div>
<a id="a3a78965e22bac673e147b79483b37418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a78965e22bac673e147b79483b37418">&#9670;&nbsp;</a></span>random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::random </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom in a random way. It does the same thing as the above function, only that it does this for one single level of a multilevel discretization. The non-multigrid part of the <a class="el" href="classDoFHandler.html">DoFHandler</a> is not touched. </p>

</div>
</div>
<a id="a50a045f2a1b63ecb6fdc95e037e278cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50a045f2a1b63ecb6fdc95e037e278cb">&#9670;&nbsp;</a></span>compute_random() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_random </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random()</a> function. See there for more information on the computed random renumbering.</p>
<p>This function does not perform the renumbering on the <a class="el" href="classDoFHandler.html">DoFHandler</a> dofs but returns the renumbering vector. </p>

</div>
</div>
<a id="a126f17ce3959e408e25dfacaef517273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a126f17ce3959e408e25dfacaef517273">&#9670;&nbsp;</a></span>compute_random() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_random </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#abbd608826acd7c01f91db401a3728e25">random()</a> function. Same as the above function but for a single level of a multilevel discretization. </p>

</div>
</div>
<a id="a166d0082503ec2b8d9c560222b48f9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a166d0082503ec2b8d9c560222b48f9d2">&#9670;&nbsp;</a></span>subdomain_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::subdomain_wise </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Renumber the degrees of freedom such that they are associated with the subdomain id of the cells they are living on, i.e. first all degrees of freedom that belong to cells with subdomain zero, then all with subdomain one, etc. This is useful when doing parallel computations with a standard <a class="el" href="classTriangulation.html">Triangulation</a> after assigning subdomain ids using a partitioner (see the <a class="el" href="namespaceGridTools.html#a99eba8e3b388258eda37a2724579dd1d">GridTools::partition_triangulation</a> function for this). Calling this function is unnecessary when using a <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a> or <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, as the degrees of freedom are already enumerated according to the MPI process id. Therefore, if the underlying triangulation is of this type then an error will be thrown.</p>
<p>Note that degrees of freedom associated with faces, edges, and vertices may be associated with multiple subdomains if they are sitting on partition boundaries. It would therefore be undefined with which subdomain they have to be associated. For this, we use what we get from the <a class="el" href="namespaceDoFTools.html#a0429b3117b2ab1f5a1fd0d55de26ad81">DoFTools::get_subdomain_association</a> function.</p>
<p>The algorithm is stable, i.e. if two dofs i,j have <code>i&lt;j</code> and belong to the same subdomain, then they will be in this order also after reordering. </p>

</div>
</div>
<a id="a07eb2394e83abb813590338409650103"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07eb2394e83abb813590338409650103">&#9670;&nbsp;</a></span>compute_subdomain_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void DoFRenumbering::compute_subdomain_wise </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the renumbering vector needed by the <a class="el" href="namespaceDoFRenumbering.html#a166d0082503ec2b8d9c560222b48f9d2">subdomain_wise()</a> function. Does not perform the renumbering on the <code><a class="el" href="classDoFHandler.html">DoFHandler</a></code> dofs but returns the renumbering vector. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
