<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespacehp_1_1Refinement.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: hp::Refinement Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehp.html">hp</a></li><li class="navelem"><a class="el" href="namespacehp_1_1Refinement.html">Refinement</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">hp::Refinement Namespace Reference<div class="ingroups"><a class="el" href="group__hp.html">hp finite element support</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad0ca178ceaa3fbd70627d23d2adabeeb"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ad0ca178ceaa3fbd70627d23d2adabeeb"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a> = std::function&lt; <a class="el" href="classbool.html">bool</a>(const Number &amp;, const Number &amp;)&gt;</td></tr>
<tr class="separator:ad0ca178ceaa3fbd70627d23d2adabeeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Setting p-adaptivity flags</div></td></tr>
<tr class="memitem:a7fc52cae14b805ecd78d329dbdd03986"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7fc52cae14b805ecd78d329dbdd03986"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a7fc52cae14b805ecd78d329dbdd03986">full_p_adaptivity</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a7fc52cae14b805ecd78d329dbdd03986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b763dabdf5f7740a73b0dcc6d3f721d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4b763dabdf5f7740a73b0dcc6d3f721d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a4b763dabdf5f7740a73b0dcc6d3f721d">p_adaptivity_from_flags</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;p_flags)</td></tr>
<tr class="separator:a4b763dabdf5f7740a73b0dcc6d3f721d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95de4d68d350f8ea7555441c299d0ea5"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a95de4d68d350f8ea7555441c299d0ea5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a95de4d68d350f8ea7555441c299d0ea5">p_adaptivity_from_absolute_threshold</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const Number p_refine_threshold, const Number p_coarsen_threshold, const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_refine=std::greater_equal&lt; Number &gt;(), const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_coarsen=std::less_equal&lt; Number &gt;())</td></tr>
<tr class="separator:a95de4d68d350f8ea7555441c299d0ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54156dbe64e8eda42b2e964c9b1c0963"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a54156dbe64e8eda42b2e964c9b1c0963"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">p_adaptivity_from_relative_threshold</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> p_refine_fraction=0.5, const <a class="el" href="classdouble.html">double</a> p_coarsen_fraction=0.5, const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_refine=std::greater_equal&lt; Number &gt;(), const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_coarsen=std::less_equal&lt; Number &gt;())</td></tr>
<tr class="separator:a54156dbe64e8eda42b2e964c9b1c0963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6066e056301dd2b9f6c31191c47c7b16"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a6066e056301dd2b9f6c31191c47c7b16"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a6066e056301dd2b9f6c31191c47c7b16">p_adaptivity_fixed_number</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classdouble.html">double</a> p_refine_fraction=0.5, const <a class="el" href="classdouble.html">double</a> p_coarsen_fraction=0.5, const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_refine=std::greater_equal&lt; Number &gt;(), const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_coarsen=std::less_equal&lt; Number &gt;())</td></tr>
<tr class="separator:a6066e056301dd2b9f6c31191c47c7b16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff154ed2b5f28b7eeaf81494d6071b59"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:aff154ed2b5f28b7eeaf81494d6071b59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#aff154ed2b5f28b7eeaf81494d6071b59">p_adaptivity_from_regularity</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;sobolev_indices)</td></tr>
<tr class="separator:aff154ed2b5f28b7eeaf81494d6071b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ca8f3c6d6ef49918329fc7d45d9f7db"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a1ca8f3c6d6ef49918329fc7d45d9f7db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">p_adaptivity_from_reference</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;criteria, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;references, const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_refine, const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;compare_coarsen)</td></tr>
<tr class="separator:a1ca8f3c6d6ef49918329fc7d45d9f7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Error prediction</div></td></tr>
<tr class="memitem:a9c96d6a85b38f120b5d7cf68126cded9"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , int spacedim&gt; </td></tr>
<tr class="memitem:a9c96d6a85b38f120b5d7cf68126cded9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">predict_error</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;error_indicators, <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;predicted_errors, const <a class="el" href="classdouble.html">double</a> gamma_p=std::sqrt(0.4), const <a class="el" href="classdouble.html">double</a> gamma_h=2., const <a class="el" href="classdouble.html">double</a> gamma_n=1.)</td></tr>
<tr class="separator:a9c96d6a85b38f120b5d7cf68126cded9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Decide between h- and p-adaptivity</div></td></tr>
<tr class="memitem:a7dcdcc921a66bb023b4d1ed7c648137c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7dcdcc921a66bb023b4d1ed7c648137c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a7dcdcc921a66bb023b4d1ed7c648137c">force_p_over_h</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a7dcdcc921a66bb023b4d1ed7c648137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4890d9eae896d749b103c8eec9c2029d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4890d9eae896d749b103c8eec9c2029d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a4890d9eae896d749b103c8eec9c2029d">choose_p_over_h</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler)</td></tr>
<tr class="separator:a4890d9eae896d749b103c8eec9c2029d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Optimiize p-level distribution</div></td></tr>
<tr class="memitem:a33d9d552f696d578da30dc9a83048670"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a33d9d552f696d578da30dc9a83048670"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">limit_p_level_difference</a> (const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const unsigned <a class="el" href="classint.html">int</a> max_difference=1, const unsigned <a class="el" href="classint.html">int</a> contains_fe_index=0)</td></tr>
<tr class="separator:a33d9d552f696d578da30dc9a83048670"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>We supply adaptive methods to align computational resources with the complexity of the numerical solution. Error estimates are an appropriate means of determining where adjustments need to be made.</p>
<p>However with hp-adaptivity, we have two ways to realize these adjustments: For irregular solutions, h-adaptive methods which dynamically assign cell sizes tend to reduce the approximation error, while for smooth solutions p-adaptive methods are better suited in which function spaces will be selected dynamically. This namespace collects tools to decide which type of adaptive methods to apply.</p>
<h3>Usage</h3>
<p>To successfully apply hp-adaptive methods, we recommend the following workflow: </p><ol>
<li>
<p class="startli">A suitable error estimate is the basis for any kind of adaptive method. Similar to pure grid refinement, we will determine error estimates in the usual way (i.e. <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>) and mark cells for refinement or coarsening (i.e. <a class="el" href="namespaceGridRefinement.html">GridRefinement</a>).</p>
<p>Calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> at this stage will perform pure grid refinement as expected.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Once all refinement and coarsening flags have been distributed on the mesh, we may determine if those qualify for p-adaptive methods. Corresponding functions will set <code>future_fe_indices</code> on top of the refinement and coarsening flags if they fulfil a certain criterion.</p>
<p>In case of refinement, the superordinate element of the underlying <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a> will be assigned as the future finite element. Correspondingly, the subordinate element will be selected for coarsening.</p>
<p><a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> will now supply both h- and p-adaptive methods independently.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Right now, there may be cells scheduled for both h- and p-adaptation. If we do not want to impose both methods at once, we need to decide which one to pick for each cell individually and unambiguously. Since grid refinement will be imposed by default and we only determine qualification for p-adaptivity on top, we will always decide in favour of p-adaptive methods.</p>
<p>Calling <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a> will now perform either h- or p-adaptive methods uniquely on each cell.</p>
<p class="endli"></p>
</li>
<li>
Up to this point, each cell knows its destiny in terms of adaptivity. We can now move on to prepare all data structures to be transferred across mesh changes. Previously set refinement and coarsening flags as well as <code>future_fe_indices</code> will be used to update the data accordingly. </li>
</ol>
<p>As an example, a realisation of pure p-adaptive methods would look like the following: </p><div class="fragment"><div class="line"><span class="comment">// step 1: flag cells for refinement or coarsening</span></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell (triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>(</div><div class="line">    hp_dof_handler,</div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim-1&gt;</a> (<a class="code" href="namespaceParticles_1_1Generators.html#aa1cd861e3aaf1770ddcddd956cdae5e4">quadrature_points</a>),</div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim, Number&gt;</a> *&gt;(),</div><div class="line">    solution,</div><div class="line">    estimated_error_per_cell);</div><div class="line"><a class="code" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction</a>(triangulation,</div><div class="line">                                                  estimated_error_per_cell,</div><div class="line">                                                  top_fraction,</div><div class="line">                                                  bottom_fraction);</div><div class="line"></div><div class="line"><span class="comment">// step 2: set future finite element indices on flagged cells</span></div><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a7fc52cae14b805ecd78d329dbdd03986">hp::Refinement::full_p_adaptivity</a>(hp_dof_handler);</div><div class="line"></div><div class="line"><span class="comment">// step 3: decide whether h- or p-adaptive methods will be supplied</span></div><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a7dcdcc921a66bb023b4d1ed7c648137c">hp::Refinement::force_p_over_h</a>(hp_dof_handler);</div><div class="line"></div><div class="line"><span class="comment">// step 4: prepare solutions to be transferred</span></div><div class="line">...</div><div class="line"></div><div class="line">triangulation.execute_coarsening_and_refinement();</div></div><!-- fragment --> </div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ad0ca178ceaa3fbd70627d23d2adabeeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0ca178ceaa3fbd70627d23d2adabeeb">&#9670;&nbsp;</a></span>ComparisonFunction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">hp::Refinement::ComparisonFunction</a> = typedef std::function&lt;<a class="el" href="classbool.html">bool</a>(const Number &amp;, const Number &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An alias that defines the characteristics of a function that can be used as a comparison criterion for deciding whether to perform h- or p-adaptation.</p>
<p>Such functions take two numbers as arguments: The first one corresponds to the provided criterion, while the other one conforms to the reference. The result of the comparison will be returned as a boolean. </p>

<p class="definition">Definition at line <a class="el" href="refinement_8h_source.html#l00139">139</a> of file <a class="el" href="refinement_8h_source.html">refinement.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a7fc52cae14b805ecd78d329dbdd03986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc52cae14b805ecd78d329dbdd03986">&#9670;&nbsp;</a></span>full_p_adaptivity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::full_p_adaptivity </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Each cell flagged for h-refinement will also be flagged for p-refinement. The same applies to coarsening.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a4b763dabdf5f7740a73b0dcc6d3f721d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b763dabdf5f7740a73b0dcc6d3f721d">&#9670;&nbsp;</a></span>p_adaptivity_from_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_flags </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells that have been specifically flagged for p-adaptation via the parameter <code>p_flags</code>. Future finite elements will only be assigned if cells have been flagged for refinement and coarsening beforehand.</p>
<p>Each entry of the parameter <code>p_flags</code> needs to correspond to an active cell.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a95de4d68d350f8ea7555441c299d0ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95de4d68d350f8ea7555441c299d0ea5">&#9670;&nbsp;</a></span>p_adaptivity_from_absolute_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_absolute_threshold </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>p_refine_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>p_coarsen_threshold</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em> = <code>std::greater_equal&lt;&#160;Number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em> = <code>std::less_equal&lt;&#160;Number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells whose criteria meet a certain absolute threshold.</p>
<p>For p-refinement and p-coarsening, two separate thresholds need to provided via parameters <code>p_refine_threshold</code> and <code>p_coarsen_threshold</code>.</p>
<p>We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding threshold. Let us be more specific on the default case: We consider a cell for p-refinement if it is flagged for refinement and its criterion is larger than or equal to the corresponding threshold. The same applies for p-coarsening, but the cell's criterion must be lower than or equal to the threshold. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies.</p>
<p>Each entry of the parameter <code>criteria</code> needs to correspond to an active cell.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a54156dbe64e8eda42b2e964c9b1c0963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54156dbe64e8eda42b2e964c9b1c0963">&#9670;&nbsp;</a></span>p_adaptivity_from_relative_threshold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_relative_threshold </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>p_refine_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>p_coarsen_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em> = <code>std::greater_equal&lt;&#160;Number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em> = <code>std::less_equal&lt;&#160;Number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells whose criteria meet a certain threshold relative to the overall range of criterion values.</p>
<p>The threshold will be determined for refined and coarsened cells separately based on the currently set refinement markers. For each class of cells, we determine the maximal and minimal values of all criteria and determine the threshold by linear interpolation between these limits. Parameters <code>p_refine_fraction</code> and <code>p_refine_coarsen</code> are used as interpolation factors, where <code>0</code> corresponds to the minimal and <code>1</code> to the maximal value. By default, mean values are considered as thresholds.</p>
<p>We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding threshold. Let us be more specific on the default case: We consider a cell for p-refinement if it is flagged for refinement and its criterion is larger than or equal to the corresponding threshold. The same applies for p-coarsening, but the cell's criterion must be lower than or equal to the threshold. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies.</p>
<p>Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. Parameters <code>p_refine_fraction</code> and <code>p_coarsen_fraction</code> need to be in the interval \([0,1]\).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a6066e056301dd2b9f6c31191c47c7b16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6066e056301dd2b9f6c31191c47c7b16">&#9670;&nbsp;</a></span>p_adaptivity_fixed_number()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_fixed_number </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>p_refine_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>p_coarsen_fraction</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em> = <code>std::greater_equal&lt;&#160;Number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em> = <code>std::less_equal&lt;&#160;Number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on a given fraction of cells.</p>
<p>Out of all cells flagged for a certain type of adaptation, be it refinement or coarsening, we will determine a fixed number of cells among this subset that will be flagged for the corresponding p-adaptive variant.</p>
<p>For each of both refinement and coarsening subsets, we will determine a threshold based on the provided parameter <code>criteria</code> containing indicators for every active cell. In the default case for refinement, all cells with an indicator larger than or equal to the corresponding threshold will be considered for p-refinement, while for coarsening all cells with an indicator less than or equal to the matching threshold are taken into account. However, different compare function objects can be supplied via the parameters <code>compare_refine</code> and <code>compare_coarsen</code> to impose different decision strategies.</p>
<p>For refinement, the threshold will be associated with the cell that has the <code>p_refine_fraction</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> largest indicator, while it is the cell with the <code>p_refine_coarsen</code> times <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a> lowest indicator for coarsening.</p>
<p>Each entry of the parameter <code>criteria</code> needs to correspond to an active cell. Parameters <code>p_refine_fraction</code> and <code>p_coarsen_fraction</code> need to be in the interval \([0,1]\).</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="aff154ed2b5f28b7eeaf81494d6071b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff154ed2b5f28b7eeaf81494d6071b59">&#9670;&nbsp;</a></span>p_adaptivity_from_regularity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_regularity </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>sobolev_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on cells based on the regularity of the (unknown) analytical solution.</p>
<p>With an approximation of the local Sobolev regularity index \(k_K\), we may assess to which finite element space our local solution on cell \(K\) belongs. Since the regularity index is only an estimate, we won't use it to assign the finite element space directly, but rather consider it as an indicator for adaptation. If a cell is flagged for refinement, we will perform p-refinement once it satisfies \(k_K &gt; p_{K,\text{super}}\), where \(p_{K,\text{super}}\) is the polynomial degree of the finite element superordinate to the currently active element on cell \(K\). In case of coarsening, the criterion \(k_K &lt; p_{K,\text{sub}}\) has to be met, with \(p_{K,\text{sub}}\) the degree of the subordinate element.</p>
<p>Each entry of the parameter <code>sobolev_indices</code> needs to correspond to an active cell.</p>
<p>For more theoretical details see <b>[ainsworth1998hp]</b> .</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a1ca8f3c6d6ef49918329fc7d45d9f7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ca8f3c6d6ef49918329fc7d45d9f7db">&#9670;&nbsp;</a></span>p_adaptivity_from_reference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::p_adaptivity_from_reference </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>criteria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_refine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehp_1_1Refinement.html#ad0ca178ceaa3fbd70627d23d2adabeeb">ComparisonFunction</a>&lt; typename <a class="el" href="structidentity.html">identity</a>&lt; Number &gt;::type &gt; &amp;&#160;</td>
          <td class="paramname"><em>compare_coarsen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adapt which finite element to use on each cell based on how its criterion relates to a reference.</p>
<p>We consider a cell for p-adaptivity if it is currently flagged for refinement or coarsening and its criterion successfully compares to the corresponding reference. Other than functions <a class="el" href="namespacehp_1_1Refinement.html#a95de4d68d350f8ea7555441c299d0ea5">p_adaptivity_from_absolute_threshold()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a54156dbe64e8eda42b2e964c9b1c0963">p_adaptivity_from_relative_threshold()</a>, compare function objects have to be provided explicitly via the parameters <code>compare_refine</code> and <code>compare_coarsen</code>.</p>
<p>Each entry of the parameters <code>criteria</code> and <code>references</code> needs to correspond to an active cell.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a9c96d6a85b38f120b5d7cf68126cded9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c96d6a85b38f120b5d7cf68126cded9">&#9670;&nbsp;</a></span>predict_error()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::predict_error </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>error_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>predicted_errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>gamma_p</em> = <code>std::sqrt(0.4)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>gamma_h</em> = <code>2.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>gamma_n</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Predict how the current <code>error_indicators</code> will adapt after refinement and coarsening were to happen on the provided <code>dof_handler</code>, and write its results to <code>predicted_errors</code>. Each entry of <code>error_indicators</code> and <code>predicted_errors</code> corresponds to an active cell on the underlying <a class="el" href="classTriangulation.html">Triangulation</a>, thus each container has to be of size <a class="el" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">Triangulation::n_active_cells()</a>. The errors are interpreted to be measured in the energy norm; this assumption enters the rate of convergence that is used in the prediction. The \(l_2\)-norm of the output argument <code>predicted_errors</code> corresponds to the predicted global error after adaptation.</p>
<p>For p-adaptation, the local error is expected to converge exponentially with the polynomial degree of the assigned finite element. Each increase or decrease of the degree will thus change its value by a user-defined control parameter <code>gamma_p</code>.</p>
<p>For h-adaptation, we expect the local error \(\eta_K\) on cell \(K\) to be proportional to \((h_K)^{p_K}\) in the energy norm, where \(h_K\) denotes the cell diameter and \(p_K\) the polynomial degree of the currently assigned finite element on cell \(K\).</p>
<p>During h-coarsening, the finite elements on siblings may be different, and their parent cell will be assigned to their least dominating finite element that belongs to its most general child. Thus, we will always interpolate on an enclosing finite element space. Additionally assuming that the finite elements on the cells to be coarsened are sufficient to represent the solution correctly (e.g. at least quadratic basis functions for a quadratic solution), we are confident to say that the error will not change by sole interpolation on the larger finite element space.</p>
<p>For p-adaptation, the local error is expected to converge exponentially with the polynomial degree of the assigned finite element. Each increase or decrease of the degree will thus change its value by a user-defined control parameter <code>gamma_p</code>. The assumption of exponential convergence is only valid if both h- and p-adaptive methods are combined in a sense that they are both utilitzed throughout a mesh, but do not have to be applied both on a cell simultaneously.</p>
<p>The prediction algorithm is formulated as follows with control parameters <code>gamma_p</code>, <code>gamma_h</code> and <code>gamma_n</code> that may be used to influence prediction for each adaptation type individually. The results for each individual cell are stored in the <code>predicted_errors</code> output argument. </p><table class="doxtable">
<tr>
<th>Adaptation type </th><th colspan="2">Prediction formula </th></tr>
<tr>
<td>no adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{n}\) </td><td>\(\gamma_\text{n} \in (0,\infty)\) </td></tr>
<tr>
<td>p-adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_K)}\) </td><td>\(\gamma_\text{p} \in (0,1)\) </td></tr>
<tr>
<td>hp-refinement </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{h} \, 0.5^{p_{K,\text{future}}} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_{K})}\) </td><td rowspan="2">\(\gamma_\text{h} \in (0,\infty)\) </td></tr>
<tr>
<td>hp-coarsening </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, (\gamma_\text{h} \, 0.5^{p_{K,\text{future}}})^{-1} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_{K})}\) </td></tr>
</table>
<p>On basis of the refinement history, we use the predicted error estimates to decide how cells will be adapted in the next adaptation step. Comparing the predicted error from the previous adaptation step to the error estimates of the current step allows us to justify whether our previous choice of adaptation was justified, and lets us decide how to adapt in the next one.</p>
<p>We thus have to transfer the predicted error from the old to the adapted mesh. When transferring the predicted error to the adapted mesh, make sure to configure your <a class="el" href="classCellDataTransfer.html">CellDataTransfer</a> object with <a class="el" href="namespaceAdaptationStrategies_1_1Refinement.html#a629b528b2c9777d26eb9048d50d6c13a">AdaptationStrategies::Refinement::l2_norm()</a> as a refinement strategy and <a class="el" href="namespaceAdaptationStrategies_1_1Coarsening.html#ac3b7ed64dc5873912710963c3e879563">AdaptationStrategies::Coarsening::l2_norm()</a> as a coarsening strategy. This ensures that the \(l_2\)-norm of the predict errors is preserved on both meshes.</p>
<p>In this context, we assume that the local error on a cell to be h-refined will be divided equally on all of its \(n_{K_c}\) children, whereas local errors on siblings will be summed up on the parent cell in case of h-coarsening. This assumption is often not satisfied in practice: For example, if a cell is at a corner singularity, then the one child cell that ends up closest to the singularity will inherit the majority of the remaining error &ndash; but this function can not know where the singularity will be, and consequently assumes equal distribution.</p>
<p>Incorporating the transfer from the old to the adapted mesh, the complete error prediction algorithm reads as follows: </p><table class="doxtable">
<tr>
<th>Adaptation type </th><th colspan="2">Prediction formula </th></tr>
<tr>
<td>no adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{n}\) </td><td>\(\gamma_\text{n} \in (0,\infty)\) </td></tr>
<tr>
<td>p-adaptation </td><td>\(\eta_{K,\text{pred}} = \eta_{K} \, \gamma_\text{p}^{(p_{K,\text{future}} - p_K)}\) </td><td>\(\gamma_\text{p} \in (0,1)\) </td></tr>
<tr>
<td>hp-refinement </td><td>\(\left( \eta_{K_c,\text{pred}} \right)^2 = n_{K_c}^{-1} \left( \eta_{K_p} \, \gamma_\text{h} \, 0.5^{p_{K_c,\text{future}}} \, \gamma_\text{p}^{(p_{K_c,\text{future}} - p_{K_p})} \right)^2 \quad \forall K_c \text{ children of } K_p\) </td><td rowspan="2">\(\gamma_\text{h} \in (0,\infty)\) </td></tr>
<tr>
<td>hp-coarsening </td><td>\(\left( \eta_{K_p,\text{pred}} \right)^2 = \sum\limits_{K_c} \left( \eta_{K_c} \, (\gamma_\text{h} \, 0.5^{p_{K_p,\text{future}}})^{-1} \, \gamma_\text{p}^{(p_{K_p,\text{future}} - p_{K_c})} \right)^2 \quad \forall K_c \text{ children of } K_p\) </td></tr>
</table>
<p>With these predicted error estimates, we are capable of adapting the finite element on cells based on their refinement history or rather the predicted change of their error estimates.</p>
<p>If a cell is flagged for adaptation, we want to perform p-adaptation once the associated error indicators \(\eta_{K}\) on cell \(K\) satisfy \(\eta_{K} &lt; \eta_{K,\text{pred}}\), where the subscript \(\text{pred}\) denotes the predicted error. This corresponds to our assumption of smoothness being correct, else h-adaptation is applied. We achieve this with the function <a class="el" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference()</a> and a function object <code>std::less&lt;Number&gt;()</code> for both comparator parameters.</p>
<p>Also with an alternative strategy, we can determine the fractions of cells to be h- and p-adapted among all cells to be adapted. For this, use <a class="el" href="namespacehp_1_1Refinement.html#a6066e056301dd2b9f6c31191c47c7b16">hp::Refinement::p_adaptivity_fixed_number()</a> with criteria \((\eta_{K,\text{pred}} - \eta_{K})\).</p>
<p>For the very first adaptation step in either case, the user needs to decide whether h- or p-adaptation is supposed to happen. An h-step will be applied with \(\eta_{K,\text{pred}} = 0\), whereas \(\eta_{K,\text{pred}} = \infty\) ensures a p-step. The latter may be realized with <code>std::numeric_limits::infinity()</code>.</p>
<p>The following code snippet demonstrates how to impose hp-adaptivity based on refinement history in an application: </p><div class="fragment"><div class="line"><span class="comment">// [initialisation...]</span></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> predicted_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><span class="keywordflow">for</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>(); ++i)</div><div class="line">  predicted_error_per_cell[i] = std::numeric_limits&lt;float&gt;::infinity();</div><div class="line"></div><div class="line"><span class="comment">// [during each refinement step...]</span></div><div class="line"><span class="comment">// set h-adaptivity flags</span></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line"><a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator::estimate</a>(...);</div><div class="line">GridRefinemet::refine_and_coarsen_fixed_{number|fraction}(...);</div><div class="line"></div><div class="line"><span class="comment">// set p-adaptivity flags</span></div><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a1ca8f3c6d6ef49918329fc7d45d9f7db">hp::Refinement::p_adaptivity_from_reference</a>(</div><div class="line">  hp_dof_handler,</div><div class="line">  estimated_error_per_cell,</div><div class="line">  predicted_error_per_cell,</div><div class="line">  std::less&lt;float&gt;(),</div><div class="line">  std::less&lt;float&gt;());</div><div class="line"><a class="code" href="namespacehp_1_1Refinement.html">hp::Refinement</a>::{choose|force}_p_over_h(hp_dof_handler);</div><div class="line"></div><div class="line"><span class="comment">// predict error for the subsequent adaptation</span></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">prepare_coarsening_and_refinement</a>();</div><div class="line"><a class="code" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a>(</div><div class="line">  hp_dof_handler,</div><div class="line">  estimated_error_per_cell,</div><div class="line">  predicted_error_per_cell);</div><div class="line"></div><div class="line"><span class="comment">// perform adaptation</span></div><div class="line"><a class="code" href="classCellDataTransfer.html">CellDataTransfer&lt;dim, spacedim, Vector&lt;float&gt;</a>&gt; cell_data_transfer(</div><div class="line">  triangulation,</div><div class="line">  <span class="keyword">false</span>,</div><div class="line">  &amp;AdaptationStrategies::Refinement::l2_norm&lt;dim, spacedim, float&gt;,</div><div class="line">  &amp;AdaptationStrategies::Coarsening::l2_norm&lt;dim, spacedim, float&gt;);</div><div class="line">cell_data_transfer.prepare_coarsening_and_refinement();</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">execute_coarsening_and_refinement</a>();</div><div class="line"></div><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> transferred_errors(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">cell_data_transfer.unpack(predicted_error_per_cell, transferred_errors);</div><div class="line">predicted_error_per_cell = <a class="code" href="namespacemystl.html#a663604ca23ed4b96db3d1a6e301615db">std::move</a>(transferred_errors);</div></div><!-- fragment --><p>For more theoretical details see <b>[melenk2001hp]</b> , where the default parameters for this function come from as well, i.e. \(\gamma_\text{p}^2 = 0.4\), \(\gamma_\text{h}^2 = 4\), \(\gamma_\text{n}^2 = 1\).</p>
<p>If you are working with <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, you need to pay special attention. Here, p4est determines the details of grid refinement, and consequently, it yields more reliable and trustworthy results when we determine the predicted errors during the adaptation process. We can do exactly this by attaching this function to the signal <a class="el" href="structTriangulation_1_1Signals.html#ad9274f81b24503b3cbe081a74d572f80">Triangulation::Signals::post_p4est_refinement</a>, which is triggered after p4est got refined, but before data is prepared for transfer. <a class="el" href="namespacehp_1_1Refinement.html">Refinement</a> and coarsening flags of the <a class="el" href="classTriangulation.html">Triangulation</a> object need to be matched with the already refined p4est oracle using internal::parallel::distributed::TemporarilyMatchRefineFlags. Thus, a construct like the following is necessary to correctly predict errors in parallel distributed applications. </p><div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;float&gt;</a> predicted_errors;</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#ad136f601f63a6d1bd8e205edd93cbae3">signals</a>.post_p4est_refinement.connect([&amp;]() {</div><div class="line">  <span class="keyword">const</span> <a class="code" href="classparallel_1_1distributed_1_1TemporarilyMatchRefineFlags.html">parallel::distributed::TemporarilyMatchRefineFlags&lt;dim&gt;</a></div><div class="line">    refine_modifier(triangulation);</div><div class="line">  predicted_errors.<a class="code" href="classVector.html#ac4a4dbef7dd65ef8ad35ae56b57d7c05">reinit</a>(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>());</div><div class="line">  <a class="code" href="namespacehp_1_1Refinement.html#a9c96d6a85b38f120b5d7cf68126cded9">hp::Refinement::predict_error</a>(dof_handler,</div><div class="line">                                error_indicators,</div><div class="line">                                predicted_errors);</div><div class="line">});</div></div><!-- fragment --><p> The container <code>predicted_errors</code> then needs to follow the usual <a class="el" href="classparallel_1_1distributed_1_1CellDataTransfer.html">parallel::distributed::CellDataTransfer</a> workflow.</p>
<dl class="section note"><dt>Note</dt><dd>We want to predict the error by how adaptation will actually happen. Thus, this function needs to be called after <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a>. </dd></dl>

</div>
</div>
<a id="a7dcdcc921a66bb023b4d1ed7c648137c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcdcc921a66bb023b4d1ed7c648137c">&#9670;&nbsp;</a></span>force_p_over_h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::force_p_over_h </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose p-adaptivity over h-adaptivity in any case.</p>
<p>Removes all refine and coarsen flags on cells that have a <code>future_fe_index</code> assigned.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a4890d9eae896d749b103c8eec9c2029d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4890d9eae896d749b103c8eec9c2029d">&#9670;&nbsp;</a></span>choose_p_over_h()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void hp::Refinement::choose_p_over_h </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choose p-adaptivity over h-adaptivity whenever it is invoked on all related cells.</p>
<p>In case of refinement, information about finite elements will be inherited. Thus we will prefer p-refinement over h-refinement whenever desired, i.e. clear the refine flag and supply a corresponding <code>future_fe_index</code>.</p>
<p>However for coarsening, we follow a different approach. Flagging a cell for h-coarsening does not ultimately mean that it will be coarsened. Only if a cell and all of its siblings are flagged, they will be merged into their parent cell. If we consider p-coarsening on top, we must decide for all siblings together how they will be coarsened. We distinguish between three different cases: </p><ol>
<li>
Not all siblings flagged for coarsening: p-coarsening. <br />
 We keep the <code>future_fe_indices</code> and clear the coarsen flags on all siblings. </li>
<li>
All siblings flagged for coarsening, but not all for p-adaptation: h-coarsening. <br />
 We keep the coarsen flags and clear all <code>future_fe_indices</code> on all siblings. </li>
<li>
All siblings flagged for coarsening and p-adaptation: p-coarsening. <br />
 We keep the <code>future_fe_indices</code> and clear the coarsen flags on all siblings. </li>
</ol>
<dl class="section note"><dt>Note</dt><dd>The function <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> will clean up all h-coarsening flags if they are not shared among all siblings. In the hp-case, we need to bring forward this decision: If the cell will not be coarsened, but qualifies for p-adaptivity, we have to set all flags accordingly. So this function anticipates the decision that <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> would have made later on.</dd>
<dd>
<a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> and <a class="el" href="namespacehp_1_1Refinement.html#a33d9d552f696d578da30dc9a83048670">hp::Refinement::limit_p_level_difference()</a> may change refine and coarsen flags as well as future finite element indices. Avoid calling them before this particular function. </dd></dl>

</div>
</div>
<a id="a33d9d552f696d578da30dc9a83048670"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33d9d552f696d578da30dc9a83048670">&#9670;&nbsp;</a></span>limit_p_level_difference()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> hp::Refinement::limit_p_level_difference </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>max_difference</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>contains_fe_index</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit p-level differences between neighboring cells.</p>
<p>Essentially does to future FE indices what <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> does to refinement flags.</p>
<p>In detail, this function limits the level difference of neighboring cells and thus smoothes the overall function space. Future FE indices will be raised (and never lowered) so that the level difference to neighboring cells is never larger than <code>max_difference</code>.</p>
<p>Multiple FE hierarchies might have been registered via <a class="el" href="classhp_1_1FECollection.html#a8ae7823f04f51f2daaf0b770a151b1b1">hp::FECollection::set_hierarchy()</a>. This function operates on only one hierarchy, namely the one that contains the FE index <code>contains_fe_index</code>. Cells with future FE indices that are not part of the corresponding hierarchy will be ignored.</p>
<p>The function can optionally be called before performing adaptation with <a class="el" href="classTriangulation.html#aaedd900205c1879d8d9ef6ffe7d1a554">Triangulation::execute_coarsening_and_refinement()</a>. It is not necessary to call this function, nor will it be automatically invoked in any part of the library (contrary to its <a class="el" href="classTriangulation.html">Triangulation</a> counterpart).</p>
<p>On cells that will be h-coarsened, we enforce the difference criterion as if it is already a parent cell. That means, we set the level of all siblings to the highest one among them. In that case, all sibling cells need to have the h-coarsenening flags set terminally via <a class="el" href="classTriangulation.html#abf55199c30b0330cf9bf98e2582078e1">Triangulation::prepare_coarsening_and_refinement()</a> beforehand. Otherwise an assertion will be triggered.</p>
<p>Returns whether any future FE indices have been changed by this function. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
