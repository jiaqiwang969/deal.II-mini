<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classSparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseMatrix&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__matrix_8h_source.html">deal.II/lac/sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseMatrix__inherit__graph.svg" width="374" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structSparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac55a5d3fa1fbe7e280a0e3ce4c722d83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ac55a5d3fa1fbe7e280a0e3ce4c722d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7a9cef75f100f1d1d82f59fd95b0681"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a> = number</td></tr>
<tr class="separator:ae7a9cef75f100f1d1d82f59fd95b0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4466250db96cbf50504bc1473ffca9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a></td></tr>
<tr class="separator:abf4466250db96cbf50504bc1473ffca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffd7b499914cd4964c3a8d0fd8b5672"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> = <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; number, true &gt;</td></tr>
<tr class="separator:a0ffd7b499914cd4964c3a8d0fd8b5672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94776653684705604fea3dae0af35f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> = <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; number, false &gt;</td></tr>
<tr class="separator:ac94776653684705604fea3dae0af35f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gaeb64bc85329109069717cfa7e68d4740"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb64bc85329109069717cfa7e68d4740">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to access the matrix entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;&gt;, but this entry does not exist in the sparsity pattern &quot; &quot;of this matrix.&quot; &quot;\&quot; &quot;The most common cause for this problem is that you used &quot; &quot;a method to build the sparsity pattern that did not &quot; &quot;(completely) take into account all of the entries you &quot; &quot;will later try to write into. An example would be &quot; &quot;building a sparsity pattern that does not include &quot; &quot;the entries you will write into due to constraints &quot; &quot;on degrees of freedom such as hanging nodes or periodic &quot; &quot;boundary conditions. In such cases, building the &quot; &quot;sparsity pattern will succeed, but you will get errors &quot; &quot;such as the current one at one point or other when &quot; &quot;trying to write into the entries of the matrix.&quot;)</td></tr>
<tr class="separator:gaeb64bc85329109069717cfa7e68d4740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab349c6727159d55ec4b88754d4dd1e62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab349c6727159d55ec4b88754d4dd1e62">DeclExceptionMsg</a> (ExcDifferentSparsityPatterns, &quot;When copying one sparse matrix into another, &quot; &quot;or when adding one sparse matrix to another, &quot; &quot;both matrices need to refer to the same &quot; &quot;sparsity pattern.&quot;)</td></tr>
<tr class="separator:gab349c6727159d55ec4b88754d4dd1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab178929c14a89e3c7701b1251c4b0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1ab178929c14a89e3c7701b1251c4b0d">DeclException2</a> (ExcIteratorRange, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The iterators denote a range of &quot;&lt;&lt; arg1&lt;&lt; &quot; elements, but the given number of rows was &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga1ab178929c14a89e3c7701b1251c4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418f2cdecf84d79085a7c571fc30bde9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga418f2cdecf84d79085a7c571fc30bde9">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:ga418f2cdecf84d79085a7c571fc30bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造函数和初始化</div></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1435ec2862610afc1b304dc52508b0f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae1435ec2862610afc1b304dc52508b0f">SparseMatrix</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;)</td></tr>
<tr class="separator:ae1435ec2862610afc1b304dc52508b0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59917a056d39a6e30a73db7d790f6a31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a59917a056d39a6e30a73db7d790f6a31">SparseMatrix</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&amp;<a class="el" href="classSparseMatrix.html#acff5838afad6b9d4cc0c0eb5f6c515b5">m</a>) noexcept</td></tr>
<tr class="separator:a59917a056d39a6e30a73db7d790f6a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd7c8660c196bb350961307b29cc9da"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0fd7c8660c196bb350961307b29cc9da">SparseMatrix</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a0fd7c8660c196bb350961307b29cc9da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a713953af05d18bdb920a4905fb412793"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a713953af05d18bdb920a4905fb412793">SparseMatrix</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity, const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a713953af05d18bdb920a4905fb412793"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bc5c60c452a103b9f8851248bacaba"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a48bc5c60c452a103b9f8851248bacaba">~SparseMatrix</a> () override</td></tr>
<tr class="separator:a48bc5c60c452a103b9f8851248bacaba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d3bc25a277de0d402a6dbb7c799bff9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a4d3bc25a277de0d402a6dbb7c799bff9">operator=</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;)</td></tr>
<tr class="separator:a4d3bc25a277de0d402a6dbb7c799bff9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc945affb9c2ca046d69165a8c828ef1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#adc945affb9c2ca046d69165a8c828ef1">operator=</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&amp;<a class="el" href="classSparseMatrix.html#acff5838afad6b9d4cc0c0eb5f6c515b5">m</a>) noexcept</td></tr>
<tr class="separator:adc945affb9c2ca046d69165a8c828ef1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe5800b0226283f39ebe36ca365989f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aebe5800b0226283f39ebe36ca365989f">operator=</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:aebe5800b0226283f39ebe36ca365989f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae657d11c4fde457a8f79fb4c04e24f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8ae657d11c4fde457a8f79fb4c04e24f">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:a8ae657d11c4fde457a8f79fb4c04e24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7ae4d32bda6035661c9cccfe185597"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:afa7ae4d32bda6035661c9cccfe185597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45f664681373fd3a1f8dd965395d360d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a45f664681373fd3a1f8dd965395d360d">clear</a> ()</td></tr>
<tr class="separator:a45f664681373fd3a1f8dd965395d360d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵的信息</div></td></tr>
<tr class="memitem:af1dc916c46eb5e629f4862d4571cef4f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af1dc916c46eb5e629f4862d4571cef4f">empty</a> () const</td></tr>
<tr class="separator:af1dc916c46eb5e629f4862d4571cef4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff5838afad6b9d4cc0c0eb5f6c515b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acff5838afad6b9d4cc0c0eb5f6c515b5">m</a> () const</td></tr>
<tr class="separator:acff5838afad6b9d4cc0c0eb5f6c515b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbefd236587249988e5b1dc04197d3bc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acbefd236587249988e5b1dc04197d3bc">n</a> () const</td></tr>
<tr class="separator:acbefd236587249988e5b1dc04197d3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18c9e6f2bb89e5056fb0b7fe0efca566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a18c9e6f2bb89e5056fb0b7fe0efca566">get_row_length</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> row) const</td></tr>
<tr class="separator:a18c9e6f2bb89e5056fb0b7fe0efca566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ebe386bfe100a9f26404bed7d10893"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a17ebe386bfe100a9f26404bed7d10893">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a17ebe386bfe100a9f26404bed7d10893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6c3e34d4924f60ad89e3202c751f73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aee6c3e34d4924f60ad89e3202c751f73">n_actually_nonzero_elements</a> (const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:aee6c3e34d4924f60ad89e3202c751f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf185692775468ae7364a8909af2d80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aaaf185692775468ae7364a8909af2d80">get_sparsity_pattern</a> () const</td></tr>
<tr class="separator:aaaf185692775468ae7364a8909af2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ec5962de50e44c1101ac48bd277b75"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a78ec5962de50e44c1101ac48bd277b75">memory_consumption</a> () const</td></tr>
<tr class="separator:a78ec5962de50e44c1101ac48bd277b75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231105aa86cca488901d94b1e1b55ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:a231105aa86cca488901d94b1e1b55ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">修改条目</div></td></tr>
<tr class="memitem:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> j, const number value)</td></tr>
<tr class="separator:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2fdc04dbbf9b8f0071b1f2da21d6e106">set</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae96779660698dc3fdd5640f860f14bec">set</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae96779660698dc3fdd5640f860f14bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a01efc87070a6730a10c4dc526bdb7701">set</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> row, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a01efc87070a6730a10c4dc526bdb7701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afd783c07fc8b97262201d70a71b5667d">set</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> row, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> n_cols, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd783c07fc8b97262201d70a71b5667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf7629046afdd9077f77f7746a7a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">add</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> j, const number value)</td></tr>
<tr class="separator:acabf7629046afdd9077f77f7746a7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af4a987fd196ead89df045829bcc181a1">add</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:af4a987fd196ead89df045829bcc181a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a538fb6831594e3bf994c9d44af68fccc">add</a> (const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a538fb6831594e3bf994c9d44af68fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae745cf2afd297c8acdfe33ace4d366f4">add</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> row, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac97efa0f970b0bcf40da82584f71d39c">add</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> row, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> n_cols, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:ac97efa0f970b0bcf40da82584f71d39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aebb2ac677d0b2a212b289221ba4a43b7">operator*=</a> (const number factor)</td></tr>
<tr class="separator:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99829ea532c57a8de890ee70b1faa24c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a99829ea532c57a8de890ee70b1faa24c">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a99829ea532c57a8de890ee70b1faa24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1643ae82c4bd45a881c91d0066776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a70c1643ae82c4bd45a881c91d0066776">symmetrize</a> ()</td></tr>
<tr class="separator:a70c1643ae82c4bd45a881c91d0066776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104b9a4c9fc720b0201e7668b058e3d1"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a104b9a4c9fc720b0201e7668b058e3d1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a104b9a4c9fc720b0201e7668b058e3d1">copy_from</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;source)</td></tr>
<tr class="separator:a104b9a4c9fc720b0201e7668b058e3d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9240d87b7695c58c41c93506a4723c08">copy_from</a> (const ForwardIterator <a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">begin</a>, const ForwardIterator <a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">end</a>)</td></tr>
<tr class="separator:a9240d87b7695c58c41c93506a4723c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad182785cbf271adb6a29fa470ecde8d7">copy_from</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:ad182785cbf271adb6a29fa470ecde8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4b458133c76bb6b4966a5c89e2157c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a6b4b458133c76bb6b4966a5c89e2157c">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:a6b4b458133c76bb6b4966a5c89e2157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a157053c3502b33962ac736cc873a8dbd">add</a> (const number factor, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a157053c3502b33962ac736cc873a8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">条目访问</div></td></tr>
<tr class="memitem:a3871cf59e0e7c8bd18cabbcd3e02daa9"><td class="memItemLeft" align="right" valign="top">const number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3871cf59e0e7c8bd18cabbcd3e02daa9">operator()</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> j) const</td></tr>
<tr class="separator:a3871cf59e0e7c8bd18cabbcd3e02daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96ad36bd86637f146fff43b3996536d"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac96ad36bd86637f146fff43b3996536d">operator()</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> j)</td></tr>
<tr class="separator:ac96ad36bd86637f146fff43b3996536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25229f70f1bfccd2437d587a000001e"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa25229f70f1bfccd2437d587a000001e">el</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i, const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> j) const</td></tr>
<tr class="separator:aa25229f70f1bfccd2437d587a000001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d9466d88f725141780a95c41e79951"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a49d9466d88f725141780a95c41e79951">diag_element</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i) const</td></tr>
<tr class="separator:a49d9466d88f725141780a95c41e79951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a159957553e3a4ca34cee51fdfa4cafa7">diag_element</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> i)</td></tr>
<tr class="separator:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">乘法运算</div></td></tr>
<tr class="memitem:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">vmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224a78133e7b655e3a2c26647097c2c7"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a224a78133e7b655e3a2c26647097c2c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a224a78133e7b655e3a2c26647097c2c7">Tvmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a224a78133e7b655e3a2c26647097c2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48cdb75f02c2aaf3b5285ee084085091"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a48cdb75f02c2aaf3b5285ee084085091"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a48cdb75f02c2aaf3b5285ee084085091">vmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a48cdb75f02c2aaf3b5285ee084085091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae58727ce898d97c486b3bc1ec4826a0b"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:ae58727ce898d97c486b3bc1ec4826a0b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae58727ce898d97c486b3bc1ec4826a0b">Tvmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:ae58727ce898d97c486b3bc1ec4826a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ded9134adf275ede256b92eefae8ed"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a03ded9134adf275ede256b92eefae8ed"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a03ded9134adf275ede256b92eefae8ed">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a03ded9134adf275ede256b92eefae8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1a7074c2cc7fd4ed760d5bf06594cf12">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b) const</td></tr>
<tr class="separator:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a38676dc8cd6d6c7b8aea3a335653a25f">mmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const</td></tr>
<tr class="separator:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21044730f1f38257cc0397accb4d05e5"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a21044730f1f38257cc0397accb4d05e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a21044730f1f38257cc0397accb4d05e5">Tmmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const</td></tr>
<tr class="separator:a21044730f1f38257cc0397accb4d05e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵规范</div></td></tr>
<tr class="memitem:aeb0010028e98a1e616d3ea1bed765f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aeb0010028e98a1e616d3ea1bed765f4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeb0010028e98a1e616d3ea1bed765f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64627cdd2dc0d8c8991996c029ba9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae64627cdd2dc0d8c8991996c029ba9ca">linfty_norm</a> () const</td></tr>
<tr class="separator:ae64627cdd2dc0d8c8991996c029ba9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae403bf35656c6b5c075186b116e7f293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae403bf35656c6b5c075186b116e7f293">frobenius_norm</a> () const</td></tr>
<tr class="separator:ae403bf35656c6b5c075186b116e7f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">预处理方法</div></td></tr>
<tr class="memitem:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0b1f22866ffd7e47bfb32f62a1d3e711">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa6f7ebdcc75ee730592c0bf23014405f">precondition_SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1., const std::vector&lt; std::size_t &gt; &amp;pos_right_of_diagonal=std::vector&lt; std::size_t &gt;()) const</td></tr>
<tr class="separator:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9ce0a2202ddc552f004523f3aef544"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:adc9ce0a2202ddc552f004523f3aef544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#adc9ce0a2202ddc552f004523f3aef544">precondition_SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:adc9ce0a2202ddc552f004523f3aef544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967052ec6d13489bc529bb11515f89ea"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a967052ec6d13489bc529bb11515f89ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a967052ec6d13489bc529bb11515f89ea">precondition_TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:a967052ec6d13489bc529bb11515f89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a5439b4fc51d59a4cfa0f0829ee876763">SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number omega=1.) const</td></tr>
<tr class="separator:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ca15703f371cfa2b8281bb1eba0267"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a76ca15703f371cfa2b8281bb1eba0267"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a76ca15703f371cfa2b8281bb1eba0267">SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:a76ca15703f371cfa2b8281bb1eba0267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab8aa1eba02ee6d5180fbb8173b9967eb">TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94530f37331ed997e91d9458a1303f79"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a94530f37331ed997e91d9458a1303f79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a94530f37331ed997e91d9458a1303f79">PSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:a94530f37331ed997e91d9458a1303f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa3514d4a24a63ce70fe7e9486ad1688a">TPSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa039cc30461321e4f54dd54e67e8ca36"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa039cc30461321e4f54dd54e67e8ca36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa039cc30461321e4f54dd54e67e8ca36">Jacobi_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:aa039cc30461321e4f54dd54e67e8ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a72eaf0aedbda317c83cd6b3fe460d995">SOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a36852dfbd7e9623dc96301d73fa2cf22">TSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2d92814be1b12c114a2e86f7c7c9410c">SSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器</div></td></tr>
<tr class="memitem:a419e25c734b10802f9c7f59d652f84ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">begin</a> () const</td></tr>
<tr class="separator:a419e25c734b10802f9c7f59d652f84ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872bb70a86280328309c97c78bc39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab0872bb70a86280328309c97c78bc39f">begin</a> ()</td></tr>
<tr class="separator:ab0872bb70a86280328309c97c78bc39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c613fbc2273dd9f16c716b1d4dc29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">end</a> () const</td></tr>
<tr class="separator:a24c613fbc2273dd9f16c716b1d4dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa99041df4c848c5b46180327c1e9b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1aa99041df4c848c5b46180327c1e9b5">end</a> ()</td></tr>
<tr class="separator:a1aa99041df4c848c5b46180327c1e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cdd83806e88c53003d185ad639cd35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a22cdd83806e88c53003d185ad639cd35">begin</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> r) const</td></tr>
<tr class="separator:a22cdd83806e88c53003d185ad639cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abc32c2ee41aa5e02b5838ed9e3423919">begin</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> r)</td></tr>
<tr class="separator:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8d50d7700dbd8560af071e146979c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aac8d50d7700dbd8560af071e146979c0">end</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> r) const</td></tr>
<tr class="separator:aac8d50d7700dbd8560af071e146979c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bd553a69c0374c72195d4eb0158696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad5bd553a69c0374c72195d4eb0158696">end</a> (const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> r)</td></tr>
<tr class="separator:ad5bd553a69c0374c72195d4eb0158696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">输入/输出</div></td></tr>
<tr class="memitem:aa84c2e29d3b520c53a9695b42b3941c5"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:aa84c2e29d3b520c53a9695b42b3941c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa84c2e29d3b520c53a9695b42b3941c5">print</a> (StreamType &amp;out, const <a class="el" href="classbool.html">bool</a> across=false, const <a class="el" href="classbool.html">bool</a> diagonal_first=true) const</td></tr>
<tr class="separator:aa84c2e29d3b520c53a9695b42b3941c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6456ebe393c32b076eae0b5c9811e0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a6456ebe393c32b076eae0b5c9811e0c8">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const</td></tr>
<tr class="separator:a6456ebe393c32b076eae0b5c9811e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737f5df58f2bf6ab275ed382ed725abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a737f5df58f2bf6ab275ed382ed725abb">print_pattern</a> (std::ostream &amp;out, const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:a737f5df58f2bf6ab275ed382ed725abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3141075e3ad6362fce005d2f1c8da699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3141075e3ad6362fce005d2f1c8da699">print_as_numpy_arrays</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=9) const</td></tr>
<tr class="separator:a3141075e3ad6362fce005d2f1c8da699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32b99a054482f06fc026248c27bb74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8b32b99a054482f06fc026248c27bb74">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a8b32b99a054482f06fc026248c27bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b670368c98d6392ff8c9284db0622b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9b670368c98d6392ff8c9284db0622b2">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a9b670368c98d6392ff8c9284db0622b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a1debf998b61291d913dfac4c8a22eaa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1debf998b61291d913dfac4c8a22eaa7">prepare_add</a> ()</td></tr>
<tr class="separator:a1debf998b61291d913dfac4c8a22eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68a9f93813ca167dc9f39624be2f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9f68a9f93813ca167dc9f39624be2f5b">prepare_set</a> ()</td></tr>
<tr class="separator:a9f68a9f93813ca167dc9f39624be2f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a345be12c610d63bb10f4fa6a1be14f9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a345be12c610d63bb10f4fa6a1be14f9e">cols</a></td></tr>
<tr class="separator:a345be12c610d63bb10f4fa6a1be14f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7e5b9eb6ad7c45635d346de98b1c1e5"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; number[]&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab7e5b9eb6ad7c45635d346de98b1c1e5">val</a></td></tr>
<tr class="separator:ab7e5b9eb6ad7c45635d346de98b1c1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad183b90df780534d2143a45d97668de3"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad183b90df780534d2143a45d97668de3">max_len</a></td></tr>
<tr class="separator:ad183b90df780534d2143a45d97668de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ad66f15847b7c27c5898f3b859d6cfe05"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad66f15847b7c27c5898f3b859d6cfe05"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad66f15847b7c27c5898f3b859d6cfe05">SparseMatrix</a></td></tr>
<tr class="separator:ad66f15847b7c27c5898f3b859d6cfe05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b41703cc0d0eea14c99c2bac2c5149"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab3b41703cc0d0eea14c99c2bac2c5149"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab3b41703cc0d0eea14c99c2bac2c5149">SparseLUDecomposition</a></td></tr>
<tr class="separator:ab3b41703cc0d0eea14c99c2bac2c5149"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a821b53e73219682e8d8efdacd3571e62"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a821b53e73219682e8d8efdacd3571e62"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a821b53e73219682e8d8efdacd3571e62">SparseILU</a></td></tr>
<tr class="separator:a821b53e73219682e8d8efdacd3571e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35c04bb7fa6f87652d7749935baaaf1"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:ac35c04bb7fa6f87652d7749935baaaf1"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac35c04bb7fa6f87652d7749935baaaf1">BlockMatrixBase</a></td></tr>
<tr class="separator:ac35c04bb7fa6f87652d7749935baaaf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadb72d74c6d5421b8bdf522916064359"><td class="memTemplParams" colspan="2">template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:aadb72d74c6d5421b8bdf522916064359"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aadb72d74c6d5421b8bdf522916064359">SparseMatrixIterators::Iterator</a></td></tr>
<tr class="separator:aadb72d74c6d5421b8bdf522916064359"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8834e738affcd56700ea78a3cbb7e051"><td class="memTemplParams" colspan="2">template&lt;typename , bool &gt; </td></tr>
<tr class="memitem:a8834e738affcd56700ea78a3cbb7e051"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8834e738affcd56700ea78a3cbb7e051">SparseMatrixIterators::Accessor</a></td></tr>
<tr class="separator:a8834e738affcd56700ea78a3cbb7e051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7cc79151e928ea71a124bdebc02833"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a9b7cc79151e928ea71a124bdebc02833"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9b7cc79151e928ea71a124bdebc02833">Utilities::MPI::sum</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;)</td></tr>
<tr class="separator:a9b7cc79151e928ea71a124bdebc02833"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class SparseMatrix&lt; number &gt;</h3>

<p>稀疏矩阵。这个类实现了在SparsityPattern表示的位置存储矩阵入口值的功能。参见 <a class="el" href="group__Sparsity.html">Sparsity patterns</a> 中关于稀疏模式和矩阵之间分离的讨论。 </p><h1>SparseMatrix的元素是按照SparsityPattern类存储其条目的相同顺序来存储的。在每一行中，元素通常以列索引递增的顺序从左到右存储；这一规则的例外是，如果矩阵是正方形（m() </h1>
<p><a class="el" href="classSparseMatrix.html#acbefd236587249988e5b1dc04197d3bc">n()</a>），那么对角线条目就会被存储为每一行的第一个元素，以使应用雅可比或SSOR预处理程序等操作更快。因此，如果你用迭代器遍历稀疏矩阵的某一行的元素（使用 <a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">SparseMatrix::begin</a> 和 <a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">SparseMatrix::end</a>) ，你会发现只要矩阵是平方的，每一行的元素就不会按列索引排序。</p>
<dl class="section note"><dt>Note</dt><dd>这个模板的实例化提供给<code> &lt;float&gt; 和 &lt;double&gt;</code>; 其他的可以在应用程序中生成（见手册中 <a class="el" href="Instantiations.html">Template instantiations</a> 一节）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00479">479</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac55a5d3fa1fbe7e280a0e3ce4c722d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac55a5d3fa1fbe7e280a0e3ce4c722d83">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器尺寸的类型。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00486">486</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae7a9cef75f100f1d1d82f59fd95b0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9cef75f100f1d1d82f59fd95b0681">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a> =  number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵条目的类型。这个别名类似于标准库容器中的<code>value_type</code>。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00492">492</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abf4466250db96cbf50504bc1473ffca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4466250db96cbf50504bc1473ffca9">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一个类型，该类型持有与本类的模板参数相同精度的实值数。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。 如果模板参数是一个 std::complex 类型，那么real_type等于复数的基础类型。 这个别名被用来表示规范的返回类型。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00501">501</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a0ffd7b499914cd4964c3a8d0fd8b5672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffd7b499914cd4964c3a8d0fd8b5672">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> =  <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number, true&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个迭代器类的类型定义，在这个矩阵的所有非零项上行走。这个迭代器不能改变矩阵的值。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00507">507</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac94776653684705604fea3dae0af35f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94776653684705604fea3dae0af35f4">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> =  <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number, false&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>走过该矩阵所有非零项的迭代器类的类型定义。这个迭代器 <em>可以改变矩阵的值，但当然不能改变稀疏模式，因为一旦稀疏矩阵被附加到它上面，这个模式就固定了。</em> </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00515">515</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数；将矩阵初始化为空，没有任何结构，也就是说，矩阵根本无法使用。因此，这个构造函数只对作为类的成员的矩阵有用。所有其他的矩阵都应该在数据流中的一个点上创建，在那里所有必要的信息都是可用的。 你必须在使用前用reinit(const SparsityPattern&amp;)初始化矩阵。 </p>

</div>
</div>
<a id="ae1435ec2862610afc1b304dc52508b0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1435ec2862610afc1b304dc52508b0f">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数。只有当要复制的矩阵为空时，才允许调用该构造函数。这与SparsityPattern的原因相同，详见那里。 如果你真的想复制一个完整的矩阵，你可以通过使用copy_from()函数来实现。 </p>

</div>
</div>
<a id="a59917a056d39a6e30a73db7d790f6a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59917a056d39a6e30a73db7d790f6a31">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。通过将矩阵的内部数据 <code>m</code> 转移到一个新的对象中，构造一个新的稀疏矩阵。 移动构造允许一个对象从一个函数中返回或打包成一个元组，即使该类不能被复制构造。 </p>

</div>
</div>
<a id="a0fd7c8660c196bb350961307b29cc9da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd7c8660c196bb350961307b29cc9da">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造器。接受给定的矩阵稀疏度结构来表示这个矩阵的稀疏度模式。你可以在以后通过调用reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp;)函数来改变稀疏性模式。 你必须确保稀疏结构的寿命至少与该矩阵的寿命一样长，或者只要reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp;)没有被调用新的稀疏模式。 构造函数被明确标记，以便不允许有人将稀疏模式代替稀疏矩阵传递给某个函数，这样就会生成一个空矩阵。 </p>

</div>
</div>
<a id="a713953af05d18bdb920a4905fb412793"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a713953af05d18bdb920a4905fb412793">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝构造函数：用身份矩阵初始化矩阵。如果稀疏模式和身份矩阵的大小不一致，或者如果稀疏模式没有在整个对角线上提供非零条目，这个构造函数将抛出一个异常。 </p>

</div>
</div>
<a id="a48bc5c60c452a103b9f8851248bacaba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bc5c60c452a103b9f8851248bacaba">&#9670;&nbsp;</a></span>~SparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::~<a class="el" href="classSparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。释放所有内存，但不释放稀疏结构的内存。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4d3bc25a277de0d402a6dbb7c799bff9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d3bc25a277de0d402a6dbb7c799bff9">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制操作符。由于复制整个稀疏矩阵是一个非常昂贵的操作，我们不允许这样做，除了大小为0的空矩阵这一特殊情况。这看起来不是特别有用，但如果想有一个 <code>std::vector&lt;<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;double&gt; &gt;</code> ，这正是人们所需要的：在这种情况下，人们可以创建一个空矩阵的向量（需要复制对象的能力），然后用有用的东西来填充。 </p>

</div>
</div>
<a id="adc945affb9c2ca046d69165a8c828ef1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc945affb9c2ca046d69165a8c828ef1">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符。这个操作符通过转移 <code>m</code>. 的内部数据，将目前的矩阵替换成 <code>m</code> 。 </p>

</div>
</div>
<a id="aebe5800b0226283f39ebe36ca365989f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe5800b0226283f39ebe36ca365989f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制运算符：用身份矩阵初始化矩阵。如果稀疏模式和身份矩阵的大小不一致，或者如果稀疏模式没有规定整个对角线上的非零条目，这个操作符将抛出一个异常。 </p>

</div>
</div>
<a id="a8ae657d11c4fde457a8f79fb4c04e24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae657d11c4fde457a8f79fb4c04e24f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？ 仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="afa7ae4d32bda6035661c9cccfe185597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7ae4d32bda6035661c9cccfe185597">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用给定的稀疏模式重新初始化稀疏矩阵。后者告诉矩阵需要保留多少个非零元素。 关于内存分配，和上面说的一样。 你必须确保稀疏结构的寿命至少与该矩阵的寿命一样长，或者只要reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;)没有被调用，就不会有新的稀疏结构。 矩阵的元素被这个函数设置为零。 </p>

</div>
</div>
<a id="a45f664681373fd3a1f8dd965395d360d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45f664681373fd3a1f8dd965395d360d">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。它也会忘记它之前绑定的稀疏模式。 </p>

<p>Reimplemented in <a class="el" href="classSparseLUDecomposition.html#ab74ecba3e2568b61268ea69b9b890a9e">SparseLUDecomposition&lt; number &gt;</a>, and <a class="el" href="classSparseMIC.html#ac82e3f7a7e669fbe1c2a3f9624f02586">SparseMIC&lt; number &gt;</a>.</p>

</div>
</div>
<a id="af1dc916c46eb5e629f4862d4571cef4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dc916c46eb5e629f4862d4571cef4f">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该对象是否为空。如果两个维度都是零或者没有关联的SparsityPattern，它就是空的。 </p>

</div>
</div>
<a id="acff5838afad6b9d4cc0c0eb5f6c515b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff5838afad6b9d4cc0c0eb5f6c515b5">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回共域（或范围）空间的维度。注意，矩阵的维度是 \(m \times n\) 。 </p>

</div>
</div>
<a id="acbefd236587249988e5b1dc04197d3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbefd236587249988e5b1dc04197d3bc">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回域空间的维度。请注意，矩阵的维度是 \(m \times n\) . </p>

</div>
</div>
<a id="a18c9e6f2bb89e5056fb0b7fe0efca566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9e6f2bb89e5056fb0b7fe0efca566">&#9670;&nbsp;</a></span>get_row_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回特定行中的条目数。 </p>

</div>
</div>
<a id="a17ebe386bfe100a9f26404bed7d10893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ebe386bfe100a9f26404bed7d10893">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目恰好是零，无论如何都会被计算在内。 </p>

</div>
</div>
<a id="aee6c3e34d4924f60ad89e3202c751f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6c3e34d4924f60ad89e3202c751f73">&#9670;&nbsp;</a></span>n_actually_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵中实际非零元素的数量。可以指定参数<code>threshold</code>，以便只计算绝对值大于阈值的元素。 注意，这个函数（与n_nonzero_elements()相反）不计算稀疏模式的所有条目，而只计算非零的（或绝对值大于阈值的）。 </p>

</div>
</div>
<a id="aaaf185692775468ae7364a8909af2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf185692775468ae7364a8909af2d80">&#9670;&nbsp;</a></span>get_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对该矩阵底层稀疏性模式的（常量）引用。 尽管返回值被声明为<code>const</code>，但你应该注意，如果你调用任何对其进行操作的对象的非常量函数，它可能会改变。 </p>

</div>
</div>
<a id="a78ec5962de50e44c1101ac48bd277b75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ec5962de50e44c1101ac48bd277b75">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定此对象的内存消耗（以字节为单位）的估计值。参见MemoryConsumption。 </p>

</div>
</div>
<a id="a231105aa86cca488901d94b1e1b55ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231105aa86cca488901d94b1e1b55ac7">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>虚函数，与分布式并行矩阵兼容。 </p>

</div>
</div>
<a id="a3e77fcfbd1fa3ac83ef4ff2951b24ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>设置元素（<em>i,j</em>）为<code>value</code>。如果条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="a2fdc04dbbf9b8f0071b1f2da21d6e106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc04dbbf9b8f0071b1f2da21d6e106">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将FullMatrix中给出的所有元素设置到<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球的索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="ae96779660698dc3fdd5640f860f14bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96779660698dc3fdd5640f860f14bec">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a01efc87070a6730a10c4dc526bdb7701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01efc87070a6730a10c4dc526bdb7701">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="afd783c07fc8b97262201d70a71b5667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd783c07fc8b97262201d70a71b5667d">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给出的值，在给定的行和col_indices给出的列中设置为稀疏矩阵。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要插入零值还是要过滤掉它们。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="acabf7629046afdd9077f77f7746a7a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabf7629046afdd9077f77f7746a7a3f">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>向元素添加<code>value</code>（<em>i,j</em>）。 如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="af4a987fd196ead89df045829bcc181a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a987fd196ead89df045829bcc181a1">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假定一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中通常的情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a538fb6831594e3bf994c9d44af68fccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538fb6831594e3bf994c9d44af68fccc">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="ae745cf2afd297c8acdfe33ace4d366f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae745cf2afd297c8acdfe33ace4d366f4">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="ac97efa0f970b0bcf40da82584f71d39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97efa0f970b0bcf40da82584f71d39c">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="aebb2ac677d0b2a212b289221ba4a43b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb2ac677d0b2a212b289221ba4a43b7">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

</div>
</div>
<a id="a99829ea532c57a8de890ee70b1faa24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99829ea532c57a8de890ee70b1faa24c">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

</div>
</div>
<a id="a70c1643ae82c4bd45a881c91d0066776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c1643ae82c4bd45a881c91d0066776">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过形成现有矩阵和其转置之间的平均值来对称矩阵， \(A = \frac 12(A+A^T)\) 。 这个操作假设底层的稀疏模式代表一个对称的对象。如果不是这样，那么这个操作的结果将不是一个对称矩阵，因为出于效率的考虑，它只通过在左下角的三角形部分进行循环来明确地进行对称；如果右上角的三角形有条目，那么这些元素在对称过程中会被遗漏。稀疏模式的对称化可以通过 <a class="el" href="classSparsityPatternBase.html#a16c1ebb8fbefcdce0a313e7be27ad34d">SparsityPattern::symmetrize()</a>. 得到。 </p>

</div>
</div>
<a id="a104b9a4c9fc720b0201e7668b058e3d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104b9a4c9fc720b0201e7668b058e3d1">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将作为参数给出的矩阵复制到当前对象中。 复制矩阵是一个昂贵的操作，我们不希望通过编译器生成的代码 <code>operator=</code> 而意外发生（例如，如果不小心声明了当前类型的函数参数为<em>by value</em>而不是<em>by reference</em>，就会发生这种情况）。复制矩阵的功能是在这个成员函数中实现的。因此，该类型对象的所有复制操作都需要一个明确的函数调用。 源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型。 该函数返回一个对<code>*this</code>的引用。 </p>

</div>
</div>
<a id="a9240d87b7695c58c41c93506a4723c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9240d87b7695c58c41c93506a4723c08">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数完全类似于 <a class="el" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">SparsityPattern::copy_from()</a> 函数，它允许在一个步骤中初始化整个矩阵。关于参数类型及其含义的更多信息请见那里。你还可以在那里找到一个关于如何使用这个函数的小例子。 与引用的函数唯一不同的是，内部迭代器指向的对象需要是 <code>std::pair&lt;unsigned int, value</code>类型，其中<code>value</code>需要可转换为该类的元素类型，由<code>number</code>模板参数指定。 矩阵以前的内容被覆盖。注意，由输入参数指定的条目不一定要覆盖矩阵的所有元素。未覆盖的元素保持不动。 </p>

</div>
</div>
<a id="ad182785cbf271adb6a29fa470ecde8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad182785cbf271adb6a29fa470ecde8d7">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个完整矩阵的非零条目复制到此对象中。之前的内容被删除。 请注意，底层的稀疏模式必须适合容纳全矩阵的非零条目。这可以使用 <a class="el" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">SparsityPattern::copy_from()</a> 的那个版本来实现，该版本以FullMatrix作为参数。 </p>

</div>
</div>
<a id="a6b4b458133c76bb6b4966a5c89e2157c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4b458133c76bb6b4966a5c89e2157c">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的特里诺斯矩阵复制到这个矩阵中。如果当前对象的稀疏模式不包含给定参数的非零条目的位置，该操作会触发一个断言。 这个函数假设两个矩阵有相同的大小。 该函数返回一个对<code>*this</code>的引用。 </p>

</div>
</div>
<a id="a157053c3502b33962ac736cc873a8dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157053c3502b33962ac736cc873a8dbd">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将<code>matrix</code>按<code>factor</code>的比例添加到这个矩阵中，也就是说，将<code>factor*matrix</code>的矩阵添加到<code>this</code>。如果所涉及的两个矩阵的稀疏性模式不指向同一个对象，这个函数会抛出一个错误，因为在这种情况下，操作会比较便宜。 源矩阵可以是一个任意底层标量类型的稀疏矩阵，只要其数据类型可以转换为这个矩阵的数据类型。 </p>

</div>
</div>
<a id="a3871cf59e0e7c8bd18cabbcd3e02daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3871cf59e0e7c8bd18cabbcd3e02daa9">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。为了避免滥用，如果所需元素在矩阵中不存在，该函数会抛出一个异常。 如果你想要一个返回零的函数（对于不在矩阵的稀疏模式中的条目），请使用el()函数。 如果你要在所有元素上循环，可以考虑使用一个迭代器类来代替，因为它们更适合稀疏的矩阵结构。 </p>

</div>
</div>
<a id="ac96ad36bd86637f146fff43b3996536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96ad36bd86637f146fff43b3996536d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面那个相反，这个函数允许修改对象。 </p>

</div>
</div>
<a id="aa25229f70f1bfccd2437d587a000001e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25229f70f1bfccd2437d587a000001e">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数主要像operator()()，它返回矩阵条目的值（<em>i,j</em>）。唯一的区别是，如果这个条目不存在于稀疏模式中，那么就不会引发异常，而是返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，所以很容易写出与最优解相比很慢的算法。 如果你要在所有元素上循环，可以考虑使用一个迭代器类来代替，因为它们更适合稀疏的矩阵结构。 </p>

</div>
</div>
<a id="a49d9466d88f725141780a95c41e79951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d9466d88f725141780a95c41e79951">&#9670;&nbsp;</a></span>diag_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次方的，这个函数会抛出一个错误。 这个函数比operator()()快得多，因为对于二次矩阵来说，对角线条目可能是每行中第一个被存储的，因此访问时不需要搜索正确的列号。 </p>

</div>
</div>
<a id="a159957553e3a4ca34cee51fdfa4cafa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159957553e3a4ca34cee51fdfa4cafa7">&#9670;&nbsp;</a></span>diag_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但返回一个可写的引用。你确定你知道你在做什么吗？ </p>

</div>
</div>
<a id="a7706b5f721efc5ea1966f5a5cdaad0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7706b5f721efc5ea1966f5a5cdaad0e6">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M*src</em>与<em>M</em>是这个矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockSparseMatrix。 源和目的不能是同一个向量。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a224a78133e7b655e3a2c26647097c2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224a78133e7b655e3a2c26647097c2c7">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>是这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockSparseMatrix。 源和目的不能是同一个向量。 </p>

</div>
</div>
<a id="a48cdb75f02c2aaf3b5285ee084085091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48cdb75f02c2aaf3b5285ee084085091">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量的乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>是这个矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockSparseMatrix。 源和目的不能是同一个向量。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="ae58727ce898d97c486b3bc1ec4826a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae58727ce898d97c486b3bc1ec4826a0b">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量的乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数与vmult_add()的操作相同，但取的是转置的矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockSparseMatrix。 源和目的不能是同一个向量。 </p>

</div>
</div>
<a id="a56d106dfe8792db57f2d6e60bdfe63e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d106dfe8792db57f2d6e60bdfe63e1">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的法线的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 显然，对于这个操作来说，矩阵需要是二次的，而且为了使结果真正成为一个规范，它还需要是实数对称的或复数隐式的。 该矩阵和给定向量的底层模板类型应该都是实值或复值，但不是混合的，这样这个函数才有意义。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a03ded9134adf275ede256b92eefae8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ded9134adf275ede256b92eefae8ed">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a1a7074c2cc7fd4ed760d5bf06594cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7074c2cc7fd4ed760d5bf06594cf12">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入<code>dst</code>。残差向量的<em>l<sub>2</sub></em>准则被返回。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a38676dc8cd6d6c7b8aea3a335653a25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38676dc8cd6d6c7b8aea3a335653a25f">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法<code>C = A B</code>，或者，如果给出一个可选的矢量参数，则<code>C = A diag(V) B</code>，其中<code>diag(V)</code>定义了一个带有矢量项的对角矩阵。 这个函数假定调用矩阵 <code>A</code> 和参数 <code>B</code> 的大小兼容。默认情况下，输出矩阵 <code>C</code> 将被适当调整大小。 默认情况下，即如果可选的参数 <code>rebuild_sparsity_pattern</code> 是 <code>true</code>, ，矩阵C的稀疏模式将被改变，以确保由乘积 \(AB\) 产生的所有条目可以被存储在 \(C\) 中。这是一个昂贵的操作，如果有办法预先预测稀疏模式，你可能应该在以 <code>false</code> 为最后一个参数调用这个函数之前自己建立它。在这种情况下，疏密模式的重建被绕过了。 当把 <code>rebuild_sparsity_pattern</code> 设置为 <code>true</code> 时（即把它留在默认值），必须意识到作为第一个参数传递的矩阵 <code>C</code> 仍然需要用稀疏模式进行初始化（可以在创建稀疏矩阵对象时，或者通过 <a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">SparseMatrix::reinit()</a> 函数）。这是因为我们可以在当前函数中创建一个稀疏模式，然后将 <code>C</code> 与之关联，但一旦当前函数结束，就没有办法将这个稀疏模式的所有权转移给任何人。因此，该函数要求 <code>C</code> 已经与一个稀疏模式对象相关联，然后该对象被重置为适合 <code>A</code> 和 <code>B</code>. 的乘积。 然而，作为其结果，还必须认识到 <code>C</code> 的稀疏模式被修改，这将使碰巧<em>also</em>使用该稀疏模式对象的<em>all other <a class="el" href="classSparseMatrix.html">SparseMatrix</a> objects</em>无效。 </p>

</div>
</div>
<a id="a21044730f1f38257cc0397accb4d05e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21044730f1f38257cc0397accb4d05e5">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用<code>this</code>的转置执行矩阵-矩阵乘法，即<code>C = A<sup>T</sup> B</code>，或者，如果给出了可选的矢量参数，<code>C = A<sup>T</sup> diag(V) B</code>，其中<code>diag(V)</code>定义了一个带有矢量项的对角矩阵。 这个函数假定调用矩阵<code>A</code>和<code>B</code>的大小兼容。<code>C</code>的大小将在本函数中设置。 矩阵C的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在你使用这个函数之前要三思而后行。 有一个可选的标志<code>rebuild_sparsity_pattern</code>，可以用来绕过创建一个新的稀疏度模式，而使用存储在<code>C</code>中的稀疏度模式。在这种情况下，要确保它真的适合。默认情况下是重建稀疏度模式。 </p><dl class="section note"><dt>Note</dt><dd>重建稀疏度模式需要改变它。这意味着所有与该稀疏性模式相关的其他矩阵将有无效的条目。 </dd></dl>

</div>
</div>
<a id="aeb0010028e98a1e616d3ea1bed765f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0010028e98a1e616d3ea1bed765f4e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的 \(l_1\) 规范，即 \(|M|_1=\max_{\mathrm{all\ columns\ }j}\sum_{\mathrm{all\ rows\ } i} |M_{ij}|\) ，（最大列数之和）。 这是自然的矩阵准则，与向量的 \(l_1\) 准则兼容，即 \(|Mv|_1\leq |M|_1 |v|_1\) 。(参见Haemmerlin- Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a id="ae64627cdd2dc0d8c8991996c029ba9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64627cdd2dc0d8c8991996c029ba9ca">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的 \(l_\infty\) 准则，即 \(|M|_\infty=\max_{\mathrm{all\ rows\ }i}\sum_{\mathrm{all\ columns\ }j} |M_{ij}|\) , (行的最大和)。 这是自然的矩阵准则，与向量的 \(l_\infty\) 准则兼容，即 \(|Mv|_\infty \leq |M|_\infty |v|_\infty\) 。 (参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a id="ae403bf35656c6b5c075186b116e7f293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae403bf35656c6b5c075186b116e7f293">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

</div>
</div>
<a id="a0b1f22866ffd7e47bfb32f62a1d3e711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1f22866ffd7e47bfb32f62a1d3e711">&#9670;&nbsp;</a></span>precondition_Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>应用雅可比预处理，将<code>src</code>向量的每个元素乘以各自对角线元素的逆值，并将结果乘以松弛因子<code>omega</code>。 </p>

</div>
</div>
<a id="aa6f7ebdcc75ee730592c0bf23014405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f7ebdcc75ee730592c0bf23014405f">&#9670;&nbsp;</a></span>precondition_SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos_right_of_diagonal</em> = <code>std::vector&lt;&#160;std::size_t&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>src</code>应用SSOR预处理，阻尼<code>omega</code>。 可选的参数<code>pos_right_of_diagonal</code>应该提供一个数组，其中每个条目指定全局非零点阵列中对角线的右边位置。 </p>

</div>
</div>
<a id="adc9ce0a2202ddc552f004523f3aef544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9ce0a2202ddc552f004523f3aef544">&#9670;&nbsp;</a></span>precondition_SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将SOR预处理矩阵应用于<code>src</code>。 </p>

</div>
</div>
<a id="a967052ec6d13489bc529bb11515f89ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967052ec6d13489bc529bb11515f89ea">&#9670;&nbsp;</a></span>precondition_TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>src</code>应用转置的SOR预处理矩阵。 </p>

</div>
</div>
<a id="a5439b4fc51d59a4cfa0f0829ee876763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5439b4fc51d59a4cfa0f0829ee876763">&#9670;&nbsp;</a></span>SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地执行SSOR预处理。 应用预处理矩阵而不复制到第二个向量。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="a76ca15703f371cfa2b8281bb1eba0267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ca15703f371cfa2b8281bb1eba0267">&#9670;&nbsp;</a></span>SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地执行SOR预处理。 <code>omega</code>是松弛参数。 </p>

</div>
</div>
<a id="ab8aa1eba02ee6d5180fbb8173b9967eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aa1eba02ee6d5180fbb8173b9967eb">&#9670;&nbsp;</a></span>TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地进行转置SOR预处理。 <code>omega</code>是松弛参数。 </p>

</div>
</div>
<a id="a94530f37331ed997e91d9458a1303f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94530f37331ed997e91d9458a1303f79">&#9670;&nbsp;</a></span>PSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::PSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地进行移置的SOR预处理。 标准的SOR方法是按照<code>permutation</code>规定的顺序应用的，即首先是行<code>permutation[0]</code>，然后是<code>permutation[1]</code>，依此类推。出于效率的考虑，需要排列组合以及它的逆向排列。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="aa3514d4a24a63ce70fe7e9486ad1688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3514d4a24a63ce70fe7e9486ad1688a">&#9670;&nbsp;</a></span>TPSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TPSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就地进行转置的包络SOR预处理。 转置的SOR方法按照<code>permutation</code>规定的顺序应用，即首先是行<code>permutation[<a class="el" href="classSparseMatrix.html#acff5838afad6b9d4cc0c0eb5f6c515b5">m()</a>-1]</code>，然后是<code>permutation[<a class="el" href="classSparseMatrix.html#acff5838afad6b9d4cc0c0eb5f6c515b5">m()</a>-2]</code>，依此类推。出于效率的考虑，需要用到permutation以及它的逆向。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="aa039cc30461321e4f54dd54e67e8ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa039cc30461321e4f54dd54e67e8ca36">&#9670;&nbsp;</a></span>Jacobi_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Jacobi_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个雅可比步骤。 对<code>b</code>做一个直接的雅可比步骤，右手边<code>b</code>。这个函数需要一个辅助向量，它从GrowingVectorMemory中获取。 </p>

</div>
</div>
<a id="a72eaf0aedbda317c83cd6b3fe460d995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72eaf0aedbda317c83cd6b3fe460d995">&#9670;&nbsp;</a></span>SOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个SOR步骤。 对右手边的<code>b</code>直接执行SOR步骤。 </p>

</div>
</div>
<a id="a36852dfbd7e9623dc96301d73fa2cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36852dfbd7e9623dc96301d73fa2cf22">&#9670;&nbsp;</a></span>TSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个邻接的SOR步骤。 对<code>b</code>做一个直接的TSOR步骤，右手边<code>b</code>。 </p>

</div>
</div>
<a id="a2d92814be1b12c114a2e86f7c7c9410c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d92814be1b12c114a2e86f7c7c9410c">&#9670;&nbsp;</a></span>SSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对<code>v</code>做一个SSOR步骤。 通过在SOR之后执行TSOR，对右手边的<code>b</code>直接执行SSOR步骤。 </p>

</div>
</div>
<a id="a419e25c734b10802f9c7f59d652f84ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419e25c734b10802f9c7f59d652f84ca">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向矩阵的第一个元素的迭代器。 注意这个类的一般文档中关于元素访问顺序的讨论。 </p>

</div>
</div>
<a id="ab0872bb70a86280328309c97c78bc39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0872bb70a86280328309c97c78bc39f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但是对于非恒定矩阵。 </p>

</div>
</div>
<a id="a24c613fbc2273dd9f16c716b1d4dc29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c613fbc2273dd9f16c716b1d4dc29f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个迭代器，指向这个矩阵的最后一个以上的元素。 </p>

</div>
</div>
<a id="a1aa99041df4c848c5b46180327c1e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa99041df4c848c5b46180327c1e9b5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但对于非静态矩阵。 </p>

</div>
</div>
<a id="a22cdd83806e88c53003d185ad639cd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cdd83806e88c53003d185ad639cd35">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向行 <code>r</code>. 第一个元素的迭代器 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器等于<code>end(r)</code>。在这种情况下，如果行 <code>r</code> 和以下任何一行都不包含任何非零条目，则返回的迭代器可能无法被解除引用。 </p>

</div>
</div>
<a id="abc32c2ee41aa5e02b5838ed9e3423919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc32c2ee41aa5e02b5838ed9e3423919">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但对于非恒定矩阵。 </p>

</div>
</div>
<a id="aac8d50d7700dbd8560af071e146979c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8d50d7700dbd8560af071e146979c0">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个指向第 <code>r</code> 行最后一个元素的迭代器，如果 <code>r</code> 之后的行根本不包含任何条目，则指向整个稀疏模式的末端。 请注意，结束迭代器不一定是可被解读的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 </p>

</div>
</div>
<a id="ad5bd553a69c0374c72195d4eb0158696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bd553a69c0374c72195d4eb0158696">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>像上面的函数一样，但是对于非恒定矩阵。 </p>

</div>
</div>
<a id="aa84c2e29d3b520c53a9695b42b3941c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84c2e29d3b520c53a9695b42b3941c5">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>diagonal_first</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵到给定的流，使用格式&lt;tt&gt;(row,column) value，即每行打印矩阵的一个非零条目。如果<code>across</code>为真，则在单行上打印所有条目，使用格式row,column:value。 如果参数<code>diagonal_first</code>为真，则二次方矩阵的对角线元素在其行中首先打印，对应于内部存储方案。如果它是假的，一行中的元素将按升列顺序写入。 </p>

</div>
</div>
<a id="a6456ebe393c32b076eae0b5c9811e0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6456ebe393c32b076eae0b5c9811e0c8">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>以通常的格式打印矩阵，即作为矩阵，而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。 参数允许对输出格式进行灵活设置。 <code>precision</code>和<code>scientific</code>用于确定数字格式，其中<code>scientific = false</code>表示固定点符号。 <code>width</code>的一个零条目使函数计算出一个宽度，但如果输出粗略的话，可以将其改为一个正值。 此外，还可以指定一个空值的字符。 最后，整个矩阵可以与一个共同的分母相乘，以产生更可读的输出，甚至是整数。 </p><dl class="section attention"><dt>Attention</dt><dd>如果应用于一个大的矩阵，这个函数可能会产生<b>large</b>量的输出! </dd></dl>

</div>
</div>
<a id="a737f5df58f2bf6ab275ed382ed725abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737f5df58f2bf6ab275ed382ed725abb">&#9670;&nbsp;</a></span>print_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_pattern </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵的实际模式。对于每个绝对值大于阈值的条目，打印一个'*'，对于每个较小的数值打印一个':'，对于每个未分配的条目打印一个'.'。 </p>

</div>
</div>
<a id="a3141075e3ad6362fce005d2f1c8da699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3141075e3ad6362fce005d2f1c8da699">&#9670;&nbsp;</a></span>print_as_numpy_arrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_as_numpy_arrays </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵打印到输出流 <code>out</code> 中，其格式可以被 numpy::readtxt(). 读取 要在python中加载矩阵，只需做<code> [data, row, column] = numpy.loadtxt('my_matrix.txt') sparse_matrix = scipy.sparse.csr_matrix((data, (row, column)) </code> </p>

</div>
</div>
<a id="a8b32b99a054482f06fc026248c27bb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b32b99a054482f06fc026248c27bb74">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>把这个对象的数据全部写到一个文件中。这是以二进制模式进行的，所以输出的数据既不能被人类阅读，也不能（可能）被其他使用不同操作系统的数字格式的计算机阅读。 这个函数的目的是，如果你的内存不足，想在不同的程序之间进行交流，或者允许对象在程序的不同运行中持续存在，你可以把矩阵和稀疏模式换出来。 </p>

</div>
</div>
<a id="a9b670368c98d6392ff8c9284db0622b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b670368c98d6392ff8c9284db0622b2">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从文件中读取先前由block_write()写入的数据。 这是用上述函数的逆运算来完成的，所以它的速度相当快，因为除了前面的几个数字，比特流是不被解释的。 在这个操作中，对象被调整了大小，所有以前的内容都会丢失。然而，请注意，没有对新数据和底层的SparsityPattern对象是否适合在一起进行检查。你有责任确保稀疏度模式和要读取的数据是匹配的。 一个原始形式的错误检查会被执行，它将识别最直白的尝试，即把一些数据解释为一个矩阵，以比特方式存储到一个实际上不是这样创建的文件中，但不是更多。 </p>

</div>
</div>
<a id="a1debf998b61291d913dfac4c8a22eaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1debf998b61291d913dfac4c8a22eaa7">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于某些矩阵存储格式，特别是PETSc分布式块矩阵，对单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。 BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。 这个函数确保矩阵处于一个允许添加元素的状态；如果它之前已经处于这个状态，那么这个函数就不会做任何事情。 </p>

</div>
</div>
<a id="a9f68a9f93813ca167dc9f39624be2f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f68a9f93813ca167dc9f39624be2f5b">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ad66f15847b7c27c5898f3b859d6cfe05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad66f15847b7c27c5898f3b859d6cfe05">&#9670;&nbsp;</a></span>SparseMatrix</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseMatrix.html">SparseMatrix</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于稀疏矩阵类型的类型定义</p>
<p>用于描述稀疏矩阵类型的类型定义。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01517">1517</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ab3b41703cc0d0eea14c99c2bac2c5149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b41703cc0d0eea14c99c2bac2c5149">&#9670;&nbsp;</a></span>SparseLUDecomposition</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01519">1519</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a821b53e73219682e8d8efdacd3571e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a821b53e73219682e8d8efdacd3571e62">&#9670;&nbsp;</a></span>SparseILU</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseILU.html">SparseILU</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01521">1521</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac35c04bb7fa6f87652d7749935baaaf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35c04bb7fa6f87652d7749935baaaf1">&#9670;&nbsp;</a></span>BlockMatrixBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01525">1525</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aadb72d74c6d5421b8bdf522916064359"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadb72d74c6d5421b8bdf522916064359">&#9670;&nbsp;</a></span>SparseMatrixIterators::Iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename , bool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01529">1529</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a8834e738affcd56700ea78a3cbb7e051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8834e738affcd56700ea78a3cbb7e051">&#9670;&nbsp;</a></span>SparseMatrixIterators::Accessor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename , bool &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classSparseMatrixIterators_1_1Accessor.html">SparseMatrixIterators::Accessor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01531">1531</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a9b7cc79151e928ea71a124bdebc02833"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7cc79151e928ea71a124bdebc02833">&#9670;&nbsp;</a></span>Utilities::MPI::sum</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">Utilities::MPI::sum</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a345be12c610d63bb10f4fa6a1be14f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345be12c610d63bb10f4fa6a1be14f9e">&#9670;&nbsp;</a></span>cols</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt; &gt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::cols</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向该矩阵使用的稀疏模式的指针。为了保证它在使用中不被删除，我们使用SmartPointer类来订阅它。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01501">1501</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ab7e5b9eb6ad7c45635d346de98b1c1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e5b9eb6ad7c45635d346de98b1c1e5">&#9670;&nbsp;</a></span>val</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;number[]&gt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::val</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>所有非零条目的数值数组。一个条目在矩阵中的位置，也就是这个数组中给定值的行号和列号，只能用稀疏模式来推导。同样的道理也适用于更常见的通过坐标寻找一个条目的操作。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01507">1507</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ad183b90df780534d2143a45d97668de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad183b90df780534d2143a45d97668de3">&#9670;&nbsp;</a></span>max_len</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::max_len</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>拨出的::val的大小。如果在过去的某个时候，通过使用reinit()函数将具有较小尺寸的稀疏模式关联到该对象，从而减少了矩阵的尺寸，那么这个尺寸可能大于实际使用的部分。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l01513">1513</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
