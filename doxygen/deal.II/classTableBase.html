<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTableBase.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TableBase&lt; N, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classTableBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TableBase&lt; N, T &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a> &raquo; <a class="el" href="group__data.html">Data storage primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="table_8h_source.html">deal.II/base/table.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TableBase&lt; N, T &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTableBase__inherit__graph.svg" width="2274" height="716"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a91dbd84881f529bc6e026fb7dccd8a14"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a91dbd84881f529bc6e026fb7dccd8a14">value_type</a> = T</td></tr>
<tr class="separator:a91dbd84881f529bc6e026fb7dccd8a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630e675ce95aabc0a759a30f0bc1c20d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> = typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::<a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a></td></tr>
<tr class="separator:a630e675ce95aabc0a759a30f0bc1c20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aaee05c9fdcfe902905b8f366cdc9ecf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aaee05c9fdcfe902905b8f366cdc9ecf8">TableBase</a> ()=default</td></tr>
<tr class="separator:aaee05c9fdcfe902905b8f366cdc9ecf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af15af459bf3b300499ded46de0b2eec0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af15af459bf3b300499ded46de0b2eec0">TableBase</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;sizes)</td></tr>
<tr class="separator:af15af459bf3b300499ded46de0b2eec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b08c4ce198f3c4a697813a56db00a18"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:a8b08c4ce198f3c4a697813a56db00a18"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a8b08c4ce198f3c4a697813a56db00a18">TableBase</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;sizes, InputIterator entries, const <a class="el" href="classbool.html">bool</a> C_style_indexing=true)</td></tr>
<tr class="separator:a8b08c4ce198f3c4a697813a56db00a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9996bc992edcbcc2d349554c6097249"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab9996bc992edcbcc2d349554c6097249">TableBase</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;src)</td></tr>
<tr class="separator:ab9996bc992edcbcc2d349554c6097249"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736feb31b90fcba77fd410ffe70b2622"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:a736feb31b90fcba77fd410ffe70b2622"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a736feb31b90fcba77fd410ffe70b2622">TableBase</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;src)</td></tr>
<tr class="separator:a736feb31b90fcba77fd410ffe70b2622"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3168edb85b2dbb6f3ad5780a9c66b8e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af3168edb85b2dbb6f3ad5780a9c66b8e">TableBase</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="separator:af3168edb85b2dbb6f3ad5780a9c66b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6af75136b8d0e86919723e0d95fceb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a5d6af75136b8d0e86919723e0d95fceb">~TableBase</a> () override=default</td></tr>
<tr class="separator:a5d6af75136b8d0e86919723e0d95fceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecddb439075ebc7f16d5e84100fba019"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aecddb439075ebc7f16d5e84100fba019">operator=</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;src)</td></tr>
<tr class="separator:aecddb439075ebc7f16d5e84100fba019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0802d78342f566c36c5e7b6639bd42c"><td class="memTemplParams" colspan="2">template&lt;typename T2 &gt; </td></tr>
<tr class="memitem:ab0802d78342f566c36c5e7b6639bd42c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab0802d78342f566c36c5e7b6639bd42c">operator=</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;src)</td></tr>
<tr class="separator:ab0802d78342f566c36c5e7b6639bd42c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaae8c4afa0c962eb9c61f477f627eac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#afaae8c4afa0c962eb9c61f477f627eac">operator=</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;src) noexcept</td></tr>
<tr class="separator:afaae8c4afa0c962eb9c61f477f627eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa998401367252589f5a4bdd7d8087380"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aa998401367252589f5a4bdd7d8087380">operator==</a> (const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;T2) const</td></tr>
<tr class="separator:aa998401367252589f5a4bdd7d8087380"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af0e75a7ccd3359dccbddc0934bc1bf27">reset_values</a> ()</td></tr>
<tr class="separator:af0e75a7ccd3359dccbddc0934bc1bf27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a302ef67031a523602fd39911b968d6ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a302ef67031a523602fd39911b968d6ab">reinit</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;new_size, const <a class="el" href="classbool.html">bool</a> omit_default_initialization=false)</td></tr>
<tr class="separator:a302ef67031a523602fd39911b968d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2204c132154b5d6bfd571eb85d8a58f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:af2204c132154b5d6bfd571eb85d8a58f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#aaba8a3da6e403297e8d2b231e9d6c35f">size</a> () const</td></tr>
<tr class="separator:aaba8a3da6e403297e8d2b231e9d6c35f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67161f19c760e98588bdecc560285d2d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements</a> () const</td></tr>
<tr class="separator:a67161f19c760e98588bdecc560285d2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#abb7b890ac4bbcba1b6524b45af1cbfd9">empty</a> () const</td></tr>
<tr class="separator:abb7b890ac4bbcba1b6524b45af1cbfd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:ad54a19dddbed32640b977b4d7948b434"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad54a19dddbed32640b977b4d7948b434">fill</a> (InputIterator entries, const <a class="el" href="classbool.html">bool</a> C_style_indexing=true)</td></tr>
<tr class="separator:ad54a19dddbed32640b977b4d7948b434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2a0d148a657080f22dc7c4f213c5a8ee">fill</a> (const T &amp;value)</td></tr>
<tr class="separator:a2a0d148a657080f22dc7c4f213c5a8ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b90cda631253866e0f2fa02d714e6b0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2b90cda631253866e0f2fa02d714e6b0">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:a2b90cda631253866e0f2fa02d714e6b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2966017e02f461809ff90eb8f4c86ed3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2966017e02f461809ff90eb8f4c86ed3">operator()</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a2966017e02f461809ff90eb8f4c86ed3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1959c3a73b399248ccda523c66831a01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a1959c3a73b399248ccda523c66831a01">replicate_across_communicator</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator, const unsigned <a class="el" href="classint.html">int</a> root_process)</td></tr>
<tr class="separator:a1959c3a73b399248ccda523c66831a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140815b9435c997be48f439634afc4f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a140815b9435c997be48f439634afc4f5">swap</a> (<a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;v)</td></tr>
<tr class="separator:a140815b9435c997be48f439634afc4f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c63db9ae49e0e3b099f0244801016f2"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2c63db9ae49e0e3b099f0244801016f2">memory_consumption</a> () const</td></tr>
<tr class="separator:a2c63db9ae49e0e3b099f0244801016f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aee01f8890040d7b480fc0c72e19f6711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#aee01f8890040d7b480fc0c72e19f6711">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:aee01f8890040d7b480fc0c72e19f6711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:ab8546237d4c76440bfaed5e1818cdd90"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ab8546237d4c76440bfaed5e1818cdd90">position</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:ab8546237d4c76440bfaed5e1818cdd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4474b545894de5a80f3fdacb9ead38c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#ad4474b545894de5a80f3fdacb9ead38c">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices)</td></tr>
<tr class="separator:ad4474b545894de5a80f3fdacb9ead38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a9979fda00a9293c3fa6a6df97639e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;::const_reference&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a40a9979fda00a9293c3fa6a6df97639e">el</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;indices) const</td></tr>
<tr class="separator:a40a9979fda00a9293c3fa6a6df97639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt; T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#a50beea2748a06b3abb8d65d5fe7aa8aa">values</a></td></tr>
<tr class="separator:a50beea2748a06b3abb8d65d5fe7aa8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33df922c5081e1b69e73027cacdaa95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTableBase.html#af33df922c5081e1b69e73027cacdaa95">table_size</a></td></tr>
<tr class="separator:af33df922c5081e1b69e73027cacdaa95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2b417c0141e8f8a1800830f237577112"><td class="memTemplParams" colspan="2">template&lt;int , typename &gt; </td></tr>
<tr class="memitem:a2b417c0141e8f8a1800830f237577112"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTableBase.html#a2b417c0141e8f8a1800830f237577112">TableBase</a></td></tr>
<tr class="separator:a2b417c0141e8f8a1800830f237577112"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int N, typename T&gt;<br />
class TableBase&lt; N, T &gt;</h3>

<p>一个持有多维数组的模板类型的对象的类。如果表示维数的模板参数是一个，那么这个类或多或少代表了一个向量；如果是两个，那么它就是一个矩阵；以此类推。 这个类特别取代了对高维数组的尝试，如 <code>std::vector&lt;std::vector&lt;T&gt;&gt;</code>, 或甚至更高的嵌套结构。这些结构体的缺点是很难初始化，最重要的是，如果一个矩阵或高维表的所有行都有相同的大小（这是通常的情况），那么它们的效率就非常低，因为此时每一行的内存都是独立分配的，既浪费时间又浪费内存。这可以通过为整个对象只分配一大块内存而变得更有效率，这就是当前类的做法。</p>
<h3>Comparison with the <a class="el" href="classTensor.html">Tensor</a> class</h3>
<p>在某种程度上，这个类类似于张量类，因为它对维数进行模板化。然而，有两个主要区别。第一是Tensor类只存储数值（如<code>double</code>s），而Table类存储任意的对象。第二是张量类在每个维度都有固定的尺寸，也是作为模板参数给出的，而这个类可以在每个维度处理任意的、不同的尺寸。 这有两个后果。首先，由于在编译时不知道大小，它必须进行显式内存分配。其次，各个元素的布局在编译时并不知道，所以访问速度比张量类慢，在张量类中，元素的数量和它们的位置在编译时就已经知道了，而且编译器可以利用这些知识进行优化（例如在展开循环的时候）。另一方面，这个类当然更灵活，例如，当你想要一个二维表，其行数等于单元格的自由度数，列数等于正交点的数量。这两个数字可能只有在运行时才知道，所以这里需要一个灵活的表格。此外，你可能想存储，例如，形状函数的梯度，所以数据类型不是单一的标量值，而是张量本身。</p>
<h3>Dealing with large data sets</h3>
<p>表类（派生自该类）经常被用来存储大型数据表。在 <a class="el" href="step_53.html">step-53</a> 中给出了一个适度的例子，我们存储了一个 \(380 \times 220\) 非洲地区的地理海拔数据的表，这个数据需要大约670 kB，如果内存；然而，存储三维或更多维度数据的表（例如，关于地球内部的密度、压力和温度的信息，在<code>（纬度、经度、深度）</code>点的规则网格上）可以轻松达到数百兆字节或更多。这些表格通常被提供给诸如InterpolatedTensorProductGridData或InterpolatedUniformGridData等类。 如果你需要在单处理器（或多线程）作业中加载这样的表，那么你对这些表的大小无能为力。该表只需适合内存即可。但是，如果你的程序是通过MPI并行化的，那么典型的第一种实现方式是在每个进程上创建一个表对象，并通过从文件中读取数据在每个MPI进程上填充它。这从两个方面来说是低效的。</p>
<ul>
<li>你会有很多进程同时试图从同一个文件中读取数据。</li>
<li>在大多数情况下，每个进程上存储的数据都是一样的，虽然每个进程都需要能够从表中读取数据，但没有必要每个进程都存储自己的表。碰巧位于同一台机器上的所有MPI进程不妨只存储一个副本，并通过<a href="https://en.wikipedia.org/wiki/Shared_memory">共享内存</a>使其彼此可用；在这种模式下，每台机器只有一个MPI进程需要存储数据，然后所有其他进程可以访问它。 这两种用例都是由内部基于 <a class="el" href="classAlignedVector.html#ad4dcb894546bc3211462aa0da2dbe570">AlignedVector::replicate_across_communicator()</a>. 的 <a class="el" href="classTableBase.html#a1959c3a73b399248ccda523c66831a01">TableBase::replicate_across_communicator()</a> 函数实现的，该函数允许像下面这样的工作流程，我们让那个等级为0的MPI进程负责读取数据（但它也可以是任何其他 "根等级"）。</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>=..., M=...;     <span class="comment">// table sizes, assumed known</span></div><div class="line"><a class="code" href="classTable.html">Table&lt;2,double&gt;</a>    data_table;</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> root_rank = 0;</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == root_rank)</div><div class="line">{</div><div class="line">  data_table.resize (N,M);</div><div class="line"></div><div class="line">  std::ifstream input_file (<span class="stringliteral">&quot;data_file.dat&quot;</span>);</div><div class="line">  ...;                               <span class="comment">// read the data from the file</span></div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Now distribute to all processes</span></div><div class="line">data_table.replicate_across_communicator (mpi_communicator, root_rank);</div></div><!-- fragment --><p>这段代码中的最后一个调用确保数据在所有非根进程中可用，方法是在其他进程的内存空间中重新创建一个表的副本，或者，如果可能的话，在共享内存中为位于MPI作业使用的每台机器上的所有进程创建一次副本。 </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00347">347</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a91dbd84881f529bc6e026fb7dccd8a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dbd84881f529bc6e026fb7dccd8a14">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html#a91dbd84881f529bc6e026fb7dccd8a14">value_type</a> =  T</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00350">350</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="a630e675ce95aabc0a759a30f0bc1c20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630e675ce95aabc0a759a30f0bc1c20d">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> =  typename <a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::<a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用来计算这个容器中的元素数量的整数类型。 </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00356">356</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="aaee05c9fdcfe902905b8f366cdc9ecf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee05c9fdcfe902905b8f366cdc9ecf8">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认构造函数。将所有尺寸设置为零。 </p>

</div>
</div>
<a id="af15af459bf3b300499ded46de0b2eec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af15af459bf3b300499ded46de0b2eec0">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。用每个索引组件中的给定尺寸初始化数组。 </p>

</div>
</div>
<a id="a8b08c4ce198f3c4a697813a56db00a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b08c4ce198f3c4a697813a56db00a18">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。在每个索引组件中用给定的尺寸初始化数组，然后通过调用fill( entries,C_style_indexing)，用第二个和第三个参数初始化表格中的元素。 </p>

</div>
</div>
<a id="ab9996bc992edcbcc2d349554c6097249"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9996bc992edcbcc2d349554c6097249">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝构造函数。执行一个深度拷贝。 </p>

</div>
</div>
<a id="a736feb31b90fcba77fd410ffe70b2622"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736feb31b90fcba77fd410ffe70b2622">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝构造函数。从存储其他数据类型的表对象中执行深度拷贝。 </p>

</div>
</div>
<a id="af3168edb85b2dbb6f3ad5780a9c66b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3168edb85b2dbb6f3ad5780a9c66b8e">&#9670;&nbsp;</a></span>TableBase() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。转移另一个表的内容。 </p>

</div>
</div>
<a id="a5d6af75136b8d0e86919723e0d95fceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6af75136b8d0e86919723e0d95fceb">&#9670;&nbsp;</a></span>~TableBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::~<a class="el" href="classTableBase.html">TableBase</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解除构造函数。释放分配的内存。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aecddb439075ebc7f16d5e84100fba019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecddb439075ebc7f16d5e84100fba019">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt;N, T&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>赋值运算符。将<code>src</code>的所有元素复制到矩阵中。 如果需要，大小会被调整。 我们不能使用其他的、模板化的版本，因为如果我们不声明这个版本，编译器会很高兴地生成一个预定义的复制操作符，这不是我们想要的。 </p>

</div>
</div>
<a id="ab0802d78342f566c36c5e7b6639bd42c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0802d78342f566c36c5e7b6639bd42c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt;N, T&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>拷贝操作符。将<code>src</code>的所有元素复制到数组中。如果需要的话，大小会被调整。 这个函数要求<code>T2</code>的类型可以转换为<code>T</code>。 </p>

</div>
</div>
<a id="afaae8c4afa0c962eb9c61f477f627eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaae8c4afa0c962eb9c61f477f627eac">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html">TableBase</a>&lt;N, T&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符。将<code>src</code>的所有元素转移到表中。 </p>

</div>
</div>
<a id="aa998401367252589f5a4bdd7d8087380"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa998401367252589f5a4bdd7d8087380">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>T2</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试两个表的相等。 </p>

</div>
</div>
<a id="af0e75a7ccd3359dccbddc0934bc1bf27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0e75a7ccd3359dccbddc0934bc1bf27">&#9670;&nbsp;</a></span>reset_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reset_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将所有条目设置为默认值（即用默认构造的对象将它们复制过来）。但不要改变表的大小。 </p>

</div>
</div>
<a id="a302ef67031a523602fd39911b968d6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a302ef67031a523602fd39911b968d6ab">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_default_initialization</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将此对象的尺寸设置为第一个参数中给出的尺寸，并为表项分配所需的内存以适应这些尺寸。如果 <code>omit_default_initialization</code> 被设置为 <code>false</code>, ，表的所有元素都被设置为元素类型的默认构造对象。否则，内存将处于未初始化或其他未定义的状态。 </p>

</div>
</div>
<a id="af2204c132154b5d6bfd571eb85d8a58f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2204c132154b5d6bfd571eb85d8a58f">&#9670;&nbsp;</a></span>size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>表的大小在<code>i</code>方向。 </p>

</div>
</div>
<a id="aaba8a3da6e403297e8d2b231e9d6c35f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaba8a3da6e403297e8d2b231e9d6c35f">&#9670;&nbsp;</a></span>size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt;&amp; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个对象在每个方向上的大小。 </p>

</div>
</div>
<a id="a67161f19c760e98588bdecc560285d2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67161f19c760e98588bdecc560285d2d">&#9670;&nbsp;</a></span>n_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::n_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回存储在此对象中的元素数量，它是每个维度上的扩展量的乘积。 </p>

</div>
</div>
<a id="abb7b890ac4bbcba1b6524b45af1cbfd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb7b890ac4bbcba1b6524b45af1cbfd9">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该对象是否为空，即其中一个方向为零。 这等同于<code><a class="el" href="classTableBase.html#a67161f19c760e98588bdecc560285d2d">n_elements()</a>==0</code>。 </p>

</div>
</div>
<a id="ad54a19dddbed32640b977b4d7948b434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54a19dddbed32640b977b4d7948b434">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename InputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">InputIterator&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>C_style_indexing</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过解引用给定的前向迭代器（例如，可以是一个指向数组第一个元素的指针，或者一个插入 std::istream_iterator). 第二个参数表示所指向的元素的排列方式是对应于最后一个索引运行最快还是最慢。默认情况下，使用C风格的索引，即最后一个索引运行最快（与Fortran风格相反，当遍历多维数组时，第一个索引运行最快。例如，如果你试图填充一个Table&lt;2,T&gt;类型的对象，那么用第二个参数的默认值来调用这个函数将导致等同于做 </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(0); ++i)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(1); ++j)</div><div class="line">    t[i][j] =entries++;</div></div><!-- fragment --><p> 另一方面，如果这个函数的第二个参数是假的，那么这将导致以下形式的代码。 </p><div class="fragment"><div class="line"><a class="code" href="classTable_3_012_00_01T_01_4.html">Table&lt;2,T&gt;</a> t;</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j=0; j&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(1); ++j)</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;t.<a class="code" href="classTableBase.html#af2204c132154b5d6bfd571eb85d8a58f">size</a>(0); ++i)</div><div class="line">    t[i][j] =entries++;</div></div><!-- fragment --><p> 注意我们通过遍历给定的迭代器集合来填充表元素的转换顺序。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">entries</td><td>一个迭代器，用于初始化这个表的元素集。假设迭代器可以被递增和取消引用足够多的次数来填充这个表。 </td></tr>
    <tr><td class="paramname">C_style_indexing</td><td>如果是true，当我们解指输入范围的后续元素时，以最后一个索引最快的速度运行该表的元素。如果为假，则最快改变第一个索引。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2a0d148a657080f22dc7c4f213c5a8ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a0d148a657080f22dc7c4f213c5a8ee">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用相同的值填充所有的表项。 </p>

</div>
</div>
<a id="a2b90cda631253866e0f2fa02d714e6b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b90cda631253866e0f2fa02d714e6b0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对指定元素的读写引用。 </p>

</div>
</div>
<a id="a2966017e02f461809ff90eb8f4c86ed3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2966017e02f461809ff90eb8f4c86ed3">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::const_reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回指定元素的值作为只读引用。 我们将请求的值作为一个常量引用而不是按值返回，因为这个对象可能持有的数据类型可能很大，而且我们在这里不知道复制是否昂贵。 </p>

</div>
</div>
<a id="a1959c3a73b399248ccda523c66831a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1959c3a73b399248ccda523c66831a01">&#9670;&nbsp;</a></span>replicate_across_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::replicate_across_communicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>root_process</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数在MPI通信器的所有进程中复制由 <code>root_process</code> 指示的进程上发现的状态。在 <code>root_process</code> 以外的任何进程中发现的当前状态都会在这个进程中丢失。我们可以想象这个操作就像从根进程到所有其他进程对 <a class="el" href="namespaceUtilities_1_1MPI.html#a128aed5c46be49d692bbbc3a23424c36">Utilities::MPI::broadcast()</a> 的调用，尽管在实践中这个函数可能试图将数据移动到每个承载MPI进程的机器上的共享内存区域，然后让这个机器上的所有MPI进程访问这个共享内存区域，而不是保留自己的副本。请看这个类的一般文档中的代码例子。 这个函数的意图是将大的数组从一个进程快速交换给其他进程，而不是在所有进程上计算或创建它。这特别适用于从磁盘加载的数据</p>
<ul>
<li>说，大的数据表</li>
</ul>
<p>比起让每个进程自己从磁盘上读取数据，通过读取一次，然后在MPI宇宙中的所有进程中分发，更容易处理。 具体来说，共享内存区域的使用允许在MPI宇宙中每个多核机器上只复制一次数据，而不是为每个MPI进程复制一次数据。如果今天的机器上的数据很大，每个共享内存空间可以很容易地容纳几十个MPI进程，这就可以节省大量内存。 这个功能并不意味着保持不同进程的数据同步，就像 parallel::distributed::Vector 和其他矢量类所做的那样，存在一个由每个进程拥有的矢量的某些元素的概念，可能还有从其拥有的进程镜像到其他进程的幽灵元素。相反，当前对象的元素被简单地复制到其他进程中，把这个操作看作是在所有进程中创建一组<code>const</code>AlignedVector对象，在复制操作之后不应该再被改变，这是确保向量在所有进程中保持一致的唯一方法。这尤其是因为共享内存区域的使用，在一个MPI进程上对一个向量元素的任何修改也可能导致对其他进程上可见元素的修改，假设它们位于一个共享内存节点内。 </p><dl class="section note"><dt>Note</dt><dd>在MPI进程之间使用共享内存需要检测的MPI安装支持必要的操作。 这对于MPI 3.0和更高版本来说是这样的。 </dd>
<dd>
这个功能并不便宜。它需要创建所提供 <code>communicator</code> 对象的子通信器，这通常是一个昂贵的操作。同样地，共享内存空间的生成也不是一个便宜的操作。因此，当目标是在进程之间共享大的只读数据表时，这个功能主要是有意义的；例子是在启动时加载数据表，然后在程序的运行时间内使用。 在这种情况下，运行这个函数的启动成本可以随着时间的推移而摊销，而且在具有大核心数的机器上，许多MPI进程在同一台机器上运行时，不必在每个进程上存储表所带来的潜在内存节省可能是相当大的。 </dd>
<dd>
这个函数只有在数据类型<code>T</code>是 "自足
"的情况下才有意义，也就是说，它的所有信息都存储在其成员变量中，并且没有一个成员变量是指向内存的其他部分的指针。这是因为如果一个类型<code>T</code>确实有指向内存其他部分的指针，那么将<code>T</code>移到共享内存空间不会导致其他进程访问该对象用其成员变量指针指向的数据。这些数据仍然只存在于一个进程中，并且通常在其他进程无法访问的内存区域。 因此，这个函数的通常使用情况是共享简单对象的数组，如<code>double's或</code>int's。 </dd>
<dd>
调用该函数后，不同MPI进程的对象共享一个共同的状态。这意味着某些操作变得 "集体"，即必须在所有参与的处理器上同时调用。特别是，你不能再在一个MPI进程上调用resize()、reserve()或clear()。</dd></dl>
<ul>
<li>你必须在所有进程上同时这样做，因为它们必须为这些操作进行通信。如果你不这样做，你很可能会得到一个死锁，可能很难调试。推而广之，这个只集体调整大小的规则也延伸到这个函数本身。你不能连续调用它两次，因为这意味着首先除了<code>root_process'以外的所有进程都要扔掉他们的数据，这不是一个集体操作。一般来说，这些关于可以做什么和不可以做什么的限制，暗示了上面评论的正确性。你应该把一个当前函数被调用的AlignedVector视为</code>const'，在调用析构器之前，不能对其进行进一步的操作。 </li>
</ul>

</div>
</div>
<a id="a140815b9435c997be48f439634afc4f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140815b9435c997be48f439634afc4f5">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换这个表和另一个表的内容 <code>v</code>. 人们可以用一个临时变量和复制过来的数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。 这个函数类似于所有C++标准容器的 <code>swap</code> 函数。此外，还有一个全局函数<code>swap(u,v)</code>，它简单地调用<code>u.swap(v)</code>，同样与标准函数相类似。 </p>

</div>
</div>
<a id="a2c63db9ae49e0e3b099f0244801016f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c63db9ae49e0e3b099f0244801016f2">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="aee01f8890040d7b480fc0c72e19f6711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee01f8890040d7b480fc0c72e19f6711">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>将此对象的数据写入或读出到一个流中，以便进行序列化。 </p>

</div>
</div>
<a id="ab8546237d4c76440bfaed5e1818cdd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8546237d4c76440bfaed5e1818cdd90">&#9670;&nbsp;</a></span>position()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableBase.html#a630e675ce95aabc0a759a30f0bc1c20d">size_type</a> <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定元素在一个接一个存储的元素阵列中的位置。这个函数不做索引检查。 </p>

</div>
</div>
<a id="ad4474b545894de5a80f3fdacb9ead38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4474b545894de5a80f3fdacb9ead38c">&#9670;&nbsp;</a></span>el() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对指定元素的读写引用。 这个函数不做边界检查，只在内部和已经检查过的函数中使用。 </p>

</div>
</div>
<a id="a40a9979fda00a9293c3fa6a6df97639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40a9979fda00a9293c3fa6a6df97639e">&#9670;&nbsp;</a></span>el() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt;::const_reference <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; N &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回指定元素的值，作为一个只读引用。 这个函数不做边界检查，只在内部和已经检查过的函数中使用。 我们将请求的值作为一个常数引用而不是按值返回，因为这个对象可能持有的数据类型可能很大，而且我们在这里不知道复制是否昂贵。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2b417c0141e8f8a1800830f237577112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b417c0141e8f8a1800830f237577112">&#9670;&nbsp;</a></span>TableBase</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<div class="memtemplate">
template&lt;int , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTableBase.html">TableBase</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00635">635</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a50beea2748a06b3abb8d65d5fe7aa8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50beea2748a06b3abb8d65d5fe7aa8aa">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAlignedVector.html">AlignedVector</a>&lt;T&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::values</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>组件-数组。 </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00625">625</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<a id="af33df922c5081e1b69e73027cacdaa95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33df922c5081e1b69e73027cacdaa95">&#9670;&nbsp;</a></span>table_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTableIndices.html">TableIndices</a>&lt;N&gt; <a class="el" href="classTableBase.html">TableBase</a>&lt; N, T &gt;::table_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>表的每个方向上的大小。 </p>

<p class="definition">Definition at line <a class="el" href="table_8h_source.html#l00631">631</a> of file <a class="el" href="table_8h_source.html">table.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="table_8h_source.html">table.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
