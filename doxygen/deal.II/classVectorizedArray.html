<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classVectorizedArray.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: VectorizedArray&lt; Number, width &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classVectorizedArray-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">VectorizedArray&lt; Number, width &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="vectorization_8h_source.html">deal.II/base/vectorization.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for VectorizedArray&lt; Number, width &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classVectorizedArray__inherit__graph.svg" width="440" height="366"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad5e3061a2d2cf13c446354059e6fa8ef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ad5e3061a2d2cf13c446354059e6fa8ef">value_type</a> = Number</td></tr>
<tr class="separator:ad5e3061a2d2cf13c446354059e6fa8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5ffe4e7bfe1dc8ff28ce26e79776f0cd"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a5ffe4e7bfe1dc8ff28ce26e79776f0cd">VectorizedArray</a> ()=default</td></tr>
<tr class="separator:a5ffe4e7bfe1dc8ff28ce26e79776f0cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6367cca1b81fc817e58f1d961d223fc4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a6367cca1b81fc817e58f1d961d223fc4">VectorizedArray</a> (const Number scalar)</td></tr>
<tr class="separator:a6367cca1b81fc817e58f1d961d223fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bab1253b131475943b076b83179ae76"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a4bab1253b131475943b076b83179ae76">operator=</a> (const Number scalar)</td></tr>
<tr class="separator:a4bab1253b131475943b076b83179ae76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8bdefac7d751bef7e42be5dae12fa"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a99f8bdefac7d751bef7e42be5dae12fa">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> comp)</td></tr>
<tr class="separator:a99f8bdefac7d751bef7e42be5dae12fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40f56a62c0f7c527629540a7af0d9d0"><td class="memItemLeft" align="right" valign="top">const Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ab40f56a62c0f7c527629540a7af0d9d0">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> comp) const</td></tr>
<tr class="separator:ab40f56a62c0f7c527629540a7af0d9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23cd28d5bd07f3944d7e56fe33f652fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a23cd28d5bd07f3944d7e56fe33f652fc">operator+=</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;vec)</td></tr>
<tr class="separator:a23cd28d5bd07f3944d7e56fe33f652fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff4825de67b123e97613fd1f1dd96436"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#aff4825de67b123e97613fd1f1dd96436">operator-=</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;vec)</td></tr>
<tr class="separator:aff4825de67b123e97613fd1f1dd96436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab5595f01cf6de1bb959befa44bb6603"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#aab5595f01cf6de1bb959befa44bb6603">operator*=</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;vec)</td></tr>
<tr class="separator:aab5595f01cf6de1bb959befa44bb6603"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ed02d36053ebd2d903eac17fc832d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a73ed02d36053ebd2d903eac17fc832d2">operator/=</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;vec)</td></tr>
<tr class="separator:a73ed02d36053ebd2d903eac17fc832d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0c3d5bcdf208c37fc1f8055765c03b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ab0c3d5bcdf208c37fc1f8055765c03b1">load</a> (const Number *ptr)</td></tr>
<tr class="separator:ab0c3d5bcdf208c37fc1f8055765c03b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2cef2c40dbc7871c7c702bc0cfe533"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a9f2cef2c40dbc7871c7c702bc0cfe533">store</a> (Number *ptr) const</td></tr>
<tr class="separator:a9f2cef2c40dbc7871c7c702bc0cfe533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5fa52c39ffcb5a2e740552a92833009"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ae5fa52c39ffcb5a2e740552a92833009">streaming_store</a> (Number *ptr) const</td></tr>
<tr class="separator:ae5fa52c39ffcb5a2e740552a92833009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137b7cf45664efddbc332cad9c5c8839"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a137b7cf45664efddbc332cad9c5c8839">gather</a> (const Number *base_ptr, const unsigned <a class="el" href="classint.html">int</a> *offsets)</td></tr>
<tr class="separator:a137b7cf45664efddbc332cad9c5c8839"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa05c67eb5742dc4eea633174e8a88986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#aa05c67eb5742dc4eea633174e8a88986">scatter</a> (const unsigned <a class="el" href="classint.html">int</a> *offsets, Number *base_ptr) const</td></tr>
<tr class="separator:aa05c67eb5742dc4eea633174e8a88986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3079ced5292fcebec8a4ff8a6bdb0f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html#ac3079ced5292fcebec8a4ff8a6bdb0f0">begin</a> ()</td></tr>
<tr class="separator:ac3079ced5292fcebec8a4ff8a6bdb0f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abc43c177332ab7133ae7b42850c3cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt; const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html#a4abc43c177332ab7133ae7b42850c3cc">begin</a> () const</td></tr>
<tr class="separator:a4abc43c177332ab7133ae7b42850c3cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e62fef92c4dd89eee5bcd616be5ef0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html#a78e62fef92c4dd89eee5bcd616be5ef0">end</a> ()</td></tr>
<tr class="separator:a78e62fef92c4dd89eee5bcd616be5ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60230d197dc20a35c0fe0289e4a03b53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt; const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html#a60230d197dc20a35c0fe0289e4a03b53">end</a> () const</td></tr>
<tr class="separator:a60230d197dc20a35c0fe0289e4a03b53"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acb35404acc1693aee6e990228924cc09"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size</a> ()</td></tr>
<tr class="separator:acb35404acc1693aee6e990228924cc09"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ad38190d02537705964e021da7ecbab3f"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ad38190d02537705964e021da7ecbab3f">data</a></td></tr>
<tr class="separator:ad38190d02537705964e021da7ecbab3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac3828c2f77428ee28013df11e678a897"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ac3828c2f77428ee28013df11e678a897">get_sqrt</a> () const</td></tr>
<tr class="separator:ac3828c2f77428ee28013df11e678a897"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29d1dcaad4340a1a08f9660ff3f4ac7f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a29d1dcaad4340a1a08f9660ff3f4ac7f">get_abs</a> () const</td></tr>
<tr class="separator:a29d1dcaad4340a1a08f9660ff3f4ac7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6bce743d38c5e0afd42e8834f8f6dabf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a6bce743d38c5e0afd42e8834f8f6dabf">get_max</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;other) const</td></tr>
<tr class="separator:a6bce743d38c5e0afd42e8834f8f6dabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c9518b5e35e5596944e124d6a3a2d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a84c9518b5e35e5596944e124d6a3a2d9">get_min</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a> &amp;other) const</td></tr>
<tr class="separator:a84c9518b5e35e5596944e124d6a3a2d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae26a3ccb0ff2794dcd568eb04509c273"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , std::size_t width2&gt; </td></tr>
<tr class="memitem:ae26a3ccb0ff2794dcd568eb04509c273"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ae26a3ccb0ff2794dcd568eb04509c273">std::sqrt</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;)</td></tr>
<tr class="separator:ae26a3ccb0ff2794dcd568eb04509c273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e0d09ec7d1f3f6cc89b0a727169ebcd"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , std::size_t width2&gt; </td></tr>
<tr class="memitem:a6e0d09ec7d1f3f6cc89b0a727169ebcd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a6e0d09ec7d1f3f6cc89b0a727169ebcd">std::abs</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;)</td></tr>
<tr class="separator:a6e0d09ec7d1f3f6cc89b0a727169ebcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f3ad590ae0def50951fa45978d7327"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , std::size_t width2&gt; </td></tr>
<tr class="memitem:a20f3ad590ae0def50951fa45978d7327"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a20f3ad590ae0def50951fa45978d7327">std::max</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;)</td></tr>
<tr class="separator:a20f3ad590ae0def50951fa45978d7327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db4cb7c16a82c6fe5f122f273feb42d"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , std::size_t width2&gt; </td></tr>
<tr class="memitem:a1db4cb7c16a82c6fe5f122f273feb42d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a1db4cb7c16a82c6fe5f122f273feb42d">std::min</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;)</td></tr>
<tr class="separator:a1db4cb7c16a82c6fe5f122f273feb42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:adea3423146bcdda2dce143cfb4d10ae8"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:adea3423146bcdda2dce143cfb4d10ae8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#adea3423146bcdda2dce143cfb4d10ae8">cos</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:adea3423146bcdda2dce143cfb4d10ae8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a615c2bc9aed946b4e0c526f977009195"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a615c2bc9aed946b4e0c526f977009195"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a615c2bc9aed946b4e0c526f977009195">tan</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x)</td></tr>
<tr class="separator:a615c2bc9aed946b4e0c526f977009195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92b3114a0ad75bad4886443acde56abf"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a92b3114a0ad75bad4886443acde56abf"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;p)</td></tr>
<tr class="separator:a92b3114a0ad75bad4886443acde56abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ffe4cdaef4472045fff75d609590f8a"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a2ffe4cdaef4472045fff75d609590f8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a2ffe4cdaef4472045fff75d609590f8a">max</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;y)</td></tr>
<tr class="separator:a2ffe4cdaef4472045fff75d609590f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8402043a938d7bb8af59713a5c0cc73e"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a8402043a938d7bb8af59713a5c0cc73e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a8402043a938d7bb8af59713a5c0cc73e">min</a> (const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;x, const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;y)</td></tr>
<tr class="separator:a8402043a938d7bb8af59713a5c0cc73e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矢量数组的打包和拆包</div></td></tr>
<tr class="memitem:ad7d7e08942faeecf438c75a254e06cbe"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width = internal::VectorizedArrayWidthSpecifier&lt;Number&gt;::max_width&gt; </td></tr>
<tr class="memitem:ad7d7e08942faeecf438c75a254e06cbe"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ad7d7e08942faeecf438c75a254e06cbe">make_vectorized_array</a> (const Number &amp;u)</td></tr>
<tr class="separator:ad7d7e08942faeecf438c75a254e06cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memTemplParams" colspan="2">template&lt;typename VectorizedArrayType &gt; </td></tr>
<tr class="memitem:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memTemplItemLeft" align="right" valign="top">VectorizedArrayType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a1e5618abfc968e28f587c4fcfa1fdb34">make_vectorized_array</a> (const typename VectorizedArrayType::value_type &amp;u)</td></tr>
<tr class="separator:a1e5618abfc968e28f587c4fcfa1fdb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14da4327264fd3a88a9f73a8f72a9094"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a14da4327264fd3a88a9f73a8f72a9094"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a14da4327264fd3a88a9f73a8f72a9094">vectorized_load_and_transpose</a> (const unsigned <a class="el" href="classint.html">int</a> n_entries, const Number *in, const unsigned <a class="el" href="classint.html">int</a> *offsets, <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *out)</td></tr>
<tr class="separator:a14da4327264fd3a88a9f73a8f72a9094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af396b43c783502e8acd2ca7d071a7325"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:af396b43c783502e8acd2ca7d071a7325"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#af396b43c783502e8acd2ca7d071a7325">vectorized_transpose_and_store</a> (const <a class="el" href="classbool.html">bool</a> add_into, const unsigned <a class="el" href="classint.html">int</a> n_entries, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *in, const unsigned <a class="el" href="classint.html">int</a> *offsets, Number *out)</td></tr>
<tr class="separator:af396b43c783502e8acd2ca7d071a7325"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">用VectorizedArray进行算术运算</div></td></tr>
<tr class="memitem:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a60e4e5dd338cf4353bbdccc117fa883d">operator==</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;lhs, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;rhs)</td></tr>
<tr class="separator:a60e4e5dd338cf4353bbdccc117fa883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad938a80e7098f4bf2193b14a14e73460"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ad938a80e7098f4bf2193b14a14e73460"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ad938a80e7098f4bf2193b14a14e73460">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ad938a80e7098f4bf2193b14a14e73460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655230f65541b3787d1f71fa57a44072"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a655230f65541b3787d1f71fa57a44072"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a655230f65541b3787d1f71fa57a44072">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a655230f65541b3787d1f71fa57a44072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab848bd1da37f381f87cb5eaf51de6019"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ab848bd1da37f381f87cb5eaf51de6019"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ab848bd1da37f381f87cb5eaf51de6019">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ab848bd1da37f381f87cb5eaf51de6019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad92490d85f7b45a7e55a1a77b1e070b1"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ad92490d85f7b45a7e55a1a77b1e070b1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ad92490d85f7b45a7e55a1a77b1e070b1">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ad92490d85f7b45a7e55a1a77b1e070b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53b8b0dc43deb68af60df1a76f8badb3"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a53b8b0dc43deb68af60df1a76f8badb3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a53b8b0dc43deb68af60df1a76f8badb3">operator+</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:a53b8b0dc43deb68af60df1a76f8badb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1ad99276a124e6b2262e6adc2621a4"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:abd1ad99276a124e6b2262e6adc2621a4"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#abd1ad99276a124e6b2262e6adc2621a4">operator+</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:abd1ad99276a124e6b2262e6adc2621a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bfc4e9feda79490243911ac8389abeb"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a1bfc4e9feda79490243911ac8389abeb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a1bfc4e9feda79490243911ac8389abeb">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a1bfc4e9feda79490243911ac8389abeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a041de227d36132ca524ee4178d98093b"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a041de227d36132ca524ee4178d98093b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a041de227d36132ca524ee4178d98093b">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a041de227d36132ca524ee4178d98093b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad492519b2494af83eaa083eee9a7d7f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:aad492519b2494af83eaa083eee9a7d7f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#aad492519b2494af83eaa083eee9a7d7f">operator-</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:aad492519b2494af83eaa083eee9a7d7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c891c4bdf89ab5fece2d15da7f7e21a"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a4c891c4bdf89ab5fece2d15da7f7e21a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a4c891c4bdf89ab5fece2d15da7f7e21a">operator-</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:a4c891c4bdf89ab5fece2d15da7f7e21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bda9e065a143791d3a12c41843c603d"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a3bda9e065a143791d3a12c41843c603d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a3bda9e065a143791d3a12c41843c603d">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a3bda9e065a143791d3a12c41843c603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9740a3e31e10c1a08e1c3d0a673da29e"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a9740a3e31e10c1a08e1c3d0a673da29e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a9740a3e31e10c1a08e1c3d0a673da29e">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a9740a3e31e10c1a08e1c3d0a673da29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd70ba108142e51cf551ef397538d319"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:abd70ba108142e51cf551ef397538d319"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#abd70ba108142e51cf551ef397538d319">operator*</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:abd70ba108142e51cf551ef397538d319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88298154660a2544e69a5d98e9c1347"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:af88298154660a2544e69a5d98e9c1347"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#af88298154660a2544e69a5d98e9c1347">operator*</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:af88298154660a2544e69a5d98e9c1347"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36e38a9fd6c14af630fd5d2ce05a90a7"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a36e38a9fd6c14af630fd5d2ce05a90a7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a36e38a9fd6c14af630fd5d2ce05a90a7">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a36e38a9fd6c14af630fd5d2ce05a90a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c6e2d4507e185ef3e691897d068885"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a67c6e2d4507e185ef3e691897d068885"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a67c6e2d4507e185ef3e691897d068885">operator*</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a67c6e2d4507e185ef3e691897d068885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b532bf8e52de9bdf6f50a32e0e7850"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:ac8b532bf8e52de9bdf6f50a32e0e7850"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#ac8b532bf8e52de9bdf6f50a32e0e7850">operator/</a> (const Number &amp;u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v)</td></tr>
<tr class="separator:ac8b532bf8e52de9bdf6f50a32e0e7850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f25b89d500cb7729727d9fb88aba1d"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:af6f25b89d500cb7729727d9fb88aba1d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#af6f25b89d500cb7729727d9fb88aba1d">operator/</a> (const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v)</td></tr>
<tr class="separator:af6f25b89d500cb7729727d9fb88aba1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250c9df8da4b13efaab02e1302dfc60f"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a250c9df8da4b13efaab02e1302dfc60f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a250c9df8da4b13efaab02e1302dfc60f">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;v, const Number &amp;u)</td></tr>
<tr class="separator:a250c9df8da4b13efaab02e1302dfc60f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba8c9defa578058e48dde1e112a67da"><td class="memTemplParams" colspan="2">template&lt;std::size_t width&gt; </td></tr>
<tr class="memitem:a2ba8c9defa578058e48dde1e112a67da"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a2ba8c9defa578058e48dde1e112a67da">operator/</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;v, const <a class="el" href="classdouble.html">double</a> u)</td></tr>
<tr class="separator:a2ba8c9defa578058e48dde1e112a67da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55f68552b3739e75e9ff533277174863"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a55f68552b3739e75e9ff533277174863"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a55f68552b3739e75e9ff533277174863">operator+</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u)</td></tr>
<tr class="separator:a55f68552b3739e75e9ff533277174863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00794d026f4360efda32d2e3a0c0ce72"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a00794d026f4360efda32d2e3a0c0ce72"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a00794d026f4360efda32d2e3a0c0ce72">operator-</a> (const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;u)</td></tr>
<tr class="separator:a00794d026f4360efda32d2e3a0c0ce72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3676d2de40d79d2ab01808334e9a69b9"><td class="memTemplParams" colspan="2">template&lt;typename Number , std::size_t width&gt; </td></tr>
<tr class="memitem:a3676d2de40d79d2ab01808334e9a69b9"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classVectorizedArray.html#a3676d2de40d79d2ab01808334e9a69b9">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;p)</td></tr>
<tr class="separator:a3676d2de40d79d2ab01808334e9a69b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number, std::size_t width&gt;<br />
class VectorizedArray&lt; Number, width &gt;</h3>

<p>这个通用类定义了一个矢量数据类型的统一接口。对于一般的模板参数，这个类简单地对应于模板参数。例如，VectorizedArray&lt;long double&gt;=""&gt;只不过是<code>long double</code>的一个封装器，它的数据字段正好是<code>long double</code>类型，并且有重载的算术操作。这意味着<code>VectorizedArray&lt;ComplicatedType&gt;</code>具有与ComplicatedType类似的布局，只要ComplicatedType定义了基本的算术操作。对于浮点数和双数来说，数组被打包在一起，目的是为了以单指令/多数据（SIMD）的方式进行处理。在SIMD背景下，这种短矢量的元素通常被称为通道。包装在一起的元素的数量，即车道的数量，取决于计算机系统和用于编译deal.II的编译器标志。这些打包数据类型的基本思想是使用一条CPU指令，利用处理器的向量（SIMD）单元对整个阵列进行算术运算。按照2010年的标准，大多数计算机系统在64位操作系统上编译deal.II时，将分别使用两个双数或四个浮点数的数组（这对应于SSE/SSE2数据集）。在英特尔Sandy Bridge处理器和更新的处理器或AMD Bulldozer处理器和更新的处理器上，当deal.II使用gcc配置为 --with-cpu=native 或 --with-cpu=corei7-avx时，会使用四个双数或八个浮点。在支持AVX-512的编译器上（例如2017年开始的英特尔Skylake服务器），会使用8个双数或16个浮点。 这个类的行为被做成与基本数据类型double和float类似。向量数组的定义并不初始化数据字段，而是让它未被定义，就像double和float的情况一样。然而，当调用诸如<code>矢量化数组&lt;double&gt; a =矢量化数组&lt;double&gt;()</code>或<code>矢量化数组&lt;double&gt; a = 0.</code>时，它将这个字段中的所有数字设置为零。根据C++11标准，该类属于标准布局类型，这意味着有一个等效的C表示法，例如，该类可以用 std::memcpy. 安全地复制（也见https://en.cppreference.com/w/cpp/named_req/StandardLayoutType）。标准布局对于确保在向量中收集的数据与地址边界正确对齐也是必要的（即，当向量中的第一个元素正确对齐时，所有后续元素也将正确对齐）。 请注意，为了使这个类的正常运行，必须遵守某些数据对齐规则。这是因为计算机期望VectorizedArray&lt;double&gt;字段的起始地址在内存中的特定地址（通常，矢量数组的地址应该是以字节为单位的数组长度的倍数）。否则，可能会出现分段故障或严重的性能损失。当在堆栈上创建一个单一的数据字段时，如 "VectorizedArray&lt;double&gt; a = 5.
;"，编译器会自动处理数据对齐。然而，当分配一个VectorizedArray&lt;double&gt;数据的长向量时，需要尊重这些规则。为此要使用AlignedVector类或基于AlignedVector的数据容器（如Table）。这是一个与 std::vector 非常相似的类，否则，它总是能确保数据正确对齐。 用户可以通过该封装类的第二个模板参数指定通道数，明确控制特定指令集架构（ISA）扩展的宽度。例如，在英特尔Skylake服务器上，你对数据类型double有以下选择。</p>
<ul>
<li>VectorizedArray&lt;double, 1&gt; // 无矢量化（自动优化）。</li>
<li>VectorizedArray&lt;double, 2&gt; // SSE2</li>
<li>VectorizedArray&lt;double, 4&gt; // AVX</li>
<li>VectorizedArray&lt;double, 8&gt; // AVX-512 (默认) 并用于英特尔Sandy Bridge、Haswell、Broadwell、AMD Bulldozer和Zen/Ryzen。</li>
<li>VectorizedArray&lt;double, 1&gt; // 无矢量化（自动优化）。</li>
<li>VectorizedArray&lt;double, 2&gt; // SSE2</li>
<li>VectorizedArray&lt;double, 4&gt; // AVX (默认) 以及对于支持AltiVec的处理器。</li>
<li>矢量Array&lt;double, 1&gt; * - 矢量Array&lt;double, 1&gt;</li>
</ul>
<p>适用于旧的x86处理器或在没有添加特定处理器编译标志的情况下（即没有<code>-D CMAKE_CXX_FLAGS=-march=native</code>或类似标志）。</p>
<ul>
<li>VectorizedArray&lt;double, 1&gt; // 无矢量化（自动优化）。</li>
<li>VectorizedArray&lt;double, 2&gt; // SSE2 类似的考虑也适用于数据类型<code>float</code>。 错误地选择宽度，例如，在不支持AVX-512的处理器上选择width=3或width=8，会导致静态断言。 <dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">数字基础数据类型</td><td></td></tr>
    <tr><td class="paramname">宽度向量长度（可选；如果不设置，则使用架构的最大宽度）。</td><td></td></tr>
  </table>
  </dd>
</dl>
</li>
</ul>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00409">409</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ad5e3061a2d2cf13c446354059e6fa8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e3061a2d2cf13c446354059e6fa8ef">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::<a class="el" href="classVectorizedArray.html#ad5e3061a2d2cf13c446354059e6fa8ef">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这给出了数组元素的类型。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00417">417</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5ffe4e7bfe1dc8ff28ce26e79776f0cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ffe4e7bfe1dc8ff28ce26e79776f0cd">&#9670;&nbsp;</a></span>VectorizedArray() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::<a class="el" href="classVectorizedArray.html">VectorizedArray</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的空构造函数，使数据处于未初始化的状态，类似于float/double。 </p>

</div>
</div>
<a id="a6367cca1b81fc817e58f1d961d223fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6367cca1b81fc817e58f1d961d223fc4">&#9670;&nbsp;</a></span>VectorizedArray() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::<a class="el" href="classVectorizedArray.html">VectorizedArray</a> </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用给定的标量构建一个数组广播到所有的通道。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00432">432</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a4bab1253b131475943b076b83179ae76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bab1253b131475943b076b83179ae76">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数将一个标量分配给这个类。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00443">443</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a99f8bdefac7d751bef7e42be5dae12fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f8bdefac7d751bef7e42be5dae12fa">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问操作符（只对基类中的0号组件有效，没有特殊化）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00454">454</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ab40f56a62c0f7c527629540a7af0d9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40f56a62c0f7c527629540a7af0d9d0">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const Number&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>常数访问操作符（只对基类中的0号组件有效，没有特殊化）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00466">466</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a23cd28d5bd07f3944d7e56fe33f652fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23cd28d5bd07f3944d7e56fe33f652fc">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00479">479</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aff4825de67b123e97613fd1f1dd96436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff4825de67b123e97613fd1f1dd96436">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>减法 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00491">491</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aab5595f01cf6de1bb959befa44bb6603"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab5595f01cf6de1bb959befa44bb6603">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>乘法 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00503">503</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a73ed02d36053ebd2d903eac17fc832d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ed02d36053ebd2d903eac17fc832d2">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&amp; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>除法 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00515">515</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ab0c3d5bcdf208c37fc1f8055765c03b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0c3d5bcdf208c37fc1f8055765c03b1">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::load </td>
          <td>(</td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从内存中加载size()数据项到调用类中，从给定的地址开始。指针<code>ptr</code>不需要按矢量数组中的字节数对齐，与之相反的是，将双倍地址投给VectorizedArray&lt;double&gt;*。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00527">527</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a9f2cef2c40dbc7871c7c702bc0cfe533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2cef2c40dbc7871c7c702bc0cfe533">&#9670;&nbsp;</a></span>store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::store </td>
          <td>(</td>
          <td class="paramtype">Number *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将调用类的内容以size()数据项的形式写入内存中，到给定的地址。指针<code>ptr</code>不需要按矢量数组中的字节数对齐，与之相反的是，将一个双倍地址投给VectorizedArray&lt;double&gt;*。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00538">538</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ae5fa52c39ffcb5a2e740552a92833009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5fa52c39ffcb5a2e740552a92833009">&#9670;&nbsp;</a></span>streaming_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::streaming_store </td>
          <td>(</td>
          <td class="paramtype">Number *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在支持的CPU上使用 <code>_mm_stream_pd</code> 存储本征，将调用类的内容以size()数据项的形式写入内存，并使用绕过处理器缓存的非时间性存储来给定地址。存储 <code>ptr</code> 的目标必须按矢量数组中的字节数对齐。 在存储是流式的情况下，这种存储操作可以比通常的存储操作更快，因为它避免了通常在标准存储中调用的读取所有权转移。这个大约的工作原理如下（详见计算机结构方面的文献）。当一个算法将一些结果存储到一个内存地址时，一个处理器通常希望将它移到它的一些缓存中，因为它期望这些数据在某个时候会被再次使用。由于缓存是以64字节或128字节的行来组织的，但写入的数据通常较小，所以处理器在写入时必须首先加载目标缓存行，因为最初只有部分缓存行被覆盖。如果一系列的存储写入的数据比任何一个缓冲区都要大，那么这些数据最后就必须从缓冲区转移到主内存。但是，由于所有的地址都是先被读取的，这就使主内存的负载增加了一倍，这就会产生性能上的损失。此外，在多核环境下的缓存组织也需要在将某一地址写入缓存之前读取该地址，详情请参见<a href="https://en.wikipedia.org/wiki/MESI_protocol">Wikipedia article on the MESI protocol</a>。这个函数调用的基础指令向处理器发出信号，在存储上的这两个先决条件被放宽了：首先，人们期望整个高速缓存行被覆盖（意味着内存子系统确保一起跨越高速缓存行的连续存储被合并，并适当处理只有部分高速缓存行被写入的情况），所以没有必要首先读取高速缓存行的 "剩余部分"。其次，该特定内存后面的数据将不受缓存一致性协议的约束，因为当同一处理器想要再次访问它时，以及在多核芯片中的任何其他处理器，它都将在主内存中。由于这种特殊的设置，随后对该函数写入的数据的任何访问都需要查询主存，这在延迟和吞吐量上都比从高速缓存中访问要慢。因此，这个命令应该只用于存储大的数组，这些数组总体上不适合放在缓存中，否则性能就会下降。关于一个典型的用例，请参见<a href="https://blogs.fau.de/hager/archives/2103">this blog article</a>。 注意，流式存储只在类型为 <code>double</code> 或 <code>float</code>, 的VectorizedArray的专业SSE/AVX类中可用，而不是在通用基类中。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00559">559</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a137b7cf45664efddbc332cad9c5c8839"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137b7cf45664efddbc332cad9c5c8839">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::gather </td>
          <td>(</td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>base_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从内存中加载size()数据项到调用的类中，从给定的地址和给定的偏移量开始，从偏移量开始的每个条目提供一个矢量化数组的元素。 这个操作对应于以下代码（但在硬件允许的情况下，使用了更有效的实现）。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">this-&gt;<span class="keyword">operator</span>[](v) = base_ptr[offsets[v]];</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00576">576</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aa05c67eb5742dc4eea633174e8a88986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa05c67eb5742dc4eea633174e8a88986">&#9670;&nbsp;</a></span>scatter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::scatter </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *&#160;</td>
          <td class="paramname"><em>base_ptr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将调用类的内容以size()数据项的形式写入内存，到给定的地址和给定的偏移量，将矢量数组的元素填入每个偏移量。 这个操作对应于下面的代码（但在硬件允许的情况下，使用更有效的实现）。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">base_ptr[offsets[v]] = this-&gt;<span class="keyword">operator</span>[](v);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00592">592</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac3828c2f77428ee28013df11e678a897"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3828c2f77428ee28013df11e678a897">&#9670;&nbsp;</a></span>get_sqrt()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::get_sqrt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个字段的平方根。不适合在用户代码中使用。使用sqrt(x)代替。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00610">610</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a29d1dcaad4340a1a08f9660ff3f4ac7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29d1dcaad4340a1a08f9660ff3f4ac7f">&#9670;&nbsp;</a></span>get_abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::get_abs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个字段的绝对值。不适合在用户代码中使用。请使用abs(x)代替。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00623">623</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a6bce743d38c5e0afd42e8834f8f6dabf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bce743d38c5e0afd42e8834f8f6dabf">&#9670;&nbsp;</a></span>get_max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::get_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个字段和另一个字段的分量上的最大值。不适合在用户代码中使用。使用max(x,y)代替。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00636">636</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a84c9518b5e35e5596944e124d6a3a2d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c9518b5e35e5596944e124d6a3a2d9">&#9670;&nbsp;</a></span>get_min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a> <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::get_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个字段和另一个字段的最小分量。不适合在用户代码中使用。使用min(x,y)代替。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00649">649</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="acb35404acc1693aee6e990228924cc09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb35404acc1693aee6e990228924cc09">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; , width &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回数组中元素的数量。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00266">266</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac3079ced5292fcebec8a4ff8a6bdb0f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3079ced5292fcebec8a4ff8a6bdb0f0">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt;<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt; <a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; , width &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>指向底层数据开始的一个迭代器。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00276">276</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a4abc43c177332ab7133ae7b42850c3cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4abc43c177332ab7133ae7b42850c3cc">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt;const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt; <a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; , width &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>一个指向基础数据开始的迭代器（<code>const</code>版本）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00286">286</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a78e62fef92c4dd89eee5bcd616be5ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e62fef92c4dd89eee5bcd616be5ef0">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt;<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt; <a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; , width &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>指向基础数据结束的迭代器。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00296">296</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a60230d197dc20a35c0fe0289e4a03b53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60230d197dc20a35c0fe0289e4a03b53">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArrayIterator.html">VectorizedArrayIterator</a>&lt;const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &gt; <a class="el" href="classVectorizedArrayBase.html">VectorizedArrayBase</a>&lt; <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; , width &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>一个指向基础数据末端的迭代器（<code>const</code>版本）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00306">306</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae26a3ccb0ff2794dcd568eb04509c273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26a3ccb0ff2794dcd568eb04509c273">&#9670;&nbsp;</a></span>std::sqrt</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , std::size_t width2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number2, width2&gt; std::sqrt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e0d09ec7d1f3f6cc89b0a727169ebcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e0d09ec7d1f3f6cc89b0a727169ebcd">&#9670;&nbsp;</a></span>std::abs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , std::size_t width2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number2, width2&gt; std::abs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a20f3ad590ae0def50951fa45978d7327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f3ad590ae0def50951fa45978d7327">&#9670;&nbsp;</a></span>std::max</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , std::size_t width2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number2, width2&gt; std::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1db4cb7c16a82c6fe5f122f273feb42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db4cb7c16a82c6fe5f122f273feb42d">&#9670;&nbsp;</a></span>std::min</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , std::size_t width2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt;Number2, width2&gt; std::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number2, width2 &gt; &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7d7e08942faeecf438c75a254e06cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7d7e08942faeecf438c75a254e06cbe">&#9670;&nbsp;</a></span>make_vectorized_array() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width = internal::VectorizedArrayWidthSpecifier&lt;Number&gt;::max_width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; make_vectorized_array </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个矢量数组，将数组中的所有条目设置为给定的标量，也就是说，将标量广播到所有数组元素。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00693">693</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a1e5618abfc968e28f587c4fcfa1fdb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e5618abfc968e28f587c4fcfa1fdb34">&#9670;&nbsp;</a></span>make_vectorized_array() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorizedArrayType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">VectorizedArrayType make_vectorized_array </td>
          <td>(</td>
          <td class="paramtype">const typename VectorizedArrayType::value_type &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>创建一个给定类型的矢量数组，并将标量值广播给所有数组元素。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00709">709</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a14da4327264fd3a88a9f73a8f72a9094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14da4327264fd3a88a9f73a8f72a9094">&#9670;&nbsp;</a></span>vectorized_load_and_transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_load_and_transpose </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个方法从给定的数组 <code>in</code>. 中加载 <a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">VectorizedArray::size()</a> 数据流，输入数组的偏移量由数组 <code>偏移量给出。从每个数据流中读取n_entries。然后数据被转置并存储到一个VectorizedArray类型的数组中。输出数组</code> <code>out预计是一个大小为</code> <code>n_entries</code>. 的数组。这个方法在普通数组上操作，所以没有检查有效的数据访问。用户有责任确保给定的数组根据下面的访问布局是有效的。 该操作对应于根据以下公式将一个结构数组（输入）转换为一个数组结构（输出）。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">  out[i][v] = in[offsets[v]+i];</div></div><!-- fragment --><p>该代码的一个更优化的版本将用于支持的类型。 这是对vectorized_transpose_and_store()的逆向操作。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00771">771</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af396b43c783502e8acd2ca7d071a7325"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af396b43c783502e8acd2ca7d071a7325">&#9670;&nbsp;</a></span>vectorized_transpose_and_store()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vectorized_transpose_and_store </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>add_into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; *&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a> *&#160;</td>
          <td class="paramname"><em>offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number *&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>该方法以转置的形式将矢量数组存储到给定的输出数组 <code>out</code> 中，并给定偏移量 <code>offsets</code>. ，该操作相当于将一个数组结构（输入）转换为一个数组结构（输出）。该方法对纯数组进行操作，所以没有对有效的数据访问进行检查。用户有责任确保给定的数组根据下面的访问布局是有效的。 该方法假设指定的偏移量不重叠。否则，在矢量化的情况下，该行为是未定义的。用户有责任确保访问不重叠，避免未定义的行为。 参数 <code>add_into</code> 选择哪里的条目应该只被写入输出数组，或者结果应该被添加到输出的现有条目中。对于 <code>add_into == false</code> ，假设以下代码。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">  out[offsets[v]+i] = in[i][v];</div></div><!-- fragment --><p>对于 <code>add_into == true</code> ，代码实现了以下动作。 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;n_entries; ++i)</div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> v=0; v&lt;VectorizedArray&lt;Number&gt;::size(); ++v)</div><div class="line">  out[offsets[v]+i] += in[i][v];</div></div><!-- fragment --><p>对于支持的类型，将使用该代码的一个更优化的版本。 这是对vectorized_load_and_transpose()的逆向操作。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00834">834</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a60e4e5dd338cf4353bbdccc117fa883d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60e4e5dd338cf4353bbdccc117fa883d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对VectorizedArray的关系运算符== </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04644">4644</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ad938a80e7098f4bf2193b14a14e73460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad938a80e7098f4bf2193b14a14e73460">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用操作符+对两个矢量数组进行加法。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04663">4663</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a655230f65541b3787d1f71fa57a44072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655230f65541b3787d1f71fa57a44072">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个矢量数组的减法，用操作符</p>
<ul>
<li></li>
</ul>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04680">4680</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ab848bd1da37f381f87cb5eaf51de6019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab848bd1da37f381f87cb5eaf51de6019">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用运算符对两个矢量数组进行乘法。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04695">4695</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ad92490d85f7b45a7e55a1a77b1e070b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad92490d85f7b45a7e55a1a77b1e070b1">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用运算符/对两个矢量数组进行除法。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04710">4710</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a53b8b0dc43deb68af60df1a76f8badb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53b8b0dc43deb68af60df1a76f8badb3">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个标量（用 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>相等的条目扩展为一个向量数组）和一个向量数组的加法。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04726">4726</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="abd1ad99276a124e6b2262e6adc2621a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1ad99276a124e6b2262e6adc2621a4">&#9670;&nbsp;</a></span>operator+() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量是双数的情况下，标量的加法（扩展为矢量数组， <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>相等的条目）和矢量数组的加法（为了能够用通常是双数的常量编写简单的代码而需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04742">4742</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a1bfc4e9feda79490243911ac8389abeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bfc4e9feda79490243911ac8389abeb">&#9670;&nbsp;</a></span>operator+() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量数组和标量的相加（扩展为一个具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 等量项的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04757">4757</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a041de227d36132ca524ee4178d98093b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a041de227d36132ca524ee4178d98093b">&#9670;&nbsp;</a></span>operator+() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，将一个矢量数组和一个标量相加（扩展为一个具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04772">4772</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="aad492519b2494af83eaa083eee9a7d7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad492519b2494af83eaa083eee9a7d7f">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从标量中减去一个矢量数组（扩展为一个具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04786">4786</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a4c891c4bdf89ab5fece2d15da7f7e21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c891c4bdf89ab5fece2d15da7f7e21a">&#9670;&nbsp;</a></span>operator-() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，从标量中减去一个矢量数组（扩展为一个具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）（为了能够用通常为双数的常数编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04802">4802</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a3bda9e065a143791d3a12c41843c603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bda9e065a143791d3a12c41843c603d">&#9670;&nbsp;</a></span>operator-() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个矢量数组中减去一个标量（扩展为一个矢量数组， <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>等于条目）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04817">4817</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a9740a3e31e10c1a08e1c3d0a673da29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9740a3e31e10c1a08e1c3d0a673da29e">&#9670;&nbsp;</a></span>operator-() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从一个矢量数组中减去一个标量（扩展为一个矢量数组， <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>相等的条目），如果该标量是一个双数（为了能够用通常是双数的常量编写简单的代码而需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04833">4833</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="abd70ba108142e51cf551ef397538d319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd70ba108142e51cf551ef397538d319">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个标量（扩展为一个具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>等分项的向量数组）和一个向量数组的乘法。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04848">4848</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af88298154660a2544e69a5d98e9c1347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88298154660a2544e69a5d98e9c1347">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量是双数的情况下，标量（扩展为一个矢量数组， <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>相等的条目）和矢量数组的乘法（为了能够用通常是双数的常量编写简单的代码而需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04863">4863</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a36e38a9fd6c14af630fd5d2ce05a90a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36e38a9fd6c14af630fd5d2ce05a90a7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量数组和标量的乘法（扩展为具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04878">4878</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a67c6e2d4507e185ef3e691897d068885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67c6e2d4507e185ef3e691897d068885">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，矢量数组和标量的乘法（扩展为具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04893">4893</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="ac8b532bf8e52de9bdf6f50a32e0e7850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b532bf8e52de9bdf6f50a32e0e7850">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>标量（扩展为矢量数组， <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>等于条目）与矢量数组之间的商。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04907">4907</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="af6f25b89d500cb7729727d9fb88aba1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f25b89d500cb7729727d9fb88aba1d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量是双数的情况下，标量（扩展为具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>相等条目的向量数组）和向量数组之间的商（为了能够用通常为双数的常量编写简单的代码，需要）。</code> </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04922">4922</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a250c9df8da4b13efaab02e1302dfc60f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250c9df8da4b13efaab02e1302dfc60f">&#9670;&nbsp;</a></span>operator/() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量数组和标量之间的商（扩展为具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04937">4937</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a2ba8c9defa578058e48dde1e112a67da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba8c9defa578058e48dde1e112a67da">&#9670;&nbsp;</a></span>operator/() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; float, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在标量为双数的情况下，矢量数组和标量之间的商（扩展为具有 <code><a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a></code> 相等条目的矢量数组）（为了能够用通常为双数的常量编写简单的代码而需要）。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04953">4953</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a55f68552b3739e75e9ff533277174863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55f68552b3739e75e9ff533277174863">&#9670;&nbsp;</a></span>operator+() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量化数组上的单项运算符+。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04967">4967</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a00794d026f4360efda32d2e3a0c0ce72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00794d026f4360efda32d2e3a0c0ce72">&#9670;&nbsp;</a></span>operator-() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>单元运算符</p>
<ul>
<li>在一个矢量化数组上。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04982">4982</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a3676d2de40d79d2ab01808334e9a69b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3676d2de40d79d2ab01808334e9a69b9">&#9670;&nbsp;</a></span>operator<<()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矢量化数组的输出运算符。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l04997">4997</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="adea3423146bcdda2dce143cfb4d10ae8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea3423146bcdda2dce143cfb4d10ae8">&#9670;&nbsp;</a></span>cos()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; cos </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个矢量数据域的余弦。结果以矢量数组的形式返回<code>{cos(x[0]), cos(x[1]), ..., cos(x[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>-1]) }</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05359">5359</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a615c2bc9aed946b4e0c526f977009195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a615c2bc9aed946b4e0c526f977009195">&#9670;&nbsp;</a></span>tan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; tan </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个矢量数据域的正切。结果以矢量数组的形式返回<code>{tan(x[0]), tan(x[1]), ..., tan(x[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>-1]) }</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05379">5379</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a92b3114a0ad75bad4886443acde56abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92b3114a0ad75bad4886443acde56abf">&#9670;&nbsp;</a></span>pow()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; pow </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将给定的数字 <code>x</code> 提高到幂数 <code>p</code> ，用于一个矢量数据域。结果以矢量数组的形式返回<code>{pow(x[0],p[0]), pow(x[1],p[1]), ..., pow(x[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>-1],p[<a class="el" href="classVectorizedArrayBase.html#acb35404acc1693aee6e990228924cc09">size()</a>-1]) }</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05480">5480</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a2ffe4cdaef4472045fff75d609590f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ffe4cdaef4472045fff75d609590f8a">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; max </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算两个矢量数据域的分量最大。结果以矢量数组的形式返回<code>{max(x[0],y[0]), max(x[1],y[1), ...}</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05516">5516</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<a id="a8402043a938d7bb8af59713a5c0cc73e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8402043a938d7bb8af59713a5c0cc73e">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number , std::size_t width&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; min </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算两个矢量数据域的分量最小值。结果以矢量数组的形式返回<code>{min(x[0],y[0]), min(x[1],y[1), ...}</code>。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l05531">5531</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad38190d02537705964e021da7ecbab3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad38190d02537705964e021da7ecbab3f">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, std::size_t width&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classVectorizedArray.html">VectorizedArray</a>&lt; Number, width &gt;::data</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>实际的数据字段。为了与标准布局类型保持一致，并且能够与外部SIMD功能进行交互，这个成员被声明为公共的。 </p>

<p class="definition">Definition at line <a class="el" href="vectorization_8h_source.html#l00601">601</a> of file <a class="el" href="vectorization_8h_source.html">vectorization.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/base/<a class="el" href="vectorization_8h_source.html">vectorization.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
