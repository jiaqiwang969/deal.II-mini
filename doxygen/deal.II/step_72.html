<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_72.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-72 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-72 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_71.html">step-71</a>, <a class="el" href="step_15.html">step-15</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Motivation">Motivation</a>
        <li><a href="#ComputingtheJacobianfromtheresidual"> Computing the Jacobian from the residual </a>
        <li><a href="#ComputingtheJacobianandtheresidualfromtheenergyfunctional"> Computing the Jacobian and the residual from the energy functional </a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#ThecodeMinimalSurfaceProblemParameterscodeclass">The <code>MinimalSurfaceProblemParameters</code> class</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclasstemplate">The <code>MinimalSurfaceProblem</code> class template</a>
        <li><a href="#Boundarycondition">Boundary condition</a>
        <li><a href="#ThecodeMinimalSurfaceProblemcodeclassimplementation">The <code>MinimalSurfaceProblem</code> class implementation</a>
      <ul>
        <li><a href="#MinimalSurfaceProblemMinimalSurfaceProblem">MinimalSurfaceProblem::MinimalSurfaceProblem</a>
        <li><a href="#MinimalSurfaceProblemsetup_system">MinimalSurfaceProblem::setup_system</a>
        <li><a href="#Assemblingthelinearsystem">Assembling the linear system</a>
      <ul>
        <li><a href="#Manualassembly">Manual assembly</a>
        <li><a href="#Assemblyviadifferentiationoftheresidualvector">Assembly via differentiation of the residual vector</a>
        <li><a href="#Assemblyviadifferentiationoftheenergyfunctional">Assembly via differentiation of the energy functional</a>
      </ul>
        <li><a href="#MinimalSurfaceProblemsolve">MinimalSurfaceProblem::solve</a>
        <li><a href="#MinimalSurfaceProblemrefine_mesh">MinimalSurfaceProblem::refine_mesh</a>
        <li><a href="#MinimalSurfaceProblemset_boundary_values">MinimalSurfaceProblem::set_boundary_values</a>
        <li><a href="#MinimalSurfaceProblemcompute_residual">MinimalSurfaceProblem::compute_residual</a>
        <li><a href="#MinimalSurfaceProblemdetermine_step_length">MinimalSurfaceProblem::determine_step_length</a>
        <li><a href="#MinimalSurfaceProblemoutput_results">MinimalSurfaceProblem::output_results</a>
        <li><a href="#MinimalSurfaceProblemrun">MinimalSurfaceProblem::run</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Possibilitiesforextensions"> Possibilities for extensions </a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-72/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Jean-Paul Pelteret and Wolfgang Bangerth.</em></p>
<p><em>Wolfgang Bangerth's work is partially supported by National Science Foundation grants OCI-1148116, OAC-1835673, DMS-1821210, and EAR-1925595; and by the Computational Infrastructure in Geodynamics initiative (CIG), through the National Science Foundation under Award No. EAR-1550901 and The University of California-Davis. </em></p>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p><a class="anchor" id="Motivation"></a></p><h3>Motivation</h3>
<p>这个程序解决的问题与步骤15相同，即求解<a href="https://en.wikipedia.org/wiki/Minimal_surface">最小表面方程</a> </p><p class="formulaDsp">
\begin{align*} F(u) \dealcoloneq -\nabla \cdot \left( \frac{1}{\sqrt{1+|\nabla u|^{2}}}\nabla u \right) &amp;= 0 \qquad \qquad &amp;&amp;\textrm{in} ~ \Omega \\ u&amp;=g \qquad\qquad &amp;&amp;\textrm{on} ~ \partial \Omega. \end{align*}
</p>
<p>我们在那里发现的问题（见<a href="step_15#extensions">Possibilities for extensions</a>部分）是，当想要使用牛顿迭代时，我们需要计算方程残差对解的导数 \(u\) （这里，因为右手边是零，残差只是左手边）。对于我们这里的方程来说，这很麻烦，但并非不可能 &ndash; 但我们很容易想象出更复杂的方程，仅仅正确实现残差本身就是一个挑战，更不用说为计算雅各布矩阵所需的导数而这样做。我们将在这个程序中解决这个问题。使用在步骤-71中详细讨论的自动微分技术，我们将想出一个办法，我们只需要实现残差，就可以免费得到雅各布矩阵。</p>
<p>事实上，我们甚至可以更进一步。虽然在第15步中，我们只是把方程作为一个给定值，但最小表面方程实际上是最小化一个能量的产物。具体来说，最小曲面方程是对应于最小化能量的欧拉-拉格朗日方程 </p><p class="formulaDsp">
\[ E(u) = \int_\Omega \Psi \left( u \right) \]
</p>
<p>其中*能量密度*由 </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}}. \]
</p>
<p>给出。</p>
<p>这等于说，我们寻求找到能量函数变化的静止点 </p><p class="formulaDsp">
\[ \min\limits_{u} E \left( u \right) \quad \rightarrow \quad \delta E \left( u, \varphi \right) \dealcoloneq \left(\varphi, F(u)\right) = 0 \qquad \forall \varphi, \]
</p>
<p> 。</p>
<p>因为这是边界值问题的平衡解所在。</p>
<p>那么关键的一点是，也许，我们甚至不需要实现残差，但实现更简单的能量密度 \(\Psi(u)\) 可能实际上已经足够了。</p>
<p>那么我们的目标是这样的。当使用牛顿迭代时，我们需要反复解决线性偏微分方程 </p><p class="formulaDsp">
\begin{align*} F&#39;(u^{n},\delta u^{n}) &amp;=- F(u^{n}) \end{align*}
</p>
<p>。</p>
<p>这样我们就可以计算出更新 </p><p class="formulaDsp">
\begin{align*} u^{n+1}&amp;=u^{n}+\alpha^n \delta u^{n} \end{align*}
</p>
<p>。</p>
<p>与牛顿步骤的解 \(\delta u^{n}\) 。正如步骤15所讨论的，我们可以用手计算导数 \(F&#39;(u,\delta u)\) ，得到 </p><p class="formulaDsp">
\[ F&#39;(u,\delta u) = - \nabla \cdot \left( \frac{1}{\left(1+|\nabla u|^{2}\right)^{\frac{1}{2}}}\nabla \delta u \right) + \nabla \cdot \left( \frac{\nabla u \cdot \nabla \delta u}{\left(1+|\nabla u|^{2}\right)^{\frac{3}{2}}} \nabla u \right). \]
</p>
<p>。</p>
<p>那么，这里就是这个计划的内容。它是关于可以帮助我们计算 \(F&#39;(u,\delta u)\) 的技术，而不必明确地实现它，要么提供 \(F(u)\) 的实现，要么提供 \(E(u)\) 的实现。更确切地说，我们将实现三种不同的方法，并在运行时间方面进行比较，但同时&ndash;也许更重要的是&ndash;实现这些方法需要多少人力。</p>
<ul>
<li>第15步中使用的方法，形成雅各布矩阵。</li>
<li>从残差 \(F(u)\) 的实现中计算雅各布矩阵，使用自动微分法。</li>
<li>从能量函数 \(E(u)\) 的实现中计算残差和雅各布矩阵，也使用自动微分法。</li>
</ul>
<p>对于这些方法中的第一个，与步骤15相比，没有任何概念上的变化。</p>
<p><a class="anchor" id="ComputingtheJacobianfromtheresidual"></a></p><h3>Computing the Jacobian from the residual </h3>
<p>对于第二种方法，让我们概述一下我们将如何利用自动微分来计算残差向量的线性化。为此，让我们暂时改变一下符号，用 \(F(U)\) 表示的不是微分方程的残差，而实际上是*残差向量*，即*离散残差。我们这样做是因为当我们在给定的网格上对问题进行离散时，这就是我们*实际*做的事情。我们解决 \(F(U)=0\) 问题，其中 \(U\) 是未知数的矢量。</p>
<p>更准确地说，残差的 \(i\) th分量由以下公式给出</p>
<p class="formulaDsp">
\[ F(U)_i \dealcoloneq \int\limits_{\Omega}\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p>其中 \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) 。鉴于此，单元格 \(K\) 的贡献是</p>
<p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p>它的一阶泰勒展开为</p>
<p class="formulaDsp">
\[ F(U + \delta U)_i^K \approx F(U)_i^K + \sum_{j}^{n_{\textrm{dofs}}} \left[ \frac{\partial F(U)_i^K}{\partial U_j} \delta U_j \right], \]
</p>
<p>因此我们可以计算出 \(K\) 单元格对雅各布矩阵 \(J\) 的贡献为 \(J(U)_{ij}^K = \frac{\partial F(U)_i^K}{\partial U_j}\) 。这里重要的一点是，在单元格 \(K\) 上，我们可以表示为</p>
<p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+\left| \sum_{j&#39;}^{n_\textrm{dofs}} U_{j&#39;} \nabla \varphi_{j&#39;}\right|^{2}}} \left(\sum_{j&#39;&#39;}^{n_\textrm{dofs}} U_{j&#39;&#39;} \nabla \varphi_{j&#39;&#39;}\right)\right] \, dV. \]
</p>
<p>为了清楚起见，我们用 \(j&#39;\) 和 \(j&#39;&#39;\) 作为计数索引，以明确它们彼此之间以及与上述 \(j\) 的区别。因为在这个公式中， \(F(U)\) 只取决于系数 \(U_j\) ，我们可以通过自动微分 \(F(U)_i^K\) 来计算导数 \(J(U)_{ij}^K\) 作为一个矩阵。通过我们一直使用的相同论证，很明显 \(F(U)^K\) 实际上并不依赖于*所有*未知数 \(U_j\) ，而只是依赖于 \(j\) 是住在单元格 \(K\) 的形状函数的那些未知数。] ，因此在实践中，我们将 \(F(U)^K\) 和 \(J(U)^K\) 限制为矢量和矩阵中对应于*本地*DoF指数的部分，然后从本地单元 \(K\) 分布到全球对象。</p>
<p>使用所有这些实现，然后的方法将是在程序中实现 \(F(U)^K\) ，并让自动微分机械从中计算导数 \(J(U)^K\) 。</p>
<p><a class="anchor" id="ComputingtheJacobianandtheresidualfromtheenergyfunctional"></a></p><h3>Computing the Jacobian and the residual from the energy functional </h3>
<p>对于装配过程的最终实现，我们将比残差高一个层次：我们的整个线性系统将直接由支配这个边界值问题的物理学的能量函数决定。我们可以利用这样一个事实：我们可以直接从局部贡献中计算出域中的总能量，即。</p>
<p class="formulaDsp">
\[ E \left( U \right) \dealcoloneq \int\limits_{\Omega} \Psi \left( u \right) \, dV . \]
</p>
<p>在离散设置中，这意味着在每个有限元上我们有</p>
<p class="formulaDsp">
\[ E \left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{x}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} . \]
</p>
<p>如果我们实现细胞能量，它取决于场解，我们可以计算它的第一个（离散）变化</p>
<p class="formulaDsp">
\[ F(U)^K_i = \frac{\partial E(U)^K}{\partial U_i} \]
</p>
<p>此后，它的第二个（离散）变化</p>
<p class="formulaDsp">
\[ J(U)^K_{ij} = \frac{\partial^{2} E(U)^K}{\partial U_i \partial U_j}. \]
</p>
<p>因此，从单元格对总能量函数的贡献来看，只要我们能够提供局部能量的实现，我们就可以期望为我们生成近似的残差和正切贡献 \(E(U)^K\) 。同样，由于本教程中使用的自动微分变量的设计，在实践中，这些对残差向量和正切矩阵贡献的近似值实际上是精确到机器精度的。</p>
<p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p>本教程的大部分内容是对 <a class="el" href="step_15.html">step-15</a> 的完全复制。因此，为了简洁起见，并保持对这里所实现的变化的关注，我们将只记录新的内容，并简单地指出哪些部分的代码是对以前内容的重复。</p>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>本教程中包含了几个新的头文件。第一个是提供ParameterAcceptor类的声明的文件。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span> </div></div><!-- fragment --><p>这是第二个，这是一个包罗万象的头，它将使我们能够在这段代码中纳入自动区分（AD）功能。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span> </div></div><!-- fragment --><p>而接下来的三个提供了一些使用通用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 框架的多线程能力。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span> </div></div><!-- fragment --><p>然后，我们为这个程序打开一个命名空间，像以前的程序一样，将dealii命名空间中的所有东西导入其中。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>Step72 </div><div class="line">{ </div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemParameterscodeclass"></a> </p><h3>The <code>MinimalSurfaceProblemParameters</code> class</h3>
<p>在本教程中，我们将实现三种不同的方法来组装线性系统。其中一种反映了最初在 <a class="el" href="step_15.html">step-15</a> 中提供的手工实现，而另外两种则使用作为Trilinos框架的一部分提供的Sacado自动微分库。</p>
<p>为了方便在三种实现之间进行切换，我们有这个非常基本的参数类，它只有两个可配置的选项。</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a> </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  MinimalSurfaceProblemParameters(); </div></div><!-- fragment --><p>选择要使用的配方和相应的AD框架。</p>
<ul>
<li>formulation = 0 : 无辅助执行（全手工线性化）。</li>
<li>配方 = 1 : 有限元残差的自动线性化。</li>
<li>formulation = 2 : 使用变量公式自动计算有限元残差和线性化。</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0; </div></div><!-- fragment --><p>线性系统残差的最大可接受公差。我们将看到，一旦我们使用AD框架，装配时间就会变得很明显，所以我们将 <a class="el" href="step_15.html">step-15</a> 中选择的公差提高了一个数量级。这样，计算就不会花费太长时间来完成。</p>
<div class="fragment"><div class="line">  <span class="keywordtype">double</span> tolerance = 1e-2; </div><div class="line">}; </div><div class="line"></div><div class="line">MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters() </div><div class="line">  : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>) </div><div class="line">{ </div><div class="line">  add_parameter( </div><div class="line">    <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2)); </div><div class="line">  add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0)); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclasstemplate"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class template</h3>
<p>该类模板与 <a class="el" href="step_15.html">step-15</a> 中的内容基本相同。该类的唯一功能变化是：。</p>
<ul>
<li><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a>函数现在接收两个参数：一个是选择采用哪种装配方式，一个是允许的最终残差的公差，以及</li>
<li>现在有三个不同的装配函数来实现线性系统的三种装配方法。我们将在后面提供关于这些的细节。</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>MinimalSurfaceProblem </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  MinimalSurfaceProblem(); </div><div class="line"></div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance); </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line">  <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step); </div><div class="line">  <span class="keywordtype">void</span>   assemble_system_unassisted(); </div><div class="line">  <span class="keywordtype">void</span>   assemble_system_with_residual_linearization(); </div><div class="line">  <span class="keywordtype">void</span>   assemble_system_using_energy_functional(); </div><div class="line">  <span class="keywordtype">void</span>   solve(); </div><div class="line">  <span class="keywordtype">void</span>   refine_mesh(); </div><div class="line">  <span class="keywordtype">void</span>   set_boundary_values(); </div><div class="line">  <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>; </div><div class="line">  <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>; </div><div class="line">  <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>; </div><div class="line"></div><div class="line">  <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>; </div><div class="line"></div><div class="line">  <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler; </div><div class="line">  <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe; </div><div class="line">  <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula; </div><div class="line"></div><div class="line">  <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints; </div><div class="line"></div><div class="line">  <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern; </div><div class="line">  SparseMatrix&lt;double&gt; system_matrix; </div><div class="line"></div><div class="line">  Vector&lt;double&gt; current_solution; </div><div class="line">  Vector&lt;double&gt; newton_update; </div><div class="line">  Vector&lt;double&gt; system_rhs; </div><div class="line">}; </div></div><!-- fragment --><p><a class="anchor" id="Boundarycondition"></a> </p><h3>Boundary condition</h3>
<p>应用于该问题的边界条件没有变化。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>; </div><div class="line">}; </div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, </div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1])); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ThecodeMinimalSurfaceProblemcodeclassimplementation"></a> </p><h3>The <code>MinimalSurfaceProblem</code> class implementation</h3>
<p><a class="anchor" id="MinimalSurfaceProblemMinimalSurfaceProblem"></a> </p><h4>MinimalSurfaceProblem::MinimalSurfaceProblem</h4>
<p>对类的构造函数没有做任何修改。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem() </div><div class="line">  : dof_handler(triangulation) </div><div class="line">  , fe(2) </div><div class="line">  , quadrature_formula(fe.degree + 1) </div><div class="line">{} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsetup_system"></a> </p><h4>MinimalSurfaceProblem::setup_system</h4>
<p>设置类数据结构的函数没有任何变化，即DoFHandler、应用于问题的悬挂节点约束以及线性系统。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step) </div><div class="line">{ </div><div class="line">  <span class="keywordflow">if</span> (initial_step) </div><div class="line">    { </div><div class="line">      dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe); </div><div class="line">      current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line"></div><div class="line">      hanging_node_constraints.clear(); </div><div class="line">      <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, </div><div class="line">                                              hanging_node_constraints); </div><div class="line">      hanging_node_constraints.close(); </div><div class="line">    } </div><div class="line"></div><div class="line">  newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp); </div><div class="line"></div><div class="line">  hanging_node_constraints.condense(dsp); </div><div class="line"></div><div class="line">  sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp); </div><div class="line">  system_matrix.reinit(sparsity_pattern); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="Assemblingthelinearsystem"></a> </p><h4>Assembling the linear system</h4>
<p><a class="anchor" id="Manualassembly"></a> </p><h5>Manual assembly</h5>
<p>汇编函数是本教程的有趣贡献。assemble_system_unassisted()方法实现了与 <a class="el" href="step_15.html">step-15</a> 中详述的完全相同的装配函数，但在这个例子中，我们使用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 函数来多线程装配过程。这样做的原因很简单。当使用自动分化时，我们知道会有一些额外的计算开销产生。为了减轻这种性能损失，我们希望尽可能多地利用（容易获得的）计算资源。 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 的概念使这成为一个相对简单的任务。同时，为了公平比较，我们需要对在计算残差或其线性化时不使用任何援助的实现做同样的事情。( <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 函数首先在 <a class="el" href="step_12.html">step-12</a> 和 <a class="el" href="step_16.html">step-16</a> 中讨论，如果你想阅读它的话。)</p>
<p>实现多线程所需的步骤在这三个函数中是相同的，所以我们将利用assemble_system_unassisted()函数的机会，重点讨论多线程本身。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted() </div><div class="line">{ </div><div class="line">  system_matrix = 0; </div><div class="line">  system_rhs    = 0; </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div></div><!-- fragment --><p><a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 希望我们提供两个示范性的数据结构。第一个，<code>ScratchData</code>，是用来存储所有要在线程间重复使用的大数据。<code>CopyData</code>将保存来自每个单元的对线性系统的贡献。这些独立的矩阵-向量对必须按顺序累积到全局线性系统中。由于我们不需要 <a class="el" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData</a> 和 <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> 类已经提供的东西，所以我们使用这些确切的类定义来解决我们的问题。请注意，我们只需要一个局部矩阵、局部右手向量和单元自由度索引向量的单个实例&ndash;因此 <a class="el" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData</a> 的三个模板参数都是<code>1</code>。</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>; </div><div class="line"><span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>; </div></div><!-- fragment --><p>我们还需要知道我们在装配过程中要处理的迭代器的类型。为了简单起见，我们只要求编译器使用decltype()指定器为我们解决这个问题，知道我们将在由 <code>dof_handler</code>. 拥有的活动单元上迭代。</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()); </div></div><!-- fragment --><p>在这里我们初始化示例的数据结构。因为我们知道我们需要计算形状函数梯度、加权雅各布和四分位点在实空间的位置，所以我们把这些标志传给类的构造函数。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> ScratchData sample_scratch_data(fe, </div><div class="line">                                      quadrature_formula, </div><div class="line">                                      <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line"><span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell); </div></div><!-- fragment --><p>现在我们定义一个lambda函数，它将在一个单元格上执行装配。三个参数是由于我们将传递给该最终调用的参数，将被 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a>, 所期望的参数。我们还捕获了 <code>this</code> 指针，这意味着我们将可以访问 "this"（即当前的<code>MinimalSurfaceProblem&lt;dim&gt;</code>）类实例，以及它的私有成员数据（因为lambda函数被定义在MinimalSurfaceProblem&lt;dim&gt;方法中）。</p>
<p>在函数的顶部，我们初始化了依赖于正在执行工作的单元的数据结构。请注意，重新初始化的调用实际上返回了一个FEValues对象的实例，该对象被初始化并存储在<code>scratch_data</code>对象中（因此，被重复使用）。</p>
<p>同样地，我们从 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 提供的<code>copy_data</code>实例中获得本地矩阵、本地RHS向量和本地单元格DoF指数的别名。然后我们初始化单元格的DoF指数，因为我们知道本地矩阵和向量的大小已经正确。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell, </div><div class="line">                                ScratchData &amp;           scratch_data, </div><div class="line">                                CopyData &amp;              copy_data) { </div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0]; </div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0]; </div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">    copy_data.local_dof_indices[0]; </div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices); </div></div><!-- fragment --><p>对于牛顿方法，我们需要问题被线性化的那一点的解的梯度。</p>
<p>一旦我们有了这个梯度，我们就可以用通常的方法对这个单元进行装配。 与 <a class="el" href="step_15.html">step-15</a> 的一个小区别是，我们使用了（相当方便的）基于范围的循环来迭代所有的正交点和自由度。</p>
<div class="fragment"><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients( </div><div class="line">    fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>); </div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution, </div><div class="line">                                   old_solution_gradients); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>()) </div><div class="line">    { </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> coeff = </div><div class="line">        1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] * </div><div class="line">                                old_solution_gradients[q]); </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>()) </div><div class="line">        { </div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>()) </div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += </div><div class="line">              (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i </span></div><div class="line">                 * coeff                         <span class="comment">//   * a_n </span></div><div class="line">                 * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j) </span></div><div class="line">                -                                <span class="comment">//  - </span></div><div class="line">                (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i </span></div><div class="line">                 * coeff * coeff * coeff         <span class="comment">//   * a_n^3 </span></div><div class="line">                 * (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j </span></div><div class="line">                    * old_solution_gradients[q]) <span class="comment">//      * \nabla u_n) </span></div><div class="line">                 * old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n))) </span></div><div class="line">               * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx </span></div><div class="line"></div><div class="line">          cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i </span></div><div class="line">                          * coeff                     <span class="comment">// * a_n </span></div><div class="line">                          * old_solution_gradients[q] <span class="comment">// * u_n </span></div><div class="line">                          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx </span></div><div class="line">        } </div><div class="line">    } </div><div class="line">}; </div></div><!-- fragment --><p><a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 要求的第二个lambda函数是一个执行累积全局线性系统中的局部贡献的任务。这正是这个函数所做的，实现的细节在前面已经看到过。需要认识的主要一点是，局部贡献被存储在传入该函数的<code>copy_data</code>实例中。这个<code>copy_data</code>在 <em>对<code>cell_worker</code>的一些调用中已经被填满了数据。</em> </p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) { </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0]; </div><div class="line">  <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0]; </div><div class="line">  <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">    copy_data.local_dof_indices[0]; </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">    { </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">        system_matrix.add(local_dof_indices[i], </div><div class="line">                          local_dof_indices[j], </div><div class="line">                          cell_matrix(i, j)); </div><div class="line"></div><div class="line">      system_rhs(local_dof_indices[i]) += cell_rhs(i); </div><div class="line">    } </div><div class="line">}; </div></div><!-- fragment --><p>我们已经有了所有需要的函数定义，所以现在我们调用 <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 来执行实际的装配。 我们传递一个标志作为最后的参数，说明我们只想对单元格进行装配。在内部， <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop()</a> 然后将可用的工作分配给不同的线程，有效地利用当今几乎所有的处理器所提供的多核。</p>
<div class="fragment"><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(), </div><div class="line">                      cell_worker, </div><div class="line">                      copier, </div><div class="line">                      sample_scratch_data, </div><div class="line">                      sample_copy_data, </div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>); </div></div><!-- fragment --><p>最后，正如在 <a class="el" href="step_15.html">step-15</a> 中所做的那样，我们从系统中移除悬空的节点，并对定义牛顿更新的线性系统应用零边界值 \(\delta u^n\) 。</p>
<div class="fragment"><div class="line">  hanging_node_constraints.condense(system_matrix); </div><div class="line">  hanging_node_constraints.condense(system_rhs); </div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler, </div><div class="line">                                           0, </div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                           boundary_values); </div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values, </div><div class="line">                                     system_matrix, </div><div class="line">                                     newton_update, </div><div class="line">                                     system_rhs); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheresidualvector"></a> </p><h5>Assembly via differentiation of the residual vector</h5>
<p>正如介绍中所述，我们需要为第二种方法做的是实现 \(F(U)^K\) 单元对残差向量的局部贡献，然后让AD机器处理如何计算它的导数 \(J(U)_{ij}^K=\frac{\partial F(U)^K_i}{\partial U_j}\) 。</p>
<p>对于下面的内容，请记住， </p><p class="formulaDsp">
\[ F(U)_i^K \dealcoloneq \int\limits_K\nabla \varphi_i \cdot \left[ \frac{1}{\sqrt{1+|\nabla u|^{2}}} \nabla u \right] \, dV , \]
</p>
<p> 其中 \(u(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)\) 。</p>
<p>我们来看看这在实践中是如何实现的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization() </div><div class="line">{ </div><div class="line">  system_matrix = 0; </div><div class="line">  system_rhs    = 0; </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>; </div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>; </div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe, </div><div class="line">                                        quadrature_formula, </div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell); </div></div><!-- fragment --><p>我们将利用 <a class="el" href="step_71.html">step-71</a> 中所示的技术，预先定义我们要使用的AD数据结构。在这种情况下，我们选择辅助类，它将使用Sacado向前自动微分类型自动计算有限元残差的线性化。这些数字类型可以只用来计算一阶导数。这正是我们想要的，因为我们知道我们将只对残差进行线性化，这意味着我们只需要计算一阶导数。计算的返回值将是<code>double</code>类型。</p>
<p>我们还需要一个提取器来检索一些与问题的现场解决方案有关的数据。</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt; </div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>, </div><div class="line">  <span class="keywordtype">double</span>&gt;; </div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type; </div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0); </div></div><!-- fragment --><p>有了这个，让我们定义lambda函数，它将被用来计算单元格对雅各布矩阵和右手边的贡献。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell, </div><div class="line">                                       ScratchData &amp;           scratch_data, </div><div class="line">                                       CopyData &amp;              copy_data) { </div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell(); </div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0]; </div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0]; </div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">    copy_data.local_dof_indices[0]; </div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices); </div></div><!-- fragment --><p>我们现在要创建并初始化一个AD辅助类的实例。要做到这一点，我们需要指定有多少个自变量和因变量。自变量将是我们的解向量所具有的局部自由度的数量，即离散化解向量 \(u (\mathbf{x})|_K = \sum\limits_{j} U^K_i \varphi_j(\mathbf{x})\) 的每元素表示中的数字 \(j\) ，它表示每个有限元素有多少个解系数。在deal.II中，这等于 <a class="el" href="classFiniteElementData.html#ae2fa3b8d578ba488b4f37061bb0278bb">FiniteElement::dofs_per_cell</a>. ，自变量的数量将是我们要形成的局部残差向量的条目数。在这个特定的问题中（就像许多其他采用<a href="https:en.wikipedia.org/wiki/Galerkin_method">标准Galerkin方法</a>的问题一样），局部求解系数的数量与局部残差方程的数量相符。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size(); </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell; </div><div class="line">ADHelper ad_helper(n_independent_variables, n_dependent_variables); </div></div><!-- fragment --><p>接下来，我们将解决方案的值告知帮助器，即我们希望线性化的 \(U_j\) 的实际值。由于这是在每个元素上单独进行的，我们必须从全局解决方案向量中提取解决方案的系数。换句话说，我们将所有这些系数 \(U_j\) （其中 \(j\) 是一个局部自由度）定义为进入向量 \(F(U)^{K}\) （因果函数）计算的自变量。 然后， 我们就得到了由可自动微分的数字表示的自由度值的完整集合。对这些变量进行的操作从这一点开始被AD库跟踪，直到对象超出范围。所以正是这些变量 <em> </em> ，我们将对其计算残差项的导数。</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices); </div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad = </div><div class="line">  ad_helper.get_sensitive_dof_values(); </div></div><!-- fragment --><p>然后我们做一些特定问题的任务，首先是根据 "敏感 "的AD自由度值计算所有数值、（空间）梯度等。在这个例子中，我们要检索每个正交点的解梯度。请注意，现在解梯度对自由度值很敏感，因为它们使用 <code>ADNumberType</code> 作为标量类型， <code>dof_values_ad</code> 矢量提供局部自由度值。</p>
<div class="fragment"><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients( </div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>); </div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values( </div><div class="line">  dof_values_ad, old_solution_gradients); </div></div><!-- fragment --><p>我们声明的下一个变量将存储单元格残余向量贡献。这是相当不言自明的，除了一个<b>very important</b>的细节。请注意，向量中的每个条目都是手工初始化的，数值为0。这是一个 <em> 强烈推荐的 </em> 做法，因为一些AD库似乎没有安全地初始化这些数字类型的内部数据结构。不这样做可能会导致一些非常难以理解或检测的错误（感谢这个程序的作者出于一般的坏经验而提到这一点）。因此，出于谨慎考虑，值得明确地将初始值归零。在这之后，除了符号的改变，残差集看起来和我们之前看到的单元格RHS向量差不多。我们在所有正交点上循环，确保系数现在通过使用正确的`ADNumberType'来编码它对（敏感的）有限元DoF值的依赖性，最后我们组装残差向量的组件。为了完全清楚，有限元形状函数（及其梯度等）以及 "JxW "值仍然是标量值，但每个正交点的 <code>coeff</code> 和 <code>old_solution_gradients</code> 是以独立变量计算的。</p>
<div class="fragment"><div class="line">std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables, </div><div class="line">                                      ADNumberType(0.0)); </div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>()) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> ADNumberType coeff = </div><div class="line">      1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] * </div><div class="line">                              old_solution_gradients[q]); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>()) </div><div class="line">      { </div><div class="line">        residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i </span></div><div class="line">                           * coeff                      <span class="comment">// * a_n </span></div><div class="line">                           * old_solution_gradients[q]) <span class="comment">// * u_n </span></div><div class="line">                          * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx </span></div><div class="line">      } </div><div class="line">  } </div></div><!-- fragment --><p>一旦我们计算出完整的单元格残差向量，我们就可以将其注册到辅助类。</p>
<p>此后，我们在评估点计算残差值（基本上是从我们已经计算出来的东西中提取出真实的值）和它们的Jacobian（每个残差分量相对于所有单元DoF的线性化）。为了组装成全局线性系统，我们必须尊重残差和RHS贡献之间的符号差异。对于牛顿方法，右手边的向量需要等于*负的残差向量。</p>
<div class="fragment"><div class="line">  ad_helper.register_residual_vector(residual_ad); </div><div class="line"></div><div class="line">  ad_helper.compute_residual(cell_rhs); </div><div class="line">  cell_rhs *= -1.0; </div><div class="line"></div><div class="line">  ad_helper.compute_linearization(cell_matrix); </div><div class="line">}; </div></div><!-- fragment --><p>该函数的剩余部分等于我们之前的内容。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) { </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0]; </div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0]; </div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">      copy_data.local_dof_indices[0]; </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">          system_matrix.add(local_dof_indices[i], </div><div class="line">                            local_dof_indices[j], </div><div class="line">                            cell_matrix(i, j)); </div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i); </div><div class="line">      } </div><div class="line">  }; </div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(), </div><div class="line">                        cell_worker, </div><div class="line">                        copier, </div><div class="line">                        sample_scratch_data, </div><div class="line">                        sample_copy_data, </div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>); </div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix); </div><div class="line">  hanging_node_constraints.condense(system_rhs); </div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler, </div><div class="line">                                           0, </div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                           boundary_values); </div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values, </div><div class="line">                                     system_matrix, </div><div class="line">                                     newton_update, </div><div class="line">                                     system_rhs); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="Assemblyviadifferentiationoftheenergyfunctional"></a> </p><h5>Assembly via differentiation of the energy functional</h5>
<p>在这第三种方法中，我们将残差和雅各布作为局部能量函数 </p><p class="formulaDsp">
\[ E\left( U \right)^K \dealcoloneq \int\limits_{K} \Psi \left( u \right) \, dV \approx \sum\limits_{q}^{n_{\textrm{q-points}}} \Psi \left( u \left( \mathbf{X}_{q} \right) \right) \underbrace{\vert J_{q} \vert \times W_{q}}_{\text{JxW(q)}} \]
</p>
<p> 的第一和第二导数来计算，能量密度由 </p><p class="formulaDsp">
\[ \Psi \left( u \right) = \sqrt{1+|\nabla u|^{2}} . \]
</p>
<p>给出。</p>
<p>我们再来看看这是如何做到的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional() </div><div class="line">{ </div><div class="line">  system_matrix = 0; </div><div class="line">  system_rhs    = 0; </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line"></div><div class="line">  <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>; </div><div class="line">  <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>; </div><div class="line">  <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> ScratchData sample_scratch_data(fe, </div><div class="line">                                        quadrature_formula, </div><div class="line">                                        <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">  <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell); </div></div><!-- fragment --><p>在这个装配过程的实现中，我们选择了辅助类，它将使用嵌套的Sacado前向自动微分类型自动计算残差及其从单元贡献到能量函数的线性化。所选的数字类型可以用来计算第一和第二导数。我们需要这样做，因为残差定义为势能对DoF值的敏感性（即其梯度）。然后我们需要将残差线性化，这意味着必须计算势能的二阶导数。你可能想把这与之前函数中使用的 "ADHelper "的定义进行比较，在那里我们使用 <code><a class="el" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt;<a class="el" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>,double&gt;</code>. 。</p>
<div class="fragment"><div class="line"><span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt; </div><div class="line">  <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>, </div><div class="line">  <span class="keywordtype">double</span>&gt;; </div><div class="line"><span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type; </div><div class="line"></div><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0); </div></div><!-- fragment --><p>然后让我们再次定义lambda函数，对一个单元进行积分。</p>
<p>为了初始化辅助类的实例，我们现在只需要预先知道自变量的数量（即与元素解向量相关的自由度数量）。这是因为由能量函数产生的二阶导数矩阵必然是平方的（顺便说一下，也是对称的）。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell, </div><div class="line">                                       ScratchData &amp;           scratch_data, </div><div class="line">                                       CopyData &amp;              copy_data) { </div><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0]; </div><div class="line">  Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0]; </div><div class="line">  std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">    copy_data.local_dof_indices[0]; </div><div class="line">  cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size(); </div><div class="line">  ADHelper           ad_helper(n_independent_variables); </div></div><!-- fragment --><p>再一次，我们将所有的单元格DoFs值注册到帮助器中，然后提取这些值的 "敏感 "变体，用于后续必须区分的操作&ndash;其中之一是计算解决方案的梯度。</p>
<div class="fragment"><div class="line">ad_helper.register_dof_values(current_solution, local_dof_indices); </div><div class="line"></div><div class="line"><span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad = </div><div class="line">  ad_helper.get_sensitive_dof_values(); </div><div class="line"></div><div class="line">std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients( </div><div class="line">  fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>); </div><div class="line">fe_values[u_fe].get_function_gradients_from_local_dof_values( </div><div class="line">  dof_values_ad, old_solution_gradients); </div></div><!-- fragment --><p>我们接下来创建一个变量来存储电池的总能量。我们再一次强调，我们明确地对这个值进行零初始化，从而确保这个起始值的数据的完整性。</p>
<p>我们的目的是计算细胞总能量，它是内部能量（由于右手函数，通常是 \(U\) 的线性）和外部能量的总和。在这种特殊情况下，我们没有外部能量（例如，来自源项或诺伊曼边界条件），所以我们将关注内部能量部分。</p>
<p>事实上，计算 \(E(U)^K\) 几乎是微不足道的，只需要以下几行。</p>
<div class="fragment"><div class="line">ADNumberType energy_ad = ADNumberType(0.0); </div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>()) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] * </div><div class="line">                                               old_solution_gradients[q]); </div><div class="line"></div><div class="line">    energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q); </div><div class="line">  } </div></div><!-- fragment --><p>在我们计算出这个单元的总能量后，我们将把它注册到帮助器上。 在此基础上，我们现在可以计算出所需的数量，即残差值和它们在评估点的雅各布系数。和以前一样，牛顿的右手边需要是残差的负数。</p>
<div class="fragment"><div class="line">  ad_helper.register_energy_functional(energy_ad); </div><div class="line"></div><div class="line">  ad_helper.compute_residual(cell_rhs); </div><div class="line">  cell_rhs *= -1.0; </div><div class="line"></div><div class="line"></div><div class="line">}; </div></div><!-- fragment --><p>与前两个函数一样，函数的剩余部分与之前一样。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) { </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0]; </div><div class="line">    <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0]; </div><div class="line">    <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">      copy_data.local_dof_indices[0]; </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">          system_matrix.add(local_dof_indices[i], </div><div class="line">                            local_dof_indices[j], </div><div class="line">                            cell_matrix(i, j)); </div><div class="line"></div><div class="line">        system_rhs(local_dof_indices[i]) += cell_rhs(i); </div><div class="line">      } </div><div class="line">  }; </div><div class="line"></div><div class="line">  <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(), </div><div class="line">                        cell_worker, </div><div class="line">                        copier, </div><div class="line">                        sample_scratch_data, </div><div class="line">                        sample_copy_data, </div><div class="line">                        <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>); </div><div class="line"></div><div class="line">  hanging_node_constraints.condense(system_matrix); </div><div class="line">  hanging_node_constraints.condense(system_rhs); </div><div class="line"></div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">  <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler, </div><div class="line">                                           0, </div><div class="line">                                           <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                           boundary_values); </div><div class="line">  <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values, </div><div class="line">                                     system_matrix, </div><div class="line">                                     newton_update, </div><div class="line">                                     system_rhs); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemsolve"></a> </p><h4>MinimalSurfaceProblem::solve</h4>
<p>解算函数与 <a class="el" href="step_15.html">step-15</a> 中使用的相同。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve() </div><div class="line">{ </div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.<a class="code" href="classBlockVectorBase.html#a69b8dc1f71903659eb44f12e02359ac6">size</a>(), </div><div class="line">                               system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>() * 1e-6); </div><div class="line">  <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control); </div><div class="line"></div><div class="line">  <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner; </div><div class="line">  preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2); </div><div class="line"></div><div class="line">  solver.solve(system_matrix, newton_update, system_rhs, preconditioner); </div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(newton_update); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length(); </div><div class="line">  current_solution.add(alpha, newton_update); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrefine_mesh"></a> </p><h4>MinimalSurfaceProblem::refine_mesh</h4>
<p>自 <a class="el" href="step_15.html">step-15</a> 以来，在网格细化程序和适应性网格之间的解决方案的转移方面没有任何变化。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh() </div><div class="line">{ </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;float&gt;</a> estimated_error_per_cell(triangulation.n_active_cells()); </div><div class="line"></div><div class="line">  <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>( </div><div class="line">    dof_handler, </div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1), </div><div class="line">    std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(), </div><div class="line">    current_solution, </div><div class="line">    estimated_error_per_cell); </div><div class="line"></div><div class="line">  <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation, </div><div class="line">                                                  estimated_error_per_cell, </div><div class="line">                                                  0.3, </div><div class="line">                                                  0.03); </div><div class="line"></div><div class="line">  triangulation.prepare_coarsening_and_refinement(); </div><div class="line">  <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler); </div><div class="line">  solution_transfer.prepare_for_coarsening_and_refinement(current_solution); </div><div class="line">  triangulation.execute_coarsening_and_refinement(); </div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe); </div><div class="line"></div><div class="line">  Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">  solution_transfer.interpolate(current_solution, tmp); </div><div class="line">  current_solution = tmp; </div><div class="line"></div><div class="line">  hanging_node_constraints.clear(); </div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, </div><div class="line">                                          hanging_node_constraints); </div><div class="line">  hanging_node_constraints.close(); </div><div class="line"></div><div class="line">  set_boundary_values(); </div><div class="line"></div><div class="line"></div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemset_boundary_values"></a> </p><h4>MinimalSurfaceProblem::set_boundary_values</h4>
<p>边界条件的选择仍然与 <a class="el" href="step_15.html">step-15</a> 相同 ...</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values() </div><div class="line">{ </div><div class="line">  std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">}; </div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">                                           BoundaryValues&lt;dim&gt;(), </div><div class="line">                                           boundary_values); </div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values) </div><div class="line">    current_solution(boundary_value.first) = boundary_value.second; </div><div class="line"></div><div class="line">  hanging_node_constraints.distribute(current_solution); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemcompute_residual"></a> </p><h4>MinimalSurfaceProblem::compute_residual</h4>
<p>...就像在求解迭代过程中用来计算残差的函数一样。如果真的需要，我们可以用能量函数的微分来代替它，但是为了简单起见，我们在这里只是简单地复制我们在 <a class="el" href="step_15.html">step-15</a> 中已经有的东西。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line"></div><div class="line">  Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">  evaluation_point = current_solution; </div><div class="line">  evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1); </div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe, </div><div class="line">                          quadrature_formula, </div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); </div><div class="line"></div><div class="line">  Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell); </div><div class="line">  std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points); </div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>()) </div><div class="line">    { </div><div class="line">      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0; </div><div class="line">      fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>); </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff = </div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]); </div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">            <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i </span></div><div class="line">                                 * coeff                    <span class="comment">// * a_n </span></div><div class="line">                                 * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n </span></div><div class="line">                                 * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx </span></div><div class="line">        } </div><div class="line"></div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">        residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i); </div><div class="line">    } </div><div class="line"></div><div class="line">  hanging_node_constraints.condense(residual); </div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i : </div><div class="line">       <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler)) </div><div class="line">    residual(i) = 0; </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>(); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemdetermine_step_length"></a> </p><h4>MinimalSurfaceProblem::determine_step_length</h4>
<p>非线性迭代程序的步长（或欠松系数）的选择仍然固定在 <a class="el" href="step_15.html">step-15</a> 中选择和讨论的值。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <span class="keywordflow">return</span> 0.1; </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemoutput_results"></a> </p><h4>MinimalSurfaceProblem::output_results</h4>
<p>从<code><a class="el" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run()</a></code>调用的最后一个函数以图形形式输出当前的解决方案（和牛顿更新），作为VTU文件。它与之前教程中使用的完全相同。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results( </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; </div><div class="line"></div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler); </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>); </div><div class="line">  data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>); </div><div class="line">  data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(); </div><div class="line"></div><div class="line">  <span class="keyword">const</span> std::string filename = </div><div class="line">    <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>; </div><div class="line">  std::ofstream output(filename); </div><div class="line">  data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="MinimalSurfaceProblemrun"></a> </p><h4>MinimalSurfaceProblem::run</h4>
<p>在运行函数中，大部分内容与最初在 <a class="el" href="step_15.html">step-15</a> 中实现的相同。唯一可以观察到的变化是，我们现在可以（通过参数文件）选择系统残差的最终可接受的公差是什么，并且我们可以选择我们希望利用的装配方法。为了使第二个选择明确，我们向控制台输出一些信息，表明选择。由于我们对比较三种方法中每一种的装配时间感兴趣，我们还添加了一个计时器，跟踪装配过程中所花费的时间。我们还跟踪了解决线性系统所需的时间，这样我们就可以将这些数字与通常需要最长时间执行的那部分代码进行对比。</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation, </div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) </div><div class="line">  { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl; </div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = { </div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>, </div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>, </div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}}; </div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size()); </div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl; </div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>); </div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation); </div><div class="line">    triangulation.refine_global(2); </div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>); </div><div class="line">    set_boundary_values(); </div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(); </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0; </div><div class="line">    <span class="keywordflow">do</span> </div><div class="line">      { </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0) </div><div class="line">          refine_mesh(); </div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5; </div><div class="line">             ++inner_iteration) </div><div class="line">          { </div><div class="line">            { </div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>); </div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0) </div><div class="line">                assemble_system_unassisted(); </div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1) </div><div class="line">                assemble_system_with_residual_linearization(); </div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2) </div><div class="line">                assemble_system_using_energy_functional(); </div><div class="line">              <span class="keywordflow">else</span> </div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()); </div><div class="line">            } </div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>(); </div><div class="line"></div><div class="line">            { </div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>); </div><div class="line">              solve(); </div><div class="line">            } </div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl; </div><div class="line">          } </div><div class="line"></div><div class="line">        output_results(refinement_cycle); </div><div class="line"></div><div class="line">        ++refinement_cycle; </div><div class="line">        std::cout &lt;&lt; std::endl; </div><div class="line">      } </div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance); </div><div class="line">  } </div><div class="line">} <span class="comment">// namespace Step72 </span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main function</h4>
<p>最后是主函数。它遵循大多数其他主函数的方案，但有两个明显的例外。</p>
<ul>
<li>我们调用 <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> ，以便（通过一个隐藏的默认参数）设置使用多线程任务执行的线程数。</li>
<li>我们还有几行专门用于读取或初始化用户定义的参数，这些参数将在程序执行过程中被考虑。</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) </div><div class="line">{ </div><div class="line">  <span class="keywordflow">try</span> </div><div class="line">    { </div><div class="line">      <span class="keyword">using namespace </span>Step72; </div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv); </div><div class="line"></div><div class="line">      std::string prm_file; </div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1) </div><div class="line">        prm_file = argv[1]; </div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>; </div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters; </div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file); </div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d; </div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation, </div><div class="line">                                     parameters.tolerance); </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (...) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">} </div></div><!-- fragment --><p> examples/step-72/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p>由于在步骤15中首先分析的问题的物理学没有变化，所以没有什么可报告的。它们之间唯一外显的区别是，在默认情况下，这个程序只运行9个网格细化步骤（相对于第15步，执行11个细化）。这可以从模拟状态中观察到，该状态出现在打印出正在使用的装配方法的标题文本和最终的时间。下面报告的所有时间都是在发布模式下获得的）。</p>
<div class="fragment"><div class="line">Mesh refinement step 0</div><div class="line">  Initial residual: 1.53143</div><div class="line">  Residual: 1.08746</div><div class="line">  Residual: 0.966748</div><div class="line">  Residual: 0.859602</div><div class="line">  Residual: 0.766462</div><div class="line">  Residual: 0.685475</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">Mesh refinement step 9</div><div class="line">  Initial residual: 0.00924594</div><div class="line">  Residual: 0.00831928</div><div class="line">  Residual: 0.0074859</div><div class="line">  Residual: 0.0067363</div><div class="line">  Residual: 0.00606197</div><div class="line">  Residual: 0.00545529</div></div><!-- fragment --><p>因此，我们感兴趣的是比较三种不同实现方式的装配过程需要多长时间，并把它放到更大的背景中。下面是手部线性化的输出结果（在2012年左右的四核八线程笔记本电脑上计算的结果&ndash;但我们真正感兴趣的只是不同实现方式之间的相对时间）。</p>
<div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Unassisted implementation (full hand linearization).</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      35.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      1.56s |       4.5% |</div><div class="line">| Solve                           |        50 |      30.8s |        88% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>而对于使用萨卡多动态正向AD数字类型，以自动方式将残差线性化的实施。</p>
<div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Automated linearization of the finite element residual.</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      40.1s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |       8.8s |        22% |</div><div class="line">| Solve                           |        50 |      28.6s |        71% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>最后，对于直接从能量函数（使用嵌套的Sacado动态前向AD数）计算残差和其线性化的实现。</p>
<div class="fragment"><div class="line">         Assembly approach ********</div><div class="line">Automated computation of finite element residual and linearization <span class="keyword">using</span> a variational formulation.</div><div class="line"></div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line"></div><div class="line">+---------------------------------------------+------------+------------+</div><div class="line">| Total wallclock time elapsed since start    |      48.8s |            |</div><div class="line">|                                             |            |            |</div><div class="line">| Section                         | no. calls |  wall time | % of total |</div><div class="line">+---------------------------------+-----------+------------+------------+</div><div class="line">| Assemble                        |        50 |      16.7s |        34% |</div><div class="line">| Solve                           |        50 |      29.3s |        60% |</div><div class="line">+---------------------------------+-----------+------------+------------+</div></div><!-- fragment --><p>很明显，交给自动分化框架执行的工作越多，在装配过程中花费的时间就越多。在所有细化步骤中累积起来，与无辅助装配相比，使用一级自动微分导致在装配阶段花费了 \(5.65 \times\) 的计算时间，而直接从能量函数推导时，装配离散线性系统花费了 \(10.7 \times\) 的时间。不足为奇的是，解决线性系统的总体时间保持不变。这意味着，随着在有限元水平上进行自动微分的次数的增加，花在求解阶段的时间与装配阶段的时间比例发生了明显的转变。对许多人来说，这可能意味着在生产代码中利用高阶微分（在有限元水平）会导致不可接受的开销，但在原型设计阶段，它可能仍然有用。因此，两者之间的一个很好的折衷办法是有限元残差的自动线性化，它以可衡量的、但也许不是不可接受的成本提供了很多便利。另外，我们可以考虑不在每一步中重新建立牛顿矩阵&ndash;这个主题在步骤77中有大量的深入探讨。</p>
<p>当然，在实践中，实际的开销在很大程度上取决于被评估的问题（例如，解决方案中有多少成分，被微分的函数的性质是什么，等等）。因此，这里提出的确切结果应该仅在这个标量问题的背景下进行解释，当涉及到其他问题时，用户肯定需要进行一些初步调查。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions </h3>
<p>与步骤-71一样，有几个与自动区分有关的项目可以进一步评估。</p>
<ul>
<li>应调查其他AD框架的使用情况，并展望其他实施方式可能提供性能优势。</li>
<li>除了本教程中硬编码的数字类型外，还值得对AD数字类型进行评估。关于在有限元水平上采用的两次微分类型，混合微分模式（"RAD-FAD"）原则上应该比这里采用的单一模式（"FAD-FAD"）类型的计算效率更高。RAD-FAD类型没有被默认选择的原因是，在撰写本文时，在Sacado库中，它的实现仍然存在一些错误，导致内存泄漏。 这在 <a class="el" href="group__auto__symb__diff.html">Automatic and symbolic differentiation</a> 模块中有所记载。</li>
<li>也许使用低精度类型（即 "浮动"）作为AD数字的标量类型可以减少装配时的计算费用。使用 "float "作为矩阵和残差的数据类型并不是不合理的，因为牛顿更新只是为了让我们更接近解决方案，而不是实际*到解决方案；因此，考虑使用降低精度的数据类型来计算这些更新，然后将这些更新累积到使用全 "双 "精度的解决方案向量中，是有意义的。</li>
<li>在装配过程中可能减少资源的另一个方法是将AD的实现作为一个构成模型。这类似于步骤71中采用的方法，并将自动微分的起点推到了计算链的上一级。这反过来意味着AD库跟踪的操作更少，从而降低了微分的成本（尽管我们会在每个单元的正交点进行微分）。</li>
<li>第77步是第15步的另一个变化，解决了问题的一个非常不同的部分：直线搜索以及是否有必要在每次非线性迭代中重新建立牛顿矩阵。鉴于上述结果表明，使用自动微分是有代价的，第77步的技术有可能在一定程度上抵消这些代价。因此，将目前的程序与第77步中的技术结合起来是相当有趣的。对于生产代码来说，这肯定是个好办法。</li>
</ul>
<p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* --------------------------------------------------------------------- </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Copyright (C) 2021 by the deal.II authors </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * This file is part of the deal.II library. </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute </span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General </span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either </span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version. </span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE.md at </span></div><div class="line"><span class="comment"> * the top level directory of deal.II. </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * --------------------------------------------------------------------- </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Authors: Jean-Paul Pelteret, </span></div><div class="line"><span class="comment"> *          Wolfgang Bangerth, Colorado State University, 2021. </span></div><div class="line"><span class="comment"> * Based on @ref step_15 &quot;step-15&quot;, authored by Sven Wetterauer, University of Heidelberg, 2012 </span></div><div class="line"><span class="comment"> */</span> </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="parameter__acceptor_8h.html">deal.II/base/parameter_acceptor.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="ad_8h.html">deal.II/differentiation/ad.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="sparse__matrix_8h.html">deal.II/lac/sparse_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="solver__cg_8h.html">deal.II/lac/solver_cg.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="precondition_8h.html">deal.II/lac/precondition.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2tria_8h.html">deal.II/grid/tria.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__values__extractors_8h.html">deal.II/fe/fe_values_extractors.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="copy__data_8h.html">deal.II/meshworker/copy_data.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="mesh__loop_8h.html">deal.II/meshworker/mesh_loop.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="scratch__data_8h.html">deal.II/meshworker/scratch_data.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="matrix__tools_8h.html">deal.II/numerics/matrix_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2solution__transfer_8h.html">deal.II/numerics/solution_transfer.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">namespace </span>Step72 </div><div class="line">{ </div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblemParameters : <span class="keyword">public</span> <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a> </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    MinimalSurfaceProblemParameters(); </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> formulation = 0; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> tolerance = 1e-2; </div><div class="line">  }; </div><div class="line"></div><div class="line">  MinimalSurfaceProblemParameters::MinimalSurfaceProblemParameters() </div><div class="line">    : <a class="code" href="classParameterAcceptor.html">ParameterAcceptor</a>(<span class="stringliteral">&quot;Minimal Surface Problem/&quot;</span>) </div><div class="line">  { </div><div class="line">    add_parameter( </div><div class="line">      <span class="stringliteral">&quot;Formulation&quot;</span>, formulation, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Integer.html">Patterns::Integer</a>(0, 2)); </div><div class="line">    add_parameter(<span class="stringliteral">&quot;Tolerance&quot;</span>, tolerance, <span class="stringliteral">&quot;&quot;</span>, this-&gt;prm, <a class="code" href="classPatterns_1_1Double.html">Patterns::Double</a>(0.0)); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>MinimalSurfaceProblem </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    MinimalSurfaceProblem(); </div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span> formulation, <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance); </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line">    <span class="keywordtype">void</span>   setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step); </div><div class="line">    <span class="keywordtype">void</span>   assemble_system_unassisted(); </div><div class="line">    <span class="keywordtype">void</span>   assemble_system_with_residual_linearization(); </div><div class="line">    <span class="keywordtype">void</span>   assemble_system_using_energy_functional(); </div><div class="line">    <span class="keywordtype">void</span>   solve(); </div><div class="line">    <span class="keywordtype">void</span>   refine_mesh(); </div><div class="line">    <span class="keywordtype">void</span>   set_boundary_values(); </div><div class="line">    <span class="keywordtype">double</span> compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha) <span class="keyword">const</span>; </div><div class="line">    <span class="keywordtype">double</span> determine_step_length() <span class="keyword">const</span>; </div><div class="line">    <span class="keywordtype">void</span>   output_results(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle) <span class="keyword">const</span>; </div><div class="line"></div><div class="line">    <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>; </div><div class="line"></div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler; </div><div class="line">    <a class="code" href="classFE__Q.html">FE_Q&lt;dim&gt;</a>       fe; </div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a>     quadrature_formula; </div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;double&gt;</a> hanging_node_constraints; </div><div class="line"></div><div class="line">    <a class="code" href="classSparsityPattern.html">SparsityPattern</a>      sparsity_pattern; </div><div class="line">    SparseMatrix&lt;double&gt; system_matrix; </div><div class="line"></div><div class="line">    Vector&lt;double&gt; current_solution; </div><div class="line">    Vector&lt;double&gt; newton_update; </div><div class="line">    Vector&lt;double&gt; system_rhs; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>BoundaryValues : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>; </div><div class="line">  }; </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">double</span> BoundaryValues&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, </div><div class="line">                                    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    <span class="keywordflow">return</span> <a class="code" href="vectorization_8h.html#ad9b7aa5c50bf9ce988a0f756a3f2baa5">std::sin</a>(2 * numbers::PI * (p[0] + p[1])); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  MinimalSurfaceProblem&lt;dim&gt;::MinimalSurfaceProblem() </div><div class="line">    : dof_handler(triangulation) </div><div class="line">    , fe(2) </div><div class="line">    , quadrature_formula(fe.degree + 1) </div><div class="line">  {} </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::setup_system(<span class="keyword">const</span> <span class="keywordtype">bool</span> initial_step) </div><div class="line">  { </div><div class="line">    <span class="keywordflow">if</span> (initial_step) </div><div class="line">      { </div><div class="line">        dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe); </div><div class="line">        current_solution.reinit(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line"></div><div class="line">        hanging_node_constraints.clear(); </div><div class="line">        <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, </div><div class="line">                                                hanging_node_constraints); </div><div class="line">        hanging_node_constraints.close(); </div><div class="line">      } </div><div class="line"></div><div class="line">    newton_update.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp); </div><div class="line"></div><div class="line">    hanging_node_constraints.condense(dsp); </div><div class="line"></div><div class="line">    sparsity_pattern.<a class="code" href="classBlockSparsityPattern.html#a923288e4b4093f86b680e7045e9b4984">copy_from</a>(dsp); </div><div class="line">    system_matrix.reinit(sparsity_pattern); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_unassisted() </div><div class="line">  { </div><div class="line">    system_matrix = 0; </div><div class="line">    system_rhs    = 0; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>; </div><div class="line">    <span class="keyword">using</span> CopyData    = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>; </div><div class="line"></div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe, </div><div class="line">                                          quadrature_formula, </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell); </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [<span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell, </div><div class="line">                                    ScratchData &amp;           scratch_data, </div><div class="line">                                    CopyData &amp;              copy_data) { </div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0]; </div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0]; </div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">        copy_data.local_dof_indices[0]; </div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim&gt;&gt; old_solution_gradients( </div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>); </div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(current_solution, </div><div class="line">                                       old_solution_gradients); </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>()) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> coeff = </div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] * </div><div class="line">                                    old_solution_gradients[q]); </div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>()) </div><div class="line">            { </div><div class="line">              <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>()) </div><div class="line">                <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += </div><div class="line">                  (((fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">// ((\nabla \phi_i </span></div><div class="line">                     * coeff                         <span class="comment">//   * a_n </span></div><div class="line">                     * fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q))   <span class="comment">//   * \nabla \phi_j) </span></div><div class="line">                    -                                <span class="comment">//  - </span></div><div class="line">                    (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)      <span class="comment">//  (\nabla \phi_i </span></div><div class="line">                     * coeff * coeff * coeff         <span class="comment">//   * a_n^3 </span></div><div class="line">                     * (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(j, q)   <span class="comment">//   * (\nabla \phi_j </span></div><div class="line">                        * old_solution_gradients[q]) <span class="comment">//      * \nabla u_n) </span></div><div class="line">                     * old_solution_gradients[q]))   <span class="comment">//   * \nabla u_n))) </span></div><div class="line">                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));              <span class="comment">// * dx </span></div><div class="line"></div><div class="line">              cell_rhs(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)  <span class="comment">// \nabla \phi_i </span></div><div class="line">                              * coeff                     <span class="comment">// * a_n </span></div><div class="line">                              * old_solution_gradients[q] <span class="comment">// * u_n </span></div><div class="line">                              * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));        <span class="comment">// * dx </span></div><div class="line">            } </div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) { </div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0]; </div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0]; </div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">        copy_data.local_dof_indices[0]; </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">        { </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">            system_matrix.add(local_dof_indices[i], </div><div class="line">                              local_dof_indices[j], </div><div class="line">                              cell_matrix(i, j)); </div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i); </div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(), </div><div class="line">                          cell_worker, </div><div class="line">                          copier, </div><div class="line">                          sample_scratch_data, </div><div class="line">                          sample_copy_data, </div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>); </div><div class="line"></div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix); </div><div class="line">    hanging_node_constraints.condense(system_rhs); </div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler, </div><div class="line">                                             0, </div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                             boundary_values); </div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values, </div><div class="line">                                       system_matrix, </div><div class="line">                                       newton_update, </div><div class="line">                                       system_rhs); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_with_residual_linearization() </div><div class="line">  { </div><div class="line">    system_matrix = 0; </div><div class="line">    system_rhs    = 0; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>; </div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>; </div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()); </div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe, </div><div class="line">                                          quadrature_formula, </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell); </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1ResidualLinearization.html">Differentiation::AD::ResidualLinearization</a>&lt; </div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca3616da751c767b07051278ed7d81c0dc">Differentiation::AD::NumberTypes::sacado_dfad</a>, </div><div class="line">      <span class="keywordtype">double</span>&gt;; </div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell, </div><div class="line">                                           ScratchData &amp;           scratch_data, </div><div class="line">                                           CopyData &amp;              copy_data) { </div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;       fe_values     = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe_values.<a class="code" href="classFEValuesBase.html#ade22ffd9fb5b07842daa504929244aa7">get_fe</a>().n_dofs_per_cell(); </div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0]; </div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0]; </div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">        copy_data.local_dof_indices[0]; </div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size(); </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_dependent_variables   = dofs_per_cell; </div><div class="line">      ADHelper ad_helper(n_independent_variables, n_dependent_variables); </div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad = </div><div class="line">        ad_helper.get_sensitive_dof_values(); </div><div class="line"></div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients( </div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>); </div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values( </div><div class="line">        dof_values_ad, old_solution_gradients); </div><div class="line"></div><div class="line"></div><div class="line">      std::vector&lt;ADNumberType&gt; residual_ad(n_dependent_variables, </div><div class="line">                                            ADNumberType(0.0)); </div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>()) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> ADNumberType coeff = </div><div class="line">            1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] * </div><div class="line">                                    old_solution_gradients[q]); </div><div class="line"></div><div class="line">          <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i : fe_values.<a class="code" href="classFEValuesBase.html#a93872d888911cda7e2e716168afc1b3f">dof_indices</a>()) </div><div class="line">            { </div><div class="line">              residual_ad[i] += (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q)   <span class="comment">// \nabla \phi_i </span></div><div class="line">                                 * coeff                      <span class="comment">// * a_n </span></div><div class="line">                                 * old_solution_gradients[q]) <span class="comment">// * u_n </span></div><div class="line">                                * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q);           <span class="comment">// * dx </span></div><div class="line">            } </div><div class="line">        } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_residual_vector(residual_ad); </div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs); </div><div class="line">      cell_rhs *= -1.0; </div><div class="line"></div><div class="line">      ad_helper.compute_linearization(cell_matrix); </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) { </div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0]; </div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0]; </div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">        copy_data.local_dof_indices[0]; </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">        { </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">            system_matrix.add(local_dof_indices[i], </div><div class="line">                              local_dof_indices[j], </div><div class="line">                              cell_matrix(i, j)); </div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i); </div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(), </div><div class="line">                          cell_worker, </div><div class="line">                          copier, </div><div class="line">                          sample_scratch_data, </div><div class="line">                          sample_copy_data, </div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>); </div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix); </div><div class="line">    hanging_node_constraints.condense(system_rhs); </div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler, </div><div class="line">                                             0, </div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                             boundary_values); </div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values, </div><div class="line">                                       system_matrix, </div><div class="line">                                       newton_update, </div><div class="line">                                       system_rhs); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::assemble_system_using_energy_functional() </div><div class="line">  { </div><div class="line">    system_matrix = 0; </div><div class="line">    system_rhs    = 0; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line"></div><div class="line">    <span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim&gt;</a>; </div><div class="line">    <span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>; </div><div class="line">    <span class="keyword">using</span> CellIteratorType = decltype(dof_handler.<a class="code" href="classDoFHandler.html#a1a36dbbb4c54a7038c60ee9c8eab369a">begin_active</a>()); </div><div class="line"></div><div class="line">    <span class="keyword">const</span> ScratchData sample_scratch_data(fe, </div><div class="line">                                          quadrature_formula, </div><div class="line">                                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">    <span class="keyword">const</span> CopyData    sample_copy_data(dofs_per_cell); </div><div class="line"></div><div class="line">    <span class="keyword">using</span> ADHelper = <a class="code" href="classDifferentiation_1_1AD_1_1EnergyFunctional.html">Differentiation::AD::EnergyFunctional</a>&lt; </div><div class="line">      <a class="code" href="namespaceDifferentiation_1_1AD.html#acc1d0db17ec4125ac4e28f6ad2069b1ca31c59c1a501105f4291d9a492c4465f7">Differentiation::AD::NumberTypes::sacado_dfad_dfad</a>, </div><div class="line">      <span class="keywordtype">double</span>&gt;; </div><div class="line">    <span class="keyword">using</span> ADNumberType = <span class="keyword">typename</span> ADHelper::ad_type; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Scalar.html">FEValuesExtractors::Scalar</a> u_fe(0); </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> cell_worker = [&amp;u_fe, <span class="keyword">this</span>](<span class="keyword">const</span> CellIteratorType &amp;cell, </div><div class="line">                                           ScratchData &amp;           scratch_data, </div><div class="line">                                           CopyData &amp;              copy_data) { </div><div class="line">      <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_values = scratch_data.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">      <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;                  cell_matrix = copy_data.matrices[0]; </div><div class="line">      Vector&lt;double&gt; &amp;                      cell_rhs    = copy_data.vectors[0]; </div><div class="line">      std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">        copy_data.local_dof_indices[0]; </div><div class="line">      cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_independent_variables = local_dof_indices.size(); </div><div class="line">      ADHelper           ad_helper(n_independent_variables); </div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_dof_values(current_solution, local_dof_indices); </div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;ADNumberType&gt; &amp;dof_values_ad = </div><div class="line">        ad_helper.get_sensitive_dof_values(); </div><div class="line"></div><div class="line">      std::vector&lt;Tensor&lt;1, dim, ADNumberType&gt;&gt; old_solution_gradients( </div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#a807c3049bfe81743fc0f237dfc2fbdea">n_quadrature_points</a>); </div><div class="line">      fe_values[u_fe].get_function_gradients_from_local_dof_values( </div><div class="line">        dof_values_ad, old_solution_gradients); </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      ADNumberType energy_ad = ADNumberType(0.0); </div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q : fe_values.<a class="code" href="classFEValuesBase.html#aada8380792b5e6a1f91dcba94b558cb8">quadrature_point_indices</a>()) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> ADNumberType psi = <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + old_solution_gradients[q] * </div><div class="line">                                                     old_solution_gradients[q]); </div><div class="line"></div><div class="line">          energy_ad += psi * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q); </div><div class="line">        } </div><div class="line"></div><div class="line"></div><div class="line">      ad_helper.register_energy_functional(energy_ad); </div><div class="line"></div><div class="line">      ad_helper.compute_residual(cell_rhs); </div><div class="line">      cell_rhs *= -1.0; </div><div class="line"></div><div class="line"> </div><div class="line">    }; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> copier = [dofs_per_cell, <span class="keyword">this</span>](<span class="keyword">const</span> CopyData &amp;copy_data) { </div><div class="line">      <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> &amp;cell_matrix = copy_data.matrices[0]; </div><div class="line">      <span class="keyword">const</span> Vector&lt;double&gt; &amp;    cell_rhs    = copy_data.vectors[0]; </div><div class="line">      <span class="keyword">const</span> std::vector&lt;types::global_dof_index&gt; &amp;local_dof_indices = </div><div class="line">        copy_data.local_dof_indices[0]; </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">        { </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">            system_matrix.add(local_dof_indices[i], </div><div class="line">                              local_dof_indices[j], </div><div class="line">                              cell_matrix(i, j)); </div><div class="line"></div><div class="line">          system_rhs(local_dof_indices[i]) += cell_rhs(i); </div><div class="line">        } </div><div class="line">    }; </div><div class="line"></div><div class="line">    <a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>(), </div><div class="line">                          cell_worker, </div><div class="line">                          copier, </div><div class="line">                          sample_scratch_data, </div><div class="line">                          sample_copy_data, </div><div class="line">                          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>); </div><div class="line"></div><div class="line">    hanging_node_constraints.condense(system_matrix); </div><div class="line">    hanging_node_constraints.condense(system_rhs); </div><div class="line"></div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">    <a class="code" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values</a>(dof_handler, </div><div class="line">                                             0, </div><div class="line">                                             <a class="code" href="classFunctions_1_1ZeroFunction.html">Functions::ZeroFunction&lt;dim&gt;</a>(), </div><div class="line">                                             boundary_values); </div><div class="line">    <a class="code" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values</a>(boundary_values, </div><div class="line">                                       system_matrix, </div><div class="line">                                       newton_update, </div><div class="line">                                       system_rhs); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::solve() </div><div class="line">  { </div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>            solver_control(system_rhs.<a class="code" href="classBlockVectorBase.html#a69b8dc1f71903659eb44f12e02359ac6">size</a>(), </div><div class="line">                                 system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>() * 1e-6); </div><div class="line">    <a class="code" href="classSolverCG.html">SolverCG&lt;Vector&lt;double&gt;</a>&gt; solver(solver_control); </div><div class="line"></div><div class="line">    <a class="code" href="classPreconditionSSOR.html">PreconditionSSOR&lt;SparseMatrix&lt;double&gt;</a>&gt; preconditioner; </div><div class="line">    preconditioner.<a class="code" href="classPreconditionSSOR.html#a7a3d66b17bb0ea1b16606e222474c2ea">initialize</a>(system_matrix, 1.2); </div><div class="line"></div><div class="line">    solver.solve(system_matrix, newton_update, system_rhs, preconditioner); </div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(newton_update); </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> alpha = determine_step_length(); </div><div class="line">    current_solution.add(alpha, newton_update); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::refine_mesh() </div><div class="line">  { </div><div class="line">    Vector&lt;float&gt; estimated_error_per_cell(triangulation.n_active_cells()); </div><div class="line"></div><div class="line">    <a class="code" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">KellyErrorEstimator&lt;dim&gt;::estimate</a>( </div><div class="line">      dof_handler, </div><div class="line">      <a class="code" href="classQGauss.html">QGauss&lt;dim - 1&gt;</a>(fe.degree + 1), </div><div class="line">      std::map&lt;<a class="code" href="classunsigned_01int.html">types::boundary_id</a>, <span class="keyword">const</span> <a class="code" href="classFunction.html">Function&lt;dim&gt;</a> *&gt;(), </div><div class="line">      current_solution, </div><div class="line">      estimated_error_per_cell); </div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number</a>(triangulation, </div><div class="line">                                                    estimated_error_per_cell, </div><div class="line">                                                    0.3, </div><div class="line">                                                    0.03); </div><div class="line"></div><div class="line">    triangulation.prepare_coarsening_and_refinement(); </div><div class="line">    <a class="code" href="classSolutionTransfer.html">SolutionTransfer&lt;dim&gt;</a> solution_transfer(dof_handler); </div><div class="line">    solution_transfer.prepare_for_coarsening_and_refinement(current_solution); </div><div class="line">    triangulation.execute_coarsening_and_refinement(); </div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe); </div><div class="line"></div><div class="line">    Vector&lt;double&gt; tmp(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">    solution_transfer.interpolate(current_solution, tmp); </div><div class="line">    current_solution = tmp; </div><div class="line"></div><div class="line">    hanging_node_constraints.clear(); </div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, </div><div class="line">                                            hanging_node_constraints); </div><div class="line">    hanging_node_constraints.close(); </div><div class="line"></div><div class="line">    set_boundary_values(); </div><div class="line"></div><div class="line"> </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::set_boundary_values() </div><div class="line">  { </div><div class="line">    std::map&lt;types::global_dof_index, double&gt; boundary_values; </div><div class="line">  }; </div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">                                             BoundaryValues&lt;dim&gt;(), </div><div class="line">                                             boundary_values); </div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;boundary_value : boundary_values) </div><div class="line">      current_solution(boundary_value.first) = boundary_value.second; </div><div class="line"></div><div class="line">    hanging_node_constraints.distribute(current_solution); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::compute_residual(<span class="keyword">const</span> <span class="keywordtype">double</span> alpha)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    Vector&lt;double&gt; residual(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line"></div><div class="line">    Vector&lt;double&gt; evaluation_point(dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">    evaluation_point = current_solution; </div><div class="line">    evaluation_point.<a class="code" href="classVector.html#a10b0336c485e36c7b4b105dd2a926002">add</a>(alpha, newton_update); </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula(fe.degree + 1); </div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>     fe_values(fe, </div><div class="line">                            quadrature_formula, </div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | </div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.n_dofs_per_cell(); </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); </div><div class="line"></div><div class="line">    Vector&lt;double&gt;              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(dofs_per_cell); </div><div class="line">    std::vector&lt;Tensor&lt;1, dim&gt;&gt; <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>(n_q_points); </div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>()) </div><div class="line">      { </div><div class="line">        <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a> = 0; </div><div class="line">        fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">        fe_values.<a class="code" href="classFEValuesBase.html#ad1f4e0deb5d982e8172d82141c634a67">get_function_gradients</a>(evaluation_point, <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>); </div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) </div><div class="line">          { </div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coeff = </div><div class="line">              1.0 / <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(1.0 + <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q] * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]); </div><div class="line"></div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">              <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i) -= (fe_values.<a class="code" href="classFEValuesBase.html#a46aefdb527125dafb59dcba92a0f256e">shape_grad</a>(i, q) <span class="comment">// \nabla \phi_i </span></div><div class="line">                                   * coeff                    <span class="comment">// * a_n </span></div><div class="line">                                   * <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aea91b5f00e4be473005cc331b8644ab2f1">gradients</a>[q]             <span class="comment">// * u_n </span></div><div class="line">                                   * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q));       <span class="comment">// * dx </span></div><div class="line">          } </div><div class="line"></div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">          residual(local_dof_indices[i]) += <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#aaff3056f2b80ada5c55d8c5825932c22">cell_residual</a>(i); </div><div class="line">      } </div><div class="line"></div><div class="line">    hanging_node_constraints.condense(residual); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<a class="code" href="classunsigned_01int.html">types::global_dof_index</a> i : </div><div class="line">         <a class="code" href="namespaceDoFTools.html#a06b3c33925c1a1f15de20deda20b4d21">DoFTools::extract_boundary_dofs</a>(dof_handler)) </div><div class="line">      residual(i) = 0; </div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> residual.<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a>(); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">double</span> MinimalSurfaceProblem&lt;dim&gt;::determine_step_length()<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    <span class="keywordflow">return</span> 0.1; </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> MinimalSurfaceProblem&lt;dim&gt;::output_results( </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; </div><div class="line"></div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a>(dof_handler); </div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(current_solution, <span class="stringliteral">&quot;solution&quot;</span>); </div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(newton_update, <span class="stringliteral">&quot;update&quot;</span>); </div><div class="line">    data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(); </div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string filename = </div><div class="line">      <span class="stringliteral">&quot;solution-&quot;</span> + <a class="code" href="namespaceUtilities.html#a6195c5f009ea8c7c536c6ffdf108c32f">Utilities::int_to_string</a>(refinement_cycle, 2) + <span class="stringliteral">&quot;.vtu&quot;</span>; </div><div class="line">    std::ofstream output(filename); </div><div class="line">    data_out.<a class="code" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a>(output); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">MinimalSurfaceProblem&lt;dim&gt;::run</a>(<span class="keyword">const</span> <span class="keywordtype">int</span>    formulation, </div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">double</span> tolerance) </div><div class="line">  { </div><div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;******** Assembly approach ********&quot;</span> &lt;&lt; std::endl; </div><div class="line">    <span class="keyword">const</span> std::array&lt;std::string, 3&gt; method_descriptions = { </div><div class="line">      {<span class="stringliteral">&quot;Unassisted implementation (full hand linearization).&quot;</span>, </div><div class="line">       <span class="stringliteral">&quot;Automated linearization of the finite element residual.&quot;</span>, </div><div class="line">       <span class="stringliteral">&quot;Automated computation of finite element residual and linearization using a variational formulation.&quot;</span>}}; </div><div class="line">    <a class="code" href="group__Exceptions.html#gaafbb69cc2a791ae55880fd8d57d0c1b0">AssertIndexRange</a>(formulation, method_descriptions.size()); </div><div class="line">    std::cout &lt;&lt; method_descriptions[formulation] &lt;&lt; std::endl &lt;&lt; std::endl; </div><div class="line"></div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a> timer(std::cout, <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>); </div><div class="line"></div><div class="line">    <a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(triangulation); </div><div class="line">    triangulation.refine_global(2); </div><div class="line"></div><div class="line">    setup_system(<span class="comment">/*first time=*/</span><span class="keyword">true</span>); </div><div class="line">    set_boundary_values(); </div><div class="line"></div><div class="line">    <span class="keywordtype">double</span>       last_residual_norm = <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::numeric_limits&lt;double&gt;::max</a>(); </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> refinement_cycle   = 0; </div><div class="line">    <span class="keywordflow">do</span> </div><div class="line">      { </div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Mesh refinement step &quot;</span> &lt;&lt; refinement_cycle &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (refinement_cycle != 0) </div><div class="line">          refine_mesh(); </div><div class="line"></div><div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;  Initial residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> inner_iteration = 0; inner_iteration &lt; 5; </div><div class="line">             ++inner_iteration) </div><div class="line">          { </div><div class="line">            { </div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Assemble&quot;</span>); </div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (formulation == 0) </div><div class="line">                assemble_system_unassisted(); </div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 1) </div><div class="line">                assemble_system_with_residual_linearization(); </div><div class="line">              <span class="keywordflow">else</span> <span class="keywordflow">if</span> (formulation == 2) </div><div class="line">                assemble_system_using_energy_functional(); </div><div class="line">              <span class="keywordflow">else</span> </div><div class="line">                <a class="code" href="group__Exceptions.html#gafc0ca7ad85b3ebd64e8e51689ac85caf">AssertThrow</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga7b52b286796c23ef9ff178faf7a4b68f">ExcNotImplemented</a>()); </div><div class="line">            } </div><div class="line"></div><div class="line">            last_residual_norm = system_rhs.<a class="code" href="classBlockVectorBase.html#ac718033fc083f27c45c6bfb4ac780360">l2_norm</a>(); </div><div class="line"></div><div class="line">            { </div><div class="line">              <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(timer, <span class="stringliteral">&quot;Solve&quot;</span>); </div><div class="line">              solve(); </div><div class="line">            } </div><div class="line"></div><div class="line">            std::cout &lt;&lt; <span class="stringliteral">&quot;  Residual: &quot;</span> &lt;&lt; compute_residual(0) &lt;&lt; std::endl; </div><div class="line">          } </div><div class="line"></div><div class="line">        output_results(refinement_cycle); </div><div class="line"></div><div class="line">        ++refinement_cycle; </div><div class="line">        std::cout &lt;&lt; std::endl; </div><div class="line">      } </div><div class="line">    <span class="keywordflow">while</span> (last_residual_norm &gt; tolerance); </div><div class="line">  } </div><div class="line">} <span class="comment">// namespace Step72 </span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) </div><div class="line">{ </div><div class="line">  <span class="keywordflow">try</span> </div><div class="line">    { </div><div class="line">      <span class="keyword">using namespace </span>Step72; </div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv); </div><div class="line"></div><div class="line">      std::string prm_file; </div><div class="line">      <span class="keywordflow">if</span> (argc &gt; 1) </div><div class="line">        prm_file = argv[1]; </div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        prm_file = <span class="stringliteral">&quot;parameters.prm&quot;</span>; </div><div class="line"></div><div class="line">      <span class="keyword">const</span> MinimalSurfaceProblemParameters parameters; </div><div class="line">      <a class="code" href="classParameterAcceptor.html#a8c735525d2865112e5d67f9ba697224e">ParameterAcceptor::initialize</a>(prm_file); </div><div class="line"></div><div class="line">      MinimalSurfaceProblem&lt;2&gt; minimal_surface_problem_2d; </div><div class="line">      minimal_surface_problem_2d.run(parameters.formulation, </div><div class="line">                                     parameters.tolerance); </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (...) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">} </div><div class="line"></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
