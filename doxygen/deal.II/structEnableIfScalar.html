<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/structEnableIfScalar.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: EnableIfScalar&lt; T &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#related">Related Functions</a> &#124;
<a href="structEnableIfScalar-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">EnableIfScalar&lt; T &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af9b78c6f821c17d862d818dbacbf1813"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:af9b78c6f821c17d862d818dbacbf1813"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEnableIfScalar.html#af9b78c6f821c17d862d818dbacbf1813">operator*</a> (const OtherNumber factor, const <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:af9b78c6f821c17d862d818dbacbf1813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae7c8f95f229b4bb758a47cedc53170b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:aae7c8f95f229b4bb758a47cedc53170b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEnableIfScalar.html#aae7c8f95f229b4bb758a47cedc53170b">operator*</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:aae7c8f95f229b4bb758a47cedc53170b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a8714feb8754f7a87c18b4a14d0638"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a64a8714feb8754f7a87c18b4a14d0638"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; OtherNumber, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structEnableIfScalar.html#a64a8714feb8754f7a87c18b4a14d0638">operator*</a> (const Number &amp;factor, const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:a64a8714feb8754f7a87c18b4a14d0638"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
struct EnableIfScalar&lt; T &gt;</h3>

<p>This class provides a local alias <code>type</code> that is equal to the template argument but only if the template argument corresponds to a scalar type (i.e., one of the floating point types, signed or unsigned integer, or a complex number). If the template type <code>T</code> is not a scalar, then no class <code><a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt;T&gt;</code> is declared and, consequently, no local alias is available.</p>
<p>The purpose of the class is to disable certain template functions if one of the arguments is not a scalar number. By way of (nonsensical) example, consider the following function: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> multiply (<span class="keyword">const</span> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> t1, <span class="keyword">const</span> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> t2)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> t1*t2;</div><div class="line">}</div></div><!-- fragment --><p> This function can be called with any two arguments of the same type <code>T</code>. This includes arguments for which this clearly makes no sense. Consequently, one may want to restrict the function to only scalars, and this can be written as </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</div><div class="line"><span class="keyword">typename</span> <a class="code" href="structEnableIfScalar.html">EnableIfScalar&lt;T&gt;::type</a></div><div class="line">multiply (<span class="keyword">const</span> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> t1, <span class="keyword">const</span> <a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> t2)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span> t1*t2;</div><div class="line">}</div></div><!-- fragment --><p> At a place where you call the function, the compiler will deduce the type <code>T</code> from the arguments. For example, in </p><div class="fragment"><div class="line">multiply(1.234, 2.345);</div></div><!-- fragment --><p> it will deduce <code>T</code> to be <code>double</code>, and because <code><a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt;double&gt;::type</code> equals <code>double</code>, the compiler will instantiate a function <code>double multiply(const double, const double)</code> from the template above. On the other hand, in a context like </p><div class="fragment"><div class="line">std::vector&lt;char&gt; v1, v2;</div><div class="line">multiply(v1, v2);</div></div><!-- fragment --><p> the compiler will deduce <code>T</code> to be <code>std::vector&lt;char&gt;</code> but because <code><a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt;std::vector&lt;char&gt;&gt;::type</code> does not exist the compiler does not consider the template for instantiation. This technique is called "Substitution Failure is not an Error (SFINAE)". It makes sure that the template function can not even be called, rather than leading to a later error about the fact that the operation <code>t1*t2</code> is not defined (or may lead to some nonsensical result). It also allows the declaration of overloads of a function such as <code>multiply</code> for different types of arguments, without resulting in ambiguous call errors by the compiler. </p>

<p class="definition">Definition at line <a class="el" href="template__constraints_8h_source.html#l00429">429</a> of file <a class="el" href="template__constraints_8h_source.html">template_constraints.h</a>.</p>
</div><h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="af9b78c6f821c17d862d818dbacbf1813"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78c6f821c17d862d818dbacbf1813">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const OtherNumber&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global operator scaling a point vector by a scalar.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="base_2point_8h_source.html#l00656">656</a> of file <a class="el" href="base_2point_8h_source.html">point.h</a>.</p>

</div>
</div>
<a id="aae7c8f95f229b4bb758a47cedc53170b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae7c8f95f229b4bb758a47cedc53170b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor with a scalar number from the right.</p>
<p>The purpose of this operator is to enable only multiplication of a tensor by a scalar number (i.e., a floating point number, a complex floating point number, etc.). The function is written in a way that only allows the compiler to consider the function if the second argument is indeed a scalar number &ndash; in other words, <code>OtherNumber</code> will not match, for example <code>std::vector&lt;double&gt;</code> as the product of a tensor and a vector clearly would make no sense. The mechanism by which the compiler is prohibited of considering this operator for multiplication with non-scalar types are explained in the documentation of the <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> class.</p>
<p>The return type of the function is chosen so that it matches the types of both the tensor and the scalar argument. For example, if you multiply a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2,dim,double&gt;</code> by <code>std::complex&lt;double&gt;</code>, then the result will be a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt;2,dim,std::complex&lt;double&gt;&gt;</code>. In other words, the type with which the returned tensor stores its components equals the type you would get if you multiplied an individual component of the input tensor by the scalar factor. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03525">3525</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<a id="a64a8714feb8754f7a87c18b4a14d0638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a8714feb8754f7a87c18b4a14d0638">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; OtherNumber, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a symmetric tensor with a scalar number from the left. See the discussion with the operator with switched arguments for more information about template arguments and the return type. </p>

<p class="definition">Definition at line <a class="el" href="symmetric__tensor_8h_source.html#l03555">3555</a> of file <a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="template__constraints_8h_source.html">template_constraints.h</a></li>
<li>include/deal.II/base/<a class="el" href="base_2point_8h_source.html">point.h</a></li>
<li>include/deal.II/base/<a class="el" href="symmetric__tensor_8h_source.html">symmetric_tensor.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
