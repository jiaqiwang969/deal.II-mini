<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classBlockSparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: BlockSparseMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBlockSparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockSparseMatrix&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="block__sparse__matrix_8h_source.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BlockSparseMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classBlockSparseMatrix__inherit__graph.svg" width="404" height="308"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a53f62e71c75de40d6f733b58deeb6b6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a53f62e71c75de40d6f733b58deeb6b6d">BaseClass</a> = <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt;</td></tr>
<tr class="separator:a53f62e71c75de40d6f733b58deeb6b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf708b3b89cdb80352c82c86b549003a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> = typename <a class="el" href="classBlockMatrixBase.html#a11eb26331dcea2cd7095abf2a7182f87">BaseClass::BlockType</a></td></tr>
<tr class="separator:abf708b3b89cdb80352c82c86b549003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01090fd74745d8459d54f28faf603c8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> = typename <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">BaseClass::value_type</a></td></tr>
<tr class="separator:a01090fd74745d8459d54f28faf603c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75beade6b5675a7dea5b679b0a5cf6de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a75beade6b5675a7dea5b679b0a5cf6de">pointer</a> = typename <a class="el" href="classBlockMatrixBase.html#ae305c4e1fdaf318cd3dfdce7ff5d4fbf">BaseClass::pointer</a></td></tr>
<tr class="separator:a75beade6b5675a7dea5b679b0a5cf6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b414d5c0a3f020754f2007edf578c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a08b414d5c0a3f020754f2007edf578c8">const_pointer</a> = typename <a class="el" href="classBlockMatrixBase.html#a7c4888a73231c2eff68d01e6ecc6e975">BaseClass::const_pointer</a></td></tr>
<tr class="separator:a08b414d5c0a3f020754f2007edf578c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35360e5724f6a8d22895e5f584a221e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ac35360e5724f6a8d22895e5f584a221e">reference</a> = typename <a class="el" href="classBlockMatrixBase.html#a026a82c1fb4827731009779a8e679963">BaseClass::reference</a></td></tr>
<tr class="separator:ac35360e5724f6a8d22895e5f584a221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80757d5220db42577b6f4c5b92e01eba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a80757d5220db42577b6f4c5b92e01eba">const_reference</a> = typename <a class="el" href="classBlockMatrixBase.html#a1f04c58b85ae49f430354a71b525e533">BaseClass::const_reference</a></td></tr>
<tr class="separator:a80757d5220db42577b6f4c5b92e01eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0892dc59ebd4027c20526484231eab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> = typename <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">BaseClass::size_type</a></td></tr>
<tr class="separator:a8a0892dc59ebd4027c20526484231eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055fa7cf1762dbaf74131f2186d9186f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> = typename <a class="el" href="classBlockMatrixBase.html#a9676f6127d493633bb4b66ee1952ad24">BaseClass::iterator</a></td></tr>
<tr class="separator:a055fa7cf1762dbaf74131f2186d9186f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa901011a1c7e2ea0f9119eb498f1fdbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> = typename <a class="el" href="classBlockMatrixBase.html#a3318caa7ab0c4b2eb257cfb99daa5429">BaseClass::const_iterator</a></td></tr>
<tr class="separator:aa901011a1c7e2ea0f9119eb498f1fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a45f953f5baee30434449e1f8e9c9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> &gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a></td></tr>
<tr class="separator:aa3a45f953f5baee30434449e1f8e9c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga3552a375d735b0c6bf35f640b2e6bd95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3552a375d735b0c6bf35f640b2e6bd95">DeclException0</a> (ExcBlockDimensionMismatch)</td></tr>
<tr class="separator:ga3552a375d735b0c6bf35f640b2e6bd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60e3f81c6bacc4202f4dd951514f616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac60e3f81c6bacc4202f4dd951514f616">copy_from</a> (const BlockMatrixType &amp;source)</td></tr>
<tr class="separator:ac60e3f81c6bacc4202f4dd951514f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column)</td></tr>
<tr class="separator:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee186fad06d29d6670f241298f43faae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aee186fad06d29d6670f241298f43faae">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column) const</td></tr>
<tr class="separator:aee186fad06d29d6670f241298f43faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c51896e8656797b2086bbdfb59506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab46c51896e8656797b2086bbdfb59506">m</a> () const</td></tr>
<tr class="separator:ab46c51896e8656797b2086bbdfb59506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bb440e54c21af96dcb43fd41958a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78bb440e54c21af96dcb43fd41958a05">n</a> () const</td></tr>
<tr class="separator:a78bb440e54c21af96dcb43fd41958a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478164707bf2932ad32ddd27babfc00"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2478164707bf2932ad32ddd27babfc00">n_block_rows</a> () const</td></tr>
<tr class="separator:a2478164707bf2932ad32ddd27babfc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8a7553aacb22087640d6543a352637"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a7b8a7553aacb22087640d6543a352637">n_block_cols</a> () const</td></tr>
<tr class="separator:a7b8a7553aacb22087640d6543a352637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9784ec81d727db00f7dbfdc9859ee029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9784ec81d727db00f7dbfdc9859ee029">set</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j, const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> value)</td></tr>
<tr class="separator:a9784ec81d727db00f7dbfdc9859ee029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac6afa3a2f54b3a76ef38d8883d55a104">set</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4af16696853c4a9463031fabe748a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afd4af16696853c4a9463031fabe748a7">set</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd4af16696853c4a9463031fabe748a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f8f8fd5343815c3f7586478f3226d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc0f8f8fd5343815c3f7586478f3226d">set</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:adc0f8f8fd5343815c3f7586478f3226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78136f111eaa3f476a1981528be0d1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78136f111eaa3f476a1981528be0d1bd">set</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> n_cols, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a78136f111eaa3f476a1981528be0d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j, const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> value)</td></tr>
<tr class="separator:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec5bc680c14603ef59da590d0db0f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#acec5bc680c14603ef59da590d0db0f4a">add</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:acec5bc680c14603ef59da590d0db0f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254582e171452592759674d9074e1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0254582e171452592759674d9074e1b7">add</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a0254582e171452592759674d9074e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b25e1191e6a59ec8885912e50bd686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a00b25e1191e6a59ec8885912e50bd686">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a00b25e1191e6a59ec8885912e50bd686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c963b73dfee26bb1160755b40aad8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a02c963b73dfee26bb1160755b40aad8d">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> n_cols, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a02c963b73dfee26bb1160755b40aad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9ee9987ece33a052d2b7a44034a8a01a">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> factor, const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt; &amp;matrix)</td></tr>
<tr class="separator:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29846f2e327eb1252f8bcea47494f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2a29846f2e327eb1252f8bcea47494f7">operator()</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j) const</td></tr>
<tr class="separator:a2a29846f2e327eb1252f8bcea47494f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133093964e34c80a89b8e494f32ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a32133093964e34c80a89b8e494f32ff2">el</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j) const</td></tr>
<tr class="separator:a32133093964e34c80a89b8e494f32ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6afe454cf2282f21d1230ad74bcde2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc6afe454cf2282f21d1230ad74bcde2">diag_element</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i) const</td></tr>
<tr class="separator:adc6afe454cf2282f21d1230ad74bcde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74954a421ab950fef132131c2eb6b5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a74954a421ab950fef132131c2eb6b5f9">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a74954a421ab950fef132131c2eb6b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2190cc18dbc94dfb98d99d1d62ef4fb5">operator*=</a> (const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> factor)</td></tr>
<tr class="separator:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e772b9ccf9ea814802a81948190517f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5e772b9ccf9ea814802a81948190517f">operator/=</a> (const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> factor)</td></tr>
<tr class="separator:a5e772b9ccf9ea814802a81948190517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69dc529dec11d15c40904ef729ad25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5b69dc529dec11d15c40904ef729ad25">vmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a5b69dc529dec11d15c40904ef729ad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f2265bcb165f5b9016787d62c8d1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a657f2265bcb165f5b9016787d62c8d1a">Tvmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a657f2265bcb165f5b9016787d62c8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194567f1611984e0ffbd0a2967f94bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a194567f1611984e0ffbd0a2967f94bd9">matrix_norm_square</a> (const BlockVectorType &amp;v) const</td></tr>
<tr class="separator:a194567f1611984e0ffbd0a2967f94bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40df5806b5d3cc3f19a31a7e11b36f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a40df5806b5d3cc3f19a31a7e11b36f51">frobenius_norm</a> () const</td></tr>
<tr class="separator:a40df5806b5d3cc3f19a31a7e11b36f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d63be4e435be84abbdd0eff9c8fa7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab9d63be4e435be84abbdd0eff9c8fa7a">matrix_scalar_product</a> (const BlockVectorType &amp;u, const BlockVectorType &amp;v) const</td></tr>
<tr class="separator:ab9d63be4e435be84abbdd0eff9c8fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754a13320e96366f2b5b4269a232767b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a754a13320e96366f2b5b4269a232767b">residual</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;x, const BlockVectorType &amp;b) const</td></tr>
<tr class="separator:a754a13320e96366f2b5b4269a232767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a345092f0dea627d1b250fe51f3da6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0a345092f0dea627d1b250fe51f3da6c">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a0a345092f0dea627d1b250fe51f3da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80251837872592496f08d63deb87cd0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a80251837872592496f08d63deb87cd0c">begin</a> ()</td></tr>
<tr class="separator:a80251837872592496f08d63deb87cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed413af2409b398fd003acf6a33f351e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed413af2409b398fd003acf6a33f351e">begin</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r)</td></tr>
<tr class="separator:aed413af2409b398fd003acf6a33f351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1f6468acb2728b28ed5fad880436c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3dd1f6468acb2728b28ed5fad880436c">begin</a> () const</td></tr>
<tr class="separator:a3dd1f6468acb2728b28ed5fad880436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bd8ac7f288e11fbb9a15fcf7fa0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed8bd8ac7f288e11fbb9a15fcf7fa0af">begin</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r) const</td></tr>
<tr class="separator:aed8bd8ac7f288e11fbb9a15fcf7fa0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969257f13a198e3b39372c513d3dc5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a969257f13a198e3b39372c513d3dc5aa">end</a> ()</td></tr>
<tr class="separator:a969257f13a198e3b39372c513d3dc5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9494559d41237c44b235153035bcce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af9494559d41237c44b235153035bcce4">end</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r)</td></tr>
<tr class="separator:af9494559d41237c44b235153035bcce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f188b3a4f6540c5d8ecde61b31ade05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0f188b3a4f6540c5d8ecde61b31ade05">end</a> () const</td></tr>
<tr class="separator:a0f188b3a4f6540c5d8ecde61b31ade05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa28a3d5286822c32a3f7ef7437e730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afa28a3d5286822c32a3f7ef7437e730d">end</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r) const</td></tr>
<tr class="separator:afa28a3d5286822c32a3f7ef7437e730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa06c2fc3d4a49502844155f66078bf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aaa06c2fc3d4a49502844155f66078bf0">get_row_indices</a> () const</td></tr>
<tr class="separator:aaa06c2fc3d4a49502844155f66078bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe907561eea46905c41c3e0efd53cd0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afe907561eea46905c41c3e0efd53cd0e">get_column_indices</a> () const</td></tr>
<tr class="separator:afe907561eea46905c41c3e0efd53cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4041ccf8874d3ff3894e2c5e738d769a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4041ccf8874d3ff3894e2c5e738d769a">DeclException4</a> (ExcIncompatibleRowNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt; ','&lt;&lt; arg4&lt;&lt; &quot;] have differing row numbers.&quot;)</td></tr>
<tr class="separator:ga4041ccf8874d3ff3894e2c5e738d769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f7d355e1a8b4ca45e2f30b3ba48916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga10f7d355e1a8b4ca45e2f30b3ba48916">DeclException4</a> (ExcIncompatibleColNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt; ','&lt;&lt; arg4&lt;&lt; &quot;] have differing column numbers.&quot;)</td></tr>
<tr class="separator:ga10f7d355e1a8b4ca45e2f30b3ba48916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造函数和初始化</div></td></tr>
<tr class="memitem:a123620de8b4c883b7c19ca9940a8296c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a123620de8b4c883b7c19ca9940a8296c">BlockSparseMatrix</a> ()=default</td></tr>
<tr class="separator:a123620de8b4c883b7c19ca9940a8296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00656bb208ebfaea9004df0d2c6cb4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a00656bb208ebfaea9004df0d2c6cb4c9">BlockSparseMatrix</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a00656bb208ebfaea9004df0d2c6cb4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b23ca947517fc5d2bc332441d6962d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a75b23ca947517fc5d2bc332441d6962d">~BlockSparseMatrix</a> () override</td></tr>
<tr class="separator:a75b23ca947517fc5d2bc332441d6962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf134b6ec7f8e98a429c9892084b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ab0bf134b6ec7f8e98a429c9892084b2b">operator=</a> (const <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> &amp;)</td></tr>
<tr class="separator:ab0bf134b6ec7f8e98a429c9892084b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441b2825855fe5a6e6be9a9d0ba6375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#af441b2825855fe5a6e6be9a9d0ba6375">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:af441b2825855fe5a6e6be9a9d0ba6375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf098688a1a7db16a6582be07dcbeb6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#acf098688a1a7db16a6582be07dcbeb6a">clear</a> ()</td></tr>
<tr class="separator:acf098688a1a7db16a6582be07dcbeb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0a45e360458e7350bd93487d6bf1e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a1e0a45e360458e7350bd93487d6bf1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵的信息</div></td></tr>
<tr class="memitem:a5276ae56435994698038c8bf8cb4050b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a5276ae56435994698038c8bf8cb4050b">empty</a> () const</td></tr>
<tr class="separator:a5276ae56435994698038c8bf8cb4050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39b88413d064f0d1a07078dfa8d1a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ad39b88413d064f0d1a07078dfa8d1a5b">get_row_length</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row) const</td></tr>
<tr class="separator:ad39b88413d064f0d1a07078dfa8d1a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9177592f1cb9df4edb7b40a6c36fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a1e9177592f1cb9df4edb7b40a6c36fbb">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a1e9177592f1cb9df4edb7b40a6c36fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8495bf88b8fc693a1321a498958aefb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a8495bf88b8fc693a1321a498958aefb1">n_actually_nonzero_elements</a> (const <a class="el" href="classdouble.html">double</a> threshold=0.0) const</td></tr>
<tr class="separator:a8495bf88b8fc693a1321a498958aefb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410e8b95646a25a67506dc4eed329f05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a410e8b95646a25a67506dc4eed329f05">get_sparsity_pattern</a> () const</td></tr>
<tr class="separator:a410e8b95646a25a67506dc4eed329f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c4f17dc23a7ca73d167f34450e1db1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a33c4f17dc23a7ca73d167f34450e1db1">memory_consumption</a> () const</td></tr>
<tr class="separator:a33c4f17dc23a7ca73d167f34450e1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">乘法运算</div></td></tr>
<tr class="memitem:ab90c7cc2218c2cf226f2fb00c59e746b"><td class="memTemplParams" colspan="2">template&lt;typename block_number &gt; </td></tr>
<tr class="memitem:ab90c7cc2218c2cf226f2fb00c59e746b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ab90c7cc2218c2cf226f2fb00c59e746b">vmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:ab90c7cc2218c2cf226f2fb00c59e746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507795aed66a5f86b585bfaa2cfabbe3"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:a507795aed66a5f86b585bfaa2cfabbe3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a507795aed66a5f86b585bfaa2cfabbe3">vmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:a507795aed66a5f86b585bfaa2cfabbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9122f9939becc261dc5f1af3af072146"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:a9122f9939becc261dc5f1af3af072146"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a9122f9939becc261dc5f1af3af072146">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:a9122f9939becc261dc5f1af3af072146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935b5e5b6b15af1ed17d77ed3b195506"><td class="memTemplParams" colspan="2">template&lt;typename nonblock_number &gt; </td></tr>
<tr class="memitem:a935b5e5b6b15af1ed17d77ed3b195506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a935b5e5b6b15af1ed17d77ed3b195506">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:a935b5e5b6b15af1ed17d77ed3b195506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcb0ea8eddf6bd974b1e6cab4b9811b"><td class="memTemplParams" colspan="2">template&lt;typename block_number &gt; </td></tr>
<tr class="memitem:aadcb0ea8eddf6bd974b1e6cab4b9811b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#aadcb0ea8eddf6bd974b1e6cab4b9811b">Tvmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:aadcb0ea8eddf6bd974b1e6cab4b9811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68dd4e1121c1435b7fbdeb12735a57a"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:ab68dd4e1121c1435b7fbdeb12735a57a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ab68dd4e1121c1435b7fbdeb12735a57a">Tvmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:ab68dd4e1121c1435b7fbdeb12735a57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887a23f787dad22e556166d42a92e68c"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:a887a23f787dad22e556166d42a92e68c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a887a23f787dad22e556166d42a92e68c">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:a887a23f787dad22e556166d42a92e68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565f4c52db80d9e8f94b4236cefe5292"><td class="memTemplParams" colspan="2">template&lt;typename nonblock_number &gt; </td></tr>
<tr class="memitem:a565f4c52db80d9e8f94b4236cefe5292"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a565f4c52db80d9e8f94b4236cefe5292">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:a565f4c52db80d9e8f94b4236cefe5292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">预处理方法</div></td></tr>
<tr class="memitem:af40175362eebf81cea0541b56041c135"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:af40175362eebf81cea0541b56041c135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#af40175362eebf81cea0541b56041c135">precondition_Jacobi</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:af40175362eebf81cea0541b56041c135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318a6a40f0a56c5c1a17d99f642820e9"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a318a6a40f0a56c5c1a17d99f642820e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a318a6a40f0a56c5c1a17d99f642820e9">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a318a6a40f0a56c5c1a17d99f642820e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">输入/输出</div></td></tr>
<tr class="memitem:ae787f1316166e2590f9ad37fc2190087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ae787f1316166e2590f9ad37fc2190087">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const</td></tr>
<tr class="separator:ae787f1316166e2590f9ad37fc2190087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6acb9f7db404d81437b2007fd9368d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6acb9f7db404d81437b2007fd9368d97">collect_sizes</a> ()</td></tr>
<tr class="separator:a6acb9f7db404d81437b2007fd9368d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4109f58621de12f02b521df0bbb4728f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a4109f58621de12f02b521df0bbb4728f">vmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a4109f58621de12f02b521df0bbb4728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd4c9d2a02835be4a0e7fdb9c5fb84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adfd4c9d2a02835be4a0e7fdb9c5fb84b">vmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:adfd4c9d2a02835be4a0e7fdb9c5fb84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70152dd877ead20e92468b11dd923fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a70152dd877ead20e92468b11dd923fdb">vmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a70152dd877ead20e92468b11dd923fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f20e2d1a54fa9cc7e312175f23101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a003f20e2d1a54fa9cc7e312175f23101">vmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a003f20e2d1a54fa9cc7e312175f23101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e896a6aadc0f6663ca4bfd69e8e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1b5e896a6aadc0f6663ca4bfd69e8e73">Tvmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a1b5e896a6aadc0f6663ca4bfd69e8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f970e6afe14484f051897f5c78060f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af6f970e6afe14484f051897f5c78060f">Tvmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:af6f970e6afe14484f051897f5c78060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20df57e0ac765128dfaa48add407e490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a20df57e0ac765128dfaa48add407e490">Tvmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a20df57e0ac765128dfaa48add407e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002a305f47b31aa962b58f6a863f831d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a002a305f47b31aa962b58f6a863f831d">Tvmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a002a305f47b31aa962b58f6a863f831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f52ce530c3028e0d3194a719cb82576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6f52ce530c3028e0d3194a719cb82576">prepare_add_operation</a> ()</td></tr>
<tr class="separator:a6f52ce530c3028e0d3194a719cb82576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d3d021b1004a8fb027b50e0862c149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a79d3d021b1004a8fb027b50e0862c149">prepare_set_operation</a> ()</td></tr>
<tr class="separator:a79d3d021b1004a8fb027b50e0862c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa401f344887a4647a9a14ef41629aed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa401f344887a4647a9a14ef41629aed9">row_block_indices</a></td></tr>
<tr class="separator:aa401f344887a4647a9a14ef41629aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a10666cbe2741f71f6cf17ebedaf9080d">column_block_indices</a></td></tr>
<tr class="separator:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352220e7e9c26aaffd42bce3b2f25b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; <a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6352220e7e9c26aaffd42bce3b2f25b4">sub_objects</a></td></tr>
<tr class="separator:a6352220e7e9c26aaffd42bce3b2f25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9fb413a875ce50b9da3f61761d6324ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a9fb413a875ce50b9da3f61761d6324ce">sparsity_pattern</a></td></tr>
<tr class="separator:a9fb413a875ce50b9da3f61761d6324ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class BlockSparseMatrix&lt; number &gt;</h3>

<p>基于SparseMatrix类的阻塞式稀疏矩阵。这个类实现了SparseMatrix基对象的特定函数，用于阻塞式稀疏矩阵，并将实际工作中对各个块的大部分调用留给基类中实现的函数。关于这个类何时有用的描述，也请参见这里。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00049">49</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a53f62e71c75de40d6f733b58deeb6b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f62e71c75de40d6f733b58deeb6b6d">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a53f62e71c75de40d6f733b58deeb6b6d">BaseClass</a> =  <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对基类进行类型化定义，以便更简单地访问它自己的别名。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00056">56</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abf708b3b89cdb80352c82c86b549003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf708b3b89cdb80352c82c86b549003a">&#9670;&nbsp;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> =  typename <a class="el" href="classBlockMatrixBase.html#a11eb26331dcea2cd7095abf2a7182f87">BaseClass::BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对底层矩阵的类型进行类型化定义。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00062">62</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a01090fd74745d8459d54f28faf603c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01090fd74745d8459d54f28faf603c8c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> =  typename <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从基类中导入别名。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00068">68</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a75beade6b5675a7dea5b679b0a5cf6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75beade6b5675a7dea5b679b0a5cf6de">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a75beade6b5675a7dea5b679b0a5cf6de">pointer</a> =  typename <a class="el" href="classBlockMatrixBase.html#ae305c4e1fdaf318cd3dfdce7ff5d4fbf">BaseClass::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00069">69</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a08b414d5c0a3f020754f2007edf578c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b414d5c0a3f020754f2007edf578c8">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a08b414d5c0a3f020754f2007edf578c8">const_pointer</a> =  typename <a class="el" href="classBlockMatrixBase.html#a7c4888a73231c2eff68d01e6ecc6e975">BaseClass::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00070">70</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac35360e5724f6a8d22895e5f584a221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35360e5724f6a8d22895e5f584a221e">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#ac35360e5724f6a8d22895e5f584a221e">reference</a> =  typename <a class="el" href="classBlockMatrixBase.html#a026a82c1fb4827731009779a8e679963">BaseClass::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00071">71</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a80757d5220db42577b6f4c5b92e01eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80757d5220db42577b6f4c5b92e01eba">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a80757d5220db42577b6f4c5b92e01eba">const_reference</a> =  typename <a class="el" href="classBlockMatrixBase.html#a1f04c58b85ae49f430354a71b525e533">BaseClass::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00072">72</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a8a0892dc59ebd4027c20526484231eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0892dc59ebd4027c20526484231eab">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> =  typename <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">BaseClass::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00073">73</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a055fa7cf1762dbaf74131f2186d9186f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055fa7cf1762dbaf74131f2186d9186f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> =  typename <a class="el" href="classBlockMatrixBase.html#a9676f6127d493633bb4b66ee1952ad24">BaseClass::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00074">74</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa901011a1c7e2ea0f9119eb498f1fdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa901011a1c7e2ea0f9119eb498f1fdbb">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> =  typename <a class="el" href="classBlockMatrixBase.html#a3318caa7ab0c4b2eb257cfb99daa5429">BaseClass::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00075">75</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa3a45f953f5baee30434449e1f8e9c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a45f953f5baee30434449e1f8e9c9d">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00363">363</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a123620de8b4c883b7c19ca9940a8296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123620de8b4c883b7c19ca9940a8296c">&#9670;&nbsp;</a></span>BlockSparseMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数；将矩阵初始化为空，没有任何结构，也就是说，矩阵根本无法使用。因此，这个构造函数只对作为类的成员的矩阵有用。所有其他的矩阵都应该在数据流中的一个点上创建，在那里所有必要的信息都是可用的。 你必须在使用前用reinit(BlockSparsityPattern)初始化矩阵。然后每行和每列的块数由该函数决定。 </p>

</div>
</div>
<a id="a00656bb208ebfaea9004df0d2c6cb4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00656bb208ebfaea9004df0d2c6cb4c9">&#9670;&nbsp;</a></span>BlockSparseMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。使用给定的矩阵稀疏度结构来表示该矩阵的稀疏度模式。你可以在以后通过调用reinit()函数来改变稀疏性模式。 这个构造函数用参数中的子疏密模式初始化所有子矩阵。 你必须确保稀疏结构的寿命至少和这个矩阵的寿命一样长，或者只要reinit()没有被调用，就会有新的稀疏结构。 </p>

</div>
</div>
<a id="a75b23ca947517fc5d2bc332441d6962d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b23ca947517fc5d2bc332441d6962d">&#9670;&nbsp;</a></span>~BlockSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::~<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0bf134b6ec7f8e98a429c9892084b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bf134b6ec7f8e98a429c9892084b2b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&amp; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>伪拷贝操作符只拷贝空对象。块矩阵的大小需要相同。 </p>

</div>
</div>
<a id="af441b2825855fe5a6e6be9a9d0ba6375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441b2825855fe5a6e6be9a9d0ba6375">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。因为这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零的情况下进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00352">352</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="acf098688a1a7db16a6582be07dcbeb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf098688a1a7db16a6582be07dcbeb6a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。它也忘记了之前所绑定的稀疏模式。 这在所有子矩阵上调用 <a class="el" href="classSparseMatrix.html#a45f664681373fd3a1f8dd965395d360d">SparseMatrix::clear</a> ，然后将此对象重置为完全没有块。 </p>

</div>
</div>
<a id="a1e0a45e360458e7350bd93487d6bf1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0a45e360458e7350bd93487d6bf1e5">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用给定的稀疏模式重新初始化稀疏矩阵。后者告诉矩阵需要保留多少个非零元素。 基本上，这个函数只调用 <a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">SparseMatrix::reinit()</a> 的子矩阵与参数的块状稀疏模式。 你必须确保稀疏结构的寿命至少和这个矩阵的寿命一样长，或者只要reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;)没有被调用新的稀疏结构。 矩阵的元素被这个函数设置为零。 </p>

</div>
</div>
<a id="a5276ae56435994698038c8bf8cb4050b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5276ae56435994698038c8bf8cb4050b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该对象是否为空。如果两个维度都是零或者没有关联BlockSparsityPattern，它就是空的。 </p>

</div>
</div>
<a id="ad39b88413d064f0d1a07078dfa8d1a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39b88413d064f0d1a07078dfa8d1a5b">&#9670;&nbsp;</a></span>get_row_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::get_row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回特定行中的条目数。 </p>

</div>
</div>
<a id="a1e9177592f1cb9df4edb7b40a6c36fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9177592f1cb9df4edb7b40a6c36fbb">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。 </p>

</div>
</div>
<a id="a8495bf88b8fc693a1321a498958aefb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8495bf88b8fc693a1321a498958aefb1">&#9670;&nbsp;</a></span>n_actually_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回实际非零元素的数量。只是计算所有块中实际非零元素的数量（绝对值大于阈值）。 </p>

</div>
</div>
<a id="a410e8b95646a25a67506dc4eed329f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410e8b95646a25a67506dc4eed329f05">&#9670;&nbsp;</a></span>get_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>&amp; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对该矩阵的底层稀疏模式的（常数）引用。 尽管返回值被声明为<code>const</code>，但你应该注意，如果你调用任何对其进行操作的对象的非常量函数，它可能会发生变化。 </p>

</div>
</div>
<a id="a33c4f17dc23a7ca73d167f34450e1db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c4f17dc23a7ca73d167f34450e1db1">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="ab90c7cc2218c2cf226f2fb00c59e746b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90c7cc2218c2cf226f2fb00c59e746b">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M*src\) 与 \(M\) 为这个矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00368">368</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a507795aed66a5f86b585bfaa2cfabbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507795aed66a5f86b585bfaa2cfabbe3">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00379">379</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a9122f9939becc261dc5f1af3af072146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9122f9939becc261dc5f1af3af072146">&#9670;&nbsp;</a></span>vmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块行的情况。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00390">390</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a935b5e5b6b15af1ed17d77ed3b195506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935b5e5b6b15af1ed17d77ed3b195506">&#9670;&nbsp;</a></span>vmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00401">401</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aadcb0ea8eddf6bd974b1e6cab4b9811b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcb0ea8eddf6bd974b1e6cab4b9811b">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M^T*src\) 与 \(M\) 为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00412">412</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ab68dd4e1121c1435b7fbdeb12735a57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68dd4e1121c1435b7fbdeb12735a57a">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块行的情况。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00423">423</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a887a23f787dad22e556166d42a92e68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887a23f787dad22e556166d42a92e68c">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00434">434</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a565f4c52db80d9e8f94b4236cefe5292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565f4c52db80d9e8f94b4236cefe5292">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00445">445</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="af40175362eebf81cea0541b56041c135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40175362eebf81cea0541b56041c135">&#9670;&nbsp;</a></span>precondition_Jacobi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>应用Jacobi预处理，它将<code>src</code>向量的每个元素都乘以各自对角线元素的逆值，并将结果与松弛参数<code>omega</code>相乘。 所有的对角线块必须是方形矩阵，才能进行这个操作。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00456">456</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a318a6a40f0a56c5c1a17d99f642820e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318a6a40f0a56c5c1a17d99f642820e9">&#9670;&nbsp;</a></span>precondition_Jacobi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对一个简单的向量应用雅可比预处理程序。 为此，矩阵必须是单一的正方形块。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00477">477</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae787f1316166e2590f9ad37fc2190087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae787f1316166e2590f9ad37fc2190087">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>以通常的格式打印矩阵，即作为矩阵而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。 参数允许对输出格式进行灵活设置。 <code>precision</code>和<code>scientific</code>用于确定数字格式，其中<code>scientific = false</code>表示固定点符号。 <code>width</code>的一个零条目使函数计算出一个宽度，但如果输出粗略的话，可以将其改为一个正值。 此外，还可以指定一个空值的字符。 最后，整个矩阵可以与一个共同的分母相乘，产生更可读的输出，甚至是整数。 </p><dl class="section attention"><dt>Attention</dt><dd>如果应用于一个大的矩阵，这个函数可能会产生<b>large</b>量的输出! </dd></dl>

</div>
</div>
<a id="ac60e3f81c6bacc4202f4dd951514f616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60e3f81c6bacc4202f4dd951514f616">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将作为参数的矩阵复制到当前对象中。 复制矩阵是一个昂贵的操作，我们不希望通过编译器生成的代码意外发生 <code>operator=</code> 。（例如，如果不小心声明了一个当前类型为<em>by value</em>而不是<em>by reference</em>的函数参数，就会发生这种情况）。复制矩阵的功能是在这个成员函数中实现的。因此，该类型对象的所有复制操作都需要一个明确的函数调用。 源矩阵可以是一个任意类型的矩阵，只要其数据类型可以转换为该矩阵的数据类型。 该函数返回一个对<code>this</code>的引用。 </p>

</div>
</div>
<a id="a1e54eb8c095bf2191a29c36a7784a5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e54eb8c095bf2191a29c36a7784a5b6">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问具有给定坐标的块。 </p>

</div>
</div>
<a id="aee186fad06d29d6670f241298f43faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee186fad06d29d6670f241298f43faae">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>访问具有给定坐标的区块。常量对象的版本。 </p>

</div>
</div>
<a id="ab46c51896e8656797b2086bbdfb59506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46c51896e8656797b2086bbdfb59506">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回共域（或范围）空间的维数。注意，矩阵的维度是 \(m \times n\) 。 </p>

</div>
</div>
<a id="a78bb440e54c21af96dcb43fd41958a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bb440e54c21af96dcb43fd41958a05">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回域空间的维度。请注意，矩阵的维度是 \(m \times n\) . </p>

</div>
</div>
<a id="a2478164707bf2932ad32ddd27babfc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2478164707bf2932ad32ddd27babfc00">&#9670;&nbsp;</a></span>n_block_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::n_block_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一列中的块数。如果目前没有与此矩阵相关的稀疏模式，则返回0。 </p>

</div>
</div>
<a id="a7b8a7553aacb22087640d6543a352637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8a7553aacb22087640d6543a352637">&#9670;&nbsp;</a></span>n_block_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::n_block_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个行中的块数。如果目前没有与该矩阵相关的稀疏模式，则返回0。 </p>

</div>
</div>
<a id="a9784ec81d727db00f7dbfdc9859ee029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9784ec81d727db00f7dbfdc9859ee029">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将元素&lt;tt&gt;(i,j)/tt&gt;设置为<code>值</code>。如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="ac6afa3a2f54b3a76ef38d8883d55a104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6afa3a2f54b3a76ef38d8883d55a104">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix中给出的所有元素设置到<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球的索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="afd4af16696853c4a9463031fabe748a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4af16696853c4a9463031fabe748a7">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="adc0f8f8fd5343815c3f7586478f3226d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0f8f8fd5343815c3f7586478f3226d">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="a78136f111eaa3f476a1981528be0d1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78136f111eaa3f476a1981528be0d1bd">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给出的值，在给定的行和col_indices给出的列中设置为稀疏矩阵。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要插入零值还是要过滤掉它们。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="ad8fe7a35a3336d251a4b3aa2c3ed9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fe7a35a3336d251a4b3aa2c3ed9748">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向元素添加<code>value</code>（<em>i,j</em>）。 如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="acec5bc680c14603ef59da590d0db0f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec5bc680c14603ef59da590d0db0f4a">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假定一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中通常的情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a0254582e171452592759674d9074e1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0254582e171452592759674d9074e1b7">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a00b25e1191e6a59ec8885912e50bd686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b25e1191e6a59ec8885912e50bd686">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a02c963b73dfee26bb1160755b40aad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c963b73dfee26bb1160755b40aad8d">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a9ee9987ece33a052d2b7a44034a8a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee9987ece33a052d2b7a44034a8a01a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将<code>matrix</code>按<code>factor</code>的比例添加到这个矩阵中，也就是说，矩阵<code>factor*matrix</code>被添加到<code>this</code>。如果调用矩阵的稀疏性模式不包含输入矩阵的稀疏性模式中的所有元素，这个函数将抛出一个异常。 然而，根据MatrixType，可能会出现额外的限制。 一些稀疏矩阵格式要求<code>matrix</code>是基于与调用矩阵相同的稀疏模式的。 </p>

</div>
</div>
<a id="a2a29846f2e327eb1252f8bcea47494f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29846f2e327eb1252f8bcea47494f7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目(i,j)的值。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 为了避免滥用，如果想要的元素在矩阵中不存在，这个函数会抛出一个异常。 </p>

</div>
</div>
<a id="a32133093964e34c80a89b8e494f32ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32133093964e34c80a89b8e494f32ff2">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数主要像operator()()，它返回矩阵条目&lt;tt&gt;(i,j)的值。唯一的区别是，如果这个条目不存在于稀疏模式中，那么就不会引发异常，而是返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 </p>

</div>
</div>
<a id="adc6afe454cf2282f21d1230ad74bcde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6afe454cf2282f21d1230ad74bcde2">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次方的，以及矩阵的对角线块不是二次方的，这个函数会抛出一个错误。 这个函数比operator()()快得多，因为对于二次矩阵来说，对角线条目可能是每行中第一个被存储的，因此访问时不需要搜索正确的列号。 </p>

</div>
</div>
<a id="a74954a421ab950fef132131c2eb6b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74954a421ab950fef132131c2eb6b5f9">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在矩阵的所有子块上调用compress()函数。 参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象 </a> 以获得更多信息。 </p>

</div>
</div>
<a id="a2190cc18dbc94dfb98d99d1d62ef4fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2190cc18dbc94dfb98d99d1d62ef4fb5">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

</div>
</div>
<a id="a5e772b9ccf9ea814802a81948190517f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e772b9ccf9ea814802a81948190517f">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵除以一个固定系数。 </p>

</div>
</div>
<a id="a5b69dc529dec11d15c40904ef729ad25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b69dc529dec11d15c40904ef729ad25">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。在 \(dst\) 上添加 \(M*src\) ， \(M\) 为该矩阵。 </p>

</div>
</div>
<a id="a657f2265bcb165f5b9016787d62c8d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657f2265bcb165f5b9016787d62c8d1a">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加矩阵-向量乘法。将<em>M<sup>T</sup>src</em>加到<em>dst</em>上，<em>M</em>是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 </p>

</div>
</div>
<a id="a194567f1611984e0ffbd0a2967f94bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194567f1611984e0ffbd0a2967f94bd9">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量<em>v</em>相对于该矩阵诱导的规范，即<em>v<sup>T</sup>Mv)</em>的规范。这很有用，例如在有限元背景下，一个函数的<em>L<sup>T</sup></em>规范等于相对于代表有限元函数节点值的向量矩阵的矩阵规范。请注意，尽管函数的名称可能暗示了一些不同的东西，但由于历史原因，返回的不是法线，而是它的平方，正如上面所定义的标量积。 很明显，对于这个操作，矩阵需要是平方的。 </p>

</div>
</div>
<a id="a40df5806b5d3cc3f19a31a7e11b36f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40df5806b5d3cc3f19a31a7e11b36f51">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方和的平方根。 </p>

</div>
</div>
<a id="ab9d63be4e435be84abbdd0eff9c8fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d63be4e435be84abbdd0eff9c8fa7a">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 </p>

</div>
</div>
<a id="a754a13320e96366f2b5b4269a232767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754a13320e96366f2b5b4269a232767b">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::residual </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算残差<em>r=b-Ax</em>。将残差写进<code>dst</code>。 </p>

</div>
</div>
<a id="a0a345092f0dea627d1b250fe51f3da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a345092f0dea627d1b250fe51f3da6c">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印矩阵到给定的数据流中，使用格式&lt;tt&gt;(line,col) value，即每行有一个矩阵的非零条目。可选的标志是根据底层稀疏矩阵的类型，以不同的风格输出稀疏模式。 </p>

</div>
</div>
<a id="a80251837872592496f08d63deb87cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80251837872592496f08d63deb87cd0c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器从第一个条目开始。 </p>

</div>
</div>
<a id="aed413af2409b398fd003acf6a33f351e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed413af2409b398fd003acf6a33f351e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从<code>r</code>行的第一个条目开始的迭代器。 </p>

</div>
</div>
<a id="a3dd1f6468acb2728b28ed5fad880436c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1f6468acb2728b28ed5fad880436c">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从第一条开始的迭代器。 </p>

</div>
</div>
<a id="aed8bd8ac7f288e11fbb9a15fcf7fa0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8bd8ac7f288e11fbb9a15fcf7fa0af">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从<code>r</code>行的第一个条目开始的迭代器。 </p>

</div>
</div>
<a id="a969257f13a198e3b39372c513d3dc5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969257f13a198e3b39372c513d3dc5aa">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>最后的迭代器。 </p>

</div>
</div>
<a id="af9494559d41237c44b235153035bcce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9494559d41237c44b235153035bcce4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。 </p>

</div>
</div>
<a id="a0f188b3a4f6540c5d8ecde61b31ade05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f188b3a4f6540c5d8ecde61b31ade05">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>最后的迭代器。 </p>

</div>
</div>
<a id="afa28a3d5286822c32a3f7ef7437e730d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa28a3d5286822c32a3f7ef7437e730d">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。 </p>

</div>
</div>
<a id="aaa06c2fc3d4a49502844155f66078bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa06c2fc3d4a49502844155f66078bf0">&#9670;&nbsp;</a></span>get_row_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::get_row_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对行的底层BlockIndices数据的引用。 </p>

</div>
</div>
<a id="afe907561eea46905c41c3e0efd53cd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe907561eea46905c41c3e0efd53cd0e">&#9670;&nbsp;</a></span>get_column_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::get_column_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回对列的基本BlockIndices数据的引用。 </p>

</div>
</div>
<a id="ga4041ccf8874d3ff3894e2c5e738d769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4041ccf8874d3ff3894e2c5e738d769a">&#9670;&nbsp;</a></span>DeclException4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleRowNumbers&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The blocks  and  have differing row numbers.&quot;&#160;</td>
          <td class="paramname">[&quot; &lt;&lt; arg1 &lt;&lt; ',' &lt;&lt; arg2 &lt;&lt; &quot;][&quot; &lt;&lt; arg3 &lt;&lt; ',' &lt;&lt; arg4 &lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ga10f7d355e1a8b4ca45e2f30b3ba48916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10f7d355e1a8b4ca45e2f30b3ba48916">&#9670;&nbsp;</a></span>DeclException4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleColNumbers&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The blocks  and  have differing column numbers.&quot;&#160;</td>
          <td class="paramname">[&quot; &lt;&lt; arg1 &lt;&lt; ',' &lt;&lt; arg2 &lt;&lt; &quot;][&quot; &lt;&lt; arg3 &lt;&lt; ',' &lt;&lt; arg4 &lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a6acb9f7db404d81437b2007fd9368d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acb9f7db404d81437b2007fd9368d97">&#9670;&nbsp;</a></span>collect_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::collect_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数收集了子对象的大小，并将其存储在内部数组中，以便能够将矩阵的全局索引转为子对象的索引。在你改变了子对象的大小之后，你必须*每次都调用这个函数。 每当子对象的大小发生变化， <code>X_block_indices</code> 数组需要更新时，派生类应该调用这个函数。 注意，这个函数不是公开的，因为不是所有的派生类都需要导出其接口。例如，对于通常的deal.II SparseMatrix类，每当调用reinit()时，大小都是隐式确定的，而且单个块不能被调整大小。因此，对于该类，这个函数不必是公共的。另一方面，对于PETSc类来说，没有相关的稀疏模式对象来决定块的大小，对于这些类来说，这个函数必须是公开可用的。因此，这些类导出了这个函数。 </p>

</div>
</div>
<a id="a4109f58621de12f02b521df0bbb4728f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4109f58621de12f02b521df0bbb4728f">&#9670;&nbsp;</a></span>vmult_block_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M*src\) 与 \(M\) 是这个矩阵。 由于在vmult/Tvmult函数的块和非块版本之间衍生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器衍生。 </p>

</div>
</div>
<a id="adfd4c9d2a02835be4a0e7fdb9c5fb84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd4c9d2a02835be4a0e7fdb9c5fb84b">&#9670;&nbsp;</a></span>vmult_block_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像之前的函数一样，但只适用于矩阵只有一个块列的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a70152dd877ead20e92468b11dd923fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70152dd877ead20e92468b11dd923fdb">&#9670;&nbsp;</a></span>vmult_nonblock_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像之前的函数一样，但只适用于矩阵只有一个块行的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名字下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a003f20e2d1a54fa9cc7e312175f23101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f20e2d1a54fa9cc7e312175f23101">&#9670;&nbsp;</a></span>vmult_nonblock_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生出来的唯一名称。 </p>

</div>
</div>
<a id="a1b5e896a6aadc0f6663ca4bfd69e8e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5e896a6aadc0f6663ca4bfd69e8e73">&#9670;&nbsp;</a></span>Tvmult_block_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让 \(dst = M^T*src\) 与 \(M\) 是这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 由于vmult/Tvmult函数的块和非块版本之间的模板参数派生问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生出来的唯一名称。 </p>

</div>
</div>
<a id="af6f970e6afe14484f051897f5c78060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f970e6afe14484f051897f5c78060f">&#9670;&nbsp;</a></span>Tvmult_block_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块行的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个唯一的名称下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a20df57e0ac765128dfaa48add407e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20df57e0ac765128dfaa48add407e490">&#9670;&nbsp;</a></span>Tvmult_nonblock_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数一样，但只适用于矩阵只有一个块列的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，在一个独特的名称下，模板参数可以被编译器派生。 </p>

</div>
</div>
<a id="a002a305f47b31aa962b58f6a863f831d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002a305f47b31aa962b58f6a863f831d">&#9670;&nbsp;</a></span>Tvmult_nonblock_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法。就像前面的函数，但只适用于矩阵只有一个块的情况。 由于在vmult/Tvmult函数的块和非块版本之间派生模板参数的问题，实际的函数是在派生类中实现的，实现者将调用转发给这里提供的实现者，其模板参数可以由编译器派生的唯一名称。 </p>

</div>
</div>
<a id="a6f52ce530c3028e0d3194a719cb82576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f52ce530c3028e0d3194a719cb82576">&#9670;&nbsp;</a></span>prepare_add_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::prepare_add_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些矩阵类型，特别是PETSc，需要同步设置和添加操作。这必须对BlockMatrix中的所有矩阵进行操作。本例程通过通知所有块来准备添加元素。在添加元素之前，所有的内部例程都会调用它。 </p>

</div>
</div>
<a id="a79d3d021b1004a8fb027b50e0862c149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d3d021b1004a8fb027b50e0862c149">&#9670;&nbsp;</a></span>prepare_set_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::prepare_set_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通知所有区块，让它们为设置元素做准备，见prepare_add_operation()。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9fb413a875ce50b9da3f61761d6324ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb413a875ce50b9da3f61761d6324ce">&#9670;&nbsp;</a></span>sparsity_pattern</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt;number&gt; &gt; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::sparsity_pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向用于该矩阵的块状稀疏模式的指针。为了保证它在使用中不被删除，我们使用SmartPointer类来订阅它。 </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00340">340</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa401f344887a4647a9a14ef41629aed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa401f344887a4647a9a14ef41629aed9">&#9670;&nbsp;</a></span>row_block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::row_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行和列的索引数组。 </p>

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00794">794</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a id="a10666cbe2741f71f6cf17ebedaf9080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10666cbe2741f71f6cf17ebedaf9080d">&#9670;&nbsp;</a></span>column_block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::column_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00795">795</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a id="a6352220e7e9c26aaffd42bce3b2f25b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6352220e7e9c26aaffd42bce3b2f25b4">&#9670;&nbsp;</a></span>sub_objects</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;<a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt; &gt; &gt; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::sub_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>子矩阵的数组。 </p>

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00801">801</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
