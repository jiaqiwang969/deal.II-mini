<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classBlockSparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: BlockSparseMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classBlockSparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">BlockSparseMatrix&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="block__sparse__matrix_8h_source.html">deal.II/lac/block_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for BlockSparseMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classBlockSparseMatrix__inherit__graph.svg" width="360" height="308"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a53f62e71c75de40d6f733b58deeb6b6d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a53f62e71c75de40d6f733b58deeb6b6d">BaseClass</a> = <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt;</td></tr>
<tr class="separator:a53f62e71c75de40d6f733b58deeb6b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf708b3b89cdb80352c82c86b549003a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> = typename <a class="el" href="classBlockMatrixBase.html#a11eb26331dcea2cd7095abf2a7182f87">BaseClass::BlockType</a></td></tr>
<tr class="separator:abf708b3b89cdb80352c82c86b549003a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01090fd74745d8459d54f28faf603c8c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> = typename <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">BaseClass::value_type</a></td></tr>
<tr class="separator:a01090fd74745d8459d54f28faf603c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75beade6b5675a7dea5b679b0a5cf6de"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a75beade6b5675a7dea5b679b0a5cf6de">pointer</a> = typename <a class="el" href="classBlockMatrixBase.html#ae305c4e1fdaf318cd3dfdce7ff5d4fbf">BaseClass::pointer</a></td></tr>
<tr class="separator:a75beade6b5675a7dea5b679b0a5cf6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08b414d5c0a3f020754f2007edf578c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a08b414d5c0a3f020754f2007edf578c8">const_pointer</a> = typename <a class="el" href="classBlockMatrixBase.html#a7c4888a73231c2eff68d01e6ecc6e975">BaseClass::const_pointer</a></td></tr>
<tr class="separator:a08b414d5c0a3f020754f2007edf578c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac35360e5724f6a8d22895e5f584a221e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ac35360e5724f6a8d22895e5f584a221e">reference</a> = typename <a class="el" href="classBlockMatrixBase.html#a026a82c1fb4827731009779a8e679963">BaseClass::reference</a></td></tr>
<tr class="separator:ac35360e5724f6a8d22895e5f584a221e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80757d5220db42577b6f4c5b92e01eba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a80757d5220db42577b6f4c5b92e01eba">const_reference</a> = typename <a class="el" href="classBlockMatrixBase.html#a1f04c58b85ae49f430354a71b525e533">BaseClass::const_reference</a></td></tr>
<tr class="separator:a80757d5220db42577b6f4c5b92e01eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0892dc59ebd4027c20526484231eab"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> = typename <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">BaseClass::size_type</a></td></tr>
<tr class="separator:a8a0892dc59ebd4027c20526484231eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a055fa7cf1762dbaf74131f2186d9186f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> = typename <a class="el" href="classBlockMatrixBase.html#a9676f6127d493633bb4b66ee1952ad24">BaseClass::iterator</a></td></tr>
<tr class="separator:a055fa7cf1762dbaf74131f2186d9186f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa901011a1c7e2ea0f9119eb498f1fdbb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> = typename <a class="el" href="classBlockMatrixBase.html#a3318caa7ab0c4b2eb257cfb99daa5429">BaseClass::const_iterator</a></td></tr>
<tr class="separator:aa901011a1c7e2ea0f9119eb498f1fdbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3a45f953f5baee30434449e1f8e9c9d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> &gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a></td></tr>
<tr class="separator:aa3a45f953f5baee30434449e1f8e9c9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga3552a375d735b0c6bf35f640b2e6bd95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3552a375d735b0c6bf35f640b2e6bd95">DeclException0</a> (ExcBlockDimensionMismatch)</td></tr>
<tr class="separator:ga3552a375d735b0c6bf35f640b2e6bd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac60e3f81c6bacc4202f4dd951514f616"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac60e3f81c6bacc4202f4dd951514f616">copy_from</a> (const BlockMatrixType &amp;source)</td></tr>
<tr class="separator:ac60e3f81c6bacc4202f4dd951514f616"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1e54eb8c095bf2191a29c36a7784a5b6">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column)</td></tr>
<tr class="separator:a1e54eb8c095bf2191a29c36a7784a5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee186fad06d29d6670f241298f43faae"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aee186fad06d29d6670f241298f43faae">block</a> (const unsigned <a class="el" href="classint.html">int</a> row, const unsigned <a class="el" href="classint.html">int</a> column) const</td></tr>
<tr class="separator:aee186fad06d29d6670f241298f43faae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab46c51896e8656797b2086bbdfb59506"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab46c51896e8656797b2086bbdfb59506">m</a> () const</td></tr>
<tr class="separator:ab46c51896e8656797b2086bbdfb59506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bb440e54c21af96dcb43fd41958a05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78bb440e54c21af96dcb43fd41958a05">n</a> () const</td></tr>
<tr class="separator:a78bb440e54c21af96dcb43fd41958a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2478164707bf2932ad32ddd27babfc00"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2478164707bf2932ad32ddd27babfc00">n_block_rows</a> () const</td></tr>
<tr class="separator:a2478164707bf2932ad32ddd27babfc00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8a7553aacb22087640d6543a352637"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a7b8a7553aacb22087640d6543a352637">n_block_cols</a> () const</td></tr>
<tr class="separator:a7b8a7553aacb22087640d6543a352637"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9784ec81d727db00f7dbfdc9859ee029"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9784ec81d727db00f7dbfdc9859ee029">set</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j, const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> value)</td></tr>
<tr class="separator:a9784ec81d727db00f7dbfdc9859ee029"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ac6afa3a2f54b3a76ef38d8883d55a104">set</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ac6afa3a2f54b3a76ef38d8883d55a104"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd4af16696853c4a9463031fabe748a7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afd4af16696853c4a9463031fabe748a7">set</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd4af16696853c4a9463031fabe748a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc0f8f8fd5343815c3f7586478f3226d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc0f8f8fd5343815c3f7586478f3226d">set</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:adc0f8f8fd5343815c3f7586478f3226d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78136f111eaa3f476a1981528be0d1bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a78136f111eaa3f476a1981528be0d1bd">set</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> n_cols, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a78136f111eaa3f476a1981528be0d1bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ad8fe7a35a3336d251a4b3aa2c3ed9748">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j, const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> value)</td></tr>
<tr class="separator:ad8fe7a35a3336d251a4b3aa2c3ed9748"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acec5bc680c14603ef59da590d0db0f4a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#acec5bc680c14603ef59da590d0db0f4a">add</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:acec5bc680c14603ef59da590d0db0f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0254582e171452592759674d9074e1b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0254582e171452592759674d9074e1b7">add</a> (const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a0254582e171452592759674d9074e1b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00b25e1191e6a59ec8885912e50bd686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a00b25e1191e6a59ec8885912e50bd686">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const std::vector&lt; <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a00b25e1191e6a59ec8885912e50bd686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02c963b73dfee26bb1160755b40aad8d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a02c963b73dfee26bb1160755b40aad8d">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> n_cols, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> *col_indices, const number *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a02c963b73dfee26bb1160755b40aad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a9ee9987ece33a052d2b7a44034a8a01a">add</a> (const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> factor, const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt; &amp;matrix)</td></tr>
<tr class="separator:a9ee9987ece33a052d2b7a44034a8a01a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a29846f2e327eb1252f8bcea47494f7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2a29846f2e327eb1252f8bcea47494f7">operator()</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j) const</td></tr>
<tr class="separator:a2a29846f2e327eb1252f8bcea47494f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32133093964e34c80a89b8e494f32ff2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a32133093964e34c80a89b8e494f32ff2">el</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i, const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> j) const</td></tr>
<tr class="separator:a32133093964e34c80a89b8e494f32ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc6afe454cf2282f21d1230ad74bcde2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adc6afe454cf2282f21d1230ad74bcde2">diag_element</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> i) const</td></tr>
<tr class="separator:adc6afe454cf2282f21d1230ad74bcde2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74954a421ab950fef132131c2eb6b5f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a74954a421ab950fef132131c2eb6b5f9">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a74954a421ab950fef132131c2eb6b5f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a2190cc18dbc94dfb98d99d1d62ef4fb5">operator*=</a> (const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> factor)</td></tr>
<tr class="separator:a2190cc18dbc94dfb98d99d1d62ef4fb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e772b9ccf9ea814802a81948190517f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5e772b9ccf9ea814802a81948190517f">operator/=</a> (const <a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> factor)</td></tr>
<tr class="separator:a5e772b9ccf9ea814802a81948190517f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b69dc529dec11d15c40904ef729ad25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a5b69dc529dec11d15c40904ef729ad25">vmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a5b69dc529dec11d15c40904ef729ad25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a657f2265bcb165f5b9016787d62c8d1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a657f2265bcb165f5b9016787d62c8d1a">Tvmult_add</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a657f2265bcb165f5b9016787d62c8d1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a194567f1611984e0ffbd0a2967f94bd9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a194567f1611984e0ffbd0a2967f94bd9">matrix_norm_square</a> (const BlockVectorType &amp;v) const</td></tr>
<tr class="separator:a194567f1611984e0ffbd0a2967f94bd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40df5806b5d3cc3f19a31a7e11b36f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a40df5806b5d3cc3f19a31a7e11b36f51">frobenius_norm</a> () const</td></tr>
<tr class="separator:a40df5806b5d3cc3f19a31a7e11b36f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9d63be4e435be84abbdd0eff9c8fa7a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#ab9d63be4e435be84abbdd0eff9c8fa7a">matrix_scalar_product</a> (const BlockVectorType &amp;u, const BlockVectorType &amp;v) const</td></tr>
<tr class="separator:ab9d63be4e435be84abbdd0eff9c8fa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a754a13320e96366f2b5b4269a232767b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a754a13320e96366f2b5b4269a232767b">residual</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;x, const BlockVectorType &amp;b) const</td></tr>
<tr class="separator:a754a13320e96366f2b5b4269a232767b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a345092f0dea627d1b250fe51f3da6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0a345092f0dea627d1b250fe51f3da6c">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a0a345092f0dea627d1b250fe51f3da6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80251837872592496f08d63deb87cd0c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a80251837872592496f08d63deb87cd0c">begin</a> ()</td></tr>
<tr class="separator:a80251837872592496f08d63deb87cd0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed413af2409b398fd003acf6a33f351e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed413af2409b398fd003acf6a33f351e">begin</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r)</td></tr>
<tr class="separator:aed413af2409b398fd003acf6a33f351e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3dd1f6468acb2728b28ed5fad880436c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a3dd1f6468acb2728b28ed5fad880436c">begin</a> () const</td></tr>
<tr class="separator:a3dd1f6468acb2728b28ed5fad880436c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed8bd8ac7f288e11fbb9a15fcf7fa0af"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aed8bd8ac7f288e11fbb9a15fcf7fa0af">begin</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r) const</td></tr>
<tr class="separator:aed8bd8ac7f288e11fbb9a15fcf7fa0af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a969257f13a198e3b39372c513d3dc5aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a969257f13a198e3b39372c513d3dc5aa">end</a> ()</td></tr>
<tr class="separator:a969257f13a198e3b39372c513d3dc5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9494559d41237c44b235153035bcce4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af9494559d41237c44b235153035bcce4">end</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r)</td></tr>
<tr class="separator:af9494559d41237c44b235153035bcce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f188b3a4f6540c5d8ecde61b31ade05"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a0f188b3a4f6540c5d8ecde61b31ade05">end</a> () const</td></tr>
<tr class="separator:a0f188b3a4f6540c5d8ecde61b31ade05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa28a3d5286822c32a3f7ef7437e730d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afa28a3d5286822c32a3f7ef7437e730d">end</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> r) const</td></tr>
<tr class="separator:afa28a3d5286822c32a3f7ef7437e730d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa06c2fc3d4a49502844155f66078bf0"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aaa06c2fc3d4a49502844155f66078bf0">get_row_indices</a> () const</td></tr>
<tr class="separator:aaa06c2fc3d4a49502844155f66078bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe907561eea46905c41c3e0efd53cd0e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#afe907561eea46905c41c3e0efd53cd0e">get_column_indices</a> () const</td></tr>
<tr class="separator:afe907561eea46905c41c3e0efd53cd0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4041ccf8874d3ff3894e2c5e738d769a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga4041ccf8874d3ff3894e2c5e738d769a">DeclException4</a> (ExcIncompatibleRowNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt; ','&lt;&lt; arg4&lt;&lt; &quot;] have differing row numbers.&quot;)</td></tr>
<tr class="separator:ga4041ccf8874d3ff3894e2c5e738d769a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10f7d355e1a8b4ca45e2f30b3ba48916"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga10f7d355e1a8b4ca45e2f30b3ba48916">DeclException4</a> (ExcIncompatibleColNumbers, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The blocks [&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;] and [&quot;&lt;&lt; arg3&lt;&lt; ','&lt;&lt; arg4&lt;&lt; &quot;] have differing column numbers.&quot;)</td></tr>
<tr class="separator:ga10f7d355e1a8b4ca45e2f30b3ba48916"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization</div></td></tr>
<tr class="memitem:a123620de8b4c883b7c19ca9940a8296c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a123620de8b4c883b7c19ca9940a8296c">BlockSparseMatrix</a> ()=default</td></tr>
<tr class="separator:a123620de8b4c883b7c19ca9940a8296c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00656bb208ebfaea9004df0d2c6cb4c9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a00656bb208ebfaea9004df0d2c6cb4c9">BlockSparseMatrix</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a00656bb208ebfaea9004df0d2c6cb4c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75b23ca947517fc5d2bc332441d6962d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a75b23ca947517fc5d2bc332441d6962d">~BlockSparseMatrix</a> () override</td></tr>
<tr class="separator:a75b23ca947517fc5d2bc332441d6962d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bf134b6ec7f8e98a429c9892084b2b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ab0bf134b6ec7f8e98a429c9892084b2b">operator=</a> (const <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> &amp;)</td></tr>
<tr class="separator:ab0bf134b6ec7f8e98a429c9892084b2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af441b2825855fe5a6e6be9a9d0ba6375"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#af441b2825855fe5a6e6be9a9d0ba6375">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:af441b2825855fe5a6e6be9a9d0ba6375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf098688a1a7db16a6582be07dcbeb6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#acf098688a1a7db16a6582be07dcbeb6a">clear</a> ()</td></tr>
<tr class="separator:acf098688a1a7db16a6582be07dcbeb6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e0a45e360458e7350bd93487d6bf1e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit</a> (const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:a1e0a45e360458e7350bd93487d6bf1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Information on the matrix</div></td></tr>
<tr class="memitem:a5276ae56435994698038c8bf8cb4050b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a5276ae56435994698038c8bf8cb4050b">empty</a> () const</td></tr>
<tr class="separator:a5276ae56435994698038c8bf8cb4050b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39b88413d064f0d1a07078dfa8d1a5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ad39b88413d064f0d1a07078dfa8d1a5b">get_row_length</a> (const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> row) const</td></tr>
<tr class="separator:ad39b88413d064f0d1a07078dfa8d1a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9177592f1cb9df4edb7b40a6c36fbb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a1e9177592f1cb9df4edb7b40a6c36fbb">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a1e9177592f1cb9df4edb7b40a6c36fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8495bf88b8fc693a1321a498958aefb1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a8495bf88b8fc693a1321a498958aefb1">n_actually_nonzero_elements</a> (const <a class="el" href="classdouble.html">double</a> threshold=0.0) const</td></tr>
<tr class="separator:a8495bf88b8fc693a1321a498958aefb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a410e8b95646a25a67506dc4eed329f05"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a410e8b95646a25a67506dc4eed329f05">get_sparsity_pattern</a> () const</td></tr>
<tr class="separator:a410e8b95646a25a67506dc4eed329f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c4f17dc23a7ca73d167f34450e1db1"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a33c4f17dc23a7ca73d167f34450e1db1">memory_consumption</a> () const</td></tr>
<tr class="separator:a33c4f17dc23a7ca73d167f34450e1db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:ab90c7cc2218c2cf226f2fb00c59e746b"><td class="memTemplParams" colspan="2">template&lt;typename block_number &gt; </td></tr>
<tr class="memitem:ab90c7cc2218c2cf226f2fb00c59e746b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ab90c7cc2218c2cf226f2fb00c59e746b">vmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:ab90c7cc2218c2cf226f2fb00c59e746b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a507795aed66a5f86b585bfaa2cfabbe3"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:a507795aed66a5f86b585bfaa2cfabbe3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a507795aed66a5f86b585bfaa2cfabbe3">vmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:a507795aed66a5f86b585bfaa2cfabbe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9122f9939becc261dc5f1af3af072146"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:a9122f9939becc261dc5f1af3af072146"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a9122f9939becc261dc5f1af3af072146">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:a9122f9939becc261dc5f1af3af072146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a935b5e5b6b15af1ed17d77ed3b195506"><td class="memTemplParams" colspan="2">template&lt;typename nonblock_number &gt; </td></tr>
<tr class="memitem:a935b5e5b6b15af1ed17d77ed3b195506"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a935b5e5b6b15af1ed17d77ed3b195506">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:a935b5e5b6b15af1ed17d77ed3b195506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadcb0ea8eddf6bd974b1e6cab4b9811b"><td class="memTemplParams" colspan="2">template&lt;typename block_number &gt; </td></tr>
<tr class="memitem:aadcb0ea8eddf6bd974b1e6cab4b9811b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#aadcb0ea8eddf6bd974b1e6cab4b9811b">Tvmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:aadcb0ea8eddf6bd974b1e6cab4b9811b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68dd4e1121c1435b7fbdeb12735a57a"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:ab68dd4e1121c1435b7fbdeb12735a57a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ab68dd4e1121c1435b7fbdeb12735a57a">Tvmult</a> (<a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:ab68dd4e1121c1435b7fbdeb12735a57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a887a23f787dad22e556166d42a92e68c"><td class="memTemplParams" colspan="2">template&lt;typename block_number , typename nonblock_number &gt; </td></tr>
<tr class="memitem:a887a23f787dad22e556166d42a92e68c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a887a23f787dad22e556166d42a92e68c">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;src) const</td></tr>
<tr class="separator:a887a23f787dad22e556166d42a92e68c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565f4c52db80d9e8f94b4236cefe5292"><td class="memTemplParams" colspan="2">template&lt;typename nonblock_number &gt; </td></tr>
<tr class="memitem:a565f4c52db80d9e8f94b4236cefe5292"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a565f4c52db80d9e8f94b4236cefe5292">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;src) const</td></tr>
<tr class="separator:a565f4c52db80d9e8f94b4236cefe5292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Preconditioning methods</div></td></tr>
<tr class="memitem:af40175362eebf81cea0541b56041c135"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:af40175362eebf81cea0541b56041c135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#af40175362eebf81cea0541b56041c135">precondition_Jacobi</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:af40175362eebf81cea0541b56041c135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a318a6a40f0a56c5c1a17d99f642820e9"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a318a6a40f0a56c5c1a17d99f642820e9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a318a6a40f0a56c5c1a17d99f642820e9">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a318a6a40f0a56c5c1a17d99f642820e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Input/Output</div></td></tr>
<tr class="memitem:ae787f1316166e2590f9ad37fc2190087"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#ae787f1316166e2590f9ad37fc2190087">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const</td></tr>
<tr class="separator:ae787f1316166e2590f9ad37fc2190087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6acb9f7db404d81437b2007fd9368d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6acb9f7db404d81437b2007fd9368d97">collect_sizes</a> ()</td></tr>
<tr class="separator:a6acb9f7db404d81437b2007fd9368d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4109f58621de12f02b521df0bbb4728f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a4109f58621de12f02b521df0bbb4728f">vmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a4109f58621de12f02b521df0bbb4728f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfd4c9d2a02835be4a0e7fdb9c5fb84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#adfd4c9d2a02835be4a0e7fdb9c5fb84b">vmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:adfd4c9d2a02835be4a0e7fdb9c5fb84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70152dd877ead20e92468b11dd923fdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a70152dd877ead20e92468b11dd923fdb">vmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a70152dd877ead20e92468b11dd923fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003f20e2d1a54fa9cc7e312175f23101"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a003f20e2d1a54fa9cc7e312175f23101">vmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a003f20e2d1a54fa9cc7e312175f23101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5e896a6aadc0f6663ca4bfd69e8e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a1b5e896a6aadc0f6663ca4bfd69e8e73">Tvmult_block_block</a> (BlockVectorType &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a1b5e896a6aadc0f6663ca4bfd69e8e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f970e6afe14484f051897f5c78060f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#af6f970e6afe14484f051897f5c78060f">Tvmult_block_nonblock</a> (BlockVectorType &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:af6f970e6afe14484f051897f5c78060f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20df57e0ac765128dfaa48add407e490"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a20df57e0ac765128dfaa48add407e490">Tvmult_nonblock_block</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const BlockVectorType &amp;src) const</td></tr>
<tr class="separator:a20df57e0ac765128dfaa48add407e490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a002a305f47b31aa962b58f6a863f831d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a002a305f47b31aa962b58f6a863f831d">Tvmult_nonblock_nonblock</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classVectorType.html">VectorType</a> &amp;src) const</td></tr>
<tr class="separator:a002a305f47b31aa962b58f6a863f831d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f52ce530c3028e0d3194a719cb82576"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6f52ce530c3028e0d3194a719cb82576">prepare_add_operation</a> ()</td></tr>
<tr class="separator:a6f52ce530c3028e0d3194a719cb82576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79d3d021b1004a8fb027b50e0862c149"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a79d3d021b1004a8fb027b50e0862c149">prepare_set_operation</a> ()</td></tr>
<tr class="separator:a79d3d021b1004a8fb027b50e0862c149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aa401f344887a4647a9a14ef41629aed9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#aa401f344887a4647a9a14ef41629aed9">row_block_indices</a></td></tr>
<tr class="separator:aa401f344887a4647a9a14ef41629aed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a10666cbe2741f71f6cf17ebedaf9080d">column_block_indices</a></td></tr>
<tr class="separator:a10666cbe2741f71f6cf17ebedaf9080d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6352220e7e9c26aaffd42bce3b2f25b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; <a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockMatrixBase.html#a6352220e7e9c26aaffd42bce3b2f25b4">sub_objects</a></td></tr>
<tr class="separator:a6352220e7e9c26aaffd42bce3b2f25b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a9fb413a875ce50b9da3f61761d6324ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockSparseMatrix.html#a9fb413a875ce50b9da3f61761d6324ce">sparsity_pattern</a></td></tr>
<tr class="separator:a9fb413a875ce50b9da3f61761d6324ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class BlockSparseMatrix&lt; number &gt;</h3>

<p>Blocked sparse matrix based on the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> class. This class implements the functions that are specific to the <a class="el" href="classSparseMatrix.html">SparseMatrix</a> base objects for a blocked sparse matrix, and leaves the actual work relaying most of the calls to the individual blocks to the functions implemented in the base class. See there also for a description of when this class is useful.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00049">49</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a53f62e71c75de40d6f733b58deeb6b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53f62e71c75de40d6f733b58deeb6b6d">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a53f62e71c75de40d6f733b58deeb6b6d">BaseClass</a> =  <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the base class for simpler access to its own alias. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00055">55</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abf708b3b89cdb80352c82c86b549003a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf708b3b89cdb80352c82c86b549003a">&#9670;&nbsp;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a> =  typename <a class="el" href="classBlockMatrixBase.html#a11eb26331dcea2cd7095abf2a7182f87">BaseClass::BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the type of the underlying matrix. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00060">60</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a01090fd74745d8459d54f28faf603c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01090fd74745d8459d54f28faf603c8c">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> =  typename <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import the alias from the base class. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00065">65</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a75beade6b5675a7dea5b679b0a5cf6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75beade6b5675a7dea5b679b0a5cf6de">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a75beade6b5675a7dea5b679b0a5cf6de">pointer</a> =  typename <a class="el" href="classBlockMatrixBase.html#ae305c4e1fdaf318cd3dfdce7ff5d4fbf">BaseClass::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00066">66</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a08b414d5c0a3f020754f2007edf578c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08b414d5c0a3f020754f2007edf578c8">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a08b414d5c0a3f020754f2007edf578c8">const_pointer</a> =  typename <a class="el" href="classBlockMatrixBase.html#a7c4888a73231c2eff68d01e6ecc6e975">BaseClass::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00067">67</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac35360e5724f6a8d22895e5f584a221e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac35360e5724f6a8d22895e5f584a221e">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#ac35360e5724f6a8d22895e5f584a221e">reference</a> =  typename <a class="el" href="classBlockMatrixBase.html#a026a82c1fb4827731009779a8e679963">BaseClass::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00068">68</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a80757d5220db42577b6f4c5b92e01eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80757d5220db42577b6f4c5b92e01eba">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a80757d5220db42577b6f4c5b92e01eba">const_reference</a> =  typename <a class="el" href="classBlockMatrixBase.html#a1f04c58b85ae49f430354a71b525e533">BaseClass::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00069">69</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a8a0892dc59ebd4027c20526484231eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0892dc59ebd4027c20526484231eab">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> =  typename <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">BaseClass::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00070">70</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a055fa7cf1762dbaf74131f2186d9186f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a055fa7cf1762dbaf74131f2186d9186f">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> =  typename <a class="el" href="classBlockMatrixBase.html#a9676f6127d493633bb4b66ee1952ad24">BaseClass::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00071">71</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa901011a1c7e2ea0f9119eb498f1fdbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa901011a1c7e2ea0f9119eb498f1fdbb">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> =  typename <a class="el" href="classBlockMatrixBase.html#a3318caa7ab0c4b2eb257cfb99daa5429">BaseClass::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00072">72</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa3a45f953f5baee30434449e1f8e9c9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3a45f953f5baee30434449e1f8e9c9d">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;<a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a>&gt;::<a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00362">362</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a123620de8b4c883b7c19ca9940a8296c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123620de8b4c883b7c19ca9940a8296c">&#9670;&nbsp;</a></span>BlockSparseMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor; initializes the matrix to be empty, without any structure, i.e. the matrix is not usable at all. This constructor is therefore only useful for matrices which are members of a class. All other matrices should be created at a point in the data flow where all necessary information is available.</p>
<p>You have to initialize the matrix before usage with reinit(BlockSparsityPattern). The number of blocks per row and column are then determined by that function. </p>

</div>
</div>
<a id="a00656bb208ebfaea9004df0d2c6cb4c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00656bb208ebfaea9004df0d2c6cb4c9">&#9670;&nbsp;</a></span>BlockSparseMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Takes the given matrix sparsity structure to represent the sparsity pattern of this matrix. You can change the sparsity pattern later on by calling the <a class="el" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit()</a> function.</p>
<p>This constructor initializes all sub-matrices with the sub-sparsity pattern within the argument.</p>
<p>You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as <a class="el" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit()</a> is not called with a new sparsity structure. </p>

</div>
</div>
<a id="a75b23ca947517fc5d2bc332441d6962d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75b23ca947517fc5d2bc332441d6962d">&#9670;&nbsp;</a></span>~BlockSparseMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::~<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab0bf134b6ec7f8e98a429c9892084b2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bf134b6ec7f8e98a429c9892084b2b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&amp; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pseudo copy operator only copying empty objects. The sizes of the block matrices need to be the same. </p>

</div>
</div>
<a id="af441b2825855fe5a6e6be9a9d0ba6375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af441b2825855fe5a6e6be9a9d0ba6375">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. Since this does usually not make much sense (should we set all matrix entries to this value? Only the nonzero entries of the sparsity pattern?), this operation is only allowed if the actual value to be assigned is zero. This operator only exists to allow for the obvious notation <code>matrix=0</code>, which sets all elements of the matrix to zero, but keep the sparsity pattern previously used. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00379">379</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="acf098688a1a7db16a6582be07dcbeb6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf098688a1a7db16a6582be07dcbeb6a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. It also forgets the sparsity pattern it was previously tied to.</p>
<p>This calls <a class="el" href="classSparseMatrix.html#a45f664681373fd3a1f8dd965395d360d">SparseMatrix::clear</a> on all sub-matrices and then resets this object to have no blocks at all. </p>

</div>
</div>
<a id="a1e0a45e360458e7350bd93487d6bf1e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e0a45e360458e7350bd93487d6bf1e5">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reinitialize the sparse matrix with the given sparsity pattern. The latter tells the matrix how many nonzero elements there need to be reserved.</p>
<p>Basically, this function only calls <a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">SparseMatrix::reinit()</a> of the sub- matrices with the block sparsity patterns of the parameter.</p>
<p>You have to make sure that the lifetime of the sparsity structure is at least as long as that of this matrix or as long as reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;) is not called with a new sparsity structure.</p>
<p>The elements of the matrix are set to zero by this function. </p>

</div>
</div>
<a id="a5276ae56435994698038c8bf8cb4050b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5276ae56435994698038c8bf8cb4050b">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the object is empty. It is empty if either both dimensions are zero or no <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> is associated. </p>

</div>
</div>
<a id="ad39b88413d064f0d1a07078dfa8d1a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39b88413d064f0d1a07078dfa8d1a5b">&#9670;&nbsp;</a></span>get_row_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::get_row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of entries in a specific row. </p>

</div>
</div>
<a id="a1e9177592f1cb9df4edb7b40a6c36fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e9177592f1cb9df4edb7b40a6c36fbb">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of nonzero elements of this matrix. Actually, it returns the number of entries in the sparsity pattern; if any of the entries should happen to be zero, it is counted anyway. </p>

</div>
</div>
<a id="a8495bf88b8fc693a1321a498958aefb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8495bf88b8fc693a1321a498958aefb1">&#9670;&nbsp;</a></span>n_actually_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of actually nonzero elements. Just counts the number of actually nonzero elements (with absolute value larger than threshold) of all the blocks. </p>

</div>
</div>
<a id="a410e8b95646a25a67506dc4eed329f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a410e8b95646a25a67506dc4eed329f05">&#9670;&nbsp;</a></span>get_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>&amp; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a (constant) reference to the underlying sparsity pattern of this matrix.</p>
<p>Though the return value is declared <code>const</code>, you should be aware that it may change if you call any nonconstant function of objects which operate on it. </p>

</div>
</div>
<a id="a33c4f17dc23a7ca73d167f34450e1db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c4f17dc23a7ca73d167f34450e1db1">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="ab90c7cc2218c2cf226f2fb00c59e746b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab90c7cc2218c2cf226f2fb00c59e746b">&#9670;&nbsp;</a></span>vmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let \(dst = M*src\) with \(M\) being this matrix. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00395">395</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a507795aed66a5f86b585bfaa2cfabbe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a507795aed66a5f86b585bfaa2cfabbe3">&#9670;&nbsp;</a></span>vmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block column. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00406">406</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a9122f9939becc261dc5f1af3af072146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9122f9939becc261dc5f1af3af072146">&#9670;&nbsp;</a></span>vmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block row. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00417">417</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a935b5e5b6b15af1ed17d77ed3b195506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a935b5e5b6b15af1ed17d77ed3b195506">&#9670;&nbsp;</a></span>vmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00428">428</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aadcb0ea8eddf6bd974b1e6cab4b9811b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcb0ea8eddf6bd974b1e6cab4b9811b">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let \(dst = M^T*src\) with \(M\) being this matrix. This function does the same as <a class="el" href="classBlockSparseMatrix.html#ab90c7cc2218c2cf226f2fb00c59e746b">vmult()</a> but takes the transposed matrix. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00439">439</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ab68dd4e1121c1435b7fbdeb12735a57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68dd4e1121c1435b7fbdeb12735a57a">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block row. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00450">450</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a887a23f787dad22e556166d42a92e68c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a887a23f787dad22e556166d42a92e68c">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename block_number , typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVector.html">BlockVector</a>&lt; block_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block column. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00461">461</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a565f4c52db80d9e8f94b4236cefe5292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565f4c52db80d9e8f94b4236cefe5292">&#9670;&nbsp;</a></span>Tvmult() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename nonblock_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; nonblock_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00472">472</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="af40175362eebf81cea0541b56041c135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40175362eebf81cea0541b56041c135">&#9670;&nbsp;</a></span>precondition_Jacobi() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the Jacobi preconditioner, which multiplies every element of the <code>src</code> vector by the inverse of the respective diagonal element and multiplies the result with the relaxation parameter <code>omega</code>.</p>
<p>All diagonal blocks must be square matrices for this operation. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00483">483</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a318a6a40f0a56c5c1a17d99f642820e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a318a6a40f0a56c5c1a17d99f642820e9">&#9670;&nbsp;</a></span>precondition_Jacobi() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Apply the Jacobi preconditioner to a simple vector.</p>
<p>The matrix must be a single square block for this. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00504">504</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ae787f1316166e2590f9ad37fc2190087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae787f1316166e2590f9ad37fc2190087">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix in the usual format, i.e. as a matrix and not as a list of nonzero elements. For better readability, elements not in the matrix are displayed as empty space, while matrix elements which are explicitly set to zero are displayed as such.</p>
<p>The parameters allow for a flexible setting of the output format: <code>precision</code> and <code>scientific</code> are used to determine the number format, where <code>scientific = false</code> means fixed point notation. A zero entry for <code>width</code> makes the function compute a width, but it may be changed to a positive value, if output is crude.</p>
<p>Additionally, a character for an empty value may be specified.</p>
<p>Finally, the whole matrix can be multiplied with a common denominator to produce more readable output, even integers.</p>
<dl class="section attention"><dt>Attention</dt><dd>This function may produce <b>large</b> amounts of output if applied to a large matrix! </dd></dl>

</div>
</div>
<a id="ac60e3f81c6bacc4202f4dd951514f616"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac60e3f81c6bacc4202f4dd951514f616">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const BlockMatrixType &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the matrix given as argument into the current object.</p>
<p>Copying matrices is an expensive operation that we do not want to happen by accident through compiler generated code for <code>operator=</code>. (This would happen, for example, if one accidentally declared a function argument of the current type <em>by value</em> rather than <em>by reference</em>.) The functionality of copying matrices is implemented in this member function instead. All copy operations of objects of this type therefore require an explicit function call.</p>
<p>The source matrix may be a matrix of arbitrary type, as long as its data type is convertible to the data type of this matrix.</p>
<p>The function returns a reference to <code>this</code>. </p>

</div>
</div>
<a id="a1e54eb8c095bf2191a29c36a7784a5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e54eb8c095bf2191a29c36a7784a5b6">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. </p>

</div>
</div>
<a id="aee186fad06d29d6670f241298f43faae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee186fad06d29d6670f241298f43faae">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access the block with the given coordinates. Version for constant objects. </p>

</div>
</div>
<a id="ab46c51896e8656797b2086bbdfb59506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab46c51896e8656797b2086bbdfb59506">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the dimension of the codomain (or range) space. Note that the matrix is of dimension \(m \times n\). </p>

</div>
</div>
<a id="a78bb440e54c21af96dcb43fd41958a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78bb440e54c21af96dcb43fd41958a05">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a8a0892dc59ebd4027c20526484231eab">size_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the dimension of the domain space. Note that the matrix is of dimension \(m \times n\). </p>

</div>
</div>
<a id="a2478164707bf2932ad32ddd27babfc00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2478164707bf2932ad32ddd27babfc00">&#9670;&nbsp;</a></span>n_block_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::n_block_rows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of blocks in a column. Returns zero if no sparsity pattern is presently associated to this matrix. </p>

</div>
</div>
<a id="a7b8a7553aacb22087640d6543a352637"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8a7553aacb22087640d6543a352637">&#9670;&nbsp;</a></span>n_block_cols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::n_block_cols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of blocks in a row. Returns zero if no sparsity pattern is presently associated to this matrix. </p>

</div>
</div>
<a id="a9784ec81d727db00f7dbfdc9859ee029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9784ec81d727db00f7dbfdc9859ee029">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the element <code>(i,j)</code> to <code>value</code>. Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="ac6afa3a2f54b3a76ef38d8883d55a104"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6afa3a2f54b3a76ef38d8883d55a104">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix</a> into the sparse matrix locations given by <code>indices</code>. In other words, this function writes the elements in <code>full_matrix</code> into the calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a id="afd4af16696853c4a9463031fabe748a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd4af16696853c4a9463031fabe748a7">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="adc0f8f8fd5343815c3f7586478f3226d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc0f8f8fd5343815c3f7586478f3226d">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be set anyway or they should be filtered away (and not change the previous content in the respective element if it exists). The default value is <code>false</code>, i.e., even zero values are treated. </p>

</div>
</div>
<a id="a78136f111eaa3f476a1981528be0d1bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78136f111eaa3f476a1981528be0d1bd">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements to values given by <code>values</code> in a given row in columns given by col_indices into the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be inserted anyway or they should be filtered away. The default value is <code>false</code>, i.e., even zero values are inserted/replaced. </p>

</div>
</div>
<a id="ad8fe7a35a3336d251a4b3aa2c3ed9748"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8fe7a35a3336d251a4b3aa2c3ed9748">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>value</code> to the element (<em>i,j</em>). Throws an error if the entry does not exist or if <code>value</code> is not a finite number. Still, it is allowed to store zero values in non-existent fields. </p>

</div>
</div>
<a id="acec5bc680c14603ef59da590d0db0f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acec5bc680c14603ef59da590d0db0f4a">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add all elements given in a <a class="el" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> into sparse matrix locations given by <code>indices</code>. In other words, this function adds the elements in <code>full_matrix</code> to the respective entries in calling matrix, using the local-to-global indexing specified by <code>indices</code> for both the rows and the columns of the matrix. This function assumes a quadratic sparse matrix and a quadratic full_matrix, the usual situation in FE calculations.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a0254582e171452592759674d9074e1b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0254582e171452592759674d9074e1b7">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as before, but now including the possibility to use rectangular full_matrices and different local-to-global indexing on rows and columns, respectively. </p>

</div>
</div>
<a id="a00b25e1191e6a59ec8885912e50bd686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00b25e1191e6a59ec8885912e50bd686">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set several elements in the specified row of the matrix with column indices as given by <code>col_indices</code> to the respective value.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a02c963b73dfee26bb1160755b40aad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02c963b73dfee26bb1160755b40aad8d">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the sparse matrix.</p>
<p>The optional parameter <code>elide_zero_values</code> can be used to specify whether zero values should be added anyway or these should be filtered away and only non-zero data is added. The default value is <code>true</code>, i.e., zero values won't be added into the matrix. </p>

</div>
</div>
<a id="a9ee9987ece33a052d2b7a44034a8a01a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee9987ece33a052d2b7a44034a8a01a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>matrix</code> scaled by <code>factor</code> to this matrix, i.e. the matrix <code>factor*matrix</code> is added to <code>this</code>. If the sparsity pattern of the calling matrix does not contain all the elements in the sparsity pattern of the input matrix, this function will throw an exception.</p>
<p>Depending on MatrixType, however, additional restrictions might arise. Some sparse matrix formats require <code>matrix</code> to be based on the same sparsity pattern as the calling matrix. </p>

</div>
</div>
<a id="a2a29846f2e327eb1252f8bcea47494f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a29846f2e327eb1252f8bcea47494f7">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the entry (i,j). This may be an expensive operation and you should always take care where to call this function. In order to avoid abuse, this function throws an exception if the wanted element does not exist in the matrix. </p>

</div>
</div>
<a id="a32133093964e34c80a89b8e494f32ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32133093964e34c80a89b8e494f32ff2">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is mostly like <a class="el" href="classBlockMatrixBase.html#a2a29846f2e327eb1252f8bcea47494f7">operator()()</a> in that it returns the value of the matrix entry <code>(i,j)</code>. The only difference is that if this entry does not exist in the sparsity pattern, then instead of raising an exception, zero is returned. While this may be convenient in some cases, note that it is simple to write algorithms that are slow compared to an optimal solution, since the sparsity of the matrix is not used. </p>

</div>
</div>
<a id="adc6afe454cf2282f21d1230ad74bcde2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc6afe454cf2282f21d1230ad74bcde2">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the main diagonal element in the <em>i</em>th row. This function throws an error if the matrix is not quadratic and also if the diagonal blocks of the matrix are not quadratic.</p>
<p>This function is considerably faster than the <a class="el" href="classBlockMatrixBase.html#a2a29846f2e327eb1252f8bcea47494f7">operator()()</a>, since for quadratic matrices, the diagonal entry may be the first to be stored in each row and access therefore does not involve searching for the right column number. </p>

</div>
</div>
<a id="a74954a421ab950fef132131c2eb6b5f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74954a421ab950fef132131c2eb6b5f9">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the <a class="el" href="classBlockMatrixBase.html#a74954a421ab950fef132131c2eb6b5f9">compress()</a> function on all the subblocks of the matrix.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

</div>
</div>
<a id="a2190cc18dbc94dfb98d99d1d62ef4fb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2190cc18dbc94dfb98d99d1d62ef4fb5">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire matrix by a fixed factor. </p>

</div>
</div>
<a id="a5e772b9ccf9ea814802a81948190517f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e772b9ccf9ea814802a81948190517f">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a67f5e943e0dc120090f1e0748c38b34f">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire matrix by a fixed factor. </p>

</div>
</div>
<a id="a5b69dc529dec11d15c40904ef729ad25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b69dc529dec11d15c40904ef729ad25">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add \(M*src\) on \(dst\) with \(M\) being this matrix. </p>

</div>
</div>
<a id="a657f2265bcb165f5b9016787d62c8d1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a657f2265bcb165f5b9016787d62c8d1a">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adding Matrix-vector multiplication. Add <em>M<sup>T</sup>src</em> to <em>dst</em> with <em>M</em> being this matrix. This function does the same as <a class="el" href="classBlockMatrixBase.html#a5b69dc529dec11d15c40904ef729ad25">vmult_add()</a> but takes the transposed matrix. </p>

</div>
</div>
<a id="a194567f1611984e0ffbd0a2967f94bd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a194567f1611984e0ffbd0a2967f94bd9">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the norm of the vector <em>v</em> with respect to the norm induced by this matrix, i.e. <em>v<sup>T</sup>Mv)</em>. This is useful, e.g. in the finite element context, where the <em>L<sup>T</sup></em>-norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function. Note that even though the function's name might suggest something different, for historic reasons not the norm but its square is returned, as defined above by the scalar product.</p>
<p>Obviously, the matrix needs to be square for this operation. </p>

</div>
</div>
<a id="a40df5806b5d3cc3f19a31a7e11b36f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40df5806b5d3cc3f19a31a7e11b36f51">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html#aa3a45f953f5baee30434449e1f8e9c9d">real_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the frobenius norm of the matrix, i.e. the square root of the sum of squares of all entries in the matrix. </p>

</div>
</div>
<a id="ab9d63be4e435be84abbdd0eff9c8fa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d63be4e435be84abbdd0eff9c8fa7a">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the matrix scalar product \(\left(u,Mv\right)\). </p>

</div>
</div>
<a id="a754a13320e96366f2b5b4269a232767b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a754a13320e96366f2b5b4269a232767b">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a01090fd74745d8459d54f28faf603c8c">value_type</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::residual </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the residual <em>r=b-Ax</em>. Write the residual into <code>dst</code>. </p>

</div>
</div>
<a id="a0a345092f0dea627d1b250fe51f3da6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a345092f0dea627d1b250fe51f3da6c">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the matrix to the given stream, using the format <code>(line,col) value</code>, i.e. one nonzero entry of the matrix per line. The optional flag outputs the sparsity pattern in a different style according to the underlying sparse matrix type. </p>

</div>
</div>
<a id="a80251837872592496f08d63deb87cd0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80251837872592496f08d63deb87cd0c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator starting at the first entry. </p>

</div>
</div>
<a id="aed413af2409b398fd003acf6a33f351e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed413af2409b398fd003acf6a33f351e">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>. </p>

</div>
</div>
<a id="a3dd1f6468acb2728b28ed5fad880436c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3dd1f6468acb2728b28ed5fad880436c">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator starting at the first entry. </p>

</div>
</div>
<a id="aed8bd8ac7f288e11fbb9a15fcf7fa0af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed8bd8ac7f288e11fbb9a15fcf7fa0af">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Iterator starting at the first entry of row <code>r</code>. </p>

</div>
</div>
<a id="a969257f13a198e3b39372c513d3dc5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a969257f13a198e3b39372c513d3dc5aa">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="af9494559d41237c44b235153035bcce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9494559d41237c44b235153035bcce4">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#a055fa7cf1762dbaf74131f2186d9186f">iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. </p>

</div>
</div>
<a id="a0f188b3a4f6540c5d8ecde61b31ade05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f188b3a4f6540c5d8ecde61b31ade05">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Final iterator. </p>

</div>
</div>
<a id="afa28a3d5286822c32a3f7ef7437e730d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa28a3d5286822c32a3f7ef7437e730d">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockSparseMatrix.html#aa901011a1c7e2ea0f9119eb498f1fdbb">const_iterator</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockMatrixBase.html#a5efbae0f7219630331e7fc966cd3647a">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Final iterator of row <code>r</code>. </p>

</div>
</div>
<a id="aaa06c2fc3d4a49502844155f66078bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa06c2fc3d4a49502844155f66078bf0">&#9670;&nbsp;</a></span>get_row_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::get_row_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the underlying <a class="el" href="classBlockIndices.html">BlockIndices</a> data of the rows. </p>

</div>
</div>
<a id="afe907561eea46905c41c3e0efd53cd0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe907561eea46905c41c3e0efd53cd0e">&#9670;&nbsp;</a></span>get_column_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::get_column_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference to the underlying <a class="el" href="classBlockIndices.html">BlockIndices</a> data of the columns. </p>

</div>
</div>
<a id="ga4041ccf8874d3ff3894e2c5e738d769a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4041ccf8874d3ff3894e2c5e738d769a">&#9670;&nbsp;</a></span>DeclException4() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleRowNumbers&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The blocks  and  have differing row numbers.&quot;&#160;</td>
          <td class="paramname">[&quot; &lt;&lt; arg1 &lt;&lt; ',' &lt;&lt; arg2 &lt;&lt; &quot;][&quot; &lt;&lt; arg3 &lt;&lt; ',' &lt;&lt; arg4 &lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ga10f7d355e1a8b4ca45e2f30b3ba48916"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga10f7d355e1a8b4ca45e2f30b3ba48916">&#9670;&nbsp;</a></span>DeclException4() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleColNumbers&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The blocks  and  have differing column numbers.&quot;&#160;</td>
          <td class="paramname">[&quot; &lt;&lt; arg1 &lt;&lt; ',' &lt;&lt; arg2 &lt;&lt; &quot;][&quot; &lt;&lt; arg3 &lt;&lt; ',' &lt;&lt; arg4 &lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a6acb9f7db404d81437b2007fd9368d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acb9f7db404d81437b2007fd9368d97">&#9670;&nbsp;</a></span>collect_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::collect_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function collects the sizes of the sub-objects and stores them in internal arrays, in order to be able to relay global indices into the matrix to indices into the subobjects. You <em>must</em> call this function each time after you have changed the size of the sub-objects.</p>
<p>Derived classes should call this function whenever the size of the sub- objects has changed and the <code>X_block_indices</code> arrays need to be updated.</p>
<p>Note that this function is not public since not all derived classes need to export its interface. For example, for the usual deal.II <a class="el" href="classSparseMatrix.html">SparseMatrix</a> class, the sizes are implicitly determined whenever <a class="el" href="classBlockSparseMatrix.html#a1e0a45e360458e7350bd93487d6bf1e5">reinit()</a> is called, and individual blocks cannot be resized. For that class, this function therefore does not have to be public. On the other hand, for the PETSc classes, there is no associated sparsity pattern object that determines the block sizes, and for these the function needs to be publicly available. These classes therefore export this function. </p>

</div>
</div>
<a id="a4109f58621de12f02b521df0bbb4728f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4109f58621de12f02b521df0bbb4728f">&#9670;&nbsp;</a></span>vmult_block_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let \(dst = M*src\) with \(M\) being this matrix.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="adfd4c9d2a02835be4a0e7fdb9c5fb84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfd4c9d2a02835be4a0e7fdb9c5fb84b">&#9670;&nbsp;</a></span>vmult_block_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block column.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="a70152dd877ead20e92468b11dd923fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70152dd877ead20e92468b11dd923fdb">&#9670;&nbsp;</a></span>vmult_nonblock_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block row.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="a003f20e2d1a54fa9cc7e312175f23101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a003f20e2d1a54fa9cc7e312175f23101">&#9670;&nbsp;</a></span>vmult_nonblock_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::vmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="a1b5e896a6aadc0f6663ca4bfd69e8e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5e896a6aadc0f6663ca4bfd69e8e73">&#9670;&nbsp;</a></span>Tvmult_block_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_block_block </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication: let \(dst = M^T*src\) with \(M\) being this matrix. This function does the same as <a class="el" href="classBlockSparseMatrix.html#ab90c7cc2218c2cf226f2fb00c59e746b">vmult()</a> but takes the transposed matrix.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="af6f970e6afe14484f051897f5c78060f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f970e6afe14484f051897f5c78060f">&#9670;&nbsp;</a></span>Tvmult_block_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_block_nonblock </td>
          <td>(</td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block row.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="a20df57e0ac765128dfaa48add407e490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20df57e0ac765128dfaa48add407e490">&#9670;&nbsp;</a></span>Tvmult_nonblock_block()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_nonblock_block </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block column.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="a002a305f47b31aa962b58f6a863f831d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a002a305f47b31aa962b58f6a863f831d">&#9670;&nbsp;</a></span>Tvmult_nonblock_nonblock()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::Tvmult_nonblock_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Matrix-vector multiplication. Just like the previous function, but only applicable if the matrix has only one block.</p>
<p>Due to problems with deriving template arguments between the block and non-block versions of the vmult/Tvmult functions, the actual functions are implemented in derived classes, with implementations forwarding the calls to the implementations provided here under a unique name for which template arguments can be derived by the compiler. </p>

</div>
</div>
<a id="a6f52ce530c3028e0d3194a719cb82576"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f52ce530c3028e0d3194a719cb82576">&#9670;&nbsp;</a></span>prepare_add_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::prepare_add_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Some matrix types, in particular PETSc, need to synchronize set and add operations. This has to be done for all matrices in the BlockMatrix. This routine prepares adding of elements by notifying all blocks. Called by all internal routines before adding elements. </p>

</div>
</div>
<a id="a79d3d021b1004a8fb027b50e0862c149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79d3d021b1004a8fb027b50e0862c149">&#9670;&nbsp;</a></span>prepare_set_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::prepare_set_operation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Notifies all blocks to let them prepare for setting elements, see <a class="el" href="classBlockMatrixBase.html#a6f52ce530c3028e0d3194a719cb82576">prepare_add_operation()</a>. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9fb413a875ce50b9da3f61761d6324ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb413a875ce50b9da3f61761d6324ce">&#9670;&nbsp;</a></span>sparsity_pattern</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a>, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt;number&gt; &gt; <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt;::sparsity_pattern</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the block sparsity pattern used for this matrix. In order to guarantee that it is not deleted while still in use, we subscribe to it using the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>

<p class="definition">Definition at line <a class="el" href="block__sparse__matrix_8h_source.html#l00367">367</a> of file <a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a>.</p>

</div>
</div>
<a id="aa401f344887a4647a9a14ef41629aed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa401f344887a4647a9a14ef41629aed9">&#9670;&nbsp;</a></span>row_block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::row_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Index arrays for rows and columns. </p>

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00846">846</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a id="a10666cbe2741f71f6cf17ebedaf9080d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10666cbe2741f71f6cf17ebedaf9080d">&#9670;&nbsp;</a></span>column_block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::column_block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00847">847</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<a id="a6352220e7e9c26aaffd42bce3b2f25b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6352220e7e9c26aaffd42bce3b2f25b4">&#9670;&nbsp;</a></span>sub_objects</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTable.html">Table</a>&lt;2, <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;<a class="el" href="classBlockSparseMatrix.html#abf708b3b89cdb80352c82c86b549003a">BlockType</a>, <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt;<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &gt; &gt; &gt; <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;  &gt;::sub_objects</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of sub-matrices. </p>

<p class="definition">Definition at line <a class="el" href="block__matrix__base_8h_source.html#l00852">852</a> of file <a class="el" href="block__matrix__base_8h_source.html">block_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="block__sparse__matrix_8h_source.html">block_sparse_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
