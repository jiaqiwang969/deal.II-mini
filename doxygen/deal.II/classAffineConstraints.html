<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classAffineConstraints.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: AffineConstraints&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classAffineConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AffineConstraints&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a><a class="el" href="group__dofs.html">Degrees of Freedom</a> &raquo;  &#124; <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="affine__constraints_8h_source.html">deal.II/lac/affine_constraints.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AffineConstraints&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAffineConstraints__inherit__graph.svg" width="627" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3b54f13f985552be5a78ac928258daed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">MergeConflictBehavior</a> { <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b">no_conflicts_allowed</a>, 
<a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daedaced33eb2366bc959ac3f7403a83c8947">left_object_wins</a>, 
<a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daedad0ade894fba0235316b96337fdec9af2">right_object_wins</a>
 }</td></tr>
<tr class="separator:a3b54f13f985552be5a78ac928258daed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7ce3525c69e7b5bba3a0dd03f0dead"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a0a7ce3525c69e7b5bba3a0dd03f0dead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7fa5de5e1528a3604179b6cf77fda2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a> = typename std::vector&lt; <a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a> &gt;::<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a></td></tr>
<tr class="separator:a4d7fa5de5e1528a3604179b6cf77fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4faf58dd9b066d6441241eabb705a83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a> = boost::iterator_range&lt; <a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a> &gt;</td></tr>
<tr class="separator:af4faf58dd9b066d6441241eabb705a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb4411cdf760ae46c8ab8bf9d8302af0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#acb4411cdf760ae46c8ab8bf9d8302af0">AffineConstraints</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:acb4411cdf760ae46c8ab8bf9d8302af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f06f06ad48b3702ad113dbd3b3b239"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a79f06f06ad48b3702ad113dbd3b3b239">AffineConstraints</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;affine_constraints)</td></tr>
<tr class="separator:a79f06f06ad48b3702ad113dbd3b3b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c78cf97489e08b600695bcf4be344c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a24c78cf97489e08b600695bcf4be344c">AffineConstraints</a> (<a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&amp;affine_constraints) noexcept=default</td></tr>
<tr class="separator:a24c78cf97489e08b600695bcf4be344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b122faa76a4751d264297edb1378105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a9b122faa76a4751d264297edb1378105">operator=</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;)=delete</td></tr>
<tr class="separator:a9b122faa76a4751d264297edb1378105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa04cae92177cb45de585bf60e23fffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#afa04cae92177cb45de585bf60e23fffa">operator=</a> (<a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&amp;affine_constraints) noexcept=default</td></tr>
<tr class="separator:afa04cae92177cb45de585bf60e23fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15d04ef931b4ff581b9a4b3d7b5123e"><td class="memTemplParams" colspan="2">template&lt;typename other_number &gt; </td></tr>
<tr class="memitem:ac15d04ef931b4ff581b9a4b3d7b5123e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ac15d04ef931b4ff581b9a4b3d7b5123e">copy_from</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; other_number &gt; &amp;other)</td></tr>
<tr class="separator:ac15d04ef931b4ff581b9a4b3d7b5123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9d71b5b7e8851c25a411ccf34de986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:a2c9d71b5b7e8851c25a411ccf34de986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6a8d1dce68c51bc15b73e20bae58b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1f6a8d1dce68c51bc15b73e20bae58b2">can_store_line</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:a1f6a8d1dce68c51bc15b73e20bae58b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a204d1c0a0fdc63c293d102c0adedd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3a204d1c0a0fdc63c293d102c0adedd1">get_local_lines</a> () const</td></tr>
<tr class="separator:a3a204d1c0a0fdc63c293d102c0adedd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2dae8cbd98611a6cfbbe7c0281abcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1a2dae8cbd98611a6cfbbe7c0281abcb">add_selected_constraints</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;constraints_in, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;filter)</td></tr>
<tr class="separator:a1a2dae8cbd98611a6cfbbe7c0281abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a1ba50f17085960874c157595622f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a06a1ba50f17085960874c157595622f1">get_lines</a> () const</td></tr>
<tr class="separator:a06a1ba50f17085960874c157595622f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0731c5473a236cc0f3b140dc100b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5a0731c5473a236cc0f3b140dc100b87">is_consistent_in_parallel</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_dofs, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_active_dofs, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const <a class="el" href="classbool.html">bool</a> verbose=false) const</td></tr>
<tr class="separator:a5a0731c5473a236cc0f3b140dc100b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d347f2da63fbe1074c571df9f858486"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2d347f2da63fbe1074c571df9f858486">make_consistent_in_parallel</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_dofs, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_relevant_dofs, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator)</td></tr>
<tr class="separator:a2d347f2da63fbe1074c571df9f858486"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c0c30c7df7d5e18f17b774ef34bb1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga17c0c30c7df7d5e18f17b774ef34bb1b">DeclException0</a> (ExcMatrixIsClosed)</td></tr>
<tr class="separator:ga17c0c30c7df7d5e18f17b774ef34bb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf30c5210b44c14dd1dcc7450b712a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3cf30c5210b44c14dd1dcc7450b712a5">DeclException0</a> (ExcMatrixNotClosed)</td></tr>
<tr class="separator:ga3cf30c5210b44c14dd1dcc7450b712a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05a2687457c11675a0f7e98e42e272d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab05a2687457c11675a0f7e98e42e272d">DeclException1</a> (ExcLineInexistant, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;The specified line &quot;&lt;&lt; arg1&lt;&lt; &quot; does not exist.&quot;)</td></tr>
<tr class="separator:gab05a2687457c11675a0f7e98e42e272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e5a7989a1a22bdd50bc0a8a87b255e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf3e5a7989a1a22bdd50bc0a8a87b255e">DeclException4</a> (ExcEntryAlreadyExists, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number, number,&lt;&lt; &quot;The entry for the indices &quot;&lt;&lt; arg1&lt;&lt; &quot; and &quot;&lt;&lt; arg2&lt;&lt; &quot; already exists, but the values &quot;&lt;&lt; arg3&lt;&lt; &quot; (old) and &quot;&lt;&lt; arg4&lt;&lt; &quot; (new) differ &quot;&lt;&lt; &quot;by &quot;&lt;&lt;(arg4 - arg3)&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gaf3e5a7989a1a22bdd50bc0a8a87b255e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25908b905ef11ec9bcc0d2d867abfcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa25908b905ef11ec9bcc0d2d867abfcb">DeclException2</a> (ExcDoFConstrainedToConstrainedDoF, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to constrain DoF &quot;&lt;&lt; arg1&lt;&lt; &quot; to DoF &quot;&lt;&lt; arg2&lt;&lt; &quot;, but that one is also constrained. This is not allowed!&quot;)</td></tr>
<tr class="separator:gaa25908b905ef11ec9bcc0d2d867abfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae728e5ae4ae67d584aec813d6026de6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaae728e5ae4ae67d584aec813d6026de6">DeclException1</a> (ExcDoFIsConstrainedFromBothObjects, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;Degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; is constrained from both object in a <a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">merge</a> operation.&quot;)</td></tr>
<tr class="separator:gaae728e5ae4ae67d584aec813d6026de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a6f75ca0e092c363b8c5d61c926a2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga83a6f75ca0e092c363b8c5d61c926a2f">DeclException1</a> (ExcDoFIsConstrainedToConstrainedDoF, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;In the given argument a degree of freedom is constrained &quot;&lt;&lt; &quot;to another DoF with number &quot;&lt;&lt; arg1&lt;&lt; &quot;, which however is constrained by this object. This is not&quot;&lt;&lt; &quot; allowed.&quot;)</td></tr>
<tr class="separator:ga83a6f75ca0e092c363b8c5d61c926a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719b3201d8af13663513789d2c73d9ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga719b3201d8af13663513789d2c73d9ef">DeclException1</a> (ExcRowNotStoredHere, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;The index set given to this constraints object indicates &quot;&lt;&lt; &quot;constraints for degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; should not be stored by this object, but a constraint &quot;&lt;&lt; &quot;is being added.&quot;)</td></tr>
<tr class="separator:ga719b3201d8af13663513789d2c73d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7840b50b20f084634c57a984e0018e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad7840b50b20f084634c57a984e0018e6">DeclException2</a> (ExcColumnNotStoredHere, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;The index set given to this constraints object indicates &quot;&lt;&lt; &quot;constraints using degree of freedom &quot;&lt;&lt; arg2&lt;&lt; &quot; should not be stored by this object, but a constraint &quot;&lt;&lt; &quot;for degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; uses it.&quot;)</td></tr>
<tr class="separator:gad7840b50b20f084634c57a984e0018e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5a4db5283a662e07ab49e965086302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacc5a4db5283a662e07ab49e965086302">DeclException2</a> (ExcIncorrectConstraint, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;While distributing the constraint for DoF &quot;&lt;&lt; arg1&lt;&lt; &quot;, it turns out that one of the processors &quot;&lt;&lt; &quot;who own the &quot;&lt;&lt; arg2&lt;&lt; &quot; degrees of freedom that x_&quot;&lt;&lt; arg1&lt;&lt; &quot; is constrained against does not know about &quot;&lt;&lt; &quot;the constraint on x_&quot;&lt;&lt; arg1&lt;&lt; &quot;. Did you not initialize the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container &quot;&lt;&lt; &quot;with the appropriate locally_relevant set so &quot;&lt;&lt; &quot;that every processor who owns a DoF that constrains &quot;&lt;&lt; &quot;another DoF also knows about this constraint?&quot;)</td></tr>
<tr class="separator:gacc5a4db5283a662e07ab49e965086302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Adding constraints</div></td></tr>
<tr class="memitem:a11139b28db021be1d2b762c3c5275ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n)</td></tr>
<tr class="separator:a11139b28db021be1d2b762c3c5275ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef97b22281acb10c914d79a3881e2735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a>)</td></tr>
<tr class="separator:aef97b22281acb10c914d79a3881e2735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c8f2e42dcd9712d5ed677522bc0886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a79c8f2e42dcd9712d5ed677522bc0886">add_lines</a> (const std::set&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;<a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a>)</td></tr>
<tr class="separator:a79c8f2e42dcd9712d5ed677522bc0886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbaf061c6ba46e75e7c820261d7c10d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7bbaf061c6ba46e75e7c820261d7c10d">add_lines</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a>)</td></tr>
<tr class="separator:a7bbaf061c6ba46e75e7c820261d7c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7756e9cb8e53553211add5426f8e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> constrained_dof_index, const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> column, const number weight)</td></tr>
<tr class="separator:a2b7756e9cb8e53553211add5426f8e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc26fc668c50df9ea54b23222ae21a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#afc26fc668c50df9ea54b23222ae21a43">add_entries</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> constrained_dof_index, const std::vector&lt; std::pair&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number &gt;&gt; &amp;col_weight_pairs)</td></tr>
<tr class="separator:afc26fc668c50df9ea54b23222ae21a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7cb22b3c971599a839fddc988ef92a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> constrained_dof_index, const number value)</td></tr>
<tr class="separator:a4f7cb22b3c971599a839fddc988ef92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611aa37f754086388ca76bcd421cce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a> ()</td></tr>
<tr class="separator:a1611aa37f754086388ca76bcd421cce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d267ebb328a639eb9f3d68b1fa7ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">merge</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;other_constraints, const <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">MergeConflictBehavior</a> merge_conflict_behavior=<a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b">no_conflicts_allowed</a>, const <a class="el" href="classbool.html">bool</a> allow_different_local_lines=false)</td></tr>
<tr class="separator:a09d267ebb328a639eb9f3d68b1fa7ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc850833411818832f3dbadcdf48878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3bc850833411818832f3dbadcdf48878">shift</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> offset)</td></tr>
<tr class="separator:a3bc850833411818832f3dbadcdf48878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd15bc409c61d6f795f0132c574335b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a> ()</td></tr>
<tr class="separator:addd15bc409c61d6f795f0132c574335b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Querying constraints</div></td></tr>
<tr class="memitem:adf261da8033116444de6140403ba8c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">n_constraints</a> () const</td></tr>
<tr class="separator:adf261da8033116444de6140403ba8c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885d18f0044979873f5e5a6f33772f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:a885d18f0044979873f5e5a6f33772f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add769bef2c387002067d10b91328713e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#add769bef2c387002067d10b91328713e">is_identity_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:add769bef2c387002067d10b91328713e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96cda3efc1d336fb9b4956c8850935e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#af96cda3efc1d336fb9b4956c8850935e">are_identity_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n_1, const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n_2) const</td></tr>
<tr class="separator:af96cda3efc1d336fb9b4956c8850935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d307372bffb6cca4f51bc22b022de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a652d307372bffb6cca4f51bc22b022de">max_constraint_indirections</a> () const</td></tr>
<tr class="separator:a652d307372bffb6cca4f51bc22b022de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd58352f9d4a1166700b1a5c77e92a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abd58352f9d4a1166700b1a5c77e92a47">is_inhomogeneously_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> index) const</td></tr>
<tr class="separator:abd58352f9d4a1166700b1a5c77e92a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df947a828e8496cd04087c58b382da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a0df947a828e8496cd04087c58b382da5">has_inhomogeneities</a> () const</td></tr>
<tr class="separator:a0df947a828e8496cd04087c58b382da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34f8862c8278d995ad710efed1968de"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ab34f8862c8278d995ad710efed1968de">get_constraint_entries</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:ab34f8862c8278d995ad710efed1968de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101608954771e72318e1c8b226b7f76"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3101608954771e72318e1c8b226b7f76">get_inhomogeneity</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:a3101608954771e72318e1c8b226b7f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa145ec19c37c410ddb0fb75e165f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#adfaa145ec19c37c410ddb0fb75e165f4">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:adfaa145ec19c37c410ddb0fb75e165f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0287e2e3a5e227a3cac057d562a76d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ae0287e2e3a5e227a3cac057d562a76d8">write_dot</a> (std::ostream &amp;) const</td></tr>
<tr class="separator:ae0287e2e3a5e227a3cac057d562a76d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418e2721b2f0be9d5ac15babb407e9ac"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a418e2721b2f0be9d5ac15babb407e9ac">memory_consumption</a> () const</td></tr>
<tr class="separator:a418e2721b2f0be9d5ac15babb407e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817248b703e20879fbb882df84624440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a817248b703e20879fbb882df84624440">resolve_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices) const</td></tr>
<tr class="separator:a817248b703e20879fbb882df84624440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Eliminating constraints from linear systems after their creation</div></td></tr>
<tr class="memitem:a5a1bc1bb2d705b582889ebaa24bcae5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a5a1bc1bb2d705b582889ebaa24bcae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5303dc0789fe9b28de60dbe5c3629036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5303dc0789fe9b28de60dbe5c3629036">condense</a> (<a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a5303dc0789fe9b28de60dbe5c3629036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c79541d43e875ca86d7836f6057467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a07c79541d43e875ca86d7836f6057467">condense</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a07c79541d43e875ca86d7836f6057467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bc269b7ebd57503702a14fd78b086e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a95bc269b7ebd57503702a14fd78b086e">condense</a> (<a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a95bc269b7ebd57503702a14fd78b086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d54e78514f760904ec66ac29347884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ab8d54e78514f760904ec66ac29347884">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix) const</td></tr>
<tr class="separator:ab8d54e78514f760904ec66ac29347884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6fd43d2284bb6966a748715c7da1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7d6fd43d2284bb6966a748715c7da1f8">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix) const</td></tr>
<tr class="separator:a7d6fd43d2284bb6966a748715c7da1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7a3c4193fa4a023e03311e2ab79d3a"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a1e7a3c4193fa4a023e03311e2ab79d3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1e7a3c4193fa4a023e03311e2ab79d3a">condense</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const</td></tr>
<tr class="separator:a1e7a3c4193fa4a023e03311e2ab79d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeca4e481ca38a9324b239d40368d0f"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:abfeca4e481ca38a9324b239d40368d0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abfeca4e481ca38a9324b239d40368d0f">condense</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_ghosted, <a class="el" href="classVectorType.html">VectorType</a> &amp;output) const</td></tr>
<tr class="separator:abfeca4e481ca38a9324b239d40368d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e549d0c1ab15484f3d0626f5702b101"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a4e549d0c1ab15484f3d0626f5702b101"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a4e549d0c1ab15484f3d0626f5702b101">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector) const</td></tr>
<tr class="separator:a4e549d0c1ab15484f3d0626f5702b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a6bf400e74098f552c5121975a2d62"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:ad1a6bf400e74098f552c5121975a2d62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ad1a6bf400e74098f552c5121975a2d62">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, BlockVectorType &amp;vector) const</td></tr>
<tr class="separator:ad1a6bf400e74098f552c5121975a2d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f75876b5982cfa4334737e5439c39"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:ae82f75876b5982cfa4334737e5439c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const</td></tr>
<tr class="separator:ae82f75876b5982cfa4334737e5439c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Eliminating constraints from linear systems during their creation</div></td></tr>
<tr class="memitem:a373fbdacd8c486e675b8d2bff8943192"><td class="memTemplParams" colspan="2">template&lt;class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a373fbdacd8c486e675b8d2bff8943192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a> (const InVector &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</td></tr>
<tr class="separator:a373fbdacd8c486e675b8d2bff8943192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ed5ba9f1be9c34cf448a01b44abdb"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ae02ed5ba9f1be9c34cf448a01b44abdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ae02ed5ba9f1be9c34cf448a01b44abdb">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix) const</td></tr>
<tr class="separator:ae02ed5ba9f1be9c34cf448a01b44abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bbabbcd04192f03c00c7f4de08936b"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a48bbabbcd04192f03c00c7f4de08936b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a48bbabbcd04192f03c00c7f4de08936b">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices_row, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices_col, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, <a class="el" href="classbool.html">bool</a> diagonal=false) const</td></tr>
<tr class="separator:a48bbabbcd04192f03c00c7f4de08936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a0ad68d6c50329b31bd9ac418afb92"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a64a0ad68d6c50329b31bd9ac418afb92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a64a0ad68d6c50329b31bd9ac418afb92">distribute_local_to_global</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> index, const number value, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector) const</td></tr>
<tr class="separator:a64a0ad68d6c50329b31bd9ac418afb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e96f9d525befecd233f7ee3aa9017b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a07e96f9d525befecd233f7ee3aa9017b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a07e96f9d525befecd233f7ee3aa9017b">distribute_local_to_global</a> (ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end, ForwardIteratorInd local_indices_begin, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector) const</td></tr>
<tr class="separator:a07e96f9d525befecd233f7ee3aa9017b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a309cb9efd4b64ef5c3dda5825841f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a96a309cb9efd4b64ef5c3dda5825841f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a96a309cb9efd4b64ef5c3dda5825841f">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:a96a309cb9efd4b64ef5c3dda5825841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50363f9e0a6964a67abef37c312de460"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a50363f9e0a6964a67abef37c312de460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a50363f9e0a6964a67abef37c312de460">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;col_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:a50363f9e0a6964a67abef37c312de460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0236bb1541ec3669e3183d602b0cd9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:aed0236bb1541ec3669e3183d602b0cd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#aed0236bb1541ec3669e3183d602b0cd9">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;row_indices, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;column_affine_constraints, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;column_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:aed0236bb1541ec3669e3183d602b0cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe83a7964b516856f5acb8046ec63a15"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:abe83a7964b516856f5acb8046ec63a15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abe83a7964b516856f5acb8046ec63a15">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs=false) const</td></tr>
<tr class="separator:abe83a7964b516856f5acb8046ec63a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210f57f792afd7f51c72c546f22e298"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ad210f57f792afd7f51c72c546f22e298"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ad210f57f792afd7f51c72c546f22e298">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask=<a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;()) const</td></tr>
<tr class="separator:ad210f57f792afd7f51c72c546f22e298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c254531d58bc731db5ab76614d5cf64"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a5c254531d58bc731db5ab76614d5cf64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5c254531d58bc731db5ab76614d5cf64">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;col_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask=<a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;()) const</td></tr>
<tr class="separator:a5c254531d58bc731db5ab76614d5cf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36af074aba017e9f64ed9bc88277f4e5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a36af074aba017e9f64ed9bc88277f4e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a36af074aba017e9f64ed9bc88277f4e5">get_dof_values</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, ForwardIteratorInd local_indices_begin, ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end) const</td></tr>
<tr class="separator:a36af074aba017e9f64ed9bc88277f4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dealing with constraints after solving a linear system</div></td></tr>
<tr class="memitem:a7b3d3f295bb56d6cd6856bdc6cbe8a01"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a7b3d3f295bb56d6cd6856bdc6cbe8a01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const</td></tr>
<tr class="separator:a7b3d3f295bb56d6cd6856bdc6cbe8a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab460dcccef711e63c552742ff25a9d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ab460dcccef711e63c552742ff25a9d83">calculate_line_index</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:ab460dcccef711e63c552742ff25a9d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5501b648839b47b9696e4ae3ced90c4f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a5501b648839b47b9696e4ae3ced90c4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5501b648839b47b9696e4ae3ced90c4f">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;) const</td></tr>
<tr class="separator:a5501b648839b47b9696e4ae3ced90c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176db170b657f6f85cb7e3a33c06e50a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a176db170b657f6f85cb7e3a33c06e50a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a176db170b657f6f85cb7e3a33c06e50a">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;) const</td></tr>
<tr class="separator:a176db170b657f6f85cb7e3a33c06e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f690dd91f1b86c24562816b7266d7"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a678f690dd91f1b86c24562816b7266d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a678f690dd91f1b86c24562816b7266d7">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;) const</td></tr>
<tr class="separator:a678f690dd91f1b86c24562816b7266d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc807a273811f36138a6a7ed06762290"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:abc807a273811f36138a6a7ed06762290"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abc807a273811f36138a6a7ed06762290">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;) const</td></tr>
<tr class="separator:abc807a273811f36138a6a7ed06762290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a02d1c13ace7c8c81fe2b009f07aa48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3a02d1c13ace7c8c81fe2b009f07aa48">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, internal::AffineConstraints::GlobalRowsFromLocal&lt; number &gt; &amp;global_rows) const</td></tr>
<tr class="separator:a3a02d1c13ace7c8c81fe2b009f07aa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2b86a60e91f5f025a1546fd20e1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a34e2b86a60e91f5f025a1546fd20e1d6">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;active_dofs) const</td></tr>
<tr class="separator:a34e2b86a60e91f5f025a1546fd20e1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd07a6eacda75be75489a340f4efe51"><td class="memTemplParams" colspan="2">template&lt;typename MatrixScalar , typename VectorScalar &gt; </td></tr>
<tr class="memitem:affd07a6eacda75be75489a340f4efe51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structProductType.html">ProductType</a>&lt; VectorScalar, MatrixScalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#affd07a6eacda75be75489a340f4efe51">resolve_vector_entry</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> i, const internal::AffineConstraints::GlobalRowsFromLocal&lt; number &gt; &amp;global_rows, const <a class="el" href="classVector.html">Vector</a>&lt; VectorScalar &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; MatrixScalar &gt; &amp;local_matrix) const</td></tr>
<tr class="separator:affd07a6eacda75be75489a340f4efe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a87186b21ab5f5cb1e4635d4601ee3f05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a></td></tr>
<tr class="separator:a87186b21ab5f5cb1e4635d4601ee3f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a78094a8ee36dc8f1af979958ecf05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ac4a78094a8ee36dc8f1af979958ecf05">lines_cache</a></td></tr>
<tr class="separator:ac4a78094a8ee36dc8f1af979958ecf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5ecc66d3618beb896dc162462ae836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7d5ecc66d3618beb896dc162462ae836">local_lines</a></td></tr>
<tr class="separator:a7d5ecc66d3618beb896dc162462ae836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cacb6fdc27f68b1db0766faff484604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2cacb6fdc27f68b1db0766faff484604">sorted</a></td></tr>
<tr class="separator:a2cacb6fdc27f68b1db0766faff484604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd838dee6db05afec001e52e414f95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; internal::AffineConstraints::ScratchData&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a25dd838dee6db05afec001e52e414f95">scratch_data</a></td></tr>
<tr class="separator:a25dd838dee6db05afec001e52e414f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2684c21b09cec978c64ebf43e75a4fcc"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a2684c21b09cec978c64ebf43e75a4fcc"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2684c21b09cec978c64ebf43e75a4fcc">AffineConstraints</a></td></tr>
<tr class="separator:a2684c21b09cec978c64ebf43e75a4fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number = double&gt;<br />
class AffineConstraints&lt; number &gt;</h3>

<p>This class implements dealing with linear (possibly inhomogeneous) constraints on degrees of freedom. The concept and origin of such constraints is extensively described in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module. The class is meant to deal with a limited number of constraints relative to the total number of degrees of freedom, for example a few per cent up to maybe 30 per cent; and with a linear combination of <em>M</em> other degrees of freedom where <em>M</em> is also relatively small (no larger than at most around the average number of entries per row of a linear system). It is <em>not</em> meant to describe full rank linear systems.</p>
<p>The algorithms used in the implementation of this class are described in some detail in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a>. There is also a significant amount of documentation on how to use this class in the <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<h3>Description of constraints</h3>
<p>Each "line" in objects of this class corresponds to one constrained degree of freedom, with the number of the line being <em>i</em>, entered by using <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> or <a class="el" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines()</a>. The entries in this line are pairs of the form (<em>j</em>,<em>a<sub>ij</sub></em>), which are added by <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry()</a> or <a class="el" href="classAffineConstraints.html#afc26fc668c50df9ea54b23222ae21a43">add_entries()</a>. The organization is essentially a <a class="el" href="classSparsityPattern.html">SparsityPattern</a>, but with only a few lines containing nonzero elements, and therefore no data wasted on the others. For each line, which has been added by the mechanism above, an elimination of the constrained degree of freedom of the form </p><p class="formulaDsp">
\[ x_i = \sum_j a_{ij} x_j + b_i \]
</p>
<p> is performed, where <em>b<sub>i</sub></em> is optional and set by <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity()</a>. Thus, if a constraint is formulated for instance as a zero mean value of several degrees of freedom, one of the degrees has to be chosen to be eliminated.</p>
<p>Note that the constraints are linear in the <em>x<sub>i</sub></em>, and that there might be a constant (non-homogeneous) term in the constraint. This is exactly the form we need for hanging node constraints, where we need to constrain one degree of freedom in terms of others. There are other conditions of this form possible, for example for implementing mean value conditions as is done in the step-11 tutorial program. The name of the class stems from the fact that these constraints can be represented in matrix form as <b>X</b> <em>x</em> = <em>b</em>, and this object then describes the matrix <b>X</b> and the vector <em>b</em>. The most frequent way to create/fill objects of this type is using the <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints()</a> function. The use of these objects is first explained in step-6.</p>
<p>Objects of the present type are organized in lines (rows), but only those lines are stored where constraints are present. New constraints are added by adding new lines using the <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function, and then populating it using the <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry()</a> function to a given line, or <a class="el" href="classAffineConstraints.html#afc26fc668c50df9ea54b23222ae21a43">add_entries()</a> to add more than one entry at a time. The right hand side element, if nonzero, can be set using the <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity()</a> function. After all constraints have been added, you need to call <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a>, which compresses the storage format and sorts the entries.</p>
<dl class="section note"><dt>Note</dt><dd>Many of the algorithms this class implements are discussed in the <a class="el" href="DEALGlossary.html#hp_paper">hp_paper</a>. The algorithms are also related to those shown in <em>M. S. Shephard: Linear multipoint constraints applied via transformation as part of a direct stiffness assembly process. Int. J. Numer. Meth. Engrg., vol. 20 (1984), pp. 2107-2112.</em>, with the difference that the algorithms shown there completely eliminated constrained degrees of freedom, whereas we usually keep them as part of the linear system. </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l00506">506</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0a7ce3525c69e7b5bba3a0dd03f0dead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7ce3525c69e7b5bba3a0dd03f0dead">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare the type for container size. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l00512">512</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a4d7fa5de5e1528a3604179b6cf77fda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7fa5de5e1528a3604179b6cf77fda2">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a> =  typename std::vector&lt;<a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a>&gt;::<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the iterator type that is used in the LineRange container. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01662">1662</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="af4faf58dd9b066d6441241eabb705a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4faf58dd9b066d6441241eabb705a83">&#9670;&nbsp;</a></span>LineRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a> =  boost::iterator_range&lt;<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Alias for the return type used by <a class="el" href="classAffineConstraints.html#a06a1ba50f17085960874c157595622f1">get_lines()</a>. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01667">1667</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3b54f13f985552be5a78ac928258daed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b54f13f985552be5a78ac928258daed">&#9670;&nbsp;</a></span>MergeConflictBehavior</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">AffineConstraints::MergeConflictBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An enum that describes what should happen if the two <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects involved in a call to the <a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">merge()</a> function happen to have constraints on the same degrees of freedom. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b"></a>no_conflicts_allowed&#160;</td><td class="fielddoc"><p>Throw an exception if the two objects concerned have conflicting constraints on the same degree of freedom. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b54f13f985552be5a78ac928258daedaced33eb2366bc959ac3f7403a83c8947"></a>left_object_wins&#160;</td><td class="fielddoc"><p>In an operation <code>cm1.merge(cm2)</code>, if <code>cm1</code> and <code>cm2</code> have constraints on the same degree of freedom, take the one from <code>cm1</code>. </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b54f13f985552be5a78ac928258daedad0ade894fba0235316b96337fdec9af2"></a>right_object_wins&#160;</td><td class="fielddoc"><p>In an operation <code>cm1.merge(cm2)</code>, if <code>cm1</code> and <code>cm2</code> have constraints on the same degree of freedom, take the one from <code>cm2</code>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l00519">519</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb4411cdf760ae46c8ab8bf9d8302af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4411cdf760ae46c8ab8bf9d8302af0">&#9670;&nbsp;</a></span>AffineConstraints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html">AffineConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. The supplied <a class="el" href="classIndexSet.html">IndexSet</a> defines which indices might be constrained inside this <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container. In a calculation with a <a class="el" href="classDoFHandler.html">DoFHandler</a> object based on <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> or <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>, one should use the set of locally relevant dofs (see <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">GlossLocallyRelevantDof</a>).</p>
<p>The given <a class="el" href="classIndexSet.html">IndexSet</a> allows the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container to save memory by just not caring about degrees of freedom that are not of importance to the current processor. Alternatively, if no such <a class="el" href="classIndexSet.html">IndexSet</a> is provided, internal data structures for <em>all</em> possible indices will be created, leading to memory consumption on every processor that is proportional to the <em>overall</em> size of the problem, not just proportional to the size of the portion of the overall problem that is handled by the current processor. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01996">1996</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a79f06f06ad48b3702ad113dbd3b3b239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f06f06ad48b3702ad113dbd3b3b239">&#9670;&nbsp;</a></span>AffineConstraints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html">AffineConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>affine_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02009">2009</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a24c78cf97489e08b600695bcf4be344c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c78cf97489e08b600695bcf4be344c">&#9670;&nbsp;</a></span>AffineConstraints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html">AffineConstraints</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>affine_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b122faa76a4751d264297edb1378105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b122faa76a4751d264297edb1378105">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&amp; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator. Like for many other large objects, this operator is deleted to avoid its inadvertent use in places such as accidentally declaring a <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a></code> object as a function argument by value, rather than by reference.</p>
<p>However, you can use the <a class="el" href="classAffineConstraints.html#ac15d04ef931b4ff581b9a4b3d7b5123e">copy_from()</a> function to explicitly copy <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects. </p>

</div>
</div>
<a id="afa04cae92177cb45de585bf60e23fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa04cae92177cb45de585bf60e23fffa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&amp; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>affine_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move assignment operator </p>

</div>
</div>
<a id="ac15d04ef931b4ff581b9a4b3d7b5123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15d04ef931b4ff581b9a4b3d7b5123e">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename other_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; other_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy the given object to the current one.</p>
<p>This function exists because <code><a class="el" href="classAffineConstraints.html#a9b122faa76a4751d264297edb1378105">operator=()</a></code> is explicitly disabled. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02435">2435</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a2c9d71b5b7e8851c25a411ccf34de986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9d71b5b7e8851c25a411ccf34de986">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear()</a> the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object and supply an <a class="el" href="classIndexSet.html">IndexSet</a> with lines that may be constrained. This function is only relevant in the distributed case to supply a different <a class="el" href="classIndexSet.html">IndexSet</a>. Otherwise this routine is equivalent to calling <a class="el" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear()</a>. See the constructor for details. </p>

</div>
</div>
<a id="a1f6a8d1dce68c51bc15b73e20bae58b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6a8d1dce68c51bc15b73e20bae58b2">&#9670;&nbsp;</a></span>can_store_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::can_store_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determines if we can store a constraint for the given <code>line_n</code>. This routine only matters in the distributed case and checks if the <a class="el" href="classIndexSet.html">IndexSet</a> allows storage of this line. Always returns true if not in the distributed case. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02200">2200</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a3a204d1c0a0fdc63c293d102c0adedd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a204d1c0a0fdc63c293d102c0adedd1">&#9670;&nbsp;</a></span>get_local_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_local_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the index set describing locally relevant lines if any are present. Note that if no local lines were given, this represents an empty <a class="el" href="classIndexSet.html">IndexSet</a>, whereas otherwise it contains the global problem size and the local range. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02207">2207</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a1a2dae8cbd98611a6cfbbe7c0281abcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2dae8cbd98611a6cfbbe7c0281abcb">&#9670;&nbsp;</a></span>add_selected_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_selected_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function copies the content of <code>constraints_in</code> with DoFs that are element of the <a class="el" href="classIndexSet.html">IndexSet</a> <code>filter</code>. Elements that are not present in the <a class="el" href="classIndexSet.html">IndexSet</a> are ignored. All DoFs will be transformed to local index space of the filter, both the constrained DoFs and the other DoFs these entries are constrained to. The local index space of the filter is a contiguous numbering of all (global) DoFs that are elements in the filter.</p>
<p>If, for example, the filter represents the range <code>[10,20)</code>, and the constraints object <code>constraints_in</code> includes the global indices <code>{7,13,14}</code>, the indices <code>{3,4}</code> are added to the calling constraints object (since 13 and 14 are elements in the filter and element 13 is the fourth element in the index, and 14 is the fifth).</p>
<p>This function provides an easy way to create a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> for certain vector components in a vector-valued problem from a full <a class="el" href="classAffineConstraints.html">AffineConstraints</a>, i.e. extracting a diagonal subblock from a larger <a class="el" href="classAffineConstraints.html">AffineConstraints</a>. The block is specified by the <a class="el" href="classIndexSet.html">IndexSet</a> argument. </p>

</div>
</div>
<a id="a11139b28db021be1d2b762c3c5275ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11139b28db021be1d2b762c3c5275ee4">&#9670;&nbsp;</a></span>add_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a new line to the matrix. If the line already exists, then the function simply returns without doing anything. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02020">2020</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="aef97b22281acb10c914d79a3881e2735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef97b22281acb10c914d79a3881e2735">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function for every index <code>i</code> for which <code>lines[i]</code> is true.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single- argument <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity()</a>. </p>

</div>
</div>
<a id="a79c8f2e42dcd9712d5ed677522bc0886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c8f2e42dcd9712d5ed677522bc0886">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function for every index <code>i</code> that appears in the argument.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single- argument <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity()</a>. </p>

</div>
</div>
<a id="a7bbaf061c6ba46e75e7c820261d7c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbaf061c6ba46e75e7c820261d7c10d">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_lines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the first <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function for every index <code>i</code> that appears in the argument.</p>
<p>This function essentially exists to allow adding several constraints of the form <em>x<sub>i</sub></em>=0 all at once, where the set of indices <em>i</em> for which these constraints should be added are given by the argument of this function. On the other hand, just as if the single- argument <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function were called repeatedly, the constraints can later be modified to include linear dependencies using the <a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry()</a> function as well as inhomogeneities using <a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity()</a>. </p>

</div>
</div>
<a id="a2b7756e9cb8e53553211add5426f8e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7756e9cb8e53553211add5426f8e50">&#9670;&nbsp;</a></span>add_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>constrained_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add an entry to a given line. In other words, this function adds a term \(a_{ij} x_j\) to the constraints for the \(i\)th degree of freedom.</p>
<p>If an entry with the same indices as the one this function call denotes already exists, then this function simply returns provided that the value of the entry is the same. Thus, it does no harm to enter a constraint twice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constrained_dof_index</td><td>The index \(i\) of the degree of freedom that is being constrained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>The index \(j\) of the degree of freedom being entered into the constraint for degree of freedom \(i\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">weight</td><td>The factor \(a_{ij}\) that multiplies \(x_j\). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02052">2052</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="afc26fc668c50df9ea54b23222ae21a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc26fc668c50df9ea54b23222ae21a43">&#9670;&nbsp;</a></span>add_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>constrained_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>col_weight_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a whole series of entries, denoted by pairs of column indices and weight values, to a line of constraints. This function is equivalent to calling the preceding function several times, but is faster. </p>

</div>
</div>
<a id="a4f7cb22b3c971599a839fddc988ef92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7cb22b3c971599a839fddc988ef92a">&#9670;&nbsp;</a></span>set_inhomogeneity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::set_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>constrained_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set an inhomogeneity to the constraint for a degree of freedom. In other words, it adds a constant \(b_i\) to the constraint for degree of freedom \(i\). For this to work, you need to call <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> first for the given degree of freedom.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constrained_dof_index</td><td>The index \(i\) of the degree of freedom that is being constrained. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">value</td><td>The right hand side value \(b_i\) for the constraint on the degree of freedom \(i\). </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02094">2094</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a1611aa37f754086388ca76bcd421cce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611aa37f754086388ca76bcd421cce5">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the filling of entries. Since the lines of a matrix of this type are usually filled in an arbitrary order and since we do not want to use associative constrainers to store the lines, we need to sort the lines and within the lines the columns before usage of the matrix. This is done through this function.</p>
<p>Also, zero entries are discarded, since they are not needed.</p>
<p>After closing, no more entries are accepted. If the object was already closed, then this function returns immediately.</p>
<p>This function also resolves chains of constraints. For example, degree of freedom 13 may be constrained to \(u_{13} = \frac{u_3}{2} + \frac{u_7}{2}\) while degree of freedom 7 is itself constrained as \(u_{7} = \frac{u_2}{2} + \frac{u_4}{2}\). Then, the resolution will be that \(u_{13} = \frac{u_3}{2} + \frac{u_2}{4} + \frac{u_4}{4}\). Note, however, that cycles in this graph of constraints are not allowed, i.e., for example \(u_4\) may not itself be constrained, directly or indirectly, to \(u_{13}\) again. </p>

</div>
</div>
<a id="a09d267ebb328a639eb9f3d68b1fa7ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d267ebb328a639eb9f3d68b1fa7ffb">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">MergeConflictBehavior</a>&#160;</td>
          <td class="paramname"><em>merge_conflict_behavior</em> = <code><a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b">no_conflicts_allowed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_different_local_lines</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the constraints represented by the object given as argument into the constraints represented by this object. Both objects may or may not be closed (by having their function <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a> called before). If this object was closed before, then it will be closed afterwards as well. Note, however, that if the other argument is closed, then merging may be significantly faster.</p>
<p>Using the default value of the second arguments, the constraints in each of the two objects (the old one represented by this object and the argument) may not refer to the same degree of freedom, i.e. a degree of freedom that is constrained in one object may not be constrained in the second. If this is nevertheless the case, an exception is thrown. However, this behavior can be changed by providing a different value for the second argument.</p>
<p>By default, merging two <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects that are initialized with different <a class="el" href="classIndexSet.html">IndexSet</a> objects is not allowed. This behavior can be altered by setting <code>allow_different_local_lines</code> appropriately.</p>
<p>Merging a <a class="el" href="classAffineConstraints.html">AffineConstraints</a> that is initialized with an <a class="el" href="classIndexSet.html">IndexSet</a> and one that is not initialized with an <a class="el" href="classIndexSet.html">IndexSet</a> is not yet implemented. </p>

</div>
</div>
<a id="a3bc850833411818832f3dbadcdf48878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc850833411818832f3dbadcdf48878">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Shift all entries of this matrix down <code>offset</code> rows and over <code>offset</code> columns. If this object is initialized with an <a class="el" href="classIndexSet.html">IndexSet</a>, local_lines are shifted as well.</p>
<p>This function is useful if you are building block matrices, where all blocks are built by the same <a class="el" href="classDoFHandler.html">DoFHandler</a> object, i.e. the matrix size is larger than the number of degrees of freedom. Since several matrix rows and columns correspond to the same degrees of freedom, you'd generate several constraint objects, then shift them, and finally <a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">merge()</a> them together again. </p>

</div>
</div>
<a id="addd15bc409c61d6f795f0132c574335b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd15bc409c61d6f795f0132c574335b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear all entries of this matrix. Reset the flag determining whether new entries are accepted or not.</p>
<p>This function may be called also on objects which are empty or already cleared. </p>

</div>
</div>
<a id="adf261da8033116444de6140403ba8c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf261da8033116444de6140403ba8c3d">&#9670;&nbsp;</a></span>n_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::n_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return number of constraints stored in this matrix. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02125">2125</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a885d18f0044979873f5e5a6f33772f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885d18f0044979873f5e5a6f33772f73">&#9670;&nbsp;</a></span>is_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the degree of freedom with number <code>line_n</code> is a constrained one.</p>
<p>Note that if <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a> was called before, then this function is significantly faster, since then the constrained degrees of freedom are sorted and we can do a binary search, while before <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a> was called, we have to perform a linear search through all entries. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02132">2132</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="add769bef2c387002067d10b91328713e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add769bef2c387002067d10b91328713e">&#9670;&nbsp;</a></span>is_identity_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the dof is constrained, and whether it is constrained to only one other degree of freedom with weight one. The function therefore returns whether the degree of freedom would simply be eliminated in favor of exactly one other degree of freedom.</p>
<p>The function returns <code>false</code> if either the degree of freedom is not constrained at all, or if it is constrained to more than one other degree of freedom, or if it is constrained to only one degree of freedom but with a weight different from one. </p>

</div>
</div>
<a id="af96cda3efc1d336fb9b4956c8850935e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96cda3efc1d336fb9b4956c8850935e">&#9670;&nbsp;</a></span>are_identity_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::are_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the two given degrees of freedom are linked by an equality constraint that either constrains index1 to be so that <code>index1=index2</code> or constrains index2 so that <code>index2=index1</code>. </p>

</div>
</div>
<a id="a652d307372bffb6cca4f51bc22b022de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d307372bffb6cca4f51bc22b022de">&#9670;&nbsp;</a></span>max_constraint_indirections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::max_constraint_indirections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the maximum number of other dofs that one dof is constrained to. For example, in 2d a hanging node is constrained only to its two neighbors, so the returned value would be 2. However, for higher order elements and/or higher dimensions, or other types of constraints, this number is no more obvious.</p>
<p>The name indicates that within the system matrix, references to a constrained node are indirected to the nodes it is constrained to. </p>

</div>
</div>
<a id="abd58352f9d4a1166700b1a5c77e92a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd58352f9d4a1166700b1a5c77e92a47">&#9670;&nbsp;</a></span>is_inhomogeneously_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_inhomogeneously_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> in case the dof is constrained and there is a non- trivial inhomogeneous values set to the dof. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02141">2141</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a0df947a828e8496cd04087c58b382da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df947a828e8496cd04087c58b382da5">&#9670;&nbsp;</a></span>has_inhomogeneities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::has_inhomogeneities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>false</code> if all constraints in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> are homogeneous ones, and <code>true</code> if there is at least one inhomogeneity. </p>

</div>
</div>
<a id="ab34f8862c8278d995ad710efed1968de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34f8862c8278d995ad710efed1968de">&#9670;&nbsp;</a></span>get_constraint_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &gt; * <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_constraint_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a pointer to the vector of entries if a line is constrained, and a zero pointer in case the dof is not constrained. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02159">2159</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a3101608954771e72318e1c8b226b7f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3101608954771e72318e1c8b226b7f76">&#9670;&nbsp;</a></span>get_inhomogeneity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value of the inhomogeneity stored in the constrained dof <code>line_n</code>. Unconstrained dofs also return a zero value. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02173">2173</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="adfaa145ec19c37c410ddb0fb75e165f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaa145ec19c37c410ddb0fb75e165f4">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the constraints represented by the current object to the given stream.</p>
<p>For each constraint of the form </p><p class="formulaDsp">
\[ x_{42} = 0.5 x_2 + 0.25 x_{14} + 2.75 \]
</p>
<p> this function will write a sequence of lines that look like this: </p><div class="fragment"><div class="line">42 2 : 0.5</div><div class="line">42 14 : 0.25</div><div class="line">42 : 2.75</div></div><!-- fragment --><p> The last line is only shown if the inhomogeneity (here: 2.75) is nonzero.</p>
<p>A block of lines such as the one above is repeated for each constrained degree of freedom. </p>

</div>
</div>
<a id="ae0287e2e3a5e227a3cac057d562a76d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0287e2e3a5e227a3cac057d562a76d8">&#9670;&nbsp;</a></span>write_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::write_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph of constraints in 'dot' format. 'dot' is a program that can take a list of nodes and produce a graphical representation of the graph of constrained degrees of freedom and the degrees of freedom they are constrained to.</p>
<p>The output of this function can be used as input to the 'dot' program that can convert the graph into a graphical representation in postscript, png, xfig, and a number of other formats.</p>
<p>This function exists mostly for debugging purposes. </p>

</div>
</div>
<a id="a418e2721b2f0be9d5ac15babb407e9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418e2721b2f0be9d5ac15babb407e9ac">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="a817248b703e20879fbb882df84624440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817248b703e20879fbb882df84624440">&#9670;&nbsp;</a></span>resolve_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::resolve_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the constraint indices associated to the indices in the given vector. After a call to this function, the indices vector contains the initial elements and all the associated constrained indices. This function sorts the elements and suppresses duplicates. </p>

</div>
</div>
<a id="a5a1bc1bb2d705b582889ebaa24bcae5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1bc1bb2d705b582889ebaa24bcae5c">&#9670;&nbsp;</a></span>condense() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a sparsity pattern. The name of the function mimics the name of the function we use to condense linear systems, but it is a bit of a misnomer for the current context. This is because in the context of linear systems, we eliminate certain rows and columns of the linear system, i.e., we "reduce" or "condense" the linear system. On the other hand, in the current context, the functions does not remove nonzero entries from the sparsity pattern. Rather, it adds those nonzero entry locations to the sparsity pattern that will later be needed for the process of condensation of constrained degrees of freedom from a linear system.</p>
<p>Since this function adds new nonzero entries to the sparsity pattern, the given sparsity pattern must not be compressed. The current object must be closed. The sparsity pattern is compressed at the end of the function. </p>

</div>
</div>
<a id="a5303dc0789fe9b28de60dbe5c3629036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5303dc0789fe9b28de60dbe5c3629036">&#9670;&nbsp;</a></span>condense() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparsity patterns. </p>

</div>
</div>
<a id="a07c79541d43e875ca86d7836f6057467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c79541d43e875ca86d7836f6057467">&#9670;&nbsp;</a></span>condense() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns. </p>

</div>
</div>
<a id="a95bc269b7ebd57503702a14fd78b086e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bc269b7ebd57503702a14fd78b086e">&#9670;&nbsp;</a></span>condense() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square compressed sparsity patterns. </p>

</div>
</div>
<a id="ab8d54e78514f760904ec66ac29347884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d54e78514f760904ec66ac29347884">&#9670;&nbsp;</a></span>condense() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given matrix, i.e., eliminate the rows and columns of the matrix that correspond to constrained degrees of freedom.</p>
<p>See the general documentation of this class for more detailed information. </p>

</div>
</div>
<a id="a7d6fd43d2284bb6966a748715c7da1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6fd43d2284bb6966a748715c7da1f8">&#9670;&nbsp;</a></span>condense() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparse matrices. </p>

</div>
</div>
<a id="a1e7a3c4193fa4a023e03311e2ab79d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7a3c4193fa4a023e03311e2ab79d3a">&#9670;&nbsp;</a></span>condense() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense the given vector in-place. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;number&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. Note that this function does not take any inhomogeneity into account and throws an exception in case there are any inhomogeneities. Use the function using both a matrix and vector for that case.</p>
<dl class="section note"><dt>Note</dt><dd>This function does not work for MPI vectors. Use <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense()</a> with two vector arguments instead. </dd></dl>

</div>
</div>
<a id="abfeca4e481ca38a9324b239d40368d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeca4e481ca38a9324b239d40368d0f">&#9670;&nbsp;</a></span>condense() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_ghosted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function copies and condenses values from <code>vec_ghosted</code> into <code>output</code>. In a serial code it is equivalent to calling condense (vec). If called in parallel, <code>vec_ghosted</code> is supposed to contain ghost elements while <code>output</code> should not. </p>

</div>
</div>
<a id="a4e549d0c1ab15484f3d0626f5702b101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e549d0c1ab15484f3d0626f5702b101">&#9670;&nbsp;</a></span>condense() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Condense a given matrix and a given vector by eliminating rows and columns of the linear system that correspond to constrained degrees of freedom. The sparsity pattern associated with the matrix needs to be condensed and compressed. This function is the appropriate choice for applying inhomogeneous constraints.</p>
<p>The current object must be closed to call this function.</p>
<p>See the general documentation of this class for more detailed information. </p>

</div>
</div>
<a id="ad1a6bf400e74098f552c5121975a2d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6bf400e74098f552c5121975a2d62">&#9670;&nbsp;</a></span>condense() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but condenses square block sparse matrices and vectors. </p>

</div>
</div>
<a id="ae82f75876b5982cfa4334737e5439c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82f75876b5982cfa4334737e5439c39">&#9670;&nbsp;</a></span>set_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::set_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the values of all constrained DoFs in a vector to zero. The <code>VectorType</code> may be a Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;number&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, a PETSc or Trilinos vector wrapper class, or any other type having the same interface. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02112">2112</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a373fbdacd8c486e675b8d2bff8943192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373fbdacd8c486e675b8d2bff8943192">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class InVector , class OutVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_vector</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. On the other hand, by consequence, the function does not only write into the entries enumerated by the <code>local_dof_indices</code> array, but also (possibly) others as necessary.</p>
<p>Note that this function will apply all constraints as if they were homogeneous. For correctly setting inhomogeneous constraints, use the similar function with a matrix argument or the function with both matrix and vector arguments.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_vector</td><td><a class="el" href="classVector.html">Vector</a> of local contributions. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_dof_indices</td><td>Local degrees of freedom indices corresponding to the vector of local contributions. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global_vector</td><td>The global vector to which all local contributions will be added. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02269">2269</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="ae02ed5ba9f1be9c34cf448a01b44abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ed5ba9f1be9c34cf448a01b44abdb">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function takes a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_vector</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. On the other hand, by consequence, the function does not only write into the entries enumerated by the <code>local_dof_indices</code> array, but also (possibly) others as necessary. This includes writing into diagonal elements of the matrix if the corresponding degree of freedom is constrained.</p>
<p>The fourth argument <code>local_matrix</code> is intended to be used in case one wants to apply inhomogeneous constraints on the vector only. Such a situation could be where one wants to assemble of a right hand side vector on a problem with inhomogeneous constraints, but the global matrix has been assembled previously. A typical example of this is a time stepping algorithm where the stiffness matrix is assembled once, and the right hand side updated every time step. Note that, however, the entries in the columns of the local matrix have to be exactly the same as those that have been written into the global matrix. Otherwise, this function will not be able to correctly handle inhomogeneities.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

</div>
</div>
<a id="a48bbabbcd04192f03c00c7f4de08936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bbabbcd04192f03c00c7f4de08936b">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous function, except that it uses two (possibly) different index sets to correctly handle inhomogeneities when the local matrix is computed from a combination of two neighboring elements, for example for an edge integral term in DG. Note that in the case that these two elements have different polynomial degree, the local matrix is rectangular.</p>
<p><code>local_dof_indices_row</code> is the set of row indices and <code>local_dof_indices_col</code> is the set of column indices of the local matrix. <code>diagonal=false</code> says whether the two index sets are equal or not.</p>
<p>If both index sets are equal, <code>diagonal</code> must be set to true or we simply use the previous function. If both index sets are different (diagonal=false) the <code>global_vector</code> is modified to handle inhomogeneities but no entries from <code>local_vector</code> are added. Note that the edge integrals for inner edged for DG do not contribute any values to the right hand side. </p>

</div>
</div>
<a id="a64a0ad68d6c50329b31bd9ac418afb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a0ad68d6c50329b31bd9ac418afb92">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Enter a single value into a result vector, obeying constraints. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02215">2215</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a07e96f9d525befecd233f7ee3aa9017b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e96f9d525befecd233f7ee3aa9017b">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a pointer to a vector of local contributions (<code>local_vector</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global vector. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as the entries in <code>local_dof_indices</code> indicate reasonable global vector entries, this function is happy with whatever it is given.</p>
<p>If one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_vector</code> into <code>global_vector</code>, the element is distributed to the entries in the global vector to which this particular degree of freedom is constrained.</p>
<p>Thus, by using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled. Note that this function completely ignores inhomogeneous constraints.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global vector allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02239">2239</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a96a309cb9efd4b64ef5c3dda5825841f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a309cb9efd4b64ef5c3dda5825841f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function takes a matrix of local contributions (<code>local_matrix</code>) corresponding to the degrees of freedom indices given in <code>local_dof_indices</code> and distributes them to the global matrix. In other words, this function implements a <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a>. In most cases, these local contributions will be the result of an integration over a cell or face of a cell. However, as long as <code>local_matrix</code> and <code>local_dof_indices</code> have the same number of elements, this function is happy with whatever it is given.</p>
<p>In contrast to the similar function in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function also takes care of constraints, i.e. if one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>local_matrix</code> into <code>global_matrix</code>, the element is distributed to the entries in the global matrix to which this particular degree of freedom is constrained.</p>
<p>With this scheme, we never write into rows or columns of constrained degrees of freedom. In order to make sure that the resulting matrix can still be inverted, we need to do something with the diagonal elements corresponding to constrained nodes. Thus, if a degree of freedom in <code>local_dof_indices</code> is constrained, we distribute the corresponding entries in the matrix, but also add the absolute value of the diagonal entry of the local matrix to the corresponding entry in the global matrix. Assuming the discretized operator is positive definite, this guarantees that the diagonal entry is always non-zero, positive, and of the same order of magnitude as the other entries of the matrix. On the other hand, when solving a source problem \(Au=f\) the exact value of the diagonal element is not important, since the value of the respective degree of freedom will be overwritten by the <a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute()</a> call later on anyway.</p>
<dl class="section note"><dt>Note</dt><dd>The procedure described above adds an unforeseeable number of artificial eigenvalues to the spectrum of the matrix. Therefore, it is recommended to use the equivalent function with two local index vectors in such a case.</dd></dl>
<p>By using this function to distribute local contributions to the global object, one saves the call to the condense function after the vectors and matrices are fully assembled.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global matrix allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02450">2450</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a50363f9e0a6964a67abef37c312de460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50363f9e0a6964a67abef37c312de460">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does almost the same as the function above but can treat general rectangular matrices. The main difference to achieve this is that the diagonal entries in constrained rows are left untouched instead of being filled with arbitrary values.</p>
<p>Since the diagonal entries corresponding to eliminated degrees of freedom are not set, the result may have a zero eigenvalue, if applied to a square matrix. This has to be considered when solving the resulting problems. For solving a source problem \(Au=f\), it is possible to set the diagonal entry after building the matrix by a piece of code of the form</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.m();++i)</div><div class="line">  <span class="keywordflow">if</span> (constraints.is_constrained(i))</div><div class="line">    <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.diag_element(i) = 1.;</div></div><!-- fragment --><p>The value of one which is used here is arbitrary, but in the context of Krylov space methods uncritical, since it corresponds to an invariant subspace. If the other matrix entries are smaller or larger by a factor close to machine accuracy, it may be advisable to adjust it.</p>
<p>For solving eigenvalue problems, this will only add one spurious zero eigenvalue (with a multiplicity that is possibly greater than one). Taking this into account, nothing else has to be changed. </p>

</div>
</div>
<a id="aed0236bb1541ec3669e3183d602b0cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0236bb1541ec3669e3183d602b0cd9">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_affine_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does almost the same as the function above for general rectangular matrices but uses different <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects on the row and column indices. The convention is that row indices are constrained according to the calling <a class="el" href="classAffineConstraints.html">AffineConstraints</a> <code>*this</code>, whereas column indices are constrained according to the given <a class="el" href="classAffineConstraints.html">AffineConstraints</a> <code>column_affine_constraints</code>. This function allows to handle the case where rows and columns of a matrix are represented by different function spaces with their own enumeration of indices, as e.g. in mixed finite element problems with separate <a class="el" href="classDoFHandler.html">DoFHandler</a> objects or for flux matrices between different levels in multigrid methods.</p>
<p>Like the other method with separate slots for row and column indices, this method does not add diagonal entries to eliminated degrees of freedom. See there for a more elaborate description. </p>

</div>
</div>
<a id="abe83a7964b516856f5acb8046ec63a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe83a7964b516856f5acb8046ec63a15">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function simultaneously writes elements into matrix and vector, according to the constraints specified by the calling <a class="el" href="classAffineConstraints.html">AffineConstraints</a>. In other words, it performs the <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">scatter operation</a> of the corresponding functions for matrices and vectors at the same time. This function can correctly handle inhomogeneous constraints as well. For the parameter use_inhomogeneities_for_rhs see the documentation in <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> module.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global matrix and vector allow for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02475">2475</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="ad210f57f792afd7f51c72c546f22e298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad210f57f792afd7f51c72c546f22e298">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classTable.html">Table</a>&lt;2,&#160;<a class="el" href="classbool.html">bool</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do a similar operation as the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global()</a> function that distributes writing entries into a matrix for constrained degrees of freedom, except that here we don't write into a matrix but only allocate sparsity pattern entries.</p>
<p>As explained in the <a class="el" href="DEALGlossary.html#hp_paper">hp-paper</a> and in step-27, first allocating a sparsity pattern and later coming back and allocating additional entries for those matrix entries that will be written to due to the elimination of constrained degrees of freedom (using <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> ), can be a very expensive procedure. It is cheaper to allocate these entries right away without having to do a second pass over the sparsity pattern object. This function does exactly that.</p>
<p>Because the function only allocates entries in a sparsity pattern, all it needs to know are the degrees of freedom that couple to each other. Unlike the previous function, no actual values are written, so the second input argument is not necessary here.</p>
<p>The third argument to this function, keep_constrained_entries determines whether the function shall allocate entries in the sparsity pattern at all for entries that will later be set to zero upon condensation of the matrix. These entries are necessary if the matrix is built unconstrained, and only later condensed. They are not necessary if the matrix is built using the <a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global()</a> function of this class which distributes entries right away when copying a local matrix into a global object. The default of this argument is true, meaning to allocate the few entries that may later be set to zero.</p>
<p>By default, the function adds entries for all pairs of indices given in the first argument to the sparsity pattern (unless keep_constrained_entries is false). However, sometimes one would like to only add a subset of all of these pairs. In that case, the last argument can be used which specifies a boolean mask which of the pairs of indices should be considered. If the mask is false for a pair of indices, then no entry will be added to the sparsity pattern for this pair, irrespective of whether one or both of the indices correspond to constrained degrees of freedom.</p>
<p>This function is not typically called from user code, but is used in the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function when passed an <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object.</p>
<dl class="section note"><dt>Note</dt><dd>This function in itself is thread-safe, i.e., it works properly also when several threads call it simultaneously. However, the function call is only thread-safe if the underlying global sparsity pattern allows for simultaneous access and the access is not to rows with the same global index at the same time. This needs to be made sure from the caller's site. There is no locking mechanism inside this method to prevent data races. </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02502">2502</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a5c254531d58bc731db5ab76614d5cf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c254531d58bc731db5ab76614d5cf64">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classTable.html">Table</a>&lt;&#160;2,&#160;<a class="el" href="classbool.html">bool</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Similar to the other function, but for non-quadratic sparsity patterns. </p>

</div>
</div>
<a id="a36af074aba017e9f64ed9bc88277f4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36af074aba017e9f64ed9bc88277f4e5">&#9670;&nbsp;</a></span>get_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function imports values from a global vector (<code>global_vector</code>) by applying the constraints to a vector of local values, expressed in iterator format. In most cases, the local values will be identified by the local dof values on a cell. However, as long as the entries in <code>local_dof_indices</code> indicate reasonable global vector entries, this function is happy with whatever it is given.</p>
<p>If one of the elements of <code>local_dof_indices</code> belongs to a constrained node, then rather than writing the corresponding element of <code>global_vector</code> into <code>local_vector</code>, the constraints are resolved as the respective distribute function does, i.e., the local entry is constructed from the global entries to which this particular degree of freedom is constrained.</p>
<p>In contrast to the similar function get_dof_values in the <a class="el" href="classDoFAccessor.html">DoFAccessor</a> class, this function does not need the constrained values to be correctly set (i.e., distribute to be called). </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02287">2287</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a7b3d3f295bb56d6cd6856bdc6cbe8a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3d3f295bb56d6cd6856bdc6cbe8a01">&#9670;&nbsp;</a></span>distribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a vector, set all constrained degrees of freedom to values so that the constraints are satisfied. For example, if the current object stores the constraint \(x_3=\frac 12 x_1 + \frac 12 x_2\), then this function will read the values of \(x_1\) and \(x_2\) from the given vector and set the element \(x_3\) according to this constraints. Similarly, if the current object stores the constraint \(x_{42}=208\), then this function will set the 42nd element of the given vector to 208.</p>
<dl class="section note"><dt>Note</dt><dd>If this function is called with a parallel vector <code>vec</code>, then the vector must not contain ghost elements. </dd></dl>

</div>
</div>
<a id="a06a1ba50f17085960874c157595622f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a1ba50f17085960874c157595622f1">&#9670;&nbsp;</a></span>get_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a range object containing (const) iterators to all line entries stored in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container. Such a range is useful to initialize range-based for loops as supported by C++11.</p>
<dl class="section return"><dt>Returns</dt><dd>A range object for the half open range <code>[this-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin()</a>, this-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a>)</code> of line entries. </dd></dl>

</div>
</div>
<a id="a5a0731c5473a236cc0f3b140dc100b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0731c5473a236cc0f3b140dc100b87">&#9670;&nbsp;</a></span>is_consistent_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_consistent_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_active_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the current object is consistent on all processors in a distributed computation.</p>
<p>This method checks if all processors agree on the constraints for their local lines as given by <code>locally_active_dofs</code>. This method is a collective operation and will return <code>true</code> only if all processors are consistent.</p>
<p>Please supply the owned DoFs per processor as returned by Utilities::MPI::all_gather(MPI_Comm, DoFHandler::locally_owned_dofs()) as <code>locally_owned_dofs</code> and the result of <a class="el" href="namespaceDoFTools.html#a5f745d25d2397a91dc65b9158b8d77a6">DoFTools::extract_locally_active_dofs()</a> as <code>locally_active_dofs</code>. The former is used to determine ownership of the specific DoF, while the latter is used as the set of rows that need to be checked.</p>
<p>If <code>verbose</code> is set to <code>true</code>, additional debug information is written to std::cout.</p>
<dl class="section note"><dt>Note</dt><dd>This method exchanges all constraint information of locally active lines and is as such slow for large computations and should probably only be used in debug mode. We do not check all lines returned by <a class="el" href="classAffineConstraints.html#a3a204d1c0a0fdc63c293d102c0adedd1">get_local_lines()</a> but only the locally active ones, as we allow processors to not know about some locally relevant rows.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Whether all <a class="el" href="classAffineConstraints.html">AffineConstraints</a> objects are consistent. Returns the same value on all processors. </dd></dl>

</div>
</div>
<a id="a2d347f2da63fbe1074c571df9f858486"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d347f2da63fbe1074c571df9f858486">&#9670;&nbsp;</a></span>make_consistent_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::make_consistent_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_relevant_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the current object consistent on all processors in a distributed computation. One should call this function before calling <a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a>. </p>

</div>
</div>
<a id="ab460dcccef711e63c552742ff25a9d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab460dcccef711e63c552742ff25a9d83">&#9670;&nbsp;</a></span>calculate_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::calculate_line_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal function to calculate the index of line <code>line_n</code> in the vector lines_cache using local_lines. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02187">2187</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a5501b648839b47b9696e4ae3ced90c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5501b648839b47b9696e4ae3ced90c4f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for standard (non-block) matrices. </p>

</div>
</div>
<a id="a176db170b657f6f85cb7e3a33c06e50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176db170b657f6f85cb7e3a33c06e50a">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for block matrices. </p>

</div>
</div>
<a id="a678f690dd91f1b86c24562816b7266d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f690dd91f1b86c24562816b7266d7">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for standard (non-block) sparsity types. </p>

</div>
</div>
<a id="abc807a273811f36138a6a7ed06762290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc807a273811f36138a6a7ed06762290">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function actually implements the local_to_global function for block sparsity types. </p>

</div>
</div>
<a id="a3a02d1c13ace7c8c81fe2b009f07aa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a02d1c13ace7c8c81fe2b009f07aa48">&#9670;&nbsp;</a></span>make_sorted_row_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::AffineConstraints&lt; number &gt;::GlobalRowsFromLocal&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for distribute_local_to_global function.</p>
<p>Creates a list of affected global rows for distribution, including the local rows where the entries come from. The list is sorted according to the global row indices. </p>

</div>
</div>
<a id="a34e2b86a60e91f5f025a1546fd20e1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e2b86a60e91f5f025a1546fd20e1d6">&#9670;&nbsp;</a></span>make_sorted_row_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for add_entries_local_to_global function.</p>
<p>Creates a list of affected rows for distribution without any additional information, otherwise similar to the other <a class="el" href="classAffineConstraints.html#a3a02d1c13ace7c8c81fe2b009f07aa48">make_sorted_row_list()</a> function. </p>

</div>
</div>
<a id="affd07a6eacda75be75489a340f4efe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd07a6eacda75be75489a340f4efe51">&#9670;&nbsp;</a></span>resolve_vector_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixScalar , typename VectorScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structProductType.html">ProductType</a>&lt;VectorScalar, MatrixScalar&gt;::type <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::resolve_vector_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::AffineConstraints&lt; number &gt;::GlobalRowsFromLocal&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; VectorScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; MatrixScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for distribute_local_to_global function. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2684c21b09cec978c64ebf43e75a4fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2684c21b09cec978c64ebf43e75a4fcc">&#9670;&nbsp;</a></span>AffineConstraints</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classAffineConstraints.html">AffineConstraints</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01832">1832</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a87186b21ab5f5cb1e4635d4601ee3f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87186b21ab5f5cb1e4635d4601ee3f05">&#9670;&nbsp;</a></span>lines</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a>&gt; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store the lines of the matrix. Entries are usually appended in an arbitrary order and insertion into a vector is done best at the end, so the order is unspecified after all entries are inserted. Sorting of the entries takes place when calling the <code><a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a></code> function.</p>
<p>We could, instead of using a vector, use an associative array, like a map to store the lines. This, however, would mean a much more fragmented heap since it allocates many small objects, and would additionally make usage of this matrix much slower. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01846">1846</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="ac4a78094a8ee36dc8f1af979958ecf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a78094a8ee36dc8f1af979958ecf05">&#9670;&nbsp;</a></span>lines_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&gt; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::lines_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A list of size_type that contains the position of the <a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a> of a constrained degree of freedom, or <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> if the degree of freedom is not constrained. The <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> return value returns thus whether there is a constraint line for a given degree of freedom index. Note that this class has no notion of how many degrees of freedom there really are, so if we check whether there is a constraint line for a given degree of freedom, then this vector may actually be shorter than the index of the DoF we check for.</p>
<p>This field exists since when adding a new constraint line we have to figure out whether it already exists. Previously, we would simply walk the unsorted list of constraint lines until we either hit the end or found it. This algorithm is O(N) if N is the number of constraints, which makes it O(N^2) when inserting all constraints. For large problems with many constraints, this could easily take 5-10 per cent of the total run time. With this field, we can save this time since we find any constraint in O(1) time or get to know that it a certain degree of freedom is not constrained.</p>
<p>To make things worse, traversing the list of existing constraints requires reads from many different places in memory. Thus, in large 3d applications, the <a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line()</a> function showed up very prominently in the overall compute time, mainly because it generated a lot of cache misses. This should also be fixed by using the O(1) algorithm to access the fields of this array.</p>
<p>The field is useful in a number of other contexts as well, e.g. when one needs random access to the constraints as in all the functions that apply constraints on the fly while add cell contributions into vectors and matrices. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01880">1880</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a7d5ecc66d3618beb896dc162462ae836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5ecc66d3618beb896dc162462ae836">&#9670;&nbsp;</a></span>local_lines</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::local_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This <a class="el" href="classIndexSet.html">IndexSet</a> is used to limit the lines to save in the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> to a subset. This is necessary, because the lines_cache vector would become too big in a distributed calculation. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01887">1887</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a2cacb6fdc27f68b1db0766faff484604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cacb6fdc27f68b1db0766faff484604">&#9670;&nbsp;</a></span>sorted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::sorted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Store whether the arrays are sorted. If so, no new entries can be added. </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01892">1892</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a25dd838dee6db05afec001e52e414f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dd838dee6db05afec001e52e414f95">&#9670;&nbsp;</a></span>scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; internal::AffineConstraints::ScratchData&lt;number&gt; &gt; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::scratch_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01896">1896</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
