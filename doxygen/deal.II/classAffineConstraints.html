<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classAffineConstraints.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: AffineConstraints&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classAffineConstraints-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">AffineConstraints&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__dofs.html">Degrees of Freedom</a><a class="el" href="group__dofs.html">Degrees of Freedom</a> &raquo;  &#124; <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="affine__constraints_8h_source.html">deal.II/lac/affine_constraints.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for AffineConstraints&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classAffineConstraints__inherit__graph.svg" width="676" height="214"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3b54f13f985552be5a78ac928258daed"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">MergeConflictBehavior</a> { <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b">no_conflicts_allowed</a>, 
<a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daedaced33eb2366bc959ac3f7403a83c8947">left_object_wins</a>, 
<a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daedad0ade894fba0235316b96337fdec9af2">right_object_wins</a>
 }</td></tr>
<tr class="separator:a3b54f13f985552be5a78ac928258daed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a7ce3525c69e7b5bba3a0dd03f0dead"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a0a7ce3525c69e7b5bba3a0dd03f0dead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d7fa5de5e1528a3604179b6cf77fda2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a> = typename std::vector&lt; <a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a> &gt;::<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a></td></tr>
<tr class="separator:a4d7fa5de5e1528a3604179b6cf77fda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4faf58dd9b066d6441241eabb705a83"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a> = boost::iterator_range&lt; <a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a> &gt;</td></tr>
<tr class="separator:af4faf58dd9b066d6441241eabb705a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:acb4411cdf760ae46c8ab8bf9d8302af0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#acb4411cdf760ae46c8ab8bf9d8302af0">AffineConstraints</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:acb4411cdf760ae46c8ab8bf9d8302af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79f06f06ad48b3702ad113dbd3b3b239"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a79f06f06ad48b3702ad113dbd3b3b239">AffineConstraints</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;affine_constraints)</td></tr>
<tr class="separator:a79f06f06ad48b3702ad113dbd3b3b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c78cf97489e08b600695bcf4be344c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a24c78cf97489e08b600695bcf4be344c">AffineConstraints</a> (<a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&amp;affine_constraints) noexcept=default</td></tr>
<tr class="separator:a24c78cf97489e08b600695bcf4be344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b122faa76a4751d264297edb1378105"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a9b122faa76a4751d264297edb1378105">operator=</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;)=delete</td></tr>
<tr class="separator:a9b122faa76a4751d264297edb1378105"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa04cae92177cb45de585bf60e23fffa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#afa04cae92177cb45de585bf60e23fffa">operator=</a> (<a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;&amp;affine_constraints) noexcept=default</td></tr>
<tr class="separator:afa04cae92177cb45de585bf60e23fffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac15d04ef931b4ff581b9a4b3d7b5123e"><td class="memTemplParams" colspan="2">template&lt;typename other_number &gt; </td></tr>
<tr class="memitem:ac15d04ef931b4ff581b9a4b3d7b5123e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ac15d04ef931b4ff581b9a4b3d7b5123e">copy_from</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; other_number &gt; &amp;other)</td></tr>
<tr class="separator:ac15d04ef931b4ff581b9a4b3d7b5123e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9d71b5b7e8851c25a411ccf34de986"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_constraints=<a class="el" href="classIndexSet.html">IndexSet</a>())</td></tr>
<tr class="separator:a2c9d71b5b7e8851c25a411ccf34de986"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6a8d1dce68c51bc15b73e20bae58b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1f6a8d1dce68c51bc15b73e20bae58b2">can_store_line</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:a1f6a8d1dce68c51bc15b73e20bae58b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a204d1c0a0fdc63c293d102c0adedd1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3a204d1c0a0fdc63c293d102c0adedd1">get_local_lines</a> () const</td></tr>
<tr class="separator:a3a204d1c0a0fdc63c293d102c0adedd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2dae8cbd98611a6cfbbe7c0281abcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1a2dae8cbd98611a6cfbbe7c0281abcb">add_selected_constraints</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;constraints_in, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;filter)</td></tr>
<tr class="separator:a1a2dae8cbd98611a6cfbbe7c0281abcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06a1ba50f17085960874c157595622f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a06a1ba50f17085960874c157595622f1">get_lines</a> () const</td></tr>
<tr class="separator:a06a1ba50f17085960874c157595622f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0731c5473a236cc0f3b140dc100b87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5a0731c5473a236cc0f3b140dc100b87">is_consistent_in_parallel</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;locally_owned_dofs, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_active_dofs, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const <a class="el" href="classbool.html">bool</a> verbose=false) const</td></tr>
<tr class="separator:a5a0731c5473a236cc0f3b140dc100b87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga17c0c30c7df7d5e18f17b774ef34bb1b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga17c0c30c7df7d5e18f17b774ef34bb1b">DeclException0</a> (ExcMatrixIsClosed)</td></tr>
<tr class="separator:ga17c0c30c7df7d5e18f17b774ef34bb1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cf30c5210b44c14dd1dcc7450b712a5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3cf30c5210b44c14dd1dcc7450b712a5">DeclException0</a> (ExcMatrixNotClosed)</td></tr>
<tr class="separator:ga3cf30c5210b44c14dd1dcc7450b712a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab05a2687457c11675a0f7e98e42e272d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab05a2687457c11675a0f7e98e42e272d">DeclException1</a> (ExcLineInexistant, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;The specified line &quot;&lt;&lt; arg1&lt;&lt; &quot; does not exist.&quot;)</td></tr>
<tr class="separator:gab05a2687457c11675a0f7e98e42e272d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf3e5a7989a1a22bdd50bc0a8a87b255e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf3e5a7989a1a22bdd50bc0a8a87b255e">DeclException4</a> (ExcEntryAlreadyExists, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number, number,&lt;&lt; &quot;The entry for the indices &quot;&lt;&lt; arg1&lt;&lt; &quot; and &quot;&lt;&lt; arg2&lt;&lt; &quot; already exists, but the values &quot;&lt;&lt; arg3&lt;&lt; &quot; (old) and &quot;&lt;&lt; arg4&lt;&lt; &quot; (new) differ &quot;&lt;&lt; &quot;by &quot;&lt;&lt;(arg4 - arg3)&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gaf3e5a7989a1a22bdd50bc0a8a87b255e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa25908b905ef11ec9bcc0d2d867abfcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa25908b905ef11ec9bcc0d2d867abfcb">DeclException2</a> (ExcDoFConstrainedToConstrainedDoF, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to constrain DoF &quot;&lt;&lt; arg1&lt;&lt; &quot; to DoF &quot;&lt;&lt; arg2&lt;&lt; &quot;, but that one is also constrained. This is not allowed!&quot;)</td></tr>
<tr class="separator:gaa25908b905ef11ec9bcc0d2d867abfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaae728e5ae4ae67d584aec813d6026de6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaae728e5ae4ae67d584aec813d6026de6">DeclException1</a> (ExcDoFIsConstrainedFromBothObjects, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;Degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; is constrained from both object in a <a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">merge</a> operation.&quot;)</td></tr>
<tr class="separator:gaae728e5ae4ae67d584aec813d6026de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a6f75ca0e092c363b8c5d61c926a2f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga83a6f75ca0e092c363b8c5d61c926a2f">DeclException1</a> (ExcDoFIsConstrainedToConstrainedDoF, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;In the given argument a degree of freedom is constrained &quot;&lt;&lt; &quot;to another DoF with number &quot;&lt;&lt; arg1&lt;&lt; &quot;, which however is constrained by this object. This is not&quot;&lt;&lt; &quot; allowed.&quot;)</td></tr>
<tr class="separator:ga83a6f75ca0e092c363b8c5d61c926a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga719b3201d8af13663513789d2c73d9ef"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga719b3201d8af13663513789d2c73d9ef">DeclException1</a> (ExcRowNotStoredHere, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;The index set given to this constraints object indicates &quot;&lt;&lt; &quot;constraints for degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; should not be stored by this object, but a constraint &quot;&lt;&lt; &quot;is being added.&quot;)</td></tr>
<tr class="separator:ga719b3201d8af13663513789d2c73d9ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7840b50b20f084634c57a984e0018e6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gad7840b50b20f084634c57a984e0018e6">DeclException2</a> (ExcColumnNotStoredHere, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>,&lt;&lt; &quot;The index set given to this constraints object indicates &quot;&lt;&lt; &quot;constraints using degree of freedom &quot;&lt;&lt; arg2&lt;&lt; &quot; should not be stored by this object, but a constraint &quot;&lt;&lt; &quot;for degree of freedom &quot;&lt;&lt; arg1&lt;&lt; &quot; uses it.&quot;)</td></tr>
<tr class="separator:gad7840b50b20f084634c57a984e0018e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacc5a4db5283a662e07ab49e965086302"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gacc5a4db5283a662e07ab49e965086302">DeclException2</a> (ExcIncorrectConstraint, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;While distributing the constraint for DoF &quot;&lt;&lt; arg1&lt;&lt; &quot;, it turns out that one of the processors &quot;&lt;&lt; &quot;who own the &quot;&lt;&lt; arg2&lt;&lt; &quot; degrees of freedom that x_&quot;&lt;&lt; arg1&lt;&lt; &quot; is constrained against does not know about &quot;&lt;&lt; &quot;the constraint on x_&quot;&lt;&lt; arg1&lt;&lt; &quot;. Did you not initialize the <a class="el" href="classAffineConstraints.html">AffineConstraints</a> container &quot;&lt;&lt; &quot;with the appropriate locally_relevant set so &quot;&lt;&lt; &quot;that every processor who owns a DoF that constrains &quot;&lt;&lt; &quot;another DoF also knows about this constraint?&quot;)</td></tr>
<tr class="separator:gacc5a4db5283a662e07ab49e965086302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">添加约束</div></td></tr>
<tr class="memitem:a11139b28db021be1d2b762c3c5275ee4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a11139b28db021be1d2b762c3c5275ee4">add_line</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n)</td></tr>
<tr class="separator:a11139b28db021be1d2b762c3c5275ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef97b22281acb10c914d79a3881e2735"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#aef97b22281acb10c914d79a3881e2735">add_lines</a> (const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;<a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a>)</td></tr>
<tr class="separator:aef97b22281acb10c914d79a3881e2735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c8f2e42dcd9712d5ed677522bc0886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a79c8f2e42dcd9712d5ed677522bc0886">add_lines</a> (const std::set&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;<a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a>)</td></tr>
<tr class="separator:a79c8f2e42dcd9712d5ed677522bc0886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bbaf061c6ba46e75e7c820261d7c10d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7bbaf061c6ba46e75e7c820261d7c10d">add_lines</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;<a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a>)</td></tr>
<tr class="separator:a7bbaf061c6ba46e75e7c820261d7c10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b7756e9cb8e53553211add5426f8e50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2b7756e9cb8e53553211add5426f8e50">add_entry</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> constrained_dof_index, const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> column, const number weight)</td></tr>
<tr class="separator:a2b7756e9cb8e53553211add5426f8e50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc26fc668c50df9ea54b23222ae21a43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#afc26fc668c50df9ea54b23222ae21a43">add_entries</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> constrained_dof_index, const std::vector&lt; std::pair&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number &gt;&gt; &amp;col_weight_pairs)</td></tr>
<tr class="separator:afc26fc668c50df9ea54b23222ae21a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f7cb22b3c971599a839fddc988ef92a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a4f7cb22b3c971599a839fddc988ef92a">set_inhomogeneity</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> constrained_dof_index, const number value)</td></tr>
<tr class="separator:a4f7cb22b3c971599a839fddc988ef92a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1611aa37f754086388ca76bcd421cce5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a> ()</td></tr>
<tr class="separator:a1611aa37f754086388ca76bcd421cce5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d267ebb328a639eb9f3d68b1fa7ffb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a09d267ebb328a639eb9f3d68b1fa7ffb">merge</a> (const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;other_constraints, const <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">MergeConflictBehavior</a> merge_conflict_behavior=<a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b">no_conflicts_allowed</a>, const <a class="el" href="classbool.html">bool</a> allow_different_local_lines=false)</td></tr>
<tr class="separator:a09d267ebb328a639eb9f3d68b1fa7ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc850833411818832f3dbadcdf48878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3bc850833411818832f3dbadcdf48878">shift</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> offset)</td></tr>
<tr class="separator:a3bc850833411818832f3dbadcdf48878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addd15bc409c61d6f795f0132c574335b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a> ()</td></tr>
<tr class="separator:addd15bc409c61d6f795f0132c574335b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">查询约束条件</div></td></tr>
<tr class="memitem:adf261da8033116444de6140403ba8c3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#adf261da8033116444de6140403ba8c3d">n_constraints</a> () const</td></tr>
<tr class="separator:adf261da8033116444de6140403ba8c3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a885d18f0044979873f5e5a6f33772f73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a885d18f0044979873f5e5a6f33772f73">is_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:a885d18f0044979873f5e5a6f33772f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add769bef2c387002067d10b91328713e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#add769bef2c387002067d10b91328713e">is_identity_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:add769bef2c387002067d10b91328713e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af96cda3efc1d336fb9b4956c8850935e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#af96cda3efc1d336fb9b4956c8850935e">are_identity_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n_1, const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n_2) const</td></tr>
<tr class="separator:af96cda3efc1d336fb9b4956c8850935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652d307372bffb6cca4f51bc22b022de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a652d307372bffb6cca4f51bc22b022de">max_constraint_indirections</a> () const</td></tr>
<tr class="separator:a652d307372bffb6cca4f51bc22b022de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd58352f9d4a1166700b1a5c77e92a47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abd58352f9d4a1166700b1a5c77e92a47">is_inhomogeneously_constrained</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> index) const</td></tr>
<tr class="separator:abd58352f9d4a1166700b1a5c77e92a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df947a828e8496cd04087c58b382da5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a0df947a828e8496cd04087c58b382da5">has_inhomogeneities</a> () const</td></tr>
<tr class="separator:a0df947a828e8496cd04087c58b382da5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34f8862c8278d995ad710efed1968de"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; std::pair&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number &gt; &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ab34f8862c8278d995ad710efed1968de">get_constraint_entries</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:ab34f8862c8278d995ad710efed1968de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3101608954771e72318e1c8b226b7f76"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3101608954771e72318e1c8b226b7f76">get_inhomogeneity</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:a3101608954771e72318e1c8b226b7f76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfaa145ec19c37c410ddb0fb75e165f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#adfaa145ec19c37c410ddb0fb75e165f4">print</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:adfaa145ec19c37c410ddb0fb75e165f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0287e2e3a5e227a3cac057d562a76d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ae0287e2e3a5e227a3cac057d562a76d8">write_dot</a> (std::ostream &amp;) const</td></tr>
<tr class="separator:ae0287e2e3a5e227a3cac057d562a76d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a418e2721b2f0be9d5ac15babb407e9ac"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a418e2721b2f0be9d5ac15babb407e9ac">memory_consumption</a> () const</td></tr>
<tr class="separator:a418e2721b2f0be9d5ac15babb407e9ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817248b703e20879fbb882df84624440"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a817248b703e20879fbb882df84624440">resolve_indices</a> (std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;indices) const</td></tr>
<tr class="separator:a817248b703e20879fbb882df84624440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">在线性系统创建后消除其约束</div></td></tr>
<tr class="memitem:a5a1bc1bb2d705b582889ebaa24bcae5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">condense</a> (<a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a5a1bc1bb2d705b582889ebaa24bcae5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5303dc0789fe9b28de60dbe5c3629036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5303dc0789fe9b28de60dbe5c3629036">condense</a> (<a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a5303dc0789fe9b28de60dbe5c3629036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c79541d43e875ca86d7836f6057467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a07c79541d43e875ca86d7836f6057467">condense</a> (<a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a07c79541d43e875ca86d7836f6057467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bc269b7ebd57503702a14fd78b086e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a95bc269b7ebd57503702a14fd78b086e">condense</a> (<a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;sparsity) const</td></tr>
<tr class="separator:a95bc269b7ebd57503702a14fd78b086e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d54e78514f760904ec66ac29347884"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ab8d54e78514f760904ec66ac29347884">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix) const</td></tr>
<tr class="separator:ab8d54e78514f760904ec66ac29347884"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6fd43d2284bb6966a748715c7da1f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7d6fd43d2284bb6966a748715c7da1f8">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix) const</td></tr>
<tr class="separator:a7d6fd43d2284bb6966a748715c7da1f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7a3c4193fa4a023e03311e2ab79d3a"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a1e7a3c4193fa4a023e03311e2ab79d3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a1e7a3c4193fa4a023e03311e2ab79d3a">condense</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const</td></tr>
<tr class="separator:a1e7a3c4193fa4a023e03311e2ab79d3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfeca4e481ca38a9324b239d40368d0f"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:abfeca4e481ca38a9324b239d40368d0f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abfeca4e481ca38a9324b239d40368d0f">condense</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;vec_ghosted, <a class="el" href="classVectorType.html">VectorType</a> &amp;output) const</td></tr>
<tr class="separator:abfeca4e481ca38a9324b239d40368d0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e549d0c1ab15484f3d0626f5702b101"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a4e549d0c1ab15484f3d0626f5702b101"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a4e549d0c1ab15484f3d0626f5702b101">condense</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;vector) const</td></tr>
<tr class="separator:a4e549d0c1ab15484f3d0626f5702b101"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1a6bf400e74098f552c5121975a2d62"><td class="memTemplParams" colspan="2">template&lt;class BlockVectorType &gt; </td></tr>
<tr class="memitem:ad1a6bf400e74098f552c5121975a2d62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ad1a6bf400e74098f552c5121975a2d62">condense</a> (<a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, BlockVectorType &amp;vector) const</td></tr>
<tr class="separator:ad1a6bf400e74098f552c5121975a2d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae82f75876b5982cfa4334737e5439c39"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:ae82f75876b5982cfa4334737e5439c39"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ae82f75876b5982cfa4334737e5439c39">set_zero</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const</td></tr>
<tr class="separator:ae82f75876b5982cfa4334737e5439c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">在线性系统创建过程中消除其约束</div></td></tr>
<tr class="memitem:a373fbdacd8c486e675b8d2bff8943192"><td class="memTemplParams" colspan="2">template&lt;class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a373fbdacd8c486e675b8d2bff8943192"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a> (const InVector &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, OutVector &amp;global_vector) const</td></tr>
<tr class="separator:a373fbdacd8c486e675b8d2bff8943192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ed5ba9f1be9c34cf448a01b44abdb"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:ae02ed5ba9f1be9c34cf448a01b44abdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ae02ed5ba9f1be9c34cf448a01b44abdb">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix) const</td></tr>
<tr class="separator:ae02ed5ba9f1be9c34cf448a01b44abdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bbabbcd04192f03c00c7f4de08936b"><td class="memTemplParams" colspan="2">template&lt;typename VectorType &gt; </td></tr>
<tr class="memitem:a48bbabbcd04192f03c00c7f4de08936b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a48bbabbcd04192f03c00c7f4de08936b">distribute_local_to_global</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices_row, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices_col, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, <a class="el" href="classbool.html">bool</a> diagonal=false) const</td></tr>
<tr class="separator:a48bbabbcd04192f03c00c7f4de08936b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64a0ad68d6c50329b31bd9ac418afb92"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a64a0ad68d6c50329b31bd9ac418afb92"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a64a0ad68d6c50329b31bd9ac418afb92">distribute_local_to_global</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> index, const number value, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector) const</td></tr>
<tr class="separator:a64a0ad68d6c50329b31bd9ac418afb92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e96f9d525befecd233f7ee3aa9017b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a07e96f9d525befecd233f7ee3aa9017b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a07e96f9d525befecd233f7ee3aa9017b">distribute_local_to_global</a> (ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end, ForwardIteratorInd local_indices_begin, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector) const</td></tr>
<tr class="separator:a07e96f9d525befecd233f7ee3aa9017b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a309cb9efd4b64ef5c3dda5825841f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a96a309cb9efd4b64ef5c3dda5825841f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a96a309cb9efd4b64ef5c3dda5825841f">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:a96a309cb9efd4b64ef5c3dda5825841f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50363f9e0a6964a67abef37c312de460"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:a50363f9e0a6964a67abef37c312de460"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a50363f9e0a6964a67abef37c312de460">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;col_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:a50363f9e0a6964a67abef37c312de460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed0236bb1541ec3669e3183d602b0cd9"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:aed0236bb1541ec3669e3183d602b0cd9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#aed0236bb1541ec3669e3183d602b0cd9">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;row_indices, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a> &amp;column_affine_constraints, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;column_indices, MatrixType &amp;global_matrix) const</td></tr>
<tr class="separator:aed0236bb1541ec3669e3183d602b0cd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe83a7964b516856f5acb8046ec63a15"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:abe83a7964b516856f5acb8046ec63a15"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abe83a7964b516856f5acb8046ec63a15">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs=false) const</td></tr>
<tr class="separator:abe83a7964b516856f5acb8046ec63a15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad210f57f792afd7f51c72c546f22e298"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:ad210f57f792afd7f51c72c546f22e298"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ad210f57f792afd7f51c72c546f22e298">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask=<a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;()) const</td></tr>
<tr class="separator:ad210f57f792afd7f51c72c546f22e298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c254531d58bc731db5ab76614d5cf64"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a5c254531d58bc731db5ab76614d5cf64"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5c254531d58bc731db5ab76614d5cf64">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;col_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries=true, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask=<a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt;()) const</td></tr>
<tr class="separator:a5c254531d58bc731db5ab76614d5cf64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36af074aba017e9f64ed9bc88277f4e5"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </td></tr>
<tr class="memitem:a36af074aba017e9f64ed9bc88277f4e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a36af074aba017e9f64ed9bc88277f4e5">get_dof_values</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, ForwardIteratorInd local_indices_begin, ForwardIteratorVec local_vector_begin, ForwardIteratorVec local_vector_end) const</td></tr>
<tr class="separator:a36af074aba017e9f64ed9bc88277f4e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">在求解线性系统后处理约束条件</div></td></tr>
<tr class="memitem:a7b3d3f295bb56d6cd6856bdc6cbe8a01"><td class="memTemplParams" colspan="2">template&lt;class VectorType &gt; </td></tr>
<tr class="memitem:a7b3d3f295bb56d6cd6856bdc6cbe8a01"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;vec) const</td></tr>
<tr class="separator:a7b3d3f295bb56d6cd6856bdc6cbe8a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ab460dcccef711e63c552742ff25a9d83"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ab460dcccef711e63c552742ff25a9d83">calculate_line_index</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> line_n) const</td></tr>
<tr class="separator:ab460dcccef711e63c552742ff25a9d83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5501b648839b47b9696e4ae3ced90c4f"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a5501b648839b47b9696e4ae3ced90c4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a5501b648839b47b9696e4ae3ced90c4f">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;) const</td></tr>
<tr class="separator:a5501b648839b47b9696e4ae3ced90c4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176db170b657f6f85cb7e3a33c06e50a"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename VectorType &gt; </td></tr>
<tr class="memitem:a176db170b657f6f85cb7e3a33c06e50a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a176db170b657f6f85cb7e3a33c06e50a">distribute_local_to_global</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, MatrixType &amp;global_matrix, <a class="el" href="classVectorType.html">VectorType</a> &amp;global_vector, const <a class="el" href="classbool.html">bool</a> use_inhomogeneities_for_rhs, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;) const</td></tr>
<tr class="separator:a176db170b657f6f85cb7e3a33c06e50a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678f690dd91f1b86c24562816b7266d7"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a678f690dd91f1b86c24562816b7266d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a678f690dd91f1b86c24562816b7266d7">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;) const</td></tr>
<tr class="separator:a678f690dd91f1b86c24562816b7266d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc807a273811f36138a6a7ed06762290"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:abc807a273811f36138a6a7ed06762290"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#abc807a273811f36138a6a7ed06762290">add_entries_local_to_global</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> keep_constrained_entries, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;dof_mask, const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;) const</td></tr>
<tr class="separator:abc807a273811f36138a6a7ed06762290"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a02d1c13ace7c8c81fe2b009f07aa48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a3a02d1c13ace7c8c81fe2b009f07aa48">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, internal::AffineConstraints::GlobalRowsFromLocal&lt; number &gt; &amp;global_rows) const</td></tr>
<tr class="separator:a3a02d1c13ace7c8c81fe2b009f07aa48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e2b86a60e91f5f025a1546fd20e1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a34e2b86a60e91f5f025a1546fd20e1d6">make_sorted_row_list</a> (const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;active_dofs) const</td></tr>
<tr class="separator:a34e2b86a60e91f5f025a1546fd20e1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affd07a6eacda75be75489a340f4efe51"><td class="memTemplParams" colspan="2">template&lt;typename MatrixScalar , typename VectorScalar &gt; </td></tr>
<tr class="memitem:affd07a6eacda75be75489a340f4efe51"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structProductType.html">ProductType</a>&lt; VectorScalar, MatrixScalar &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#affd07a6eacda75be75489a340f4efe51">resolve_vector_entry</a> (const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> i, const internal::AffineConstraints::GlobalRowsFromLocal&lt; number &gt; &amp;global_rows, const <a class="el" href="classVector.html">Vector</a>&lt; VectorScalar &gt; &amp;local_vector, const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;local_dof_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; MatrixScalar &gt; &amp;local_matrix) const</td></tr>
<tr class="separator:affd07a6eacda75be75489a340f4efe51"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a87186b21ab5f5cb1e4635d4601ee3f05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a87186b21ab5f5cb1e4635d4601ee3f05">lines</a></td></tr>
<tr class="separator:a87186b21ab5f5cb1e4635d4601ee3f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4a78094a8ee36dc8f1af979958ecf05"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#ac4a78094a8ee36dc8f1af979958ecf05">lines_cache</a></td></tr>
<tr class="separator:ac4a78094a8ee36dc8f1af979958ecf05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d5ecc66d3618beb896dc162462ae836"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a7d5ecc66d3618beb896dc162462ae836">local_lines</a></td></tr>
<tr class="separator:a7d5ecc66d3618beb896dc162462ae836"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cacb6fdc27f68b1db0766faff484604"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2cacb6fdc27f68b1db0766faff484604">sorted</a></td></tr>
<tr class="separator:a2cacb6fdc27f68b1db0766faff484604"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25dd838dee6db05afec001e52e414f95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; internal::AffineConstraints::ScratchData&lt; number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a25dd838dee6db05afec001e52e414f95">scratch_data</a></td></tr>
<tr class="separator:a25dd838dee6db05afec001e52e414f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a2684c21b09cec978c64ebf43e75a4fcc"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:a2684c21b09cec978c64ebf43e75a4fcc"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classAffineConstraints.html#a2684c21b09cec978c64ebf43e75a4fcc">AffineConstraints</a></td></tr>
<tr class="separator:a2684c21b09cec978c64ebf43e75a4fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number = double&gt;<br />
class AffineConstraints&lt; number &gt;</h3>

<p>该类实现了对自由度的线性（可能是不均匀的）约束的处理。这种约束的概念和起源在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中有广泛的描述。该类旨在处理相对于自由度总数而言数量有限的约束，例如百分之几到百分之三十；以及处理<em>M</em>其他自由度的线性组合，其中<em>M</em>也相对较小（最多不超过线性系统每行的平均条目数左右）。它是 <em> 而不是 </em> ，旨在描述全等级线性系统。 在 <a class="el" href="DEALGlossary.html#hp_paper">hp-paper </a> 中详细描述了用于实现该类的算法。在 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中也有大量的关于如何使用这个类的文档。</p>
<h3>Description of constraints</h3>
<p>该类对象中的每一个 "行 "对应于一个受限自由度，行的编号为<em>i</em>，通过使用add_line()或add_lines()输入。这一行的条目是形式为(<em>j</em>, <em>a<sub>ij</sub></em>)的一对，通过add_entry()或add_entries()添加。该组织本质上是一个SparsityPattern，但只有几行包含非零元素，因此没有在其他行上浪费数据。对于通过上述机制添加的每一行，都会对形式为 </p><p class="formulaDsp">
\[ x_i = \sum_j a_{ij} x_j + b_i \]
</p>
<p>的约束自由度进行消除，其中<em>b<sub>i</sub></em>是可选的，由set_inhomogeneity()设置。因此，如果一个约束被表述为例如几个自由度的零平均值，则必须选择其中一个自由度来消除。 请注意，约束条件在<em>x<sub>i</sub></em>中是线性的，而且约束条件中可能有一个常数（非均质）项。这正是我们需要的悬挂节点约束的形式，我们需要用其他自由度来约束一个自由度。还有其他可能的这种形式的条件，例如用于实现均值条件，正如在 <a class="el" href="step_11.html">step-11</a> 教程程序中所做的那样。该类的名称源于这些约束条件可以用矩阵形式表示为<b>X</b> <em>x</em> = <em>b</em>，然后该对象描述了矩阵<b>X</b>和向量<em>b</em>。创建/填充这种类型的对象最常用的方法是使用 <a class="el" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints()</a> 函数。这些对象的使用首先在 <a class="el" href="step_6.html">step-6</a> 中解释。 本类型的对象被组织成行（row），但只有那些存在约束条件的行被存储。新的约束是通过使用add_line()函数添加新的行，然后使用add_entry()函数填充到给定的行中，或者使用add_entries()函数一次添加一个以上的条目。右边的元素，如果非零，可以使用set_inhomogeneity()函数进行设置。在所有约束条件被添加后，你需要调用close()，它可以压缩存储格式并对条目进行排序。</p>
<dl class="section note"><dt>Note</dt><dd>这个类实现的许多算法在 <a class="el" href="DEALGlossary.html#hp_paper">hp_paper</a> 中讨论。这些算法也与<em>M. S. Shephard: Linear multipoint constraints applied via transformation as part of a direct stiffness assembly process. Int. J. Numer. Meth. Engrg., vol. 20 (1984), pp. 2107-2112.</em>中所示的算法有关，不同的是，那里所示的算法完全消除了受限自由度，而我们通常将它们作为线性系统的一部分保留下来。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l00435">435</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a0a7ce3525c69e7b5bba3a0dd03f0dead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a7ce3525c69e7b5bba3a0dd03f0dead">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器尺寸的类型。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l00442">442</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a4d7fa5de5e1528a3604179b6cf77fda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d7fa5de5e1528a3604179b6cf77fda2">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a> =  typename std::vector&lt;<a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a>&gt;::<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在LineRange容器中使用的迭代器类型的别名。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01314">1314</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="af4faf58dd9b066d6441241eabb705a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4faf58dd9b066d6441241eabb705a83">&#9670;&nbsp;</a></span>LineRange</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a> =  boost::iterator_range&lt;<a class="el" href="classAffineConstraints.html#a4d7fa5de5e1528a3604179b6cf77fda2">const_iterator</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classAffineConstraints.html#a06a1ba50f17085960874c157595622f1">get_lines()</a>使用的返回类型的别名。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01320">1320</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3b54f13f985552be5a78ac928258daed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b54f13f985552be5a78ac928258daed">&#9670;&nbsp;</a></span>MergeConflictBehavior</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">AffineConstraints::MergeConflictBehavior</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个枚举，描述了如果调用merge()函数所涉及的两个AffineConstraints对象恰好在相同的自由度上有约束，应该发生什么。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b"></a>no_conflicts_allowed&#160;</td><td class="fielddoc"><p>如果两个相关对象在同一自由度上有冲突的约束，则抛出一个异常。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b54f13f985552be5a78ac928258daedaced33eb2366bc959ac3f7403a83c8947"></a>left_object_wins&#160;</td><td class="fielddoc"><p>在一个操作中 <code>cm1.merge(cm2)</code>, if <code>cm1</code> 和 <code>cm2</code> 对同一自由度有约束，取 <code>cm1</code> 中的一个。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a3b54f13f985552be5a78ac928258daedad0ade894fba0235316b96337fdec9af2"></a>right_object_wins&#160;</td><td class="fielddoc"><p>在一个操作中， <code>cm1.merge(cm2)</code>, if <code>cm1</code> 和 <code>cm2</code> 对同一自由度有约束，从 <code>cm2</code> 中选取一个。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l00448">448</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="acb4411cdf760ae46c8ab8bf9d8302af0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb4411cdf760ae46c8ab8bf9d8302af0">&#9670;&nbsp;</a></span>AffineConstraints() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html">AffineConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。提供的IndexSet定义了在这个AffineConstraints容器内可能被约束的指数。在基于 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 或 <a class="el" href="classparallel_1_1shared_1_1Triangulation.html">parallel::shared::Triangulation</a>, 的DoFHandler对象的计算中，应该使用本地相关的dofs集合（见 <a class="el" href="DEALGlossary.html#GlossLocallyRelevantDof">GlossLocallyRelevantDof</a> ）。 给定的IndexSet允许AffineConstraints容器通过不关心那些对当前处理器不重要的自由度来节省内存。另外，如果没有提供这样的IndexSet，将为<em>all</em>可能的索引创建内部数据结构，导致每个处理器的内存消耗与问题的<em>overall</em>大小成正比，而不仅仅是与当前处理器处理的整个问题的部分大小成正比。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01598">1598</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a79f06f06ad48b3702ad113dbd3b3b239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79f06f06ad48b3702ad113dbd3b3b239">&#9670;&nbsp;</a></span>AffineConstraints() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html">AffineConstraints</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>affine_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造函数 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01611">1611</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a24c78cf97489e08b600695bcf4be344c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c78cf97489e08b600695bcf4be344c">&#9670;&nbsp;</a></span>AffineConstraints() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::<a class="el" href="classAffineConstraints.html">AffineConstraints</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>affine_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9b122faa76a4751d264297edb1378105"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b122faa76a4751d264297edb1378105">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&amp; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制操作符。就像对许多其他大型对象一样，这个操作符被删除了，以避免它在一些地方被不小心使用，比如不小心将一个 <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a></code> 对象作为函数参数按值而不是按引用声明。 然而，你可以使用copy_from()函数来明确地复制AffineConstraints对象。 </p>

</div>
</div>
<a id="afa04cae92177cb45de585bf60e23fffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa04cae92177cb45de585bf60e23fffa">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&amp; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>affine_constraints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动赋值运算符 </p>

</div>
</div>
<a id="ac15d04ef931b4ff581b9a4b3d7b5123e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac15d04ef931b4ff581b9a4b3d7b5123e">&#9670;&nbsp;</a></span>copy_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename other_number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; other_number &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将给定的对象复制到当前对象。 这个函数的存在是因为 <code><a class="el" href="classAffineConstraints.html#a9b122faa76a4751d264297edb1378105">operator=()</a></code> 被明确禁止。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02025">2025</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a2c9d71b5b7e8851c25a411ccf34de986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9d71b5b7e8851c25a411ccf34de986">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_constraints</em> = <code><a class="el" href="classIndexSet.html">IndexSet</a>()</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear()</a>AffineConstraints对象，并提供一个带有可能被约束的线条的IndexSet。这个函数只在分布式情况下与提供不同的IndexSet有关。否则，这个例程就等同于调用clear()。详情见构造函数。 </p>

</div>
</div>
<a id="a1f6a8d1dce68c51bc15b73e20bae58b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6a8d1dce68c51bc15b73e20bae58b2">&#9670;&nbsp;</a></span>can_store_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::can_store_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定我们是否可以为给定的 <code>line_n</code>. 存储一个约束，这个例程只在分布式情况下有意义，并检查IndexSet是否允许存储这一行。如果不是在分布式情况下，总是返回true。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01802">1802</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a3a204d1c0a0fdc63c293d102c0adedd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a204d1c0a0fdc63c293d102c0adedd1">&#9670;&nbsp;</a></span>get_local_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_local_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回描述本地相关行的索引集，如果有的话。请注意，如果没有给出本地行，这代表一个空的IndexSet，而否则它包含全局问题大小和本地范围。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01809">1809</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a1a2dae8cbd98611a6cfbbe7c0281abcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2dae8cbd98611a6cfbbe7c0281abcb">&#9670;&nbsp;</a></span>add_selected_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_selected_constraints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>filter</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数复制了 <code>constraints_in</code> 的内容，其中的DoFs是IndexSet <code>filter</code>. 中的元素，不存在于IndexSet中的元素被忽略。所有的DoFs将被转换到过滤器的本地索引空间，包括被约束的DoFs和这些条目所约束的其他DoFs。滤波器的局部索引空间是对作为滤波器元素的所有（全局）DoF的连续编号。 例如，如果过滤器代表范围<code>[10,20)</code>，而约束对象 <code>constraints_in</code> 包括全局索引<code>{7,13,14}</code>，索引<code>{3,4}</code>被添加到调用的约束对象中（因为13和14是过滤器中的元素，元素13是索引中的第四元素，而14是第五元素）。 这个函数提供了一个简单的方法，从一个完整的AffineConstraints中为矢量值问题中的某些矢量分量创建一个AffineConstraints，即从一个较大的AffineConstraints中提取一个对角线子块。该块是由IndexSet参数指定的。 </p>

</div>
</div>
<a id="a11139b28db021be1d2b762c3c5275ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11139b28db021be1d2b762c3c5275ee4">&#9670;&nbsp;</a></span>add_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_line </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在矩阵中添加一个新行。如果该行已经存在，那么该函数只是返回而不做任何事情。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01622">1622</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="aef97b22281acb10c914d79a3881e2735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef97b22281acb10c914d79a3881e2735">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为每个索引 <code>i</code> 调用第一个add_line()函数，其中 <code>lines[i]</code> 为真。 这个函数的存在本质上是为了允许一次性添加几个形式为<em>x<sub>i</sub></em>=0的约束，其中应该添加这些约束的指数集<em>i</em>是由这个函数的参数给出。另一方面，就像重复调用单参数的add_line()函数一样，以后可以用add_entry()函数修改约束条件，以包括线性依赖，以及用set_inhomogeneity()修改不均匀性。 </p>

</div>
</div>
<a id="a79c8f2e42dcd9712d5ed677522bc0886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c8f2e42dcd9712d5ed677522bc0886">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_lines </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为参数中出现的每个索引 <code>i</code> 调用第一个add_line()函数。 这个函数的存在本质上是为了允许一次性添加几个形式为<em>x<sub>i</sub></em>=0的约束，其中应该添加这些约束的指数集<em>i</em>是由这个函数的参数给出。另一方面，就像重复调用单参数的add_line()函数一样，以后可以用add_entry()函数对约束条件进行修改，以包括线性依赖，以及用set_inhomogeneity()对不均匀性进行修改。 </p>

</div>
</div>
<a id="a7bbaf061c6ba46e75e7c820261d7c10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bbaf061c6ba46e75e7c820261d7c10d">&#9670;&nbsp;</a></span>add_lines() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_lines </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>lines</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为参数中出现的每个索引 <code>i</code> 调用第一个add_line()函数。 这个函数的存在本质上是为了允许一次性添加几个形式为<em>x<sub>i</sub></em>=0的约束，其中应该添加这些约束的指数集<em>i</em>是由这个函数的参数给出。另一方面，就像重复调用单参数的add_line()函数一样，以后可以用add_entry()函数修改约束条件，以包括线性依赖，以及用set_inhomogeneity()修改不均匀性。 </p>

</div>
</div>
<a id="a2b7756e9cb8e53553211add5426f8e50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b7756e9cb8e53553211add5426f8e50">&#9670;&nbsp;</a></span>add_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>constrained_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在一个给定的行中添加一个条目。换句话说，这个函数为 \(i\) 第1个自由度的约束条件增加了一个 \(a_{ij} x_j\) 项。 如果一个与这个函数调用所表示的条目具有相同的索引，那么这个函数只是简单地返回，条件是该条目的值是相同的。因此，两次输入一个约束条件并无大碍。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constrained_dof_index</td><td>被约束的自由度的索引 \(i\) 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">column</td><td>被输入约束自由度 \(i\) 的自由度的索引 \(j\) 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">权重</td><td>乘以 \(x_j\) 的系数 \(a_{ij}\) 。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01654">1654</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="afc26fc668c50df9ea54b23222ae21a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc26fc668c50df9ea54b23222ae21a43">&#9670;&nbsp;</a></span>add_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>constrained_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>, number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>col_weight_pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在一行约束条件中添加一整串条目，用成对的列索引和权重值表示。这个函数等同于多次调用前面的函数，但速度更快。 </p>

</div>
</div>
<a id="a4f7cb22b3c971599a839fddc988ef92a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f7cb22b3c971599a839fddc988ef92a">&#9670;&nbsp;</a></span>set_inhomogeneity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::set_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>constrained_dof_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为一个自由度的约束设置一个不均匀性。换句话说，它为自由度 \(i\) 的约束添加一个常数 \(b_i\) 。为了使其发挥作用，你需要先为给定的自由度调用add_line()。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">constrained_dof_index</td><td>被约束的自由度的索引 \(i\) 。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">值</td><td>自由度上的约束的右手边值 \(b_i\) \(i\) 。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01696">1696</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a1611aa37f754086388ca76bcd421cce5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1611aa37f754086388ca76bcd421cce5">&#9670;&nbsp;</a></span>close()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::close </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>关闭条目的填充。由于这种类型的矩阵的行通常是以任意顺序填充的，而且我们不想使用关联约束器来存储行，所以我们需要对行和行内的列进行排序，然后再使用矩阵。这可以通过这个函数完成。 此外，零条目被丢弃，因为它们不被需要。 关闭后，不再接受任何条目。如果该对象已经被关闭，那么该函数立即返回。 这个函数也可以解决约束链的问题。例如，自由度13可能被约束为 \(u_{13} = \frac{u_3}{2} + \frac{u_7}{2}\) ，而自由度7本身被约束为 \(u_{7} = \frac{u_2}{2} + \frac{u_4}{2}\) 。然后，决议将是： \(u_{13} = \frac{u_3}{2} + \frac{u_2}{4} + \frac{u_4}{4}\) 。然而，请注意，这个约束图中的循环是不允许的，也就是说，例如 \(u_4\) 本身不能直接或间接地再次约束到 \(u_{13}\) 。 </p>

</div>
</div>
<a id="a09d267ebb328a639eb9f3d68b1fa7ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09d267ebb328a639eb9f3d68b1fa7ffb">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::merge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>other_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daed">MergeConflictBehavior</a>&#160;</td>
          <td class="paramname"><em>merge_conflict_behavior</em> = <code><a class="el" href="classAffineConstraints.html#a3b54f13f985552be5a78ac928258daeda5027e6e663a186605f6901d19fa8651b">no_conflicts_allowed</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_different_local_lines</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将作为参数的对象所代表的约束合并到这个对象所代表的约束中。两个对象都可能被关闭，也可能没有被关闭（通过之前调用它们的函数close()）。如果这个对象之前被关闭了，那么之后也会被关闭。 然而，请注意，如果另一个参数是关闭的，那么合并的速度可能会大大加快。 使用第二个参数的默认值，两个对象（这个对象和参数所代表的旧对象）中的约束可能并不是指相同的自由度，也就是说，一个对象中约束的自由度可能在第二个对象中没有约束。如果是这种情况，就会抛出一个异常。 然而，这种行为可以通过为第二个参数提供一个不同的值来改变。 默认情况下，不允许合并两个被初始化为不同IndexSet对象的AffineConstraints对象。 这个行为可以通过适当地设置 <code>allow_different_local_lines</code> 来改变。 合并一个用IndexSet初始化的AffineConstraints和一个没有用IndexSet初始化的AffineConstraints还没有实现。 </p>

</div>
</div>
<a id="a3bc850833411818832f3dbadcdf48878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc850833411818832f3dbadcdf48878">&#9670;&nbsp;</a></span>shift()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::shift </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将这个矩阵的所有条目向下移动 <code>offset</code> 行，向上移动 <code>offset</code> 列。如果这个对象是用IndexSet初始化的，那么local_lines也会被移位。 如果你正在构建块状矩阵，即所有的块都是由同一个DoFHandler对象构建的，也就是说，矩阵的大小大于自由度的数量，那么这个函数就很有用。由于几个矩阵的行和列对应着相同的自由度，你会生成几个约束对象，然后将它们移位，最后再将它们合并()在一起。 </p>

</div>
</div>
<a id="addd15bc409c61d6f795f0132c574335b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addd15bc409c61d6f795f0132c574335b">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>清除这个矩阵的所有条目。重置决定是否接受新条目的标志。 这个函数也可以在对象为空或已经清空的情况下调用。 </p>

</div>
</div>
<a id="adf261da8033116444de6140403ba8c3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf261da8033116444de6140403ba8c3d">&#9670;&nbsp;</a></span>n_constraints()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::n_constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回存储在该矩阵中的约束数量。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01727">1727</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a885d18f0044979873f5e5a6f33772f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a885d18f0044979873f5e5a6f33772f73">&#9670;&nbsp;</a></span>is_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回编号为 <code>line_n</code> 的自由度是否是一个约束度。 请注意，如果之前调用了close()，那么这个函数会明显加快，因为此时受限自由度已经被排序，我们可以进行二进制搜索，而在调用close()之前，我们必须对所有条目进行线性搜索。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01734">1734</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="add769bef2c387002067d10b91328713e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add769bef2c387002067d10b91328713e">&#9670;&nbsp;</a></span>is_identity_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该自由度是否被约束，以及是否被约束到只有一个权重为1的其他自由度。因此，该函数返回该自由度是否会被简单地消除，而恰恰是其他一个自由度。 如果自由度完全不受约束，或者它受制于一个以上的其他自由度，或者它只受制于一个自由度，但其权重不同于1，则该函数返回 <code>false</code> 。 </p>

</div>
</div>
<a id="af96cda3efc1d336fb9b4956c8850935e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af96cda3efc1d336fb9b4956c8850935e">&#9670;&nbsp;</a></span>are_identity_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::are_identity_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n_2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定的两个自由度是否被一个平等约束所连接，该约束要么约束index1以便 <code>index1=index2</code> ，要么约束index2以便 <code>index2=index1</code> 。 </p>

</div>
</div>
<a id="a652d307372bffb6cca4f51bc22b022de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652d307372bffb6cca4f51bc22b022de">&#9670;&nbsp;</a></span>max_constraint_indirections()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::max_constraint_indirections </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个道夫所约束的其他道夫的最大数量。 例如，在2d中，一个悬挂的节点只受制于它的两个邻居，所以返回值是2。然而，对于高阶元素和/或高维度，或其他类型的约束，这个数字就不明显了。 这个名字表明，在系统矩阵内，对受约束节点的引用是间接指向它所受约束的节点的。 </p>

</div>
</div>
<a id="abd58352f9d4a1166700b1a5c77e92a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd58352f9d4a1166700b1a5c77e92a47">&#9670;&nbsp;</a></span>is_inhomogeneously_constrained()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_inhomogeneously_constrained </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在道夫被约束的情况下，返回<code>true</code>，并且有一个非琐碎的不均匀值设置给道夫。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01743">1743</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a0df947a828e8496cd04087c58b382da5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df947a828e8496cd04087c58b382da5">&#9670;&nbsp;</a></span>has_inhomogeneities()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::has_inhomogeneities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果AffineConstraints中的所有约束都是同质的，则返回<code>false</code>；如果至少有一个不均匀性，则返回<code>true</code>。 </p>

</div>
</div>
<a id="ab34f8862c8278d995ad710efed1968de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34f8862c8278d995ad710efed1968de">&#9670;&nbsp;</a></span>get_constraint_entries()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; std::pair&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &gt; * <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_constraint_entries </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>如果一条线被约束，则返回一个指向条目向量的指针，如果道夫没有被约束，则返回一个零指针。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01761">1761</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a3101608954771e72318e1c8b226b7f76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3101608954771e72318e1c8b226b7f76">&#9670;&nbsp;</a></span>get_inhomogeneity()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_inhomogeneity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回存储在受约束道夫 <code>line_n中的不均匀性的值。不受约束的道夫也会返回一个零值。</code> </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01775">1775</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="adfaa145ec19c37c410ddb0fb75e165f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfaa145ec19c37c410ddb0fb75e165f4">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将当前对象所代表的约束打印到给定的流中。 对于每个形式为 </p><p class="formulaDsp">
\[ x_{42} = 0.5 x_2 + 0.25 x_{14} + 2.75 \]
</p>
<p>的约束，这个函数将写出一连串的行，看起来像这样。 </p><div class="fragment"><div class="line">42 2 : 0.5</div><div class="line">42 14 : 0.25</div><div class="line">42 : 2.75</div></div><!-- fragment --><p> 最后一行只有在不均匀性（这里：2.75）非零时才会显示。 像上面这样的线块对每个受限自由度都是重复的。 </p>

</div>
</div>
<a id="ae0287e2e3a5e227a3cac057d562a76d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0287e2e3a5e227a3cac057d562a76d8">&#9670;&nbsp;</a></span>write_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::write_dot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用'dot'格式写出约束的图形。dot'是一个程序，它可以接受一个节点列表，并产生一个约束自由度和它们所约束的自由度的图形表示。 这个函数的输出可以作为'dot'程序的输入，该程序可以将图形转换成postscript、png、xfig和其他一些格式的图形表示。 这个函数的存在主要是为了调试的目的。 </p>

</div>
</div>
<a id="a418e2721b2f0be9d5ac15babb407e9ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a418e2721b2f0be9d5ac15babb407e9ac">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="a817248b703e20879fbb882df84624440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817248b703e20879fbb882df84624440">&#9670;&nbsp;</a></span>resolve_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::resolve_indices </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加与给定向量中的指数相关的约束指数。 在调用此函数后，索引向量包含初始元素和所有相关的约束指数。这个函数对这些元素进行排序，并抑制重复的元素。 </p>

</div>
</div>
<a id="a5a1bc1bb2d705b582889ebaa24bcae5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a1bc1bb2d705b582889ebaa24bcae5c">&#9670;&nbsp;</a></span>condense() <span class="overload">[1/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>浓缩一个稀疏的模式。这个函数的名字模仿了我们用来凝结线性系统的函数的名字，但对于目前的语境来说，它有点名不副实。这是因为在线性系统的背景下，我们消除了线性系统的某些行和列，即我们 "减少 "或 "浓缩
"了线性系统。另一方面，在当前情况下，函数并不从稀疏模式中删除非零条目。相反，它将那些非零条目的位置添加到稀疏性模式中，这些非零条目以后将被用于浓缩线性系统的受限自由度的过程。 由于该函数向稀疏性模式添加了新的非零条目，给定的稀疏性模式必须不被压缩。当前对象必须是封闭的。稀疏度模式在函数的最后被压缩。 </p>

</div>
</div>
<a id="a5303dc0789fe9b28de60dbe5c3629036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5303dc0789fe9b28de60dbe5c3629036">&#9670;&nbsp;</a></span>condense() <span class="overload">[2/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparsityPattern.html">BlockSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但浓缩了方形块的稀疏模式。 </p>

</div>
</div>
<a id="a07c79541d43e875ca86d7836f6057467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c79541d43e875ca86d7836f6057467">&#9670;&nbsp;</a></span>condense() <span class="overload">[3/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的函数相同，但浓缩了方形压缩的稀疏模式。 </p>

</div>
</div>
<a id="a95bc269b7ebd57503702a14fd78b086e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bc269b7ebd57503702a14fd78b086e">&#9670;&nbsp;</a></span>condense() <span class="overload">[4/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockDynamicSparsityPattern.html">BlockDynamicSparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上面的功能相同，但浓缩了方形压缩的稀疏模式。 </p>

</div>
</div>
<a id="ab8d54e78514f760904ec66ac29347884"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d54e78514f760904ec66ac29347884">&#9670;&nbsp;</a></span>condense() <span class="overload">[5/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>压缩一个给定的矩阵，即消除矩阵中对应于受限自由度的行和列。 更详细的信息请参见该类的一般文档。 </p>

</div>
</div>
<a id="a7d6fd43d2284bb6966a748715c7da1f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6fd43d2284bb6966a748715c7da1f8">&#9670;&nbsp;</a></span>condense() <span class="overload">[6/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述函数相同，但浓缩了方形块稀疏矩阵。 </p>

</div>
</div>
<a id="a1e7a3c4193fa4a023e03311e2ab79d3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7a3c4193fa4a023e03311e2ab79d3a">&#9670;&nbsp;</a></span>condense() <span class="overload">[7/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对给定的向量进行原地压缩。 <code>VectorType</code> 可以是Vector&lt;float&gt;, <a class="el" href="classVector.html">Vector&lt;number&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, PETSc或Trilinos向量包装类，或任何其他具有相同接口的类型。注意，这个函数不考虑任何不均匀性，如果有任何不均匀性，会抛出一个异常。 在这种情况下，请同时使用矩阵和矢量的函数。 </p><dl class="section note"><dt>Note</dt><dd>这个函数对MPI向量不起作用。请使用带有两个向量参数的condense()来代替。 </dd></dl>

</div>
</div>
<a id="abfeca4e481ca38a9324b239d40368d0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfeca4e481ca38a9324b239d40368d0f">&#9670;&nbsp;</a></span>condense() <span class="overload">[8/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec_ghosted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数将 <code>vec_ghosted</code> 中的值复制并浓缩到 <code>中输出。在串行代码中，它等同于调用condense</code> (vec)。如果以并行方式调用， <code>vec_ghosted</code> 应该包含幽灵元素，而 <code>output</code> 不应该。 </p>

</div>
</div>
<a id="a4e549d0c1ab15484f3d0626f5702b101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e549d0c1ab15484f3d0626f5702b101">&#9670;&nbsp;</a></span>condense() <span class="overload">[9/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过消除对应于受限自由度的线性系统的行和列，浓缩一个给定的矩阵和一个给定的向量。与矩阵相关的稀疏性模式需要被浓缩和压缩。 这个函数是应用不均匀约束的合适选择。 当前对象必须被关闭才能调用这个函数。 更详细的信息请参见该类的一般文档。 </p>

</div>
</div>
<a id="ad1a6bf400e74098f552c5121975a2d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1a6bf400e74098f552c5121975a2d62">&#9670;&nbsp;</a></span>condense() <span class="overload">[10/10]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class BlockVectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::condense </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BlockVectorType &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述函数相同，但浓缩了方形块稀疏矩阵和向量。 </p>

</div>
</div>
<a id="ae82f75876b5982cfa4334737e5439c39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae82f75876b5982cfa4334737e5439c39">&#9670;&nbsp;</a></span>set_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::set_zero </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个向量中所有受约束的DoF的值设置为零。 <code>VectorType可以是Vector&lt;float&gt;</code>, <a class="el" href="classVector.html">Vector&lt;number&gt;</a>, <a class="el" href="classBlockVector.html">BlockVector</a><code>&lt;...&gt;</code>, PETSc或Trilinos矢量包装类，或任何其他具有相同接口的类型。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01714">1714</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a373fbdacd8c486e675b8d2bff8943192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a373fbdacd8c486e675b8d2bff8943192">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;class InVector , class OutVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数接收一个局部贡献的向量( <code>local_vector</code>) 对应于 <code>local_dof_indices中给出的自由度指数，并将它们分配到全局向量中。换句话说，这个函数实现了一个</code> <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 在大多数情况下，这些局部贡献将是在一个单元或一个单元的面上进行整合的结果。然而，只要 <code>local_vector</code> 和 <code>的local_dof_indices有相同的元素数，这个函数就很乐意接受它所给的任何东西。</code> 与DoFAccessor类中的类似函数相比，这个函数也照顾到了约束，即如果 <code>local_dof_indices</code> 中的一个元素属于一个受约束的节点，那么与其将 <code>local_vector</code> 中的相应元素写入 <code>global_vector，不如将该元素分配到这个特定自由度受约束的global</code> vector中的条目。 因此，通过使用这个函数将局部贡献分配给全局对象，就省去了在向量和矩阵完全集合后对缩合函数的调用。另一方面，由于这个原因，这个函数不仅写进了 <code>local_dof_indices</code> 数组所列举的条目，而且还写进了（可能）其他必要的条目。 请注意，这个函数将应用所有的约束，就像它们是同质的一样。为了正确设置非均质约束，请使用带有矩阵参数的类似函数，或者同时带有矩阵和矢量参数的函数。 </p><dl class="section note"><dt>Note</dt><dd>这个函数本身是线程安全的，也就是说，当几个线程同时调用它时，它也能正常工作。然而，只有当底层的全局向量允许同时访问，并且在同一时间不访问具有相同全局索引的行时，该函数调用才是线程安全的。这需要从调用者的现场进行确认。这个方法内部没有锁定机制来防止数据竞赛。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">local_vector</td><td>本地贡献的向量。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">local_dof_indices</td><td>本地贡献向量对应的本地自由度指数。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">global_vector</td><td>全局向量，所有局部贡献将被添加到该向量中。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01871">1871</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="ae02ed5ba9f1be9c34cf448a01b44abdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae02ed5ba9f1be9c34cf448a01b44abdb">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数接收一个与 <code>local_dof_indices中给出的自由度指数相对应的局部贡献向量</code>( <code>local_vector</code>) ，并将其分配到全局向量中。换句话说，这个函数实现了一个<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 在大多数情况下，这些局部贡献将是在一个单元或一个单元的面上进行整合的结果。然而，只要 <code>local_vector</code> 和 <code>的local_dof_indices有相同的元素数，这个函数就很乐意接受它所给的任何东西。</code> 与DoFAccessor类中的类似函数相比，这个函数也照顾到了约束，即如果 <code>local_dof_indices</code> 中的一个元素属于一个受约束的节点，那么与其将 <code>local_vector</code> 中的相应元素写入 <code>global_vector，不如将该元素分配到这个特定自由度受约束的global</code> vector中的条目。 因此，通过使用这个函数将局部贡献分配给全局对象，就省去了在向量和矩阵完全集合后对缩合函数的调用。另一方面，由于这个原因，该函数不仅写入 <code>local_dof_indices</code> 数组所列举的条目，而且还（可能）写入其他必要的条目。这包括写进矩阵的对角线元素，如果相应的自由度受到限制。 第四个参数<code>local_matrix</code>是为了在人们想只对向量应用不均匀约束时使用。这种情况可能是人们想在一个有不均匀约束的问题上装配一个右手边的向量，但全局矩阵已经在之前装配好了。一个典型的例子是一个时间步进算法，其中刚度矩阵被组装一次，而右手边在每个时间步进中被更新。然而，请注意，局部矩阵的列中的条目必须与已经写入全局矩阵的条目完全相同。否则，这个函数将不能正确处理不均匀性。 </p><dl class="section note"><dt>Note</dt><dd>这个函数本身是线程安全的，也就是说，当几个线程同时调用它时，它也能正常工作。然而，只有当底层的全局向量允许同时访问，并且不同时访问具有相同全局索引的行时，该函数调用才是线程安全的。这需要从调用者的现场进行确认。这个方法内部没有锁定机制来防止数据竞赛。 </dd></dl>

</div>
</div>
<a id="a48bbabbcd04192f03c00c7f4de08936b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bbabbcd04192f03c00c7f4de08936b">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices_col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>diagonal</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与前一个函数相同，只是它使用了两个（可能）不同的索引集来正确处理局部矩阵由两个相邻元素组合计算时的不均匀性，例如DG中的边缘积分项。注意，在这两个元素具有不同多项式程度的情况下，局部矩阵是矩形的。 <code>local_dof_indices_row</code>是局部矩阵的行指数集合，<code>local_dof_indices_col</code>是局部矩阵的列指数集合。<code>diagonal=false</code>表示这两个索引集是否相等。 如果两个索引集相等，<code>diagonal</code>必须设置为真，否则我们直接使用前面的函数。如果两个索引集不同（对角线=false），<code>global_vector</code>会被修改以处理不均匀性，但不会增加<code>local_vector</code>的条目。请注意，对于DG的内边缘积分不对右手边贡献任何数值。 </p>

</div>
</div>
<a id="a64a0ad68d6c50329b31bd9ac418afb92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64a0ad68d6c50329b31bd9ac418afb92">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在结果向量中输入一个单一的值，服从约束。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01817">1817</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a07e96f9d525befecd233f7ee3aa9017b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e96f9d525befecd233f7ee3aa9017b">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数接收一个指向局部贡献向量的指针（ <code>local_vector），对应于</code> <code>local_dof_indices中给出的自由度指数，并将它们分配到全局向量中。换句话说，这个函数实现了一个</code> <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 在大多数情况下，这些局部贡献将是在一个单元或一个单元的面上进行整合的结果。然而，只要 <code>local_dof_indices中的条目表示合理的全局向量条目，这个函数就会对它所给出的任何东西感到满意。</code> 如果 <code>local_dof_indices</code> 中的一个元素属于受限节点，那么与其将 <code>local_vector中的相应元素写入</code> <code>global_vector</code>, ，不如将该元素分配到该特定自由度受限的全局向量中的条目。 因此，通过使用这个函数将局部贡献分配给全局对象，可以省去在向量和矩阵完全集合后对缩合函数的调用。注意，这个函数完全忽略了不均匀约束。 </p><dl class="section note"><dt>Note</dt><dd>这个函数本身是线程安全的，也就是说，当几个线程同时调用它时，它也能正常工作。然而，只有当底层的全局向量允许同时访问，并且不同时访问具有相同全局索引的行时，该函数调用才是线程安全的。这需要从调用者的现场进行确认。这个方法里面没有锁定机制来防止数据竞赛。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01841">1841</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a96a309cb9efd4b64ef5c3dda5825841f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a309cb9efd4b64ef5c3dda5825841f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数接收一个本地贡献的矩阵（ <code>local_matrix</code>) 对应于 <code>local_dof_indices中给出的自由度指数，并将它们分配到全局矩阵中。换句话说，这个函数实现了一个</code> <a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 在大多数情况下，这些局部贡献将是在一个单元或一个单元的面上进行整合的结果。然而，只要 <code>local_matrix</code> 和 <code>的local_dof_indices有相同的元素数，这个函数就很乐意接受它所给的任何东西。</code> 与DoFAccessor类中的类似函数相比，这个函数也照顾到了约束，即如果 <code>local_dof_indices</code> 中的一个元素属于一个受约束的节点，那么与其将 <code>local_matrix</code> 中的相应元素写入 <code>global_matrix，不如将该元素分配给这个特定自由度受约束的全局矩阵中的条目。</code> 通过这个方案，我们永远不会写进受约束自由度的行或列。为了确保得到的矩阵仍然可以被倒置，我们需要对对应于受约束节点的对角线元素做一些处理。因此，如果 <code>local_dof_indices中的一个自由度受到约束，我们就在矩阵中分配相应的条目，但同时也将局部矩阵的对角线条目的绝对值加到全局矩阵的相应条目上。</code> 假设离散算子是正定的，这就保证了对角线条目总是非零的、正的，并且与矩阵的其他条目具有相同的数量级。另一方面，在解决源问题时 \(Au=f\) ，对角线元素的精确值并不重要，因为无论如何，各自自由度的值将被后面的distribution()调用覆盖。 </p><dl class="section note"><dt>Note</dt><dd>上述程序在矩阵的频谱上增加了不可预见的人工特征值的数量。因此，在这种情况下，建议使用带有两个局部索引向量的等效函数。 通过使用这个函数来分配对全局对象的局部贡献，可以省去在向量和矩阵完全集合后对缩合函数的调用。 </dd>
<dd>
这个函数本身是线程安全的，也就是说，当几个线程同时调用它时，它也能正常工作。然而，只有当底层的全局矩阵允许同时访问，并且访问的不是具有相同全局索引的行时，该函数调用才是线程安全的。这需要从调用者的现场进行确认。这个方法内部没有锁定机制来防止数据竞赛。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02040">2040</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a50363f9e0a6964a67abef37c312de460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50363f9e0a6964a67abef37c312de460">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数的作用与上面的函数几乎相同，但可以处理一般的矩形矩阵。实现这一点的主要区别是，受限行中的对角线条目不被触及，而被填充为任意值。 由于对应于被消除的自由度的对角线项没有被设置，如果应用于正方形矩阵，其结果可能有一个零特征值。这在解决所产生的问题时必须加以考虑。对于解决源问题 \(Au=f\) ，可以在建立矩阵后通过以下形式的代码来设置对角线条目 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0;i&lt;<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.m();++i)</div><div class="line">  <span class="keywordflow">if</span> (constraints.is_constrained(i))</div><div class="line">    <a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>.diag_element(i) = 1.;</div></div><!-- fragment --><p> 这里使用的1的值是任意的，但在Krylov空间方法的背景下是不关键的，因为它对应于一个不变的子空间。如果其他矩阵项的大小与机器精度相近，最好对其进行调整。 对于解决特征值问题，这只会增加一个虚假的零特征值（其倍率可能大于1）。 考虑到这一点，其他的就不用改了。 </p>

</div>
</div>
<a id="aed0236bb1541ec3669e3183d602b0cd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed0236bb1541ec3669e3183d602b0cd9">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_affine_constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数与上面的函数对一般矩形矩阵的作用几乎相同，但在行和列索引上使用不同的AffineConstraints对象。惯例是，行指数根据调用的AffineConstraints <code>*this</code> 进行约束，而列指数则根据给定的AffineConstraints <code>column_affine_constraints</code> 进行约束。这个函数允许处理这样的情况：矩阵的行和列由不同的函数空间表示，并有各自的指数列举，例如，在混合有限元问题中，有独立的DoFHandler对象，或者在多网格方法中不同层次之间的通量矩阵。 与其他为行和列指数提供单独槽的方法一样，这种方法不为消除的自由度增加对角线条目。更详细的描述见那里。 </p>

</div>
</div>
<a id="abe83a7964b516856f5acb8046ec63a15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe83a7964b516856f5acb8046ec63a15">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数根据调用AffineConstraints指定的约束条件，同时将元素写入矩阵和向量中。 换句话说，它同时对矩阵和向量执行相应函数的<a href="https://en.wikipedia.org/wiki/Gather-scatter_(vector_addressing)">散点操作</a>。 这个函数也能正确处理不均匀约束。关于参数use_inhomogeneities_for_rhs见 <a class="el" href="group__constraints.html">Constraints on degrees of freedom</a> 模块中的文档。 </p><dl class="section note"><dt>Note</dt><dd>这个函数本身是线程安全的，也就是说，当几个线程同时调用它时，它也能正常工作。然而，只有当底层的全局矩阵和向量允许同时访问，并且在同一时间不访问具有相同全局索引的行时，该函数调用才是线程安全的。这需要从调用者的现场进行确认。这个方法内部没有锁定机制来防止数据竞赛。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02065">2065</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="ad210f57f792afd7f51c72c546f22e298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad210f57f792afd7f51c72c546f22e298">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classTable.html">Table</a>&lt;2,&#160;<a class="el" href="classbool.html">bool</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>做一个与distribut_local_to_global()函数类似的操作，该函数将写条目分配到受限自由度的矩阵中，只是这里我们不写进矩阵，而只是分配稀疏模式条目。 正如 <a class="el" href="DEALGlossary.html#hp_paper">hp-paper </a> 和 <a class="el" href="step_27.html">step-27</a> 中解释的那样，首先分配一个稀疏模式，然后再回来为那些由于消除受限自由度而被写入的矩阵条目分配额外的条目（使用 <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense()</a> ），可能是一个非常昂贵的过程。 更便宜的做法是立即分配这些条目，而不需要对稀疏模式对象进行第二次传递。这个函数正是这样做的。 因为该函数只分配稀疏模式中的条目，所以它需要知道的是相互耦合的自由度。 与前一个函数不同的是，没有写入实际值，所以第二个输入参数在这里是不必要的。 该函数的第三个参数keep_constrained_entries决定了该函数是否要在稀疏性模式中分配条目，这些条目以后会在矩阵浓缩时被设置为零。如果矩阵是在无约束的情况下建立的，那么这些条目是必要的，只是后来被浓缩。如果使用该类的distribut_local_to_global()函数构建矩阵，则不需要这些条目，该函数在将本地矩阵复制到全局对象时，会立即分配条目。这个参数的默认值是true，意味着要分配少数条目，这些条目以后可能被设置为0。 默认情况下，该函数将第一个参数中给出的所有索引对的条目添加到稀疏模式中（除非keep_constrained_entries为false）。然而，有时人们希望只添加所有这些对的一个子集。在这种情况下，可以使用最后一个参数，该参数指定了一个布尔掩码，哪些索引对应该被考虑。如果某对指数的掩码是假的，那么这对指数的稀疏性模式将不被添加，无论其中一个或两个指数是否对应于受限自由度。 这个函数通常不是从用户代码中调用的，而是在传递AffineConstraints对象时在 <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> 函数中使用。 </p><dl class="section note"><dt>Note</dt><dd>这个函数本身是线程安全的，也就是说，当几个线程同时调用它时，它也能正常工作。然而，只有当底层的全局稀疏性模式允许同时访问，并且在同一时间不访问具有相同全局索引的行时，该函数调用才是线程安全的。这需要从调用者那里得到确认。这个方法内部没有锁定机制来防止数据竞赛。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l02092">2092</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a5c254531d58bc731db5ab76614d5cf64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c254531d58bc731db5ab76614d5cf64">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em> = <code><a class="el" href="classTable.html">Table</a>&lt;&#160;2,&#160;<a class="el" href="classbool.html">bool</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与另一个函数类似，但用于非二次疏散模式。 </p>

</div>
</div>
<a id="a36af074aba017e9f64ed9bc88277f4e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36af074aba017e9f64ed9bc88277f4e5">&#9670;&nbsp;</a></span>get_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIteratorVec , typename ForwardIteratorInd , class VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorInd&#160;</td>
          <td class="paramname"><em>local_indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIteratorVec&#160;</td>
          <td class="paramname"><em>local_vector_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数从全局向量中导入数值（ <code>global_vector</code>) 通过将约束条件应用于本地数值的向量，以迭代器格式表示。 在大多数情况下，本地值将由单元格上的本地dof值来识别。然而，只要 <code>local_dof_indices中的条目表示合理的全局向量条目，这个函数就会对它所给的任何东西感到满意。</code> 如果 <code>local_dof_indices</code> 中的一个元素属于受约束的节点，那么与其将 <code>global_vector中的相应元素写入</code> <code>local_vector</code>, ，不如像各自的分发函数那样解决约束，也就是说，本地条目是由这个特定自由度受约束的全局条目构造的。 与DoFAccessor类中的类似函数get_dof_values相比，这个函数不需要正确设置约束值（即调用distribution）。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01889">1889</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a7b3d3f295bb56d6cd6856bdc6cbe8a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b3d3f295bb56d6cd6856bdc6cbe8a01">&#9670;&nbsp;</a></span>distribute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;class VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个向量，将所有受约束的自由度设置为数值，使约束得到满足。例如，如果当前对象存储了约束条件 \(x_3=\frac 12 x_1 + \frac 12 x_2\) ，那么这个函数将从给定的向量中读取 \(x_1\) 和 \(x_2\) 的值并根据这个约束条件设置元素 \(x_3\) 。同样地，如果当前对象存储了约束条件 \(x_{42}=208\) ，那么这个函数将把给定向量的第42个元素设置为208。 </p><dl class="section note"><dt>Note</dt><dd>如果这个函数是用一个平行向量 <code>vec</code>, 调用的，那么这个向量不能包含鬼魂元素。 </dd></dl>

</div>
</div>
<a id="a06a1ba50f17085960874c157595622f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06a1ba50f17085960874c157595622f1">&#9670;&nbsp;</a></span>get_lines()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classAffineConstraints.html#af4faf58dd9b066d6441241eabb705a83">LineRange</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::get_lines </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个包含（const）对存储在AffineConstraints容器中的所有线条的迭代器的范围对象。这样的范围对于初始化基于范围的for循环是很有用的，正如C++11所支持的那样。 </p><dl class="section return"><dt>Returns</dt><dd>一个用于半开范围<code>[this-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin()</a>, this-&gt;<a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a>)</code>的行条目的范围对象。 </dd></dl>

</div>
</div>
<a id="a5a0731c5473a236cc0f3b140dc100b87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0731c5473a236cc0f3b140dc100b87">&#9670;&nbsp;</a></span>is_consistent_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::is_consistent_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_active_dofs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检查当前对象在分布式计算的所有处理器上是否一致。 该方法检查所有处理器是否同意由 <code>locally_active_dofs</code>. 给出的其本地行的约束，该方法是一个集体操作，只有当所有处理器都一致时才会返回 <code>true</code> 。 请提供由 <a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">Utilities::MPI::all_gather</a>(MPI_Comm, <a class="el" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">DoFHandler::locally_owned_dofs()</a>) 返回的每个处理器拥有的DoF，作为 <code>locally_owned_dofs</code> ，以及 <a class="el" href="namespaceDoFTools.html#a5f745d25d2397a91dc65b9158b8d77a6">DoFTools::extract_locally_active_dofs()</a> 的结果，作为 <code>locally_active_dofs</code>. 。 前者用于确定特定DoF的所有权，而后者作为需要检查的行的集合。 如果 <code>verbose</code> 被设置为 <code>true</code>, ，额外的调试信息将被写入 std::cout. 。 </p><dl class="section note"><dt>Note</dt><dd>这个方法交换了本地活动行的所有约束信息，因此对于大型计算来说很慢，可能只应该在调试模式下使用。我们不检查get_local_lines()返回的所有行，而只检查本地活动的行，因为我们允许处理器不知道一些本地相关行。 </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>所有AffineConstraints对象是否一致。在所有处理器上返回相同的值。 </dd></dl>

</div>
</div>
<a id="ab460dcccef711e63c552742ff25a9d83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab460dcccef711e63c552742ff25a9d83">&#9670;&nbsp;</a></span>calculate_line_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::calculate_line_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>line_n</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>内部函数，使用local_lines计算向量lines_cache中的行 <code>line_n</code> 的索引。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01789">1789</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a5501b648839b47b9696e4ae3ced90c4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5501b648839b47b9696e4ae3ced90c4f">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数实际上实现了标准（非块）矩阵的local_to_global函数。 </p>

</div>
</div>
<a id="a176db170b657f6f85cb7e3a33c06e50a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176db170b657f6f85cb7e3a33c06e50a">&#9670;&nbsp;</a></span>distribute_local_to_global() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename VectorType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::distribute_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>global_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>global_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>use_inhomogeneities_for_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数实际上是为块状矩阵实现了local_to_global函数。 </p>

</div>
</div>
<a id="a678f690dd91f1b86c24562816b7266d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678f690dd91f1b86c24562816b7266d7">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, false &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数实际上是为标准（非块）稀疏类型实现了local_to_global函数。 </p>

</div>
</div>
<a id="abc807a273811f36138a6a7ed06762290"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc807a273811f36138a6a7ed06762290">&#9670;&nbsp;</a></span>add_entries_local_to_global() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::add_entries_local_to_global </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>keep_constrained_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classbool.html">bool</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::integral_constant&lt; <a class="el" href="classbool.html">bool</a>, true &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数实际上是为块状稀疏度类型实现local_to_global函数。 </p>

</div>
</div>
<a id="a3a02d1c13ace7c8c81fe2b009f07aa48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a02d1c13ace7c8c81fe2b009f07aa48">&#9670;&nbsp;</a></span>make_sorted_row_list() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">internal::AffineConstraints&lt; number &gt;::GlobalRowsFromLocal&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为distribution_local_to_global函数提供内部辅助函数。 创建一个受影响的全局行列表用于分发，包括条目来自的本地行。该列表根据全局行的索引进行排序。 </p>

</div>
</div>
<a id="a34e2b86a60e91f5f025a1546fd20e1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e2b86a60e91f5f025a1546fd20e1d6">&#9670;&nbsp;</a></span>make_sorted_row_list() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::make_sorted_row_list </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>active_dofs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>add_entries_local_to_global函数的内部辅助函数。 创建一个受影响的行的列表，用于分发，没有任何额外的信息，否则与其他make_sorted_row_list()函数类似。 </p>

</div>
</div>
<a id="affd07a6eacda75be75489a340f4efe51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affd07a6eacda75be75489a340f4efe51">&#9670;&nbsp;</a></span>resolve_vector_entry()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixScalar , typename VectorScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structProductType.html">ProductType</a>&lt;VectorScalar, MatrixScalar&gt;::type <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::resolve_vector_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const internal::AffineConstraints&lt; number &gt;::GlobalRowsFromLocal&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>global_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; VectorScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; MatrixScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>distribute_local_to_global函数的内部辅助函数。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a2684c21b09cec978c64ebf43e75a4fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2684c21b09cec978c64ebf43e75a4fcc">&#9670;&nbsp;</a></span>AffineConstraints</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classAffineConstraints.html">AffineConstraints</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01463">1463</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a87186b21ab5f5cb1e4635d4601ee3f05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87186b21ab5f5cb1e4635d4601ee3f05">&#9670;&nbsp;</a></span>lines</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structAffineConstraints_1_1ConstraintLine.html">ConstraintLine</a>&gt; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储矩阵的行数。 条目通常是以任意顺序追加的，插入到向量中最好在最后进行，所以在所有条目插入后，顺序是不指定的。对条目的排序是在调用<code><a class="el" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close()</a></code>函数时进行的。 我们可以不使用矢量，而是使用一个关联数组，像地图一样来存储这些行。然而，这将意味着一个更加碎片化的堆，因为它要分配许多小对象，而且还会使这个矩阵的使用变得更加缓慢。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01472">1472</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="ac4a78094a8ee36dc8f1af979958ecf05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4a78094a8ee36dc8f1af979958ecf05">&#9670;&nbsp;</a></span>lines_cache</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classAffineConstraints.html#a0a7ce3525c69e7b5bba3a0dd03f0dead">size_type</a>&gt; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::lines_cache</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个size_type的列表，包含受限自由度的ConstraintLine的位置，如果自由度不受限，则为 <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> 。 <a class="el" href="namespacenumbers.html#aed814969c852ea1a9aa050cf02b73b80">numbers::invalid_size_type</a> 的返回值因此返回是否有一个给定自由度指数的约束线。请注意，这个类对自由度的实际数量没有概念，所以如果我们检查某个自由度是否有约束线，那么这个向量实际上可能比我们检查的自由度的索引短。 这个字段的存在是因为当添加一个新的约束线时，我们必须弄清楚它是否已经存在。以前，我们只是简单地在未排序的约束行列表中行走，直到我们碰到终点或找到它。如果N是约束条件的数量，这个算法是O(N)，这使得它在插入所有约束条件时是O(N^2)。对于有许多约束条件的大问题来说，这很容易占用总运行时间的5-10。有了这个领域，我们可以节省这个时间，因为我们在O(1)时间内找到任何约束条件，或者得到它某个自由度不受约束。 更糟糕的是，遍历现有的约束列表需要从内存的许多不同地方读取。因此，在大型3D应用中，add_line()函数在整个计算时间中表现得非常突出，主要是因为它产生了大量的高速缓存缺失。 这也应该通过使用O(1)算法来访问这个数组的字段来解决。 这个字段在其他一些情况下也很有用，例如，当人们需要随机访问约束条件时，就像所有在飞行中应用约束条件的函数一样，同时将单元贡献添加到向量和矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01484">1484</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a7d5ecc66d3618beb896dc162462ae836"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d5ecc66d3618beb896dc162462ae836">&#9670;&nbsp;</a></span>local_lines</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::local_lines</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个IndexSet是用来限制保存在AffineConstraints中的行数的子集。这是必要的，因为在分布式计算中，lines_cache向量会变得太大。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01490">1490</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a2cacb6fdc27f68b1db0766faff484604"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cacb6fdc27f68b1db0766faff484604">&#9670;&nbsp;</a></span>sorted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::sorted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储数组是否被排序。 如果是，就不能添加新的条目。 </p>

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01496">1496</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<a id="a25dd838dee6db05afec001e52e414f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25dd838dee6db05afec001e52e414f95">&#9670;&nbsp;</a></span>scratch_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number = double&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classThreads_1_1ThreadLocalStorage.html">Threads::ThreadLocalStorage</a>&lt; internal::AffineConstraints::ScratchData&lt;number&gt; &gt; <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;::scratch_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="affine__constraints_8h_source.html#l01500">1500</a> of file <a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="affine__constraints_8h_source.html">affine_constraints.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
