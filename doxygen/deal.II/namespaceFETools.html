<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceFETools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FETools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools Namespace Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFETools_1_1Compositing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html">Compositing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40473770b86f7d4b77476097c88aaa55"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40473770b86f7d4b77476097c88aaa55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a40473770b86f7d4b77476097c88aaa55">compute_component_wise</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;start_indices)</td></tr>
<tr class="separator:a40473770b86f7d4b77476097c88aaa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad7f8f27696c0adadc316996b7281f096">compute_block_renumbering</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;block_data, <a class="el" href="classbool.html">bool</a> return_start_indices=true)</td></tr>
<tr class="separator:ad7f8f27696c0adadc316996b7281f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19348513588a636f95b32d91df5b49f0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a19348513588a636f95b32d91df5b49f0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a19348513588a636f95b32d91df5b49f0">hierarchic_to_lexicographic_numbering</a> (unsigned <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="separator:a19348513588a636f95b32d91df5b49f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854e39f9616b52536bdece5e8ec837c4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a854e39f9616b52536bdece5e8ec837c4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a854e39f9616b52536bdece5e8ec837c4">lexicographic_to_hierarchic_numbering</a> (unsigned <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="separator:a854e39f9616b52536bdece5e8ec837c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad677362df1413e1ccc8a2cf7aff19d07"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:ad677362df1413e1ccc8a2cf7aff19d07"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad677362df1413e1ccc8a2cf7aff19d07">get_fe_by_name</a> (const std::string &amp;name)</td></tr>
<tr class="separator:ad677362df1413e1ccc8a2cf7aff19d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name</a> (const std::string &amp;name, const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *factory)</td></tr>
<tr class="separator:a5a006641198ca5641c5c8ae20b741b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7c886f1760c13445c576d442e82656"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7a7c886f1760c13445c576d442e82656">DeclException1</a> (ExcInvalidFEName, std::string,&lt;&lt; &quot;Can't re-generate a finite element from the string '&quot;&lt;&lt; arg1&lt;&lt; &quot;'.&quot;)</td></tr>
<tr class="separator:ga7a7c886f1760c13445c576d442e82656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa495d33626165d02e2bac6c66b7aecfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa495d33626165d02e2bac6c66b7aecfa">DeclException2</a> (ExcInvalidFEDimension, char, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The dimension &quot;&lt;&lt; arg1&lt;&lt; &quot; in the finite element string must match &quot;&lt;&lt; &quot;the space dimension &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gaa495d33626165d02e2bac6c66b7aecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48230ff349d3d9df373d7cc4366ec62f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga48230ff349d3d9df373d7cc4366ec62f">DeclException0</a> (ExcInvalidFE)</td></tr>
<tr class="separator:ga48230ff349d3d9df373d7cc4366ec62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f9f7b18f75644cafa9126c29999c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga25f9f7b18f75644cafa9126c29999c70">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:ga25f9f7b18f75644cafa9126c29999c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6bdd9293a64902fb95d7a9f28cf7f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0d6bdd9293a64902fb95d7a9f28cf7f6">DeclException0</a> (ExcTriangulationMismatch)</td></tr>
<tr class="separator:ga0d6bdd9293a64902fb95d7a9f28cf7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45022976b3baef58649629d717da2024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga45022976b3baef58649629d717da2024">DeclExceptionMsg</a> (ExcHangingNodesNotAllowed, &quot;You are using continuous elements on a grid with &quot; &quot;hanging nodes but without providing hanging node &quot; &quot;constraints. Use the respective function with &quot; &quot;additional <a class="el" href="classAffineConstraints.html">AffineConstraints</a> argument(s), instead.&quot;)</td></tr>
<tr class="separator:ga45022976b3baef58649629d717da2024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e">DeclException0</a> (ExcGridNotRefinedAtLeastOnce)</td></tr>
<tr class="separator:gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7212ae8c27a23737206debe97f31387a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7212ae8c27a23737206debe97f31387a">DeclException4</a> (ExcMatrixDimensionMismatch, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;This is a &quot;&lt;&lt; arg1&lt;&lt; &quot;x&quot;&lt;&lt; arg2&lt;&lt; &quot; matrix, &quot;&lt;&lt; &quot;but should be a &quot;&lt;&lt; arg3&lt;&lt; &quot;x&quot;&lt;&lt; arg4&lt;&lt; &quot; matrix.&quot;)</td></tr>
<tr class="separator:ga7212ae8c27a23737206debe97f31387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3477f9cc7014a27d957882c129bdfbab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3477f9cc7014a27d957882c129bdfbab">DeclException1</a> (ExcLeastSquaresError, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;Least squares fit leaves a gap of &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga3477f9cc7014a27d957882c129bdfbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528bcabaac09e43acd643fe8e9535233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga528bcabaac09e43acd643fe8e9535233">DeclException2</a> (ExcNotGreaterThan, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; arg1&lt;&lt; &quot; must be greater than &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga528bcabaac09e43acd643fe8e9535233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Generation of local matrices</div></td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1e885987df913c64885ece9034b5c44">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:ab1e885987df913c64885ece9034b5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a3a6ade80f618ca06382d4cdc04cc0940">get_back_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aeebb94b65dba9e3790ea358afbc0d274">get_interpolation_difference_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;difference_matrix)</td></tr>
<tr class="separator:aeebb94b65dba9e3790ea358afbc0d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a415b74d2b5da88cfc78d8ef00f0bbfab">get_projection_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;matrix)</td></tr>
<tr class="separator:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f31747a809637e571e11c146d9bec0a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9f31747a809637e571e11c146d9bec0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a9f31747a809637e571e11c146d9bec0a">compute_node_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:a9f31747a809637e571e11c146d9bec0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e9897aeecf21a6aa7bbde0d3786418"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a47e9897aeecf21a6aa7bbde0d3786418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a47e9897aeecf21a6aa7bbde0d3786418">compute_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;matrices, const <a class="el" href="classbool.html">bool</a> isotropic_only=false, const <a class="el" href="classdouble.html">double</a> threshold=1.e-12)</td></tr>
<tr class="separator:a47e9897aeecf21a6aa7bbde0d3786418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ac0fe5c7f55db091a4477af7c3989b83c">compute_face_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;matrices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_face], const unsigned <a class="el" href="classint.html">int</a> face_coarse, const unsigned <a class="el" href="classint.html">int</a> face_fine, const <a class="el" href="classdouble.html">double</a> threshold=1.e-12)</td></tr>
<tr class="separator:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a37e353110a68710928c7dddd6b7823"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a4a37e353110a68710928c7dddd6b7823"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4a37e353110a68710928c7dddd6b7823">compute_projection_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;matrices, const <a class="el" href="classbool.html">bool</a> isotropic_only=false)</td></tr>
<tr class="separator:a4a37e353110a68710928c7dddd6b7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">compute_projection_from_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;rhs_quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X)</td></tr>
<tr class="separator:ab1a0545c897ee022029f8c5f2c252735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">compute_interpolation_to_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;I_q)</td></tr>
<tr class="separator:a860d229b5510b389a562ed701ad83811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd2ab2f8f14ccd863622435f89b6003"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aefd2ab2f8f14ccd863622435f89b6003"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aefd2ab2f8f14ccd863622435f89b6003">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:aefd2ab2f8f14ccd863622435f89b6003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee2da397d9ab5f23311718f36beab37"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a8ee2da397d9ab5f23311718f36beab37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a8ee2da397d9ab5f23311718f36beab37">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:a8ee2da397d9ab5f23311718f36beab37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac9c1094e73f795698d92abb7186189"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aeac9c1094e73f795698d92abb7186189"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aeac9c1094e73f795698d92abb7186189">compute_projection_from_face_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;rhs_quadrature, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X)</td></tr>
<tr class="separator:aeac9c1094e73f795698d92abb7186189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c5ec077c4ee4709660cac48bda3ad7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aa2c5ec077c4ee4709660cac48bda3ad7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aa2c5ec077c4ee4709660cac48bda3ad7">convert_generalized_support_point_values_to_dof_values</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt;&gt; &amp;support_point_values, std::vector&lt; number &gt; &amp;dof_values)</td></tr>
<tr class="separator:aa2c5ec077c4ee4709660cac48bda3ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Functions which should be in DoFTools</div></td></tr>
<tr class="memitem:ad29759cb8c51f8d369a371f63be8dde0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:ad29759cb8c51f8d369a371f63be8dde0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:ad29759cb8c51f8d369a371f63be8dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e304ff8b98435584fb57adeefdd1cc9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a7e304ff8b98435584fb57adeefdd1cc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a7e304ff8b98435584fb57adeefdd1cc9">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints, OutVector &amp;u2)</td></tr>
<tr class="separator:a7e304ff8b98435584fb57adeefdd1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a0a52af833b660bc126260df08d3df"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:af0a0a52af833b660bc126260df08d3df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#af0a0a52af833b660bc126260df08d3df">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:af0a0a52af833b660bc126260df08d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b159783856eda8acecbc848717a45"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:aa78b159783856eda8acecbc848717a45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aa78b159783856eda8acecbc848717a45">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:aa78b159783856eda8acecbc848717a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95cb15c14873edca68d26be66c1330"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a4c95cb15c14873edca68d26be66c1330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4c95cb15c14873edca68d26be66c1330">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a4c95cb15c14873edca68d26be66c1330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">project_dg</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab2c5f72f3b99909fdf7d7bb215792400">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;z2)</td></tr>
<tr class="separator:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b0fbfad93e11649be719c2aed1ee4d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a88b0fbfad93e11649be719c2aed1ee4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a88b0fbfad93e11649be719c2aed1ee4d">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints, OutVector &amp;z2)</td></tr>
<tr class="separator:a88b0fbfad93e11649be719c2aed1ee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace offers interpolations and extrapolations of discrete functions of one <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe1</code> to another <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe2</code>.</p>
<p>It also provides the local interpolation matrices that interpolate on each cell. Furthermore it provides the difference matrix \(id-I_h\) that is needed for evaluating \((id-I_h)z\) for e.g. the dual solution \(z\).</p>
<p>For more information about the <code>spacedim</code> template parameter check the documentation of <a class="el" href="classFiniteElement.html">FiniteElement</a> or the one of <a class="el" href="classTriangulation.html">Triangulation</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a40473770b86f7d4b77476097c88aaa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40473770b86f7d4b77476097c88aaa55">&#9670;&nbsp;</a></span>compute_component_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>start_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>In most cases, you will probably want to use compute_base_renumbering().</dd></dl>
<p>Compute the vector required to renumber the dofs of a cell by component. Furthermore, compute the vector storing the start indices of each component in the local block vector.</p>
<p>The second vector is organized such that there is a vector for each base element containing the start index for each component served by this base element.</p>
<p>While the first vector is checked to have the correct size, the second one is reinitialized for convenience. </p>

</div>
</div>
<a id="ad7f8f27696c0adadc316996b7281f096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f8f27696c0adadc316996b7281f096">&#9670;&nbsp;</a></span>compute_block_renumbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_block_renumbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>return_start_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the vector required to renumber the dofs of a cell by block. Furthermore, compute the vector storing either the start indices or the size of each local block vector.</p>
<p>If the <code>bool</code> parameter is true, <code>block_data</code> is filled with the start indices of each local block. If it is false, then the block sizes are returned.</p>
<p>The vector <code>renumbering</code> will be indexed by the standard numbering of local degrees of freedom, namely the first vertex, then the second vertex, after vertices lines, quads, and hexes. For each index, the entry indicates the index which this degree of freedom receives in a numbering scheme, where the first block is numbered completely before the second. </p>

</div>
</div>
<a id="ab1e885987df913c64885ece9034b5c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e885987df913c64885ece9034b5c44">&#9670;&nbsp;</a></span>get_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation matrix that interpolates a <code>fe1-function</code> to a <code>fe2-function</code> on each cell. The interpolation_matrix needs to be of size <code>(fe2.n_dofs_per_cell(), fe1.n_dofs_per_cell())</code>.</p>
<p>Note, that if the finite element space <code>fe1</code> is a subset of the finite element space <code>fe2</code> then the <code>interpolation_matrix</code> is an embedding matrix. </p>

</div>
</div>
<a id="a3a6ade80f618ca06382d4cdc04cc0940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6ade80f618ca06382d4cdc04cc0940">&#9670;&nbsp;</a></span>get_back_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_back_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation matrix that interpolates a <code>fe1-function</code> to a <code>fe2-function</code>, and interpolates this to a second <code>fe1-function</code> on each cell. The interpolation_matrix needs to be of size <code>(fe1.n_dofs_per_cell(), fe1.n_dofs_per_cell())</code>.</p>
<p>Note, that this function only makes sense if the finite element space due to <code>fe1</code> is not a subset of the finite element space due to <code>fe2</code>, as if it were a subset then the <code>interpolation_matrix</code> would be only the unit matrix. </p>

</div>
</div>
<a id="aeebb94b65dba9e3790ea358afbc0d274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb94b65dba9e3790ea358afbc0d274">&#9670;&nbsp;</a></span>get_interpolation_difference_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_difference_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the identity matrix minus the back interpolation matrix. The <code>difference_matrix</code> will be of size <code>(fe1.n_dofs_per_cell(), fe1.n_dofs_per_cell())</code> after this function. Previous content of the argument will be overwritten.</p>
<p>This function computes the matrix that transforms a <code>fe1</code> function \(z\) to \(z-I_hz\) where \(I_h\) denotes the interpolation operator from the <code>fe1</code> space to the <code>fe2</code> space. This matrix hence is useful to evaluate error-representations where \(z\) denotes the dual solution. </p>

</div>
</div>
<a id="a415b74d2b5da88cfc78d8ef00f0bbfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415b74d2b5da88cfc78d8ef00f0bbfab">&#9670;&nbsp;</a></span>get_projection_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_projection_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the local \(L^2\)-projection matrix from fe1 to fe2. </p>

</div>
</div>
<a id="a9f31747a809637e571e11c146d9bec0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f31747a809637e571e11c146d9bec0a">&#9670;&nbsp;</a></span>compute_node_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; FETools::compute_node_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a rather specialized function used during the construction of finite element objects. It is used to build the basis of shape functions for an element, given a set of polynomials and interpolation points. The function is only implemented for finite elements with exactly <code>dim</code> vector components. In particular, this applies to classes derived from the <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a> class.</p>
<p>Specifically, the purpose of this function is as follows: <a class="el" href="classFE__PolyTensor.html">FE_PolyTensor</a> receives, from its derived classes, an argument that describes a polynomial space. This space may be parameterized in terms of monomials, or in some other way, but is in general not in the form that we use for finite elements where we typically want to use a basis that is derived from some kind of node functional (e.g., the interpolation at specific points). Concretely, assume that the basis used by the polynomial space is \(\{\tilde\varphi_j(\mathbf x)\}_{j=1}^N\), and that the node functionals of the finite element are \(\{\Psi_i\}_{i=1}^N\). We then want to compute a basis \(\{\varphi_j(\mathbf x)\}_{j=1}^N\) for the finite element space so that \(\Psi_i[\varphi_j] = \delta_{ij}\). To do this, we can set \(\varphi_j(\mathbf x) = \sum_{k=1}^N c_{jk} \tilde\varphi_k(\mathbf x)\) where we need to determine the expansion coefficients \(c_{jk}\). We do this by applying \(\Psi_i\) to both sides of the equation, to obtain </p><p class="formulaDsp">
\begin{align*} \Psi_i [\varphi_j] = \sum_{k=1}^N c_{jk} \Psi_i[\tilde\varphi_k], \end{align*}
</p>
<p> and we know that the left hand side equals \(\delta_{ij}\). If you think of this as a system of \(N\times N\) equations for the elements of a matrix on the left and on the right, then this can be written as </p><p class="formulaDsp">
\begin{align*} I = C X^T \end{align*}
</p>
<p> where \(C\) is the matrix of coefficients \(c_{jk}\) and \(X_{ik} = \Psi_i[\tilde\varphi_k]\). Consequently, in order to compute the expansion coefficients \(C=X^{-T}\), we need to apply the node functionals to all functions of the "raw" basis of the polynomial space.</p>
<p>Until the finite element receives this matrix \(X\) back, it describes its shape functions (e.g., in <a class="el" href="classFiniteElement.html#ada115873f976e6078b3990ac28a70ea1">FiniteElement::shape_value()</a>) in the form \(\tilde\varphi_j\). After it calls this function, it has the expansion coefficients and can describe its shape functions as \(\varphi_j\).</p>
<p>This function therefore computes this matrix \(X\), for the following specific circumstances:</p><ul>
<li>That the node functionals \(\Psi_i\) are point evaluations at points \(\mathbf x_i\) that the finite element in question describes via its "generalized" support points (through <a class="el" href="classFiniteElement.html#a14b9d0a87e17f83f6a9abe50375b5543">FiniteElement::get_generalized_support_points()</a>, see also <a class="el" href="DEALGlossary.html#GlossGeneralizedSupport">this glossary entry</a>). These point evaluations need to necessarily evaluate the <em>value</em> of a shape function at that point (the shape function may be vector-valued, and so the functional may be a linear combination of the individual components of the values); but, in particular, the nodal functions may not be <em>integrals</em> over entire edges or faces, or other non-local functionals. In other words, we assume that \(\Psi_i[\tilde\varphi_j] = f_j(\tilde\varphi_j(\mathbf x_i))\) where \(f_j\) is a function of the (possibly vector-valued) argument that returns a scalar.</li>
<li>That the finite element has exactly <code>dim</code> vector components.</li>
<li>That the function \(f_j\) is given by whatever the element implements through the <a class="el" href="classFiniteElement.html#a5dfedd72fb0bd1c9daf2701015edac5f">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> function.</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element for which the operations above are to be performed. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The matrix \(X\) as discussed above. </dd></dl>

</div>
</div>
<a id="a47e9897aeecf21a6aa7bbde0d3786418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e9897aeecf21a6aa7bbde0d3786418">&#9670;&nbsp;</a></span>compute_embedding_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1.e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all possible (isotropic and anisotropic) refinement cases compute the embedding matrices from a coarse cell to the child cells. Each column of the resulting matrices contains the representation of a coarse grid basis function by the fine grid basis; the matrices are split such that there is one matrix for every child.</p>
<p>This function computes the coarse grid function in a sufficiently large number of quadrature points and fits the fine grid functions using least squares approximation. Therefore, the use of this function is restricted to the case that the finite element spaces are actually nested.</p>
<p>Note, that <code>matrices[refinement_case-1][child]</code> includes the embedding (or prolongation) matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no prolongation matrices available.</p>
<p>Typically this function is called by the various implementations of <a class="el" href="classFiniteElement.html">FiniteElement</a> classes in order to fill the respective <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">FiniteElement::prolongation</a> matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element class for which we compute the embedding matrices.</td></tr>
    <tr><td class="paramname">matrices</td><td>A reference to <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8aadbd360e28038a2c4f89f7af40475b7c">RefinementCase&lt;dim&gt;::isotropic_refinement</a> vectors of <a class="el" href="classFullMatrix.html">FullMatrix</a> objects. Each vector corresponds to one <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code> and is of the vector size GeometryInfo&lt;dim&gt;::n_children(refinement_case). This is the format used in <a class="el" href="classFiniteElement.html">FiniteElement</a>, where we want to use this function mostly.</td></tr>
    <tr><td class="paramname">isotropic_only</td><td>Set to <code>true</code> if you only want to compute matrices for isotropic refinement.</td></tr>
    <tr><td class="paramname">threshold</td><td>is the gap allowed in the least squares algorithm computing the embedding. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0fe5c7f55db091a4477af7c3989b83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fe5c7f55db091a4477af7c3989b83c">&#9670;&nbsp;</a></span>compute_face_embedding_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_face_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>matrices</em>[GeometryInfo&lt; dim &gt;::max_children_per_face], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1.e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the embedding matrices on faces needed for constraint matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>The finite element for which to compute these matrices.</td></tr>
    <tr><td class="paramname">matrices</td><td>An array of <em>GeometryInfo&lt;dim&gt;::subfaces_per_face = 2<sup>dim-1</sup></em> <a class="el" href="classFullMatrix.html">FullMatrix</a> objects,holding the embedding matrix for each subface.</td></tr>
    <tr><td class="paramname">face_coarse</td><td>The number of the face on the coarse side of the face for which this is computed.</td></tr>
    <tr><td class="paramname">face_fine</td><td>The number of the face on the refined side of the face for which this is computed.</td></tr>
    <tr><td class="paramname">threshold</td><td>is the gap allowed in the least squares algorithm computing the embedding.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>This function will be used in computing constraint matrices. It is not sufficiently tested yet. </dd></dl>

</div>
</div>
<a id="a4a37e353110a68710928c7dddd6b7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a37e353110a68710928c7dddd6b7823">&#9670;&nbsp;</a></span>compute_projection_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all possible (isotropic and anisotropic) refinement cases compute the <em>L<sup>2</sup></em>-projection matrices from the children to a coarse cell.</p>
<p>Note, that <code>matrices[refinement_case-1][child]</code> includes the projection (or restriction) matrix of child <code>child</code> for the <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code>. Here, we use <code>refinement_case-1</code> instead of <code>refinement_case</code> as for <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) there are no projection matrices available.</p>
<p>Typically this function is called by the various implementations of <a class="el" href="classFiniteElement.html">FiniteElement</a> classes in order to fill the respective <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">FiniteElement::restriction</a> matrices.</p>
<ul>
<li>[in] fe The finite element class for which we compute the projection matrices.</li>
</ul>
<ul>
<li>[out] matrices A reference to a set of <code><a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8aadbd360e28038a2c4f89f7af40475b7c">RefinementCase&lt;dim&gt;::isotropic_refinement</a></code> vectors of <a class="el" href="classFullMatrix.html">FullMatrix</a> objects. Each vector corresponds to one <a class="el" href="classRefinementCase.html">RefinementCase</a> <code>refinement_case</code> and is of the vector size <code>GeometryInfo&lt;dim&gt;::n_children(refinement_case)</code>. This is the format used in <a class="el" href="classFiniteElement.html">FiniteElement</a>, where we want to use this function mostly.</li>
</ul>
<ul>
<li>[in] isotropic_only If set to <code>true</code>, then this function only computes data for the isotropic refinement case. The other elements of the output vector are left untouched (but still exist). </li>
</ul>

</div>
</div>
<a id="ab1a0545c897ee022029f8c5f2c252735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a0545c897ee022029f8c5f2c252735">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Project scalar data defined in quadrature points to a finite element space on a single cell.</p>
<p>What this function does is the following: assume that there is scalar data <code>u<sub>q</sub>, 0 &lt;= q &lt; Q:=quadrature.size()</code> defined at the quadrature points of a cell, with the points defined by the given <code>rhs_quadrature</code> object. We may then want to ask for that finite element function (on a single cell) <code>v<sub>h</sub></code> in the finite- dimensional space defined by the given FE object that is the projection of <code>u</code> in the following sense:</p>
<p>Usually, the projection <code>v<sub>h</sub></code> is that function that satisfies <code>(v<sub>h</sub>,w)=(u,w)</code> for all discrete test functions <code>w</code>. In the present case, we can't evaluate the right hand side, since <code>u</code> is only defined in the quadrature points given by <code>rhs_quadrature</code>, so we replace it by a quadrature approximation. Likewise, the left hand side is approximated using the <code>lhs_quadrature</code> object; if this quadrature object is chosen appropriately, then the integration of the left hand side can be done exactly, without any approximation. The use of different quadrature objects is necessary if the quadrature object for the right hand side has too few quadrature points &ndash; for example, if data <code>q</code> is only defined at the cell center, then the corresponding one-point quadrature formula is obviously insufficient to approximate the scalar product on the left hand side by a definite form.</p>
<p>After these quadrature approximations, we end up with a nodal representation <code>V<sub>h</sub></code> of <code>v<sub>h</sub></code> that satisfies the following system of linear equations: <code>M V<sub>h</sub> = Q U</code>, where <code>M<sub>ij</sub>=(phi_i,phi_j)</code> is the mass matrix approximated by <code>lhs_quadrature</code>, and <code>Q</code> is the matrix <code>Q<sub>iq</sub>=phi<sub>i</sub>(x<sub>q</sub>) w<sub>q</sub></code> where <code>w<sub>q</sub></code> are quadrature weights; <code>U</code> is the vector of quadrature point data <code>u<sub>q</sub></code>.</p>
<p>In order to then get the nodal representation <code>V<sub>h</sub></code> of the projection of <code>U</code>, one computes <code>V<sub>h</sub> = X U, X=M<sup>-1</sup> Q</code>. The purpose of this function is to compute the matrix <code>X</code> and return it through the last argument of this function.</p>
<p>Note that this function presently only supports scalar data. An extension of the mass matrix is of course trivial, but one has to define the order of data in the vector <code>U</code> if it contains vector valued data in all quadrature points.</p>
<p>A use for this function is described in the introduction to the step-18 example program.</p>
<p>The opposite of this function, interpolation of a finite element function onto quadrature points is essentially what the <code><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a></code> functions do; to make things a little simpler, the <code><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">FETools::compute_interpolation_to_quadrature_points_matrix</a></code> provides the matrix form of this.</p>
<p>Note that this function works on a single cell, rather than an entire triangulation. In effect, it therefore doesn't matter if you use a continuous or discontinuous version of the finite element.</p>
<p>It is worth noting that there are a few confusing cases of this function. The first one is that it really only makes sense to project onto a finite element that has at most as many degrees of freedom per cell as there are quadrature points; the projection of N quadrature point data into a space with M&gt;N unknowns is well-defined, but often yields funny and non- intuitive results. Secondly, one would think that if the quadrature point data is defined in the support points of the finite element, i.e. the quadrature points of <code>ths_quadrature</code> equal <code>fe.get_unit_support_points()</code>, then the projection should be the identity, i.e. each degree of freedom of the finite element equals the value of the given data in the support point of the corresponding shape function. However, this is not generally the case: while the matrix <code>Q</code> in that case is the identity matrix, the mass matrix <code>M</code> is not equal to the identity matrix, except for the special case that the quadrature formula <code>lhs_quadrature</code> also has its quadrature points in the support points of the finite element.</p>
<p>Finally, this function only defines a cell wise projection, while one frequently wants to apply it to all cells in a triangulation. However, if it is applied to one cell after the other, the results from later cells may overwrite nodal values computed already from previous cells if degrees of freedom live on the interfaces between cells. The function is therefore most useful for discontinuous elements. </p>

</div>
</div>
<a id="a860d229b5510b389a562ed701ad83811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860d229b5510b389a562ed701ad83811">&#9670;&nbsp;</a></span>compute_interpolation_to_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_interpolation_to_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a (scalar) local finite element function, compute the matrix that maps the vector of nodal values onto the vector of values of this function at quadrature points as given by the second argument. In a sense, this function does the opposite of the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> function. </p>

</div>
</div>
<a id="aefd2ab2f8f14ccd863622435f89b6003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd2ab2f8f14ccd863622435f89b6003">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the projection of tensorial (first-order tensor) data stored at the quadrature points <code>vector_of_tensors_at_qp</code> to data <code>vector_of_tensors_at_nodes</code> at the support points of the cell. The data in <code>vector_of_tensors_at_qp</code> is ordered sequentially following the quadrature point numbering. The size of <code>vector_of_tensors_at_qp</code> must correspond to the number of columns of <code>projection_matrix</code>. The size of <code>vector_of_tensors_at_nodes</code> must correspond to the number of rows of <code>vector_of_tensors_at_nodes</code> . The projection matrix <code>projection_matrix</code> describes the projection of scalar data from the quadrature points and can be obtained from the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> function. </p>

</div>
</div>
<a id="a8ee2da397d9ab5f23311718f36beab37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee2da397d9ab5f23311718f36beab37">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>same as last function but for a <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> . </p>

</div>
</div>
<a id="aeac9c1094e73f795698d92abb7186189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac9c1094e73f795698d92abb7186189">&#9670;&nbsp;</a></span>compute_projection_from_face_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_face_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method implements the <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> method for faces of a mesh. The matrix that it returns, X, is face specific and its size is fe.n_dofs_per_cell() by rhs_quadrature.size(). The dimension, dim must be larger than 1 for this class, since <a class="el" href="classQuadrature.html">Quadrature</a>&lt;dim-1&gt; objects are required. See the documentation on the <a class="el" href="classQuadrature.html">Quadrature</a> class for more information. </p>

</div>
</div>
<a id="aa2c5ec077c4ee4709660cac48bda3ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c5ec077c4ee4709660cac48bda3ad7">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper around <a class="el" href="classFiniteElement.html#a5dfedd72fb0bd1c9daf2701015edac5f">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> that works with arbitrary number types.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">finite_element</td><td>The <a class="el" href="classFiniteElement.html">FiniteElement</a> to compute dof values for. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support_point_values</td><td>An array of size <code>dofs_per_cell</code> (which equals the number of points the get_generalized_support_points() function will return) where each element is a vector with as many entries as the element has vector components. This array should contain the values of a function at the generalized support points of the finite element. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dof_values</td><td>An array of size <code>dofs_per_cell</code> that contains the node functionals of the element applied to the given function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad29759cb8c51f8d369a371f63be8dde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29759cb8c51f8d369a371f63be8dde0">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of a the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>. <code>dof1</code> and <code>dof2</code> need to be DoFHandlers based on the same triangulation.</p>
<p>If the elements <code>fe1</code> and <code>fe2</code> are either both continuous or both discontinuous then this interpolation is the usual point interpolation. The same is true if <code>fe1</code> is a continuous and <code>fe2</code> is a discontinuous finite element. For the case that <code>fe1</code> is a discontinuous and <code>fe2</code> is a continuous finite element there is no point interpolation defined at the discontinuities. Therefore the mean value is taken at the DoF values on the discontinuities.</p>
<p>Note that for continuous elements on grids with hanging nodes (i.e. locally refined grids) this function does not give the expected output. Indeed, the resulting output vector does not necessarily respect continuity requirements at hanging nodes: if, for example, you are interpolating a Q2 field to a Q1 field, then at hanging nodes the output field will have the function value of the input field, which however is not usually the mean value of the two adjacent nodes. It is thus not part of the Q1 function space on the whole triangulation, although it is of course Q1 on each cell.</p>
<p>For this case (continuous elements on grids with hanging nodes), please use the <code><a class="el" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">interpolate()</a></code> function with an additional <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object as argument, see below, or make the field conforming yourself by calling the <code>distribute</code> function of your hanging node constraints object. </p>

</div>
</div>
<a id="a7e304ff8b98435584fb57adeefdd1cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e304ff8b98435584fb57adeefdd1cc9">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of a the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code> <code>u2</code>. <code>dof1</code> and <code>dof2</code> need to be DoFHandlers based on the same triangulation. <code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is particular important when interpolating onto continuous elements on grids with hanging nodes (locally refined grids).</p>
<p>If the elements <code>fe1</code> and <code>fe2</code> are either both continuous or both discontinuous then this interpolation is the usual point interpolation. The same is true if <code>fe1</code> is a continuous and <code>fe2</code> is a discontinuous finite element. For the case that <code>fe1</code> is a discontinuous and <code>fe2</code> is a continuous finite element there is no point interpolation defined at the discontinuities. Therefore the mean value is taken at the DoF values at the discontinuities. </p>

</div>
</div>
<a id="af0a0a52af833b660bc126260df08d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a0a52af833b660bc126260df08d3df">&#9670;&nbsp;</a></span>back_interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of the <code>fe1-function</code> <code>u1</code> to a <code>fe2-function</code>, and interpolates this to a second <code>fe1-function</code> named <code>u1_interpolated</code>.</p>
<p>Note, that this function does not work on continuous elements at hanging nodes. For that case use the <code>back_interpolate</code> function, below, that takes an additional <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a></code> object.</p>
<p>Furthermore note, that for the specific case when the finite element space corresponding to <code>fe1</code> is a subset of the finite element space corresponding to <code>fe2</code>, this function is simply an identity mapping. </p>

</div>
</div>
<a id="aa78b159783856eda8acecbc848717a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78b159783856eda8acecbc848717a45">&#9670;&nbsp;</a></span>back_interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the interpolation of the <code>dof1-function</code> <code>u1</code> to a <code>dof2-function</code>, and interpolates this to a second <code>dof1-function</code> named <code>u1_interpolated</code>. <code>constraints1</code> and <code>constraints2</code> are the hanging node constraints corresponding to <code>dof1</code> and <code>dof2</code>, respectively. These objects are particular important when continuous elements on grids with hanging nodes (locally refined grids) are involved.</p>
<p>Furthermore note, that for the specific case when the finite element space corresponding to <code>dof1</code> is a subset of the finite element space corresponding to <code>dof2</code>, this function is simply an identity mapping. </p>

</div>
</div>
<a id="a0f2e45e9f0117e1ae3ca704885c96ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2e45e9f0117e1ae3ca704885c96ebc">&#9670;&nbsp;</a></span>interpolation_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute \((Id-I_h)z_1\) for a given <code>dof1-function</code> \(z_1\), where \(I_h\) is the interpolation from <code>fe1</code> to <code>fe2</code>. The result \((Id-I_h)z_1\) is written into <code>z1_difference</code>.</p>
<p>Note, that this function does not work for continuous elements at hanging nodes. For that case use the <code>interpolation_difference</code> function, below, that takes an additional <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a></code> object. </p>

</div>
</div>
<a id="a4c95cb15c14873edca68d26be66c1330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95cb15c14873edca68d26be66c1330">&#9670;&nbsp;</a></span>interpolation_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute \((Id-I_h)z_1\) for a given <code>dof1-function</code> \(z_1\), where \(I_h\) is the interpolation from <code>fe1</code> to <code>fe2</code>. The result \((Id-I_h)z_1\) is written into <code>z1_difference</code>. <code>constraints1</code> and <code>constraints2</code> are the hanging node constraints corresponding to <code>dof1</code> and <code>dof2</code>, respectively. These objects are particular important when continuous elements on grids with hanging nodes (locally refined grids) are involved.</p>
<p>For parallel computations, supply <code>z1</code> with ghost elements and <code>z1_difference</code> without ghost elements. </p>

</div>
</div>
<a id="a2a3ad6cbc7cef0f14e60f3ae5a3a5115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">&#9670;&nbsp;</a></span>project_dg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::project_dg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(L^2\) projection for discontinuous elements. Operates the same direction as interpolate.</p>
<p>The global projection can be computed by local matrices if the finite element spaces are discontinuous. With continuous elements, this is impossible, since a global mass matrix must be inverted. </p>

</div>
</div>
<a id="ab2c5f72f3b99909fdf7d7bb215792400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c5f72f3b99909fdf7d7bb215792400">&#9670;&nbsp;</a></span>extrapolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the patchwise extrapolation of a <code>dof1</code> function <code>z1</code> to a <code>dof2</code> function <code>z2</code>. <code>dof1</code> and <code>dof2</code> need to be <a class="el" href="classDoFHandler.html">DoFHandler</a> objects based on the same triangulation. This function is used, for example, for extrapolating patchwise a piecewise linear solution to a piecewise quadratic solution.</p>
<p>The function's name is historical and probably not particularly well chosen. The function performs the following operations, one after the other:</p>
<ul>
<li>It interpolates directly from every cell of <code>dof1</code> to the corresponding cell of <code>dof2</code> using the interpolation matrix of the finite element spaces used on these cells and provided by the finite element objects involved. This step is done using the <a class="el" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate()</a> function.</li>
<li>It then performs a loop over all non-active cells of <code>dof2</code>. If such a non-active cell has at least one active child, then we call the children of this cell a "patch". We then interpolate from the children of this patch to the patch, using the finite element space associated with <code>dof2</code> and immediately interpolate back to the children. In essence, this information throws away all information in the solution vector that lives on a scale smaller than the patch cell.</li>
<li>Since we traverse non-active cells from the coarsest to the finest levels, we may find patches that correspond to child cells of previously treated patches if the mesh had been refined adaptively (this cannot happen if the mesh has been refined globally because there the children of a patch are all active). We also perform the operation described above on these patches, but it is easy to see that on patches that are children of previously treated patches, the operation is now the identity operation (since it interpolates from the children of the current patch a function that had previously been interpolated to these children from an even coarser patch). Consequently, this does not alter the solution vector any more.</li>
</ul>
<p>The name of the function originates from the fact that it can be used to construct a representation of a function of higher polynomial degree on a once coarser mesh. For example, if you imagine that you start with a \(Q_1\) function on a globally refined mesh, and that <code>dof2</code> is associated with a \(Q_2\) element, then this function computes the equivalent of the operator \(I_{2h}^{(2)}\) interpolating the original piecewise linear function onto a quadratic function on a once coarser mesh with mesh size \(2h\) (but representing this function on the original mesh with size \(h\)). If the exact solution is sufficiently smooth, then \(u^\ast=I_{2h}^{(2)}u_h\) is typically a better approximation to the exact solution \(u\) of the PDE than \(u_h\) is. In other words, this function provides a postprocessing step that improves the solution in a similar way one often obtains by extrapolating a sequence of solutions, explaining the origin of the function's name.</p>
<dl class="section note"><dt>Note</dt><dd>The resulting field does not satisfy continuity requirements of the given finite elements if the algorithm outlined above is used. When you use continuous elements on grids with hanging nodes, please use the <code>extrapolate</code> function with an additional <a class="el" href="classAffineConstraints.html">AffineConstraints</a> argument, see below.</dd>
<dd>
Since this function operates on patches of cells, it requires that the underlying grid is refined at least once for every coarse grid cell. If this is not the case, an exception will be raised. </dd></dl>

</div>
</div>
<a id="a88b0fbfad93e11649be719c2aed1ee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b0fbfad93e11649be719c2aed1ee4d">&#9670;&nbsp;</a></span>extrapolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the patchwise extrapolation of a <code>dof1</code> function <code>z1</code> to a <code>dof2</code> function <code>z2</code>. <code>dof1</code> and <code>dof2</code> need to be <a class="el" href="classDoFHandler.html">DoFHandler</a> objects based on the same triangulation. <code>constraints</code> is a hanging node constraints object corresponding to <code>dof2</code>. This object is necessary when interpolating onto continuous elements on grids with hanging nodes (locally refined grids).</p>
<p>Otherwise, the function does the same as the other <code>extrapolate</code> function above (for which the documentation provides an extensive description of its operation). </p>

</div>
</div>
<a id="a19348513588a636f95b32d91df5b49f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19348513588a636f95b32d91df5b49f0">&#9670;&nbsp;</a></span>hierarchic_to_lexicographic_numbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; FETools::hierarchic_to_lexicographic_numbering </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The numbering of the degrees of freedom in continuous finite elements is hierarchic, i.e. in such a way that we first number the vertex dofs, in the order of the vertices as defined by the triangulation, then the line dofs in the order and respecting the direction of the lines, then the dofs on quads, etc. However, we could have, as well, numbered them in a lexicographic way, i.e. with indices first running in x-direction, then in y-direction and finally in z-direction. Discontinuous elements of class <a class="el" href="classFE__DGQ.html">FE_DGQ()</a> are numbered in this way, for example.</p>
<p>This function returns a vector containing information about the lexicographic index each degree of freedom in the hierarchic numbering would have to a given degree of a continuous finite element. </p>

</div>
</div>
<a id="a854e39f9616b52536bdece5e8ec837c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854e39f9616b52536bdece5e8ec837c4">&#9670;&nbsp;</a></span>lexicographic_to_hierarchic_numbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; FETools::lexicographic_to_hierarchic_numbering </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is the reverse function to the above one, generating the map from the lexicographic to the hierarchical numbering for a given polynomial degree of a continuous finite element. All the remarks made about the above function are also valid here. </p>

</div>
</div>
<a id="ad677362df1413e1ccc8a2cf7aff19d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad677362df1413e1ccc8a2cf7aff19d07">&#9670;&nbsp;</a></span>get_fe_by_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt; FETools::get_fe_by_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the name of a finite element and generate a finite element object accordingly. The parser ignores space characters between words (things matching the regular expression [A-Za-z0-9_]).</p>
<p>The name must be in the form which is returned by the <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> function, where dimension template parameters &lt;2&gt; etc. can be omitted. Alternatively, the explicit number can be replaced by <code>dim</code> or <code>d</code>. If a number is given, it <b>must</b> match the template parameter of this function.</p>
<p>The names of <a class="el" href="classFESystem.html">FESystem</a> elements follow the pattern <code><a class="el" href="classFESystem.html">FESystem</a>[FE_Base1^p1-FE_Base2^p2]</code> The powers <code>p1</code> etc. may either be numbers or can be replaced by <code>dim</code> or <code>d</code>.</p>
<p>If no finite element can be reconstructed from this string, an exception of type <code>FETools::ExcInvalidFEName</code> is thrown.</p>
<p>The function returns a std::unique_ptr to a newly created finite element meaning the caller obtains ownership over the returned object.</p>
<p>Since the value of the template argument can't be deduced from the (string) argument given to this function, you have to explicitly specify it when you call this function.</p>
<p>This function knows about all the standard elements defined in the library. However, it doesn't by default know about elements that you may have defined in your program. To make your own elements known to this function, use the <a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name()</a> function. This function does not work if one wants to get a codimension 1 finite element. </p>

</div>
</div>
<a id="a5a006641198ca5641c5c8ae20b741b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a006641198ca5641c5c8ae20b741b4b">&#9670;&nbsp;</a></span>add_fe_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::add_fe_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extend the list of finite elements that can be generated by <a class="el" href="namespaceFETools.html#ad677362df1413e1ccc8a2cf7aff19d07">get_fe_by_name()</a> by the one given as <code>name</code>. If <a class="el" href="namespaceFETools.html#ad677362df1413e1ccc8a2cf7aff19d07">get_fe_by_name()</a> is later called with this name, it will use the object given as second argument to create a finite element object.</p>
<p>The format of the <code>name</code> parameter should include the name of a finite element. However, it is safe to use either the class name alone or to use the result of <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> (which includes the space dimension as well as the polynomial degree), since everything after the first non- name character will be ignored.</p>
<p>The <a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a> object should be an object newly created with <code>new</code>. <a class="el" href="namespaceFETools.html">FETools</a> will take ownership of this object and delete it once it is not used anymore.</p>
<p>In most cases, if you want objects of type <code>MyFE</code> be created whenever the name <code>my_fe</code> is given to get_fe_by_name, you will want the second argument to this function be of type <a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a>&lt;MyFE&gt;, but you can of course create your custom finite element factory class.</p>
<p>This function takes over ownership of the object given as second argument, i.e. you should never attempt to destroy it later on. The object will be deleted at the end of the program's lifetime.</p>
<p>If the name of the element is already in use, an exception is thrown. Thus, functionality of <a class="el" href="namespaceFETools.html#ad677362df1413e1ccc8a2cf7aff19d07">get_fe_by_name()</a> can only be added, not changed.</p>
<dl class="section note"><dt>Note</dt><dd>This function manipulates a global table (one table for each space dimension). It is thread safe in the sense that every access to this table is secured by a lock. Nevertheless, since each name can be added only once, user code has to make sure that only one thread adds a new element.</dd></dl>
<p>Note also that this table exists once for each space dimension. If you have a program that works with finite elements in different space dimensions (for example, step-4 does something like this), then you should call this function for each space dimension for which you want your finite element added to the map. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
