<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceFETools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FETools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools Namespace Reference<div class="ingroups"><a class="el" href="group__feall.html">Finite elements</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceFETools_1_1Compositing"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html">Compositing</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactory.html">FEFactory</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a40473770b86f7d4b77476097c88aaa55"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a40473770b86f7d4b77476097c88aaa55"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a40473770b86f7d4b77476097c88aaa55">compute_component_wise</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;renumbering, std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;start_indices)</td></tr>
<tr class="separator:a40473770b86f7d4b77476097c88aaa55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad7f8f27696c0adadc316996b7281f096"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad7f8f27696c0adadc316996b7281f096">compute_block_renumbering</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;renumbering, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;block_data, <a class="el" href="classbool.html">bool</a> return_start_indices=true)</td></tr>
<tr class="separator:ad7f8f27696c0adadc316996b7281f096"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19348513588a636f95b32d91df5b49f0"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a19348513588a636f95b32d91df5b49f0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a19348513588a636f95b32d91df5b49f0">hierarchic_to_lexicographic_numbering</a> (unsigned <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="separator:a19348513588a636f95b32d91df5b49f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a854e39f9616b52536bdece5e8ec837c4"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a854e39f9616b52536bdece5e8ec837c4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a854e39f9616b52536bdece5e8ec837c4">lexicographic_to_hierarchic_numbering</a> (unsigned <a class="el" href="classint.html">int</a> degree)</td></tr>
<tr class="separator:a854e39f9616b52536bdece5e8ec837c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad677362df1413e1ccc8a2cf7aff19d07"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim = dim&gt; </td></tr>
<tr class="memitem:ad677362df1413e1ccc8a2cf7aff19d07"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad677362df1413e1ccc8a2cf7aff19d07">get_fe_by_name</a> (const std::string &amp;name)</td></tr>
<tr class="separator:ad677362df1413e1ccc8a2cf7aff19d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a5a006641198ca5641c5c8ae20b741b4b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a5a006641198ca5641c5c8ae20b741b4b">add_fe_name</a> (const std::string &amp;name, const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *factory)</td></tr>
<tr class="separator:a5a006641198ca5641c5c8ae20b741b4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a7c886f1760c13445c576d442e82656"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7a7c886f1760c13445c576d442e82656">DeclException1</a> (ExcInvalidFEName, std::string,&lt;&lt; &quot;Can't re-generate a finite element from the string '&quot;&lt;&lt; arg1&lt;&lt; &quot;'.&quot;)</td></tr>
<tr class="separator:ga7a7c886f1760c13445c576d442e82656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa495d33626165d02e2bac6c66b7aecfa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaa495d33626165d02e2bac6c66b7aecfa">DeclException2</a> (ExcInvalidFEDimension, char, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The dimension &quot;&lt;&lt; arg1&lt;&lt; &quot; in the finite element string must match &quot;&lt;&lt; &quot;the space dimension &quot;&lt;&lt; arg2&lt;&lt; &quot;.&quot;)</td></tr>
<tr class="separator:gaa495d33626165d02e2bac6c66b7aecfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48230ff349d3d9df373d7cc4366ec62f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga48230ff349d3d9df373d7cc4366ec62f">DeclException0</a> (ExcInvalidFE)</td></tr>
<tr class="separator:ga48230ff349d3d9df373d7cc4366ec62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga25f9f7b18f75644cafa9126c29999c70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga25f9f7b18f75644cafa9126c29999c70">DeclException0</a> (ExcFENotPrimitive)</td></tr>
<tr class="separator:ga25f9f7b18f75644cafa9126c29999c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0d6bdd9293a64902fb95d7a9f28cf7f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga0d6bdd9293a64902fb95d7a9f28cf7f6">DeclException0</a> (ExcTriangulationMismatch)</td></tr>
<tr class="separator:ga0d6bdd9293a64902fb95d7a9f28cf7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga45022976b3baef58649629d717da2024"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga45022976b3baef58649629d717da2024">DeclExceptionMsg</a> (ExcHangingNodesNotAllowed, &quot;You are using continuous elements on a grid with &quot; &quot;hanging nodes but without providing hanging node &quot; &quot;constraints. Use the respective function with &quot; &quot;additional <a class="el" href="classAffineConstraints.html">AffineConstraints</a> argument(s), instead.&quot;)</td></tr>
<tr class="separator:ga45022976b3baef58649629d717da2024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e">DeclException0</a> (ExcGridNotRefinedAtLeastOnce)</td></tr>
<tr class="separator:gaaaa41a1d8fbdb49d6b91e6d49c5d3b2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7212ae8c27a23737206debe97f31387a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga7212ae8c27a23737206debe97f31387a">DeclException4</a> (ExcMatrixDimensionMismatch, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;This is a &quot;&lt;&lt; arg1&lt;&lt; &quot;x&quot;&lt;&lt; arg2&lt;&lt; &quot; matrix, &quot;&lt;&lt; &quot;but should be a &quot;&lt;&lt; arg3&lt;&lt; &quot;x&quot;&lt;&lt; arg4&lt;&lt; &quot; matrix.&quot;)</td></tr>
<tr class="separator:ga7212ae8c27a23737206debe97f31387a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3477f9cc7014a27d957882c129bdfbab"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga3477f9cc7014a27d957882c129bdfbab">DeclException1</a> (ExcLeastSquaresError, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;Least squares fit leaves a gap of &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:ga3477f9cc7014a27d957882c129bdfbab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga528bcabaac09e43acd643fe8e9535233"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga528bcabaac09e43acd643fe8e9535233">DeclException2</a> (ExcNotGreaterThan, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; arg1&lt;&lt; &quot; must be greater than &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga528bcabaac09e43acd643fe8e9535233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f17c54f8ea46da2840441d2a836aa23"><td class="memItemLeft" align="right" valign="top">template std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4f17c54f8ea46da2840441d2a836aa23">hierarchic_to_lexicographic_numbering&lt; 0 &gt;</a> (unsigned <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a4f17c54f8ea46da2840441d2a836aa23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ecf7052ca7bc6080a3a1b03eff35ef4"><td class="memItemLeft" align="right" valign="top">template std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a7ecf7052ca7bc6080a3a1b03eff35ef4">lexicographic_to_hierarchic_numbering&lt; 0 &gt;</a> (unsigned <a class="el" href="classint.html">int</a>)</td></tr>
<tr class="separator:a7ecf7052ca7bc6080a3a1b03eff35ef4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">生成局部矩阵</div></td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ab1e885987df913c64885ece9034b5c44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1e885987df913c64885ece9034b5c44">get_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:ab1e885987df913c64885ece9034b5c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a3a6ade80f618ca06382d4cdc04cc0940">get_back_interpolation_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;interpolation_matrix)</td></tr>
<tr class="separator:a3a6ade80f618ca06382d4cdc04cc0940"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:aeebb94b65dba9e3790ea358afbc0d274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aeebb94b65dba9e3790ea358afbc0d274">get_interpolation_difference_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;difference_matrix)</td></tr>
<tr class="separator:aeebb94b65dba9e3790ea358afbc0d274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a415b74d2b5da88cfc78d8ef00f0bbfab">get_projection_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;matrix)</td></tr>
<tr class="separator:a415b74d2b5da88cfc78d8ef00f0bbfab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f31747a809637e571e11c146d9bec0a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9f31747a809637e571e11c146d9bec0a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a9f31747a809637e571e11c146d9bec0a">compute_node_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe)</td></tr>
<tr class="separator:a9f31747a809637e571e11c146d9bec0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e9897aeecf21a6aa7bbde0d3786418"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a47e9897aeecf21a6aa7bbde0d3786418"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a47e9897aeecf21a6aa7bbde0d3786418">compute_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;matrices, const <a class="el" href="classbool.html">bool</a> isotropic_only=false, const <a class="el" href="classdouble.html">double</a> threshold=1.e-12)</td></tr>
<tr class="separator:a47e9897aeecf21a6aa7bbde0d3786418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ac0fe5c7f55db091a4477af7c3989b83c">compute_face_embedding_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;matrices)[<a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::max_children_per_face], const unsigned <a class="el" href="classint.html">int</a> face_coarse, const unsigned <a class="el" href="classint.html">int</a> face_fine, const <a class="el" href="classdouble.html">double</a> threshold=1.e-12)</td></tr>
<tr class="separator:ac0fe5c7f55db091a4477af7c3989b83c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a37e353110a68710928c7dddd6b7823"><td class="memTemplParams" colspan="2">template&lt;int dim, typename number , int spacedim&gt; </td></tr>
<tr class="memitem:a4a37e353110a68710928c7dddd6b7823"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4a37e353110a68710928c7dddd6b7823">compute_projection_matrices</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;matrices, const <a class="el" href="classbool.html">bool</a> isotropic_only=false)</td></tr>
<tr class="separator:a4a37e353110a68710928c7dddd6b7823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ab1a0545c897ee022029f8c5f2c252735"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">compute_projection_from_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;rhs_quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X)</td></tr>
<tr class="separator:ab1a0545c897ee022029f8c5f2c252735"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a860d229b5510b389a562ed701ad83811"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">compute_interpolation_to_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;quadrature, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;I_q)</td></tr>
<tr class="separator:a860d229b5510b389a562ed701ad83811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefd2ab2f8f14ccd863622435f89b6003"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:aefd2ab2f8f14ccd863622435f89b6003"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aefd2ab2f8f14ccd863622435f89b6003">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:aefd2ab2f8f14ccd863622435f89b6003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee2da397d9ab5f23311718f36beab37"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a8ee2da397d9ab5f23311718f36beab37"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a8ee2da397d9ab5f23311718f36beab37">compute_projection_from_quadrature_points</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;projection_matrix, const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;vector_of_tensors_at_qp, std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;vector_of_tensors_at_nodes)</td></tr>
<tr class="separator:a8ee2da397d9ab5f23311718f36beab37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeac9c1094e73f795698d92abb7186189"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aeac9c1094e73f795698d92abb7186189"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aeac9c1094e73f795698d92abb7186189">compute_projection_from_face_quadrature_points_matrix</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;lhs_quadrature, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;rhs_quadrature, const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;cell, const unsigned <a class="el" href="classint.html">int</a> face, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;X)</td></tr>
<tr class="separator:aeac9c1094e73f795698d92abb7186189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2c5ec077c4ee4709660cac48bda3ad7"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aa2c5ec077c4ee4709660cac48bda3ad7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aa2c5ec077c4ee4709660cac48bda3ad7">convert_generalized_support_point_values_to_dof_values</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt;&gt; &amp;support_point_values, std::vector&lt; number &gt; &amp;dof_values)</td></tr>
<tr class="separator:aa2c5ec077c4ee4709660cac48bda3ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">应该在DoFTools中出现的函数</div></td></tr>
<tr class="memitem:ad29759cb8c51f8d369a371f63be8dde0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:ad29759cb8c51f8d369a371f63be8dde0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:ad29759cb8c51f8d369a371f63be8dde0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e304ff8b98435584fb57adeefdd1cc9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </td></tr>
<tr class="memitem:a7e304ff8b98435584fb57adeefdd1cc9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a7e304ff8b98435584fb57adeefdd1cc9">interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints, OutVector &amp;u2)</td></tr>
<tr class="separator:a7e304ff8b98435584fb57adeefdd1cc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a0a52af833b660bc126260df08d3df"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:af0a0a52af833b660bc126260df08d3df"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#af0a0a52af833b660bc126260df08d3df">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:af0a0a52af833b660bc126260df08d3df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78b159783856eda8acecbc848717a45"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:aa78b159783856eda8acecbc848717a45"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#aa78b159783856eda8acecbc848717a45">back_interpolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints2, OutVector &amp;u1_interpolated)</td></tr>
<tr class="separator:aa78b159783856eda8acecbc848717a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a0f2e45e9f0117e1ae3ca704885c96ebc">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;fe2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a0f2e45e9f0117e1ae3ca704885c96ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c95cb15c14873edca68d26be66c1330"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a4c95cb15c14873edca68d26be66c1330"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a4c95cb15c14873edca68d26be66c1330">interpolation_difference</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints2, OutVector &amp;z1_difference)</td></tr>
<tr class="separator:a4c95cb15c14873edca68d26be66c1330"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">project_dg</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;u1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;u2)</td></tr>
<tr class="separator:a2a3ad6cbc7cef0f14e60f3ae5a3a5115"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#ab2c5f72f3b99909fdf7d7bb215792400">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, OutVector &amp;z2)</td></tr>
<tr class="separator:ab2c5f72f3b99909fdf7d7bb215792400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88b0fbfad93e11649be719c2aed1ee4d"><td class="memTemplParams" colspan="2">template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </td></tr>
<tr class="memitem:a88b0fbfad93e11649be719c2aed1ee4d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools.html#a88b0fbfad93e11649be719c2aed1ee4d">extrapolate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof1, const InVector &amp;z1, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof2, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;constraints, OutVector &amp;z2)</td></tr>
<tr class="separator:a88b0fbfad93e11649be719c2aed1ee4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这个命名空间提供了一个 <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe1</code> 的离散函数向另一个 <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> <code>fe2的内插和外推。</code> 它还提供了在每个单元上进行插值的局部插值矩阵。此外，它还提供了差分矩阵 \(id-I_h\) ，这是评估 \((id-I_h)z\) 所需要的，例如，对偶解 \(z\) 。 关于<code>spacedim</code>模板参数的更多信息，请查阅FiniteElement或Triangulation的文档。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a40473770b86f7d4b77476097c88aaa55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40473770b86f7d4b77476097c88aaa55">&#9670;&nbsp;</a></span>compute_component_wise()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_component_wise </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>start_indices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="section warning"><dt>Warning</dt><dd>在大多数情况下，你可能想使用 compute_base_renumbering()。 计算出一个单元格按分量重新编号所需的向量。 此外，计算存储本地块向量中每个组件的起始索引的向量。 第二个向量是这样组织的：每个基元都有一个向量，包含这个基元所服务的每个分量的起始索引。 当第一个向量被检查到有正确的大小时，第二个向量被重新初始化以方便使用。 </dd></dl>

</div>
</div>
<a id="ad7f8f27696c0adadc316996b7281f096"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7f8f27696c0adadc316996b7281f096">&#9670;&nbsp;</a></span>compute_block_renumbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_block_renumbering </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>renumbering</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>return_start_indices</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算按区块对单元格的道夫重新编号所需的向量。 此外，计算存储每个本地块向量的起始索引或大小的向量。 如果 <code>bool</code> 参数为真， <code>block_data</code> 将被填充为每个局部块的起始指数。如果它是假的，那么就返回块的大小。 向量<code>renumbering</code>将以本地自由度的标准编号为索引，即第一个顶点，然后是第二个顶点，之后是顶点线、四边形和六边形。对于每个索引，条目表示这个自由度在一个编号方案中得到的索引，其中第一块的编号完全在第二块之前。 </p>

</div>
</div>
<a id="ab1e885987df913c64885ece9034b5c44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1e885987df913c64885ece9034b5c44">&#9670;&nbsp;</a></span>get_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算内插矩阵，将每个单元上的 <code>fe1-function</code> 内插到 <code>fe2-function</code> 。插值矩阵的大小为<code>(fe2.n_dofs_per_cell(), fe1.n_dofs_per_cell())/tt&gt;。 注意，如果有限元空间 <code>fe1</code> 是有限元空间 <code>fe2</code> 的一个子集，那么 <code>interpolation_matrix</code> 就是一个嵌入矩阵。 </code></p>

</div>
</div>
<a id="a3a6ade80f618ca06382d4cdc04cc0940"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a6ade80f618ca06382d4cdc04cc0940">&#9670;&nbsp;</a></span>get_back_interpolation_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_back_interpolation_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>interpolation_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算内插矩阵，将一个 <code>fe1-function</code> 内插到一个 <code>fe2-function</code>, ，并将此内插到每个单元上的第二个 <code>fe1-function</code> 。插值矩阵的大小为<code>(fe1.n_dofs_per_cell(), fe1.n_dofs_per_cell())/tt&gt;。 注意，只有当 <code>fe1</code> 的有限元空间不是 <code>fe2</code>, 的有限元空间的子集时，这个函数才有意义，因为如果它是一个子集，那么 <code>interpolation_matrix</code> 就只有单位矩阵了。 </code></p>

</div>
</div>
<a id="aeebb94b65dba9e3790ea358afbc0d274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeebb94b65dba9e3790ea358afbc0d274">&#9670;&nbsp;</a></span>get_interpolation_difference_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_interpolation_difference_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>difference_matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算身份矩阵减去回补矩阵。 在这个函数之后， <code>difference_matrix</code> 的大小将是<code>(fe1.n_dofs_per_cell(), fe1.n_dofs_per_cell())/tt&gt;。之前的参数内容将被覆盖。 这个函数计算将 <code>fe1</code> 函数 \(z\) 转换到 \(z-I_hz\) 的矩阵，其中 \(I_h\) 表示从 <code>fe1</code> 空间到 <code>fe2</code> 空间的插值运算符。因此，这个矩阵对于评估误差呈现是有用的，其中 \(z\) 表示对偶解。 </code></p>

</div>
</div>
<a id="a415b74d2b5da88cfc78d8ef00f0bbfab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a415b74d2b5da88cfc78d8ef00f0bbfab">&#9670;&nbsp;</a></span>get_projection_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::get_projection_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算从fe1到fe2的局部 \(L^2\) -投影矩阵。 </p>

</div>
</div>
<a id="a9f31747a809637e571e11c146d9bec0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f31747a809637e571e11c146d9bec0a">&#9670;&nbsp;</a></span>compute_node_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;<a class="el" href="classdouble.html">double</a>&gt; FETools::compute_node_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是一个相当专业的函数，在构建有限元对象时使用。它用于为一个元素建立形状函数的基础，给定一组多项式和插值点。该函数只针对正好有 <code>dim</code> 个矢量分量的有限元实现。特别是，这适用于从FE_PolyTensor类派生的类。 具体来说，这个函数的目的是这样的。FE_PolyTensor从其派生类中接收一个描述多项式空间的参数。这个空间可以用单项式或其他方式进行参数化，但一般来说，不是我们用于有限元的形式，在有限元中，我们通常要使用从某种节点函数（例如，特定点的内插）派生的基。 具体来说，假设多项式空间使用的基是 \(\{\tilde\varphi_j(\mathbf x)\}_{j=1}^N\) ，而有限元的节点函数是 \(\{\Psi_i\}_{i=1}^N\) 。然后我们想为有限元空间计算一个基 \(\{\varphi_j(\mathbf x)\}_{j=1}^N\) ，以便 \(\Psi_i[\varphi_j] = \delta_{ij}\) 。为了做到这一点，我们可以设置 \(\varphi_j(\mathbf x) = \sum_{k=1}^N c_{jk} \tilde\varphi_k(\mathbf x)\) ，我们需要确定扩展系数 \(c_{jk}\) 。我们通过将 \(\Psi_i\) 应用于方程的两边来做到这一点，得到 </p><p class="formulaDsp">
\begin{align*} \Psi_i [\varphi_j] = \sum_{k=1}^N c_{jk} \Psi_i[\tilde\varphi_k], \end{align*}
</p>
<p> 我们知道左手边等于 \(\delta_{ij}\) 。 如果你认为这是一个 \(N\times N\) 的方程系统，左边和右边的矩阵的元素，那么这可以写为 </p><p class="formulaDsp">
\begin{align*} I = C X^T \end{align*}
</p>
<p> 其中 \(C\) 是系数 \(c_{jk}\) 和 \(X_{ik} = \Psi_i[\tilde\varphi_k]\) 的矩阵。因此，为了计算膨胀系数 \(C=X^{-T}\) ，我们需要将节点函数应用于多项式空间的 "原始
"基础的所有函数。 在有限元收到这个矩阵 \(X\) 回来之前，它描述其形状函数（例如，在 <a class="el" href="classFiniteElement.html#a9889833bef170393b1281a1418596d70">FiniteElement::shape_value()</a>) 中的形式 \(\tilde\varphi_j\) 。在它调用这个函数后，它有了膨胀系数，可以描述它的形状函数为 \(\varphi_j\) 。 因此，这个函数计算这个矩阵 \(X\) ，具体情形如下。</p>
<ul>
<li>有限元素正好有 <code>dim</code> 个矢量分量。</li>
<li>该函数 \(f_j\) 是由任何元素通过 <a class="el" href="classFiniteElement.html#a97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> 函数实现的。 <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>要对其进行上述操作的有限元。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>如上所述的矩阵 \(X\) 。 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a47e9897aeecf21a6aa7bbde0d3786418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47e9897aeecf21a6aa7bbde0d3786418">&#9670;&nbsp;</a></span>compute_embedding_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1.e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于所有可能的（各向同性和各向异性）细化情况，计算从一个粗单元到子单元的嵌入矩阵。所得矩阵的每一列都包含了粗网格基函数在细网格基上的表示；矩阵被分割，使得每个子单元都有一个矩阵。 这个函数在足够多的正交点中计算粗网格函数，并使用最小二乘法近似拟合细网格函数。因此，这个函数的使用只限于有限元空间实际上是嵌套的情况。 注意， <code>matrices[refinement_case-1][child]</code> 包括了RefinementCase <code>refinement_case</code> 的子 <code>child</code> 的嵌入（或延长）矩阵。这里，我们使用 <code>refinement_case-1</code> instead of <code>refinement_case</code> ，因为对于 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) ，没有可用的延长矩阵。 通常，这个函数被FiniteElement类的各种实现所调用，以填充各自的 <a class="el" href="classFiniteElement.html#afbc42f850096c429fd39cfcbde1b6b56">FiniteElement::prolongation</a> 矩阵。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>我们为其计算嵌入矩阵的有限元类。 </td></tr>
    <tr><td class="paramname">矩阵</td><td>对FullMatrix对象的 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8aadbd360e28038a2c4f89f7af40475b7c">RefinementCase&lt;dim&gt;::isotropic_refinement</a> 向量的引用。每个向量对应一个RefinementCase <code>refinement_case</code> ，向量大小为 GeometryInfo&lt;dim&gt;::n_children(refinement_case). 这是在FiniteElement中使用的格式，我们主要想在这里使用这个函数。 </td></tr>
    <tr><td class="paramname">isotropic_only</td><td>设置为 <code>true</code> 如果你只想计算各向同性的细化矩阵。 </td></tr>
    <tr><td class="paramname">threshold是计算嵌入的最小二乘法中允许的差距。</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac0fe5c7f55db091a4477af7c3989b83c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0fe5c7f55db091a4477af7c3989b83c">&#9670;&nbsp;</a></span>compute_face_embedding_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_face_embedding_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;(&amp;)&#160;</td>
          <td class="paramname"><em>matrices</em>[GeometryInfo&lt; dim &gt;::max_children_per_face], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_coarse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_fine</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>1.e-12</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算约束矩阵所需的面的嵌入矩阵。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fe</td><td>要计算这些矩阵的有限元。 </td></tr>
    <tr><td class="paramname">matrices</td><td>一个<em>GeometryInfo&lt;dim&gt;::subfaces_per_face = 2<sup>dim-1</sup></em> FullMatrix对象的数组，保存每个子面的嵌入矩阵。 </td></tr>
    <tr><td class="paramname">face_coarse</td><td>计算该面的粗面的面的编号。 </td></tr>
    <tr><td class="paramname">face_fine</td><td>脸部精细化的脸部数量，这是为其计算的。 </td></tr>
    <tr><td class="paramname">threshold是计算嵌入的最小二乘法算法中允许的差距。</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>这个函数将被用于计算约束矩阵。它还没有得到充分的测试。 </dd></dl>

</div>
</div>
<a id="a4a37e353110a68710928c7dddd6b7823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a37e353110a68710928c7dddd6b7823">&#9670;&nbsp;</a></span>compute_projection_matrices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename number , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_matrices </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>matrices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>isotropic_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于所有可能的（各向同性和各向异性）细化情况，计算从子单元到粗略单元的<em>L<sup>2</sup></em>投影矩阵。 注意， <code>matrices[refinement_case-1][child]</code> 包括RefinementCase <code>refinement_case</code> 的子集 <code>child</code> 的投影（或限制）矩阵。这里，我们使用 <code>refinement_case-1</code> instead of <code>refinement_case</code> ，因为对于 <a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8a3fd0a7e435097dfb39480143f55fbc01">RefinementCase::no_refinement</a>(=0) ，没有可用的投影矩阵。 通常，这个函数被FiniteElement类的各种实现所调用，以填充各自的 <a class="el" href="classFiniteElement.html#a4993707a4ec342560ff74e5d22401794">FiniteElement::restriction</a> 矩阵。 </p><ul>
<li>[in] fe 我们为其计算投影矩阵的有限元类。 </li>
<li>[out] 矩阵 对一组 <code><a class="el" href="structRefinementPossibilities.html#a1401217684b9c889df46b3d20cda53a8aadbd360e28038a2c4f89f7af40475b7c">RefinementCase&lt;dim&gt;::isotropic_refinement</a></code> FullMatrix对象向量的引用。每个向量对应一个RefinementCase <code>refinement_case</code> ，向量大小为 <code>GeometryInfo&lt;dim&gt;::n_children(refinement_case)</code>. 这是在FiniteElement中使用的格式，我们主要想在这里使用这个函数。 </li>
<li>[in] isotropic_only 如果设置为 <code>true</code> ，那么这个函数只计算各向同性的细化情况的数据。输出向量的其他元素将不被触及（但仍然存在）。 </li>
</ul>

</div>
</div>
<a id="ab1a0545c897ee022029f8c5f2c252735"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a0545c897ee022029f8c5f2c252735">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将定义在正交点的标量数据投射到单个单元上的有限元空间。 这个函数的作用如下：假设有标量数据<code>u<sub>q</sub>, 0 &lt;= q &lt; Q:=quadrature.size()</code>定义在一个单元的正交点，这些点由给定的<code>rhs_quadrature</code>对象定义。然后，我们可能想问在给定的FE对象所定义的有限元空间中的有限元函数（在单个单元上）<code>v<sub>h</sub></code>，它是<code>u</code>在下列意义上的投影。 通常，投影<code>v<sub>h</sub></code>是满足<code>(v<sub>h</sub>,w)=(u,w)</code>对所有离散测试函数<code>w</code>的函数。在目前的情况下，我们无法评估右侧，因为<code>u</code>只在<code>rhs_quadrature</code>给出的正交点中定义，所以我们用正交近似值代替它。同样，左手边也是用<code>lhs_quadrature</code>对象来近似；如果这个正交对象选择得当，那么左手边的积分就可以准确完成，不需要任何近似。如果右手边的正交对象的正交点太少，则有必要使用不同的正交对象</p>
<p>&ndash;例如，如果数据<code>q</code>只定义在单元格中心，那么相应的一点正交公式显然不足以用定式来近似左手边的标量积。 经过这些正交近似，我们最终得到一个<code>V<sub>h</sub></code>的<code>v<sub>h</sub></code>的节点表示，满足以下线性方程组。<code>M V<sub>h</sub> = Q U</code>，其中<code>M<sub>ij</sub>=(phi_i,phi_j)</code>是由<code>lhs_quadrature</code>近似的质量矩阵。和<code>Q</code>是矩阵<code>Q<sub>iq</sub>=phi<sub>i</sub>(x<sub>q</sub>) w<sub>q</sub></code> 其中<code>w<sub>q</sub></code>是正交权重。<code>U</code>是正交点数据的矢量 <code>u<sub>q</sub></code>。 为了得到<code>V<sub>h</sub></code>的投影的节点表示，我们计算<code>V<sub>h</sub> = X U, X=M<sup>-1</sup> Q</code>。这个函数的目的是计算矩阵<code>X</code>并通过这个函数的最后一个参数返回。 请注意，这个函数目前只支持标量数据。质量矩阵的扩展当然是微不足道的，但如果在所有正交点都包含矢量值的数据，就必须定义矢量<code>U</code>中的数据顺序。 在 <a class="el" href="step_18.html">step-18</a> 示例程序的介绍中描述了这个函数的用途。 这个函数的反面，将有限元函数插值到正交点上，基本上就是 <code><a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues::get_function_values</a></code> 函数的作用；为了使事情变得简单一点， <code><a class="el" href="namespaceFETools.html#a860d229b5510b389a562ed701ad83811">FETools::compute_interpolation_to_quadrature_points_matrix</a></code> 提供了这个函数的矩阵形式。 请注意，这个函数是在单个单元上工作的，而不是在整个三角形上。因此，实际上，如果你使用连续或不连续版本的有限元，这并不重要。 值得注意的是，这个函数有几个令人困惑的情况。 第一个是，真正有意义的是投射到每个单元的自由度最多与正交点一样多的有限元上；N个正交点数据投射到一个有M&gt;N个未知数的空间是定义明确的，但往往会产生有趣和不直观的结果。其次，人们认为如果正交点数据在有限元的支持点中定义，即<code>ths_quadrature</code>的正交点等于<code>fe.get_unit_support_points()</code>，那么投影应该是同一的，即有限元的每个自由度等于相应形状函数的支持点中给定数据的值。然而，一般情况下不是这样的：虽然在这种情况下矩阵<code>Q</code>是身份矩阵，但质量矩阵<code>M</code>不等于身份矩阵，除了正交公式<code>lhs_quadrature</code>在有限元的支持点上也有其正交点的特殊情况。 最后，这个函数只定义了一个单元的投影，而人们经常希望将其应用于三角结构中的所有单元。然而，如果它被应用于一个又一个的单元，如果自由度存在于单元之间的界面上，后面的单元的结果可能会覆盖之前的单元已经计算出来的节点值。因此，该函数对不连续的元素最有用。 </p>

</div>
</div>
<a id="a860d229b5510b389a562ed701ad83811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a860d229b5510b389a562ed701ad83811">&#9670;&nbsp;</a></span>compute_interpolation_to_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_interpolation_to_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>I_q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个（标量）局部有限元函数，计算矩阵，将节点值的矢量映射到该函数在正交点的值的矢量上，如第二个参数所给的。在某种意义上，这个函数与 <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> 函数的作用相反。 </p>

</div>
</div>
<a id="aefd2ab2f8f14ccd863622435f89b6003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefd2ab2f8f14ccd863622435f89b6003">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算存储在正交点 <code>vector_of_tensors_at_qp</code> 的张量（一阶张量）数据对单元支持点的数据 <code>张量的矢量_节点的投影。</code> <code>vector_of_tensors_at_qp</code> 中的数据是按照正交点编号顺序排列的。 <code>vector_of_tensors_at_qp</code> 的大小必须对应于 <code>projection_matrix</code>. 的列数， <code>vector_of_tensors_at_nodes</code> 的大小必须对应于 <code>向量的行数。</code> 投影矩阵 <code>projection_matrix</code> 描述了来自正交点的标量数据的投影，可以通过 <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> 函数得到。 </p>

</div>
</div>
<a id="a8ee2da397d9ab5f23311718f36beab37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee2da397d9ab5f23311718f36beab37">&#9670;&nbsp;</a></span>compute_projection_from_quadrature_points() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_quadrature_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_qp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; 2, dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vector_of_tensors_at_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上一个函数相同，但对一个 <code><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a></code> 。 </p>

</div>
</div>
<a id="aeac9c1094e73f795698d92abb7186189"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeac9c1094e73f795698d92abb7186189">&#9670;&nbsp;</a></span>compute_projection_from_face_quadrature_points_matrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::compute_projection_from_face_quadrature_points_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt;::active_cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个方法实现了 <a class="el" href="namespaceFETools.html#ab1a0545c897ee022029f8c5f2c252735">FETools::compute_projection_from_quadrature_points_matrix</a> 方法，用于网格的面。 它返回的矩阵，X，是针对面的，其大小是fe.n_dofs_per_cell()乘以rhs_quadrature.size()。 该类的尺寸，dim必须大于1，因为需要Quadrature&lt;dim-1&gt;对象。更多信息请参见正交类的文档。 </p>

</div>
</div>
<a id="aa2c5ec077c4ee4709660cac48bda3ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2c5ec077c4ee4709660cac48bda3ad7">&#9670;&nbsp;</a></span>convert_generalized_support_point_values_to_dof_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::convert_generalized_support_point_values_to_dof_values </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; number &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>support_point_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>围绕 <a class="el" href="classFiniteElement.html#a97e71a320cf0c2bcb0d0d9d8447aaa34">FiniteElement::convert_generalized_support_point_values_to_dof_values()</a> 的封装器，可用于任意的数字类型。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">finite_element</td><td>用于计算dof值的FiniteElement。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">support_point_values</td><td>一个大小为 <code>dofs_per_cell</code> 的数组（相当于get_generalized_support_points()函数将返回的点的数量），其中每个元素是一个向量，其条目数量与该元素的向量分量相同。这个数组应该包含有限元的广义支持点上的函数值。 </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dof_values</td><td>一个大小为 <code>dofs_per_cell</code> 的数组，包含应用于给定函数的元素的节点函数值。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad29759cb8c51f8d369a371f63be8dde0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29759cb8c51f8d369a371f63be8dde0">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个 <code>dof1-function</code> <code>u1</code> 到 <code>Dof2-函数</code> <code>u2</code>. <code>dof1</code> 和 <code>dof2</code> 的内插，需要基于相同的三角形的DoFHandler。 如果元素 <code>fe1</code> 和 <code>fe2</code> 都是连续的或者都是不连续的，那么这个插值就是通常的点插值。 如果 <code>fe1</code> 是一个连续的和 <code>fe2</code> 是一个不连续的有限元也是如此。对于 <code>fe1</code> 是不连续的， <code>fe2</code> 是连续有限元的情况，在不连续处没有定义点插值。 因此，平均值是在不连续点上的DoF值处取的。 请注意，对于有悬挂节点的网格上的连续元素（即局部细化的网格），这个函数并不能给出预期的输出。 事实上，产生的输出矢量在悬空节点处不一定尊重连续性要求：例如，如果你是将一个Q2场插值到Q1场，那么在悬空节点处，输出场将具有输入场的函数值，然而这通常不是两个相邻节点的平均值。因此，它不是整个三角形上Q1函数空间的一部分，尽管它当然是每个单元上的Q1。 对于这种情况（带有悬挂节点的网格上的连续元素），请使用 <code><a class="el" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">interpolate()</a></code> 函数，并以额外的AffineConstraints对象作为参数，见下文，或者通过调用悬挂节点约束对象的 <code>distribute</code> 函数使场符合。 </p>

</div>
</div>
<a id="a7e304ff8b98435584fb57adeefdd1cc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e304ff8b98435584fb57adeefdd1cc9">&#9670;&nbsp;</a></span>interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class InVector , class OutVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>dof1-function</code> <code>u1</code> 到 <code>Dof2-函数的插值</code> <code>u2</code>. <code>dof1</code> 和 <code>dof2</code> 需要是基于同一三角的DoFHandlers。 <code>constraints</code> 是对应于 <code>dof2</code>. 的悬空节点约束对象，当插值到具有悬空节点的网格（局部细化网格）上的连续元素时，该对象特别重要。 如果元素 <code>fe1</code> 和 <code>fe2</code> 都是连续的或者都是不连续的，那么这个内插就是通常的点内插。 如果 <code>fe1</code> 是一个连续的和 <code>fe2</code> 是一个不连续的有限元也是如此。对于 <code>fe1</code> 是不连续的和 <code>fe2</code> 是连续有限元的情况，在不连续处没有定义点插值。 因此，均值取自不连续处的DoF值。 </p>

</div>
</div>
<a id="af0a0a52af833b660bc126260df08d3df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a0a52af833b660bc126260df08d3df">&#9670;&nbsp;</a></span>back_interpolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>fe1-function</code> <code>u1</code> 到 <code>fe2-函数的内插，并将其内插到第二个</code> <code>fe1-function</code> 名为 <code>的u1_interpolated。</code> 注意，这个函数对悬挂节点的连续元素不起作用。对于这种情况，请使用下面的 <code>back_interpolate</code> 函数，它需要一个额外的 <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a></code> 对象。 此外，请注意，对于 <code>fe1</code> 对应的有限元空间是 <code>fe2</code>, 对应的有限元空间的一个子集的特殊情况，这个函数只是一个身份映射。 </p>

</div>
</div>
<a id="aa78b159783856eda8acecbc848717a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78b159783856eda8acecbc848717a45">&#9670;&nbsp;</a></span>back_interpolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::back_interpolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u1_interpolated</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>dof1-function</code> <code>u1</code> 到 <code>dof2-函数的内插，并将其内插到第二个</code> <code>dof1-function</code> ，命名为 <code>u1_interpolated</code>. <code>constraints1</code> 和 <code>constraints2</code> 分别是对应于 <code>dof1</code> 和 <code>dof2</code>, 的悬挂节点约束。 当涉及到带有悬挂节点的网格（局部细化网格）上的连续元素时，这些对象特别重要。 此外，请注意，对于 <code>dof1</code> 对应的有限元空间是 <code>dof2</code>, 对应的有限元空间的一个子集的特定情况，这个函数只是一个身份映射。 </p>

</div>
</div>
<a id="a0f2e45e9f0117e1ae3ca704885c96ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2e45e9f0117e1ae3ca704885c96ebc">&#9670;&nbsp;</a></span>interpolation_difference() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于给定的 <code>dof1-function</code> \(z_1\) 计算 \((Id-I_h)z_1\) ，其中 \(I_h\) 是从 <code>fe1</code> 到 <code>fe2</code>. 的插值，结果 \((Id-I_h)z_1\) 被写入 <code>z1_difference</code>. 注意，这个函数对于悬挂节点的连续元素不起作用。对于这种情况，请使用下面的 <code>interpolation_difference</code> 函数，它需要一个额外的 <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a></code> 对象。 </p>

</div>
</div>
<a id="a4c95cb15c14873edca68d26be66c1330"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c95cb15c14873edca68d26be66c1330">&#9670;&nbsp;</a></span>interpolation_difference() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::interpolation_difference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z1_difference</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于给定的 <code>dof1-function</code> \(z_1\) 计算 \((Id-I_h)z_1\) ，其中 \(I_h\) 是从 <code>fe1</code> 到 <code>fe2</code>. 的插值，结果 \((Id-I_h)z_1\) 被写入 <code>z1_difference</code>. <code>constraints1</code> 和 <code>constraints2</code> 是悬挂节点约束，分别对应 <code>dof1</code> 和 <code>dof2</code>, 。当涉及到带有悬挂节点的网格（局部细化网格）上的连续元素时，这些对象特别重要。 对于并行计算，提供 <code>z1</code> 和 <code>z1_difference，不含鬼魂元素。</code> </p>

</div>
</div>
<a id="a2a3ad6cbc7cef0f14e60f3ae5a3a5115"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a3ad6cbc7cef0f14e60f3ae5a3a5115">&#9670;&nbsp;</a></span>project_dg()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::project_dg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>u1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>u2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(L^2\) 不连续元素的投影。操作方向与插值相同。 如果有限元空间是不连续的，全局投影可以通过局部矩阵来计算。对于连续元素，这是不可能的，因为全局质量矩阵必须被倒置。 </p>

</div>
</div>
<a id="ab2c5f72f3b99909fdf7d7bb215792400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c5f72f3b99909fdf7d7bb215792400">&#9670;&nbsp;</a></span>extrapolate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>dof1</code> 函数 <code>z1</code> 到 <code>Dof2函数</code> <code>z2</code>. 的修补外推 <code>dof1</code> 和 <code>dof2</code> 需要是基于同一三角的DoFHandler对象。这个函数用于，例如，将逐片线性解外推到逐片二次解。 这个函数的名字是历史性的，可能不是特别好的选择。该函数一个接一个地执行以下操作。</p>
<ul>
<li>它直接从 <code>dof1</code> 的每个单元内插到<code>dof2</code>的相应单元，使用这些单元上使用的有限元空间的内插矩阵，并由相关的有限元对象提供。这一步是使用 <a class="el" href="namespaceFETools.html#ad29759cb8c51f8d369a371f63be8dde0">FETools::interpolate()</a> 函数完成的。</li>
<li>然后它在<code>dof2</code>的所有非活动单元上执行循环。 如果这样的非活动单元至少有一个活动的子单元，那么我们称这个单元的子单元为 "补丁"。然后我们使用与<code>dof2</code>相关的有限元空间，从这个补丁的子单元插补到补丁，并立即插补回子单元。从本质上讲，这个信息抛开了解向量中所有生活在比补丁单元更小范围内的信息。</li>
<li>由于我们从最粗的层次到最细的层次遍历非活动单元，如果网格被自适应地细化，我们可能会发现对应于先前处理过的补丁的子单元的补丁（如果网格被全局细化，这种情况不会发生，因为那里的补丁的子单元都是活动的）。我们也对这些补丁进行上述操作，但很容易看出，在作为先前处理过的补丁的子单元的补丁上，该操作现在是身份操作（因为它从当前补丁的子单元插值一个先前从更粗的补丁插值到这些子单元的函数）。因此，这不会再改变解向量。 这个函数的名字源于这样一个事实：它可以用来在一个更粗的网格上构造一个更高多项式程度的函数的表示。例如，如果你想象你从一个全局细化的网格上的 \(Q_1\) 函数开始，并且 <code>dof2</code> 与 \(Q_2\) 元素相关联，那么这个函数计算出在一个网格尺寸为 \(2h\) 的一次粗化的网格上将原始片状线性函数插值为二次函数的等效算子 \(I_{2h}^{(2)}\) （但在原始网格上表示这个函数尺寸为 \(h\) ）。 如果精确解足够平滑，那么 \(u^\ast=I_{2h}^{(2)}u_h\) 通常比 \(u_h\) 更能接近PDE的精确解 \(u\) 。换句话说，这个函数提供了一个后处理步骤，以类似于人们经常通过外推一连串的解决方案获得的方式改进解决方案，解释了该函数名称的由来。 <dl class="section note"><dt>Note</dt><dd>如果使用上述算法，产生的场不满足给定有限元的连续性要求。当你在有悬挂节点的网格上使用连续元素时，请使用带有额外AffineConstraints参数的 <code>外推函数，见下文。</code> </dd>
<dd>
由于这个函数在单元的补丁上操作，它要求底层网格对每个粗略的网格单元至少进行一次细化。 如果不是这样，就会产生一个异常。 </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a88b0fbfad93e11649be719c2aed1ee4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88b0fbfad93e11649be719c2aed1ee4d">&#9670;&nbsp;</a></span>extrapolate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, class InVector , class OutVector , int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::extrapolate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>z1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; typename OutVector::value_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>z2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 <code>dof1</code> 函数 <code>z1</code> 对 <code>Dof2函数</code> <code>z2</code>. 的修补外推 <code>dof1</code> 和 <code>dof2</code> 需要是基于同一三角的DoFHandler对象。 <code>constraints</code> 是对应于 <code>dof2</code>. 的悬空节点约束对象，当插值到有悬空节点的网格上的连续元素时，这个对象是必要的（局部细化网格）。 否则，该函数的作用与上述另一个 <code>extrapolate</code> 函数相同（对于该函数，文档中提供了大量的操作描述）。 </p>

</div>
</div>
<a id="a19348513588a636f95b32d91df5b49f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19348513588a636f95b32d91df5b49f0">&#9670;&nbsp;</a></span>hierarchic_to_lexicographic_numbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; FETools::hierarchic_to_lexicographic_numbering </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>连续有限元中自由度的编号是分层次的，也就是说，我们首先按照三角形定义的顶点顺序对顶点自由度进行编号，然后按照顺序和尊重线的方向对线自由度进行编号，然后对四边形的自由度进行编号，等等。然而，我们也可以用词法对它们进行编号，即指数先按X方向，然后按Y方向，最后按Z方向。例如，FE_DGQ()类的不连续元素就是以这种方式编号的。 这个函数返回一个向量，其中包含了分级编号中每个自由度对连续有限元的给定程度的词汇索引的信息。 </p>

</div>
</div>
<a id="a854e39f9616b52536bdece5e8ec837c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a854e39f9616b52536bdece5e8ec837c4">&#9670;&nbsp;</a></span>lexicographic_to_hierarchic_numbering()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; FETools::lexicographic_to_hierarchic_numbering </td>
          <td>(</td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>degree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是与上述函数相反的函数，生成连续有限元给定多项式程度的词典式编号到层次式编号的映射。所有关于上述函数的评论在这里也是有效的。 </p>

</div>
</div>
<a id="ad677362df1413e1ccc8a2cf7aff19d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad677362df1413e1ccc8a2cf7aff19d07">&#9670;&nbsp;</a></span>get_fe_by_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classFiniteElement.html">FiniteElement</a>&lt;dim, spacedim&gt; &gt; FETools::get_fe_by_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>解析有限元的名称并相应地生成一个有限元对象。解析器忽略单词之间的空格字符（与正则表达式[A-Za-z0-9_]相匹配的东西）。 名称必须是由 <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> 函数返回的形式，其中尺寸模板参数&lt;2&gt;等可以省略。另外，明确的数字可以用<code>dim</code>或<code>d</code>代替。如果给出一个数字，它<b>must</b>与该函数的模板参数相匹配。 FESystem元素的名称遵循 <code><a class="el" href="classFESystem.html">FESystem</a>[FE_Base1^p1-FE_Base2^p2]</code> The powers <code>p1</code> 的模式，可以是数字，也可以用<code>dim</code>或<code>d</code>代替。 如果不能从这个字符串中重建有限元，将抛出一个 <code>FETools::ExcInvalidFEName</code> 类型的异常。 该函数返回一个 std::unique_ptr 的新创建的有限元，意味着调用者获得了对返回对象的所有权。 由于模板参数的值不能从给这个函数的（字符串）参数中推导出来，你必须在调用这个函数时明确指定它。 这个函数知道库中定义的所有标准元素。然而，它默认不知道你可能在你的程序中定义的元素。要使这个函数知道你自己的元素，请使用add_fe_name()函数。 如果想得到一个模数维为1的有限元，这个函数就不起作用。 </p>

</div>
</div>
<a id="a5a006641198ca5641c5c8ae20b741b4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a006641198ca5641c5c8ae20b741b4b">&#9670;&nbsp;</a></span>add_fe_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::add_fe_name </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFETools_1_1FEFactoryBase.html">FEFactoryBase</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>factory</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用给定的 <code>name</code>. 扩展可由get_fe_by_name()生成的有限元列表，如果以后用这个名字调用get_fe_by_name()，它将使用给定的作为第二个参数的对象来创建一个有限元对象。 <code>name</code> 参数的格式应包括有限元的名称。然而，单独使用类名或使用 <a class="el" href="classFiniteElement.html#a09655d1d2555af8dcd48caebd4039d29">FiniteElement::get_name</a> 的结果（包括空间维度以及多项式程度）都是安全的，因为第一个非名称字符之后的所有内容将被忽略。 FEFactory对象应该是一个用<code>new</code>新建的对象。 FETools将拥有这个对象的所有权，一旦不再使用它，就将其删除。 在大多数情况下，如果你想在给get_fe_by_name提供名称 <code>my_fe</code> 时创建 <code>MyFE</code> 类型的对象，你会希望这个函数的第二个参数是FEFactory &lt;MyFE&gt;, 类型，但你当然可以创建你的自定义有限元工厂类。 这个函数接管了作为第二个参数的对象的所有权，也就是说，你不应该试图在以后销毁它。该对象将在程序的生命周期结束时被删除。 如果该元素的名称已经被使用，则会抛出一个异常。 因此，get_fe_by_name()的功能只能被添加，不能被改变。 </p><dl class="section note"><dt>Note</dt><dd>这个函数操作一个全局表（每个空间维度有一个表）。它是线程安全的，因为对这个表的每一次访问都有一个锁来保证。然而，由于每个名字只能被添加一次，用户代码必须确保只有一个线程添加一个新元素。 还要注意，这个表对每个空间维度都存在一次。如果你有一个在不同空间维度上处理有限元的程序（例如， <a class="el" href="step_4.html">step_4 </a>step-4"  " 做这样的事情），那么你应该为每个空间维度调用这个函数，你希望你的有限元被添加到地图中。 </dd></dl>

</div>
</div>
<a id="a4f17c54f8ea46da2840441d2a836aa23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f17c54f8ea46da2840441d2a836aa23">&#9670;&nbsp;</a></span>hierarchic_to_lexicographic_numbering< 0 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="namespaceFETools.html#a19348513588a636f95b32d91df5b49f0">FETools::hierarchic_to_lexicographic_numbering</a>&lt; 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ecf7052ca7bc6080a3a1b03eff35ef4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ecf7052ca7bc6080a3a1b03eff35ef4">&#9670;&nbsp;</a></span>lexicographic_to_hierarchic_numbering< 0 >()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::vector&lt;unsigned <a class="el" href="classint.html">int</a>&gt; <a class="el" href="namespaceFETools.html#a854e39f9616b52536bdece5e8ec837c4">FETools::lexicographic_to_hierarchic_numbering</a>&lt; 0 &gt; </td>
          <td>(</td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
