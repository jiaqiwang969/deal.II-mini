<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/step_62.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The step-62 tutorial program</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">The step-62 tutorial program </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial depends on <a class="el" href="step_8.html">step-8</a>, <a class="el" href="step_40.html">step-40</a>.</p>
<p> 
<table class="tutorial" width="50%">
<tr><th colspan="2"><b><small>Table of contents</small></b></th></tr>
<tr><td width="50%" valign="top">
<ol>
  <li> <a href="#Intro" class=bold>Introduction</a>
    <ul>
        <li><a href="#Elasticequations">Elastic equations</a>
        <li><a href="#Simulationparameters">Simulation parameters</a>
    </ul>
  <li> <a href="#CommProg" class=bold>The commented program</a>
    <ul>
        <li><a href="#Includefiles">Include files</a>
        <li><a href="#Auxiliaryclassesandfunctions">Auxiliary classes and functions</a>
      <ul>
        <li><a href="#TheRightHandSideclass">The `RightHandSide` class</a>
        <li><a href="#ThePMLclass">The `PML` class</a>
        <li><a href="#TheRhoclass">The `Rho` class</a>
        <li><a href="#TheParametersclass">The `Parameters` class</a>
        <li><a href="#TheQuadratureCacheclass">The `QuadratureCache` class</a>
        <li><a href="#Theget_stiffness_tensorfunction">The `get_stiffness_tensor()` function</a>
      </ul>
        <li><a href="#TheElasticWaveclass">The `ElasticWave` class</a>
        <li><a href="#Implementationoftheauxiliaryclasses">Implementation of the auxiliary classes</a>
      <ul>
        <li><a href="#TheRightHandSideclassimplementation">The `RightHandSide` class implementation</a>
        <li><a href="#ThePMLclassimplementation">The `PML` class implementation</a>
        <li><a href="#TheRhoclassimplementation">The `Rho` class implementation</a>
        <li><a href="#TheParametersclassimplementation">The `Parameters` class implementation</a>
        <li><a href="#TheQuadratureCacheclassimplementation">The `QuadratureCache` class implementation</a>
      </ul>
        <li><a href="#ImplementationoftheElasticWaveclass">Implementation of the `ElasticWave` class</a>
      <ul>
        <li><a href="#Constructor">Constructor</a>
        <li><a href="#ElasticWavesetup_system">ElasticWave::setup_system</a>
        <li><a href="#ElasticWaveassemble_system">ElasticWave::assemble_system</a>
        <li><a href="#ElasticWavesolve">ElasticWave::solve</a>
        <li><a href="#ElasticWaveinitialize_position_vector">ElasticWave::initialize_position_vector</a>
        <li><a href="#ElasticWavestore_frequency_step_data">ElasticWave::store_frequency_step_data</a>
        <li><a href="#ElasticWaveoutput_results">ElasticWave::output_results</a>
        <li><a href="#ElasticWavesetup_quadrature_cache">ElasticWave::setup_quadrature_cache</a>
        <li><a href="#ElasticWavefrequency_sweep">ElasticWave::frequency_sweep</a>
        <li><a href="#ElasticWaverun">ElasticWave::run</a>
        <li><a href="#Themainfunction">The main function</a>
      </ul>
      </ul>
</ol></td><td width="50%" valign="top"><ol>
  <li value="3"> <a href="#Results" class=bold>Results</a>
    <ul>
        <li><a href="#Resonancefrequencyandbandgap">Resonance frequency and bandgap</a>
        <li><a href="#Modeprofile">Mode profile</a>
        <li><a href="#Experimentalapplications">Experimental applications</a>
        <li><a href="#Possibilitiesforextensions">Possibilities for extensions</a>
    </ul>
  <li> <a href="#PlainProg" class=bold>The plain program</a>
</ol> </td> </tr> </table>
 examples/step-62/doc/intro.dox</p>
<p><br />
</p>
<p><em>This program was contributed by Daniel Garcia-Sanchez.</em> <br />
 。</p>
<dl class="section note"><dt>Note</dt><dd>作为这个程序的前提条件，你需要安装HDF5、复杂的PETSc和p4est库。在<a href="../../readme.html" target="body">README</a>文件中描述了deal.II与这些附加库的安装情况。</dd></dl>
<p><a class="anchor" id="Introduction"></a></p><h1>Introduction</h1>
<p>声子晶体是一种周期性的纳米结构，可以改变机械振动或[声子]的运动（https://en.wikipedia.org/wiki/Phonon）。声子结构可用于分散、引导和限制机械振动。这些结构在<a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391">量子信息</a>方面有潜在的应用，并已被用于研究<a href="https://science.sciencemag.org/content/358/6360/203">宏观量子现象</a>。声子晶体通常是在[洁净室]中制造的(<a href="https://en.wikipedia.org/wiki/Cleanroom">https://en.wikipedia.org/wiki/Cleanroom</a>)。</p>
<p>在本教程中，我们展示了如何设计一个<a href="https://doi.org/10.1103/PhysRevA.94.033813">声子超晶格空腔</a>，这是一种特殊类型的声子晶体，可用于限制机械振动。声子超晶格空腔是由两个<a href="https://en.wikipedia.org/wiki/Distributed_Bragg_reflector">分布式布拉格反射器</a>、镜子和一个 \(\lambda/2\) 空腔组成，其中 \(\lambda\) 是声学波长。声学DBRs是周期性结构，其中一组具有对比物理特性（声速指数）的双层堆栈被重复 \(N\) 次。超晶格空腔通常通过<a href="https://en.wikipedia.org/wiki/Molecular-beam_epitaxy">分子束外延</a>在<a href="https://en.wikipedia.org/wiki/Gallium_arsenide">砷化镓</a>晶片上生长。双层对应于砷化镓/砷化铝镜像对。如下图所示，镜像层（棕色和绿色）的厚度为 \(\lambda/4\) ，空腔（蓝色）的厚度为 \(\lambda/2\) 。</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-62.01.svg" alt="Phononic superlattice cavity" height="200"></object>
</div>
<p>在本教程中，我们计算了<a href="https://en.wikipedia.org/wiki/Band_gap">带隙</a>和声子超晶格空腔的机械共振，但这里介绍的代码可以很容易地用于设计和计算其他类型的<a href="https://science.sciencemag.org/content/358/6360/203">声子晶体</a>。</p>
<p>该装置是一个波导，其中的波从左到右。本教程的模拟是在二维进行的，但代码是独立于维度的，可以很容易地用于三维模拟。波导的宽度等于域的 \(y\) 维，波导的长度等于域的 \(x\) 维。有两个取决于波导宽度的制度。</p>
<ul>
<li>单一模式。在这种情况下，结构的宽度要比波长小得多。 这种情况可以用有限元法（我们在这里采取的方法）或用简单的半分析法[一维转移矩阵形式]（https://en.wikipedia.org/wiki/Transfer_matrix）来解决。</li>
<li>多模。在这种情况下，结构的宽度比波长大。 这种情况可以用有限元法或[散射矩阵形式主义]（https://doi.org/10.1103/PhysRevA.94.033813）来解决。 尽管我们在本教程中没有研究这种情况，但通过增加波导宽度参数（jupyter笔记本中的`dimension_y'），很容易达到多模制度。</li>
</ul>
<p>本教程的模拟是在频域进行的。为了计算传输频谱，我们使用了时域<a href="https://meep.readthedocs.io/en/latest/Python_Tutorials/Resonant_Modes_and_Transmission_in_a_Waveguide_Cavity/">FDTD</a>模拟中常用的一个[程序]。在结构的左侧产生一个特定频率的脉冲，在结构的右侧测量传输的能量。仿真运行了两次。首先，我们运行声子结构的模拟并测量传输能量。</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-62.02.svg" alt="Phononic superlattice cavity" height="200"></object>
</div>
<p>然后，我们运行没有声子结构的模拟，并测量传输的能量。我们使用没有结构的模拟来进行校准。</p>
<div class="image">
<object type="image/svg+xml" data="https://www.dealii.org/images/steps/developer/step-62.03.svg" alt="Phononic superlattice cavity" height="200"></object>
</div>
<p>传输系数相当于第一次模拟的能量除以校准能量。我们对每个频率步骤重复这一程序。</p>
<p><a class="anchor" id="Elasticequations"></a></p><h3>Elastic equations</h3>
<p>我们在这里要模拟的是弹性波的传输。因此，对问题的正确描述使用了弹性方程，在时域中，弹性方程由以下几项给出</p>
<p class="formulaDsp">
\[ \rho\partial_{tt} u_i - \partial_j (c_{ijkl} \varepsilon_{kl}) = f_i, \qquad i=0,1,2 \]
</p>
<p>其中刚度张量 \(c_{ijkl}\) 取决于空间坐标，应变是位移的对称梯度，由以下公式给出</p>
<p class="formulaDsp">
\[ \varepsilon_{kl} =\frac{1}{2}(\partial_k u_l + \partial_l u_k) \]
</p>
<p><a href="https://en.wikipedia.org/wiki/Perfectly_matched_layer">完美匹配层（PML）</a>可以用来在边界处截断解决方案。PML是一种导致复杂坐标拉伸的变换。</p>
<p>本教程程序没有采用时域方法，而是通过对时间变量进行傅里叶变换，将上述方程转换为频域。频域中的弹性方程的内容如下</p>
<p class="formulaDsp">
\begin{eqnarray*} \nabla\cdot(\boldsymbol{\bar\sigma} \xi \boldsymbol{\Lambda})&amp;=&amp;-\omega^2\rho\xi\mathbf{\bar u}\\ \boldsymbol{\bar \sigma} &amp;=&amp;\mathbf{C}\boldsymbol{\bar\varepsilon}\\ \boldsymbol{\bar\varepsilon}&amp;=&amp;\frac{1}{2}[(\nabla\mathbf{\bar{u}}\boldsymbol{\Lambda}+\boldsymbol{\Lambda}^\mathrm{T}(\nabla\mathbf{\bar{u}})^\mathrm{T})]\\ \xi &amp;=&amp;\prod_i^\textrm{dim}s_i\\ \boldsymbol{\Lambda} &amp;=&amp; \operatorname{diag}(1/s_0,1/s_1,1/s_2)\qquad\textrm{for 3D}\\ \boldsymbol{\Lambda} &amp;=&amp; \operatorname{diag}(1/s_0,1/s_1)\qquad\textrm{for 2D} \end{eqnarray*}
</p>
<p>其中系数 \(s_i = 1+is_i&#39;(x,y,z)\) 说明了吸收情况。3D中有3个 \(s_i\) 系数，2D中有2个。 \(s_i\) 的虚部在PML外等于零。PML仅对精确的波浪方程是无反射的。当方程组被离散化时，PML就不再是无反射的了。只要介质是缓慢变化的，反射就可以变得任意小，见<a href="https://doi.org/10.1103/PhysRevE.66.066608">绝热定理</a>。在代码中，已经使用了PML的二次开启。线性和立方开启也是<a href="https://doi.org/10.1364/OE.16.011376">已知可行的</a>。这些方程可以扩展为</p>
<p class="formulaDsp">
\[ -\omega^2\rho \xi u_m - \partial_n \left(\frac{\xi}{s_n}c_{mnkl} \varepsilon_{kl}\right) = f_m \]
</p>
<p class="formulaDsp">
\[ \varepsilon_{kl} =\frac{1}{2}\left(\frac{1}{s_k}\partial_k u_l + \frac{1}{s_l}\partial_l u_k\right) \]
</p>
<p>其中对重复指数（这里是 \(n\) ，以及 \(k\) 和 \(l\) ）的求和一如既往地隐含着。请注意，应用PML的复数坐标拉伸后，应变不再是对称的。这组方程可以写成</p>
<p class="formulaDsp">
\[ -\omega^2\rho \xi u_m - \partial_n \left(\frac{\xi c_{mnkl}}{2s_n s_k} \partial_k u_l + \frac{\xi c_{mnkl}}{2s_n s_l} \partial_l u_k\right) = f_m \]
</p>
<p>与应变一样，应力张量在PML内也不是对称的（ \(s_j\neq 0\) ）。事实上，PML内部的场不是物理的。介绍张量 \(\alpha_{mnkl}\) 和 \(\beta_{mnkl}\) 是有用的。</p>
<p class="formulaDsp">
\[ -\omega^2\rho \xi u_m - \partial_n \left(\alpha_{mnkl}\partial_k u_l + \beta_{mnkl}\partial_l u_k\right) = f_m \]
</p>
<p>我们可以乘以 \(\varphi_m\) 并在 \(\Omega\) 域上进行积分，并进行部分积分。</p>
<p class="formulaDsp">
\begin{eqnarray*} -\omega^2\int_\Omega\rho\xi\varphi_m u_m + \int_\Omega\partial_n\varphi_m \left(\frac{\xi c_{mnkl}}{2s_n s_k} \partial_k u_l + \frac{\xi c_{mnkl}}{2s_n s_l} \partial_l u_k\right) = \int_\Omega\varphi_m f_m \end{eqnarray*}
</p>
<p>正是这组方程，我们要解决一组频率 \(\omega\) ，以计算传输系数与频率的关系。这个线性系统变成</p>
<p class="formulaDsp">
\begin{eqnarray*} AU&amp;=&amp;F\\ A_{ij} &amp;=&amp; -\omega^2\int_\Omega\rho \xi\varphi_m^i \varphi_m^j + \int_\Omega\partial_n\varphi_m^i \left(\frac{\xi c_{mnkl}}{2s_n s_k} \partial_k \varphi_l^j + \frac{\xi c_{mnkl}}{2s_n s_l} \partial_l \varphi_k^j\right)\\ F_i &amp;=&amp; \int_\Omega\varphi_m^i f_m \end{eqnarray*}
</p>
<p><a class="anchor" id="Simulationparameters"></a></p><h3>Simulation parameters</h3>
<p>在本教程中，我们使用python <a href="https://github.com/dealii/dealii/blob/master/example/step-62/step-62.ipynb">jupyter notebook</a>来设置参数和运行模拟。首先，我们创建一个HDF5文件，在其中存储参数和模拟的结果。</p>
<p>每个模拟（位移和校准）都存储在一个单独的HDF5组中。</p>
<div class="fragment"><div class="line">import numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"><span class="keyword">import</span> scipy.constants <span class="keyword">as</span> constants</div><div class="line"><span class="keyword">import</span> scipy.optimize</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># This considerably reduces the size of the svg data</span></div><div class="line">plt.rcParams[<span class="stringliteral">&#39;svg.fonttype&#39;</span>] = <span class="stringliteral">&#39;none&#39;</span></div><div class="line"></div><div class="line"></div><div class="line">h5_file = h5py.File(<span class="stringliteral">&#39;results.h5&#39;</span>, <span class="stringliteral">&#39;w&#39;</span>)</div><div class="line">data = h5_file.create_group(<span class="stringliteral">&#39;data&#39;</span>)</div><div class="line">displacement = data.create_group(<span class="stringliteral">&#39;displacement&#39;</span>)</div><div class="line">calibration = data.create_group(<span class="stringliteral">&#39;calibration&#39;</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Set the parameters</span></div><div class="line"><span class="keywordflow">for</span> group <span class="keywordflow">in</span> [displacement, calibration]:</div><div class="line">    <span class="comment"># Dimensions of the domain</span></div><div class="line">    <span class="comment"># The waveguide length is equal to dimension_x</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;dimension_x&#39;</span>] = 2e-5</div><div class="line">    <span class="comment"># The waveguide width is equal to dimension_y</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;dimension_y&#39;</span>] = 2e-8</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Position of the probe that we use to measure the flux</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;probe_pos_x&#39;</span>]   = 8e-6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;probe_pos_y&#39;</span>]   = 0</div><div class="line">    group.attrs[<span class="stringliteral">&#39;probe_width_y&#39;</span>] = 2e-08</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Number of points in the probe</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;nb_probe_points&#39;</span>] = 5</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Global refinement</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;grid_level&#39;</span>] = 1</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Cavity</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;cavity_resonance_frequency&#39;</span>] = 20e9</div><div class="line">    group.attrs[<span class="stringliteral">&#39;nb_mirror_pairs&#39;</span>]            = 15</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Material</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>] = 0.27</div><div class="line">    group.attrs[<span class="stringliteral">&#39;youngs_modulus&#39;</span>] = 270000000000.0</div><div class="line">    group.attrs[<span class="stringliteral">&#39;material_a_rho&#39;</span>] = 3200</div><div class="line">    <span class="keywordflow">if</span> group == displacement:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;material_b_rho&#39;</span>] = 2000</div><div class="line">    <span class="keywordflow">else</span>:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;material_b_rho&#39;</span>] = 3200</div><div class="line">    group.attrs[<span class="stringliteral">&#39;lambda&#39;</span>] = (group.attrs[<span class="stringliteral">&#39;youngs_modulus&#39;</span>] * group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>] /</div><div class="line">                           ((1 + group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>]) *</div><div class="line">                           (1 - 2 * group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>])))</div><div class="line">    group.attrs[<span class="stringliteral">&#39;mu&#39;</span>]= (group.attrs[<span class="stringliteral">&#39;youngs_modulus&#39;</span>] / (2 * (1 + group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>])))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Force</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;max_force_amplitude&#39;</span>] = 1e26</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_sigma_x&#39;</span>]       = 1e-7</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_sigma_y&#39;</span>]       = 1</div><div class="line">    group.attrs[<span class="stringliteral">&#39;max_force_width_x&#39;</span>]   = 3e-7</div><div class="line">    group.attrs[<span class="stringliteral">&#39;max_force_width_y&#39;</span>]   = 2e-8</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_x_pos&#39;</span>]         = -8e-6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_y_pos&#39;</span>]         = 0</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># PML</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_x&#39;</span>]            = <span class="keyword">True</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_y&#39;</span>]            = <span class="keyword">False</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_width_x&#39;</span>]      = 1.8e-6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_width_y&#39;</span>]      = 5e-7</div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_coeff&#39;</span>]        = 1.6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_coeff_degree&#39;</span>] = 2</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Frequency sweep</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;center_frequency&#39;</span>]    = 20e9</div><div class="line">    group.attrs[<span class="stringliteral">&#39;frequency_range&#39;</span>]     = 0.5e9</div><div class="line">    group.attrs[<span class="stringliteral">&#39;start_frequency&#39;</span>]     = group.attrs[<span class="stringliteral">&#39;center_frequency&#39;</span>] - group.attrs[<span class="stringliteral">&#39;frequency_range&#39;</span>] / 2</div><div class="line">    group.attrs[<span class="stringliteral">&#39;stop_frequency&#39;</span>]      = group.attrs[<span class="stringliteral">&#39;center_frequency&#39;</span>] + group.attrs[<span class="stringliteral">&#39;frequency_range&#39;</span>] / 2</div><div class="line">    group.attrs[<span class="stringliteral">&#39;nb_frequency_points&#39;</span>] = 400</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Other parameters</span></div><div class="line">    <span class="keywordflow">if</span> group == displacement:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;simulation_name&#39;</span>] = <span class="stringliteral">&#39;phononic_cavity_displacement&#39;</span></div><div class="line">    <span class="keywordflow">else</span>:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;simulation_name&#39;</span>] = <span class="stringliteral">&#39;phononic_cavity_calibration&#39;</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;save_vtu_files&#39;</span>] = <span class="keyword">False</span></div><div class="line"></div><div class="line"></div><div class="line">h5_file.close()</div></div><!-- fragment --><p><a class="anchor" id="CommProg"></a> </p><h1>The commented program</h1>
<p><a class="anchor" id="Includefiles"></a> </p><h3>Include files</h3>
<p>我们在这个程序中需要的大部分包含文件已经在以前的程序中讨论过了，特别是在 <a class="el" href="step_40.html">step-40</a> .</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> </div></div><!-- fragment --><p>下面的标头提供了我们用来表示材料属性的张量类。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span> </div></div><!-- fragment --><p>下面的标头对于deal.II的HDF5接口是必要的。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hdf5_8h.html">deal.II/base/hdf5.h</a>&gt;</span> </div></div><!-- fragment --><p>这个头是我们用来评估模拟结果的函数 <a class="el" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a> 所需要的。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span> </div></div><!-- fragment --><p>我们在函数 <a class="el" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a> 中使用的函数 <code>ElasticWave::store_frequency_step_data()</code> 需要这些头文件。</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>step62 </div><div class="line">{ </div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div></div><!-- fragment --><p>{Auxiliary classes and functions} 下列类用于存储模拟的参数。</p>
<p>{The <code>RightHandSide</code> class} 该类用于定义结构左侧的力脉冲。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  RightHandSide(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>; </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div></div><!-- fragment --><p>变量<code>data</code>是 HDF5::Group ，所有的模拟结果都将被储存在其中。请注意， <code>RightHandSide::data</code>, 变量 <code>PML::data</code>, <code>Rho::data</code> 和 <code>Parameters::data</code> 指向HDF5文件的同一个组。当 HDF5::Group 被复制时，它将指向HDF5文件的同一组。</p>
<div class="fragment"><div class="line">HDF5::Group data; </div></div><!-- fragment --><p>仿真参数作为HDF5属性存储在<code>data</code>中。以下属性在jupyter笔记本中定义，作为HDF5属性存储在<code>data</code>中，然后由构造函数读取。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>     max_force_amplitude; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>     force_sigma_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>     force_sigma_y; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>     max_force_width_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>     max_force_width_y; </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> force_center; </div><div class="line"></div><div class="line"><span class="keyword">public</span>: </div></div><!-- fragment --><p>在这个特定的模拟中，力只有一个 \(x\) 分量， \(F_y=0\) 。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> force_component = 0; </div><div class="line">}; </div></div><!-- fragment --><p>{The <code>PML</code> class} 这个类是用来定义完美匹配层（PML）的形状，以吸收向边界传播的波。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>PML : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt; </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  PML(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> std::complex&lt;double&gt; </div><div class="line">  <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>; </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div></div><!-- fragment --><p>HDF5::Group ，所有的模拟结果将被存储在其中。</p>
<div class="fragment"><div class="line">HDF5::Group data; </div></div><!-- fragment --><p>和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在<code>data</code>中，然后由构造函数读取。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pml_coeff; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">int</span>    pml_coeff_degree; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> dimension_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> dimension_y; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>   pml_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>   pml_y; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pml_width_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> pml_width_y; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> a_coeff_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> a_coeff_y; </div><div class="line">}; </div></div><!-- fragment --><p>{The <code>Rho</code> class} 这个类是用来定义质量密度的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>Rho : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  Rho(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">double</span> <a class="code" href="classFunction.html#acbfcab66b2fc63bfea59268f40772bb4">value</a>(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>; </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div></div><!-- fragment --><p>HDF5::Group ，所有的模拟结果将被存储在其中。</p>
<div class="fragment"><div class="line">HDF5::Group data; </div></div><!-- fragment --><p>和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在<code>data</code>中，然后由构造函数读取。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       lambda; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       mu; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       material_a_rho; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       material_b_rho; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       cavity_resonance_frequency; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_mirror_pairs; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>       dimension_y; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> grid_level; </div><div class="line">  <span class="keywordtype">double</span>             average_rho_width; </div><div class="line">}; </div></div><!-- fragment --><p>{The <code>Parameters</code> class} 该类包含所有将在模拟中使用的参数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>Parameters </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  Parameters(HDF5::Group &amp;data); </div></div><!-- fragment --><p>HDF5::Group ，所有的模拟结果将被存储在其中。</p>
<div class="fragment"><div class="line">HDF5::Group data; </div></div><!-- fragment --><p>和以前一样，以下属性在jupyter笔记本中定义，作为HDF5属性存储在<code>data</code>中，然后由构造函数读取。</p>
<div class="fragment"><div class="line">  <span class="keyword">const</span> std::string        simulation_name; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">bool</span>               save_vtu_files; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>             start_frequency; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>             stop_frequency; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       nb_frequency_points; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>             lambda; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>             mu; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>             dimension_x; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span>             dimension_y; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       nb_probe_points; </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       grid_level; </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>         probe_start_point; </div><div class="line">  <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>         probe_stop_point; </div><div class="line">  <span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side; </div><div class="line">  <span class="keyword">const</span> PML&lt;dim&gt;           pml; </div><div class="line">  <span class="keyword">const</span> Rho&lt;dim&gt;           rho; </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> comparison_float_constant = 1e-12; </div><div class="line">}; </div></div><!-- fragment --><p>{The <code>QuadratureCache</code> class} 质量和刚度矩阵的计算是非常昂贵的。这些矩阵对所有的频率步骤都是一样的。右手边的向量对所有的频率步长也是一样的。我们用这个类来存储这些对象，并在每个频率步骤中重新使用它们。请注意，这里我们不存储集合的质量和刚度矩阵以及右手边，而是存储单个单元的数据。QuadratureCache "类与在  @ref step_18 "step-18"  中使用过的 "PointHistory "类非常相似。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>QuadratureCache </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  QuadratureCache(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell); </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell; </div><div class="line"></div><div class="line"><span class="keyword">public</span>: </div></div><!-- fragment --><p>我们在变量mass_coefficient和stiffness_coefficient中存储质量和刚度矩阵。我们还存储了右手边和JxW值，这些值对所有的频率步骤都是一样的。</p>
<div class="fragment"><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt;  mass_coefficient; </div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt;  stiffness_coefficient; </div><div class="line">  std::vector&lt;std::complex&lt;double&gt;&gt; right_hand_side; </div><div class="line">  <span class="keywordtype">double</span>                            JxW; </div><div class="line">}; </div></div><!-- fragment --><p><a class="anchor" id="Theget_stiffness_tensorfunction"></a> </p><h4>The <code>get_stiffness_tensor()</code> function</h4>
<p>该函数返回材料的刚度张量。为了简单起见，我们认为刚度是各向同性和同质的；只有密度 \(\rho\) 取决于位置。正如我们之前在 <a class="el" href="step_8.html">step-8</a> 中所表明的，如果刚度是各向同性和均质的，那么刚度系数 \(c_{ijkl}\) 可以表示为两个系数 \(\lambda\) 和 \(\mu\) 的函数。系数张量简化为 </p><p class="formulaDsp">
\[ c_{ijkl} = \lambda \delta_{ij} \delta_{kl} + \mu (\delta_{ik} \delta_{jl} + \delta_{il} \delta_{jk}). \]
</p>
<p> 。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_stiffness_tensor(<span class="keyword">const</span> <span class="keywordtype">double</span> lambda, </div><div class="line">                                             <span class="keyword">const</span> <span class="keywordtype">double</span> mu) </div><div class="line">{ </div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stiffness_tensor; </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i) </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dim; ++j) </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k) </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) </div><div class="line">          stiffness_tensor[i][j][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] = </div><div class="line">            (((i == k) &amp;&amp; (j == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) ? mu : 0.0) + </div><div class="line">             ((i == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) &amp;&amp; (j == k) ? mu : 0.0) + </div><div class="line">             ((i == j) &amp;&amp; (k == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) ? lambda : 0.0)); </div><div class="line">  <span class="keywordflow">return</span> stiffness_tensor; </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="TheElasticWaveclass"></a> </p><h3>The <code>ElasticWave</code> class</h3>
<p>接下来让我们声明这个程序的主类。它的结构与 <a class="el" href="step_40.html">step-40</a> 的教程程序非常相似。主要的区别是。</p>
<ul>
<li>扫过的频率值。</li>
<li>我们将刚度和质量矩阵保存在<code>quadrature_cache</code>中，并在每个频率步骤中使用它们。</li>
<li>我们在HDF5文件中存储每个频率步骤的探头测量的能量。</li>
</ul>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keyword">class </span>ElasticWave </div><div class="line">{ </div><div class="line"><span class="keyword">public</span>: </div><div class="line">  ElasticWave(<span class="keyword">const</span> Parameters&lt;dim&gt; &amp;parameters); </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(); </div><div class="line"></div><div class="line"><span class="keyword">private</span>: </div><div class="line">  <span class="keywordtype">void</span> setup_system(); </div><div class="line">  <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, </div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">bool</span>   calculate_quadrature_data); </div><div class="line">  <span class="keywordtype">void</span> solve(); </div><div class="line">  <span class="keywordtype">void</span> initialize_probe_positions_vector(); </div><div class="line">  <span class="keywordtype">void</span> store_frequency_step_data(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frequency_idx); </div><div class="line">  <span class="keywordtype">void</span> output_results(); </div></div><!-- fragment --><p>在每个频率步骤之前都会调用这个，以便为缓存变量设置一个原始状态。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> setup_quadrature_cache(); </div></div><!-- fragment --><p>这个函数在频率向量上循环，并在每个频率步骤上运行模拟。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> frequency_sweep(); </div></div><!-- fragment --><p>参数存储在这个变量中。</p>
<div class="fragment"><div class="line">Parameters&lt;dim&gt; parameters; </div><div class="line"></div><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator; </div><div class="line"></div><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>; </div><div class="line"></div><div class="line"><a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula; </div></div><!-- fragment --><p>我们将每个单元的质量和刚度矩阵存储在这个向量中。</p>
<div class="fragment"><div class="line">std::vector&lt;QuadratureCache&lt;dim&gt;&gt; quadrature_cache; </div><div class="line"></div><div class="line"><a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe; </div><div class="line"><a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler; </div><div class="line"></div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs; </div><div class="line"><a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs; </div><div class="line"></div><div class="line"><a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints; </div><div class="line"></div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">LinearAlgebraPETSc::MPI::SparseMatrix</a> system_matrix; </div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">LinearAlgebraPETSc::MPI::Vector</a>       locally_relevant_solution; </div><div class="line"><a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">LinearAlgebraPETSc::MPI::Vector</a>       system_rhs; </div></div><!-- fragment --><p>这个向量包含我们要模拟的频率范围。</p>
<div class="fragment"><div class="line">std::vector&lt;double&gt; frequency; </div></div><!-- fragment --><p>这个向量包含了测量探头各点的坐标 \((x,y)\) 。</p>
<div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> probe_positions; </div></div><!-- fragment --><p>HDF5数据集来存储频率和<code>探头位置</code>向量。</p>
<div class="fragment"><div class="line">HDF5::DataSet frequency_dataset; </div><div class="line">HDF5::DataSet probe_positions_dataset; </div></div><!-- fragment --><p>HDF5数据集，存储探头测量的能量值。</p>
<div class="fragment"><div class="line">  HDF5::DataSet displacement; </div><div class="line"></div><div class="line">  <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout; </div><div class="line">  <a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer; </div><div class="line">}; </div></div><!-- fragment --><p><a class="anchor" id="Implementationoftheauxiliaryclasses"></a> </p><h3>Implementation of the auxiliary classes</h3>
<p><a class="anchor" id="TheRightHandSideclassimplementation"></a> </p><h4>The <code>RightHandSide</code> class implementation</h4>
<p>构造函数使用 HDF5::Group <code>data</code>函数从 HDF5::Group::get_attribute() 读取所有参数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">RightHandSide&lt;dim&gt;::RightHandSide(HDF5::Group &amp;data) </div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim) </div><div class="line">  , data(data) </div><div class="line">  , max_force_amplitude(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;max_force_amplitude&quot;</span>)) </div><div class="line">  , force_sigma_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_sigma_x&quot;</span>)) </div><div class="line">  , force_sigma_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_sigma_y&quot;</span>)) </div><div class="line">  , max_force_width_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;max_force_width_x&quot;</span>)) </div><div class="line">  , max_force_width_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;max_force_width_y&quot;</span>)) </div><div class="line">  , force_center(<a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_x_pos&quot;</span>), </div><div class="line">                            data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_y_pos&quot;</span>))) </div><div class="line">{} </div></div><!-- fragment --><p>这个函数定义了力矢量脉冲的空间形状，它采取高斯函数 </p><p class="formulaDsp">
\begin{align*} F_x &amp;= \left\{ \begin{array}{ll} a \exp(- (\frac{(x-b_x)^2 }{ 2 \sigma_x^2}+\frac{(y-b_y)^2 }{ 2 \sigma_y^2})) &amp; \text{if}\, x_\textrm{min} &lt;x&lt;x_\textrm{max}\, \text{and}\, y_\textrm{min} &lt;y&lt;y_\textrm{max} \\ 0 &amp; \text{otherwise}, \end{array} \right.\\ F_y &amp;= 0 \end{align*}
</p>
<p> 的形式，其中 \(a\) 是取力的最大振幅， \(\sigma_x\) 和 \(\sigma_y\) 是 \(x\) 和 \(y\) 分量的标准偏差。请注意，脉冲已被裁剪为 \(x_\textrm{min}&lt;x&lt;x_\textrm{max}\) 和 \(y_\textrm{min} &lt;y&lt;y_\textrm{max}\) 。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                                 <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <span class="keywordflow">if</span> (component == force_component) </div><div class="line">    { </div><div class="line">      <span class="keywordflow">if</span> (std::abs(p[0] - force_center[0]) &lt; max_force_width_x / 2 &amp;&amp; </div><div class="line">          std::abs(p[1] - force_center[1]) &lt; max_force_width_y / 2) </div><div class="line">        { </div><div class="line">          <span class="keywordflow">return</span> max_force_amplitude * </div><div class="line">                 <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(std::pow(p[0] - force_center[0], 2) / </div><div class="line">                              (2 * std::pow(force_sigma_x, 2)) + </div><div class="line">                            std::pow(p[1] - force_center[1], 2) / </div><div class="line">                              (2 * std::pow(force_sigma_y, 2)))); </div><div class="line">        } </div><div class="line">      <span class="keywordflow">else</span> </div><div class="line">        { </div><div class="line">          <span class="keywordflow">return</span> 0; </div><div class="line">        } </div><div class="line">    } </div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    { </div><div class="line">      <span class="keywordflow">return</span> 0; </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ThePMLclassimplementation"></a> </p><h4>The <code>PML</code> class implementation</h4>
<p>和以前一样，构造函数使用 HDF5::Group 函数从 HDF5::Group::get_attribute() <code>data</code>中读取所有参数。正如我们所讨论的，在jupyter笔记本中已经定义了PML的二次开机。通过改变参数<code>pml_coeff_degree</code>，可以使用线性、立方或其他幂度。参数<code>pml_x</code>和<code>pml_y</code>可以用来开启和关闭<code>x</code>和<code>y</code>PML。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">PML&lt;dim&gt;::PML(HDF5::Group &amp;data) </div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(dim) </div><div class="line">  , data(data) </div><div class="line">  , pml_coeff(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;pml_coeff&quot;</span>)) </div><div class="line">  , pml_coeff_degree(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;pml_coeff_degree&quot;</span>)) </div><div class="line">  , dimension_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_x&quot;</span>)) </div><div class="line">  , dimension_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>)) </div><div class="line">  , pml_x(data.get_attribute&lt;<a class="code" href="classbool.html">bool</a>&gt;(<span class="stringliteral">&quot;pml_x&quot;</span>)) </div><div class="line">  , pml_y(data.get_attribute&lt;<a class="code" href="classbool.html">bool</a>&gt;(<span class="stringliteral">&quot;pml_y&quot;</span>)) </div><div class="line">  , pml_width_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;pml_width_x&quot;</span>)) </div><div class="line">  , pml_width_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;pml_width_y&quot;</span>)) </div><div class="line">  , a_coeff_x(pml_coeff / <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(pml_width_x, pml_coeff_degree)) </div><div class="line">  , a_coeff_y(pml_coeff / <a class="code" href="namespacestd.html">std</a>::<a class="code" href="classVectorizedArray.html#a92b3114a0ad75bad4886443acde56abf">pow</a>(pml_width_y, pml_coeff_degree)) </div><div class="line">{} </div></div><!-- fragment --><p><code>x</code>部分的PML系数的形式为 \(s&#39;_x = a_x x^{\textrm{degree}}\) 。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">std::complex&lt;double&gt; PML&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                                     <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div><div class="line">  <span class="keywordtype">double</span> calculated_pml_x_coeff = 0; </div><div class="line">  <span class="keywordtype">double</span> calculated_pml_y_coeff = 0; </div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((component == 0) &amp;&amp; pml_x) </div><div class="line">    { </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> pml_x_start_position = dimension_x / 2 - pml_width_x; </div><div class="line">      <span class="keywordflow">if</span> (std::abs(p[0]) &gt; pml_x_start_position) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> x_prime = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[0]) - pml_x_start_position; </div><div class="line">          calculated_pml_x_coeff = </div><div class="line">            a_coeff_x * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(x_prime, pml_coeff_degree); </div><div class="line">        } </div><div class="line">    } </div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> ((component == 1) &amp;&amp; pml_y) </div><div class="line">    { </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">double</span> pml_y_start_position = dimension_y / 2 - pml_width_y; </div><div class="line">      <span class="keywordflow">if</span> (std::abs(p[1]) &gt; pml_y_start_position) </div><div class="line">        { </div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">double</span> y_prime = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[1]) - pml_y_start_position; </div><div class="line">          calculated_pml_y_coeff = </div><div class="line">            a_coeff_y * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(y_prime, pml_coeff_degree); </div><div class="line">        } </div><div class="line">    } </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 1. + <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(calculated_pml_x_coeff, calculated_pml_y_coeff) * </div><div class="line">                std::complex&lt;double&gt;(0., 1.); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="TheRhoclassimplementation"></a> </p><h4>The <code>Rho</code> class implementation</h4>
<p>这个类是用来定义质量密度的。正如我们之前所解释的，一个声学超晶格空腔是由两个<a href="https:en.wikipedia.org/wiki/Band_gap">分布式反射器</a>、镜子和一个 \(\lambda/2\) 空腔组成的，其中 \(\lambda\) 是声波长。声学DBRs是一种周期性结构，其中一组具有对比性物理特性（声速指数）的双层堆栈被重复 \(N\) 次。波速的变化是由具有不同密度的层交替产生的。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">Rho&lt;dim&gt;::Rho(HDF5::Group &amp;data) </div><div class="line">  : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) </div><div class="line">  , data(data) </div><div class="line">  , lambda(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;lambda&quot;</span>)) </div><div class="line">  , mu(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;mu&quot;</span>)) </div><div class="line">  , material_a_rho(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;material_a_rho&quot;</span>)) </div><div class="line">  , material_b_rho(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;material_b_rho&quot;</span>)) </div><div class="line">  , cavity_resonance_frequency( </div><div class="line">      data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;cavity_resonance_frequency&quot;</span>)) </div><div class="line">  , nb_mirror_pairs(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;nb_mirror_pairs&quot;</span>)) </div><div class="line">  , dimension_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>)) </div><div class="line">  , grid_level(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;grid_level&quot;</span>)) </div><div class="line">{ </div></div><!-- fragment --><p>为了提高精度，我们使用[subpixel smoothing]（https:meep.readthedocs.io/en/latest/Subpixel_Smoothing/）。</p>
<div class="fragment"><div class="line">  average_rho_width = dimension_y / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2.0, grid_level)); </div><div class="line">  data.set_attribute(<span class="stringliteral">&quot;average_rho_width&quot;</span>, average_rho_width); </div><div class="line">} </div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">double</span> Rho&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, </div><div class="line">                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const </span></div><div class="line"><span class="keyword"></span>{ </div></div><!-- fragment --><p>声速由 </p><p class="formulaDsp">
\[ c = \frac{K_e}{\rho} \]
</p>
<p> 定义，其中 \(K_e\) 是有效弹性常数， \(\rho\) 是密度。这里我们考虑的是波导宽度远小于波长的情况。在这种情况下，可以证明对于二维的情况 </p><p class="formulaDsp">
\[ K_e = 4\mu\frac{\lambda +\mu}{\lambda+2\mu} \]
</p>
<p> 和三维的情况 \(K_e\) 等于杨氏模量。 </p><p class="formulaDsp">
\[ K_e = \mu\frac{3\lambda +2\mu}{\lambda+\mu} \]
</p>
<div class="fragment"><div class="line"><span class="keywordtype">double</span> elastic_constant; </div><div class="line"><span class="keywordflow">if</span> (dim == 2) </div><div class="line">  { </div><div class="line">    elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu); </div><div class="line">  } </div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == 3) </div><div class="line">  { </div><div class="line">    elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu); </div><div class="line">  } </div><div class="line"><span class="keywordflow">else</span> </div><div class="line">  { </div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line">  } </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> material_a_speed_of_sound = </div><div class="line">  <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(elastic_constant / material_a_rho); </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> material_a_wavelength = </div><div class="line">  material_a_speed_of_sound / cavity_resonance_frequency; </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> material_b_speed_of_sound = </div><div class="line">  <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(elastic_constant / material_b_rho); </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> material_b_wavelength = </div><div class="line">  material_b_speed_of_sound / cavity_resonance_frequency; </div></div><!-- fragment --><p>密度 \(\rho\) 采取以下形式 &lt;img alt="声学超晶格空腔" src="https:www.dealii.org/images/steps/developer/  step-62  .04.svg" height="200" //其中棕色代表材料_a，绿色代表材料_b。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> layer_transition_center = </div><div class="line">      material_a_wavelength / 2 + </div><div class="line">      idx * (material_b_wavelength / 4 + material_a_wavelength / 4); </div><div class="line">    <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= </div><div class="line">          (layer_transition_center - average_rho_width / 2) &amp;&amp; </div><div class="line">        std::abs(p[0]) &lt;= (layer_transition_center + average_rho_width / 2)) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = </div><div class="line">          (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[0]) - </div><div class="line">           (layer_transition_center - average_rho_width / 2)) / </div><div class="line">          average_rho_width; </div><div class="line">        <span class="keywordflow">return</span> (1 - coefficient) * material_a_rho + </div><div class="line">               coefficient * material_b_rho; </div><div class="line">      } </div><div class="line">  } </div></div><!-- fragment --><p>这里我们定义了<a href="https:meep.readthedocs.io/en/latest/Subpixel_Smoothing/">subpixel smoothing</a>，它可以提高模拟的精度。</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> layer_transition_center = </div><div class="line">      material_a_wavelength / 2 + </div><div class="line">      idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + </div><div class="line">      material_b_wavelength / 4; </div><div class="line">    <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= </div><div class="line">          (layer_transition_center - average_rho_width / 2) &amp;&amp; </div><div class="line">        std::abs(p[0]) &lt;= (layer_transition_center + average_rho_width / 2)) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = </div><div class="line">          (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[0]) - </div><div class="line">           (layer_transition_center - average_rho_width / 2)) / </div><div class="line">          average_rho_width; </div><div class="line">        <span class="keywordflow">return</span> (1 - coefficient) * material_b_rho + </div><div class="line">               coefficient * material_a_rho; </div><div class="line">      } </div><div class="line">  } </div></div><!-- fragment --><p>然后是腔体</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (std::abs(p[0]) &lt;= material_a_wavelength / 2) </div><div class="line">  { </div><div class="line">    <span class="keywordflow">return</span> material_a_rho; </div><div class="line">  } </div></div><!-- fragment --><p>材料层_a</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> layer_center = </div><div class="line">      material_a_wavelength / 2 + </div><div class="line">      idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + </div><div class="line">      material_b_wavelength / 4 + material_a_wavelength / 8; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> layer_width = material_a_wavelength / 4; </div><div class="line">    <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= (layer_center - layer_width / 2) &amp;&amp; </div><div class="line">        std::abs(p[0]) &lt;= (layer_center + layer_width / 2)) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">return</span> material_a_rho; </div><div class="line">      } </div><div class="line">  } </div></div><!-- fragment --><p>material_b层</p>
<div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> layer_center = </div><div class="line">      material_a_wavelength / 2 + </div><div class="line">      idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + </div><div class="line">      material_b_wavelength / 8; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> layer_width = material_b_wavelength / 4; </div><div class="line">    <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= (layer_center - layer_width / 2) &amp;&amp; </div><div class="line">        std::abs(p[0]) &lt;= (layer_center + layer_width / 2)) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">return</span> material_b_rho; </div><div class="line">      } </div><div class="line">  } </div></div><!-- fragment --><p>最后，默认的是 material_a。</p>
<div class="fragment"><div class="line">  <span class="keywordflow">return</span> material_a_rho; </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="TheParametersclassimplementation"></a> </p><h4>The <code>Parameters</code> class implementation</h4>
<p>构造函数使用 HDF5::Group 函数从 HDF5::Group::get_attribute() <code>data</code>中读取所有参数。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">Parameters&lt;dim&gt;::Parameters(HDF5::Group &amp;data) </div><div class="line">  : data(data) </div><div class="line">  , simulation_name(data.get_attribute&lt;<a class="code" href="namespacestd.html">std</a>::string&gt;(<span class="stringliteral">&quot;simulation_name&quot;</span>)) </div><div class="line">  , save_vtu_files(data.get_attribute&lt;<a class="code" href="classbool.html">bool</a>&gt;(<span class="stringliteral">&quot;save_vtu_files&quot;</span>)) </div><div class="line">  , start_frequency(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;start_frequency&quot;</span>)) </div><div class="line">  , stop_frequency(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;stop_frequency&quot;</span>)) </div><div class="line">  , nb_frequency_points(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;nb_frequency_points&quot;</span>)) </div><div class="line">  , lambda(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;lambda&quot;</span>)) </div><div class="line">  , mu(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;mu&quot;</span>)) </div><div class="line">  , dimension_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_x&quot;</span>)) </div><div class="line">  , dimension_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>)) </div><div class="line">  , nb_probe_points(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;nb_probe_points&quot;</span>)) </div><div class="line">  , grid_level(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;grid_level&quot;</span>)) </div><div class="line">  , probe_start_point(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_x&quot;</span>), </div><div class="line">                      data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_y&quot;</span>) - </div><div class="line">                        data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_width_y&quot;</span>) / 2) </div><div class="line">  , probe_stop_point(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_x&quot;</span>), </div><div class="line">                     data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_y&quot;</span>) + </div><div class="line">                       data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_width_y&quot;</span>) / 2) </div><div class="line">  , right_hand_side(data) </div><div class="line">  , pml(data) </div><div class="line">  , rho(data) </div><div class="line">{} </div></div><!-- fragment --><p><a class="anchor" id="TheQuadratureCacheclassimplementation"></a> </p><h4>The <code>QuadratureCache</code> class implementation</h4>
<p>我们需要为质量和刚度矩阵以及右手边的矢量保留足够的空间。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">QuadratureCache&lt;dim&gt;::QuadratureCache(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell) </div><div class="line">  : dofs_per_cell(dofs_per_cell) </div><div class="line">  , mass_coefficient(dofs_per_cell, dofs_per_cell) </div><div class="line">  , stiffness_coefficient(dofs_per_cell, dofs_per_cell) </div><div class="line">  , right_hand_side(dofs_per_cell) </div><div class="line">{} </div></div><!-- fragment --><p><a class="anchor" id="ImplementationoftheElasticWaveclass"></a> </p><h3>Implementation of the <code>ElasticWave</code> class</h3>
<p><a class="anchor" id="Constructor"></a> </p><h4>Constructor</h4>
<p>这与 <a class="el" href="step_40.html">step-40</a> 的构造函数非常相似。此外，我们还创建了HDF5数据集<code>frequency_dataset</code>，<code>position_dataset</code>和<code>displacement</code>。注意在创建HDF5数据集时使用了 "模板 "关键字。这是C++的要求，使用<code>template</code>关键字是为了将<code>create_dataset</code>作为一个依赖的模板名称。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">ElasticWave&lt;dim&gt;::ElasticWave(<span class="keyword">const</span> Parameters&lt;dim&gt; &amp;parameters) </div><div class="line">  : parameters(parameters) </div><div class="line">  , mpi_communicator(MPI_COMM_WORLD) </div><div class="line">  , triangulation(mpi_communicator, </div><div class="line">                  typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing( </div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement | </div><div class="line">                    <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)) </div><div class="line">  , quadrature_formula(2) </div><div class="line">  , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim) </div><div class="line">  , dof_handler(triangulation) </div><div class="line">  , frequency(parameters.nb_frequency_points) </div><div class="line">  , probe_positions(parameters.nb_probe_points, dim) </div><div class="line">  , frequency_dataset(parameters.data.template create_dataset&lt;<a class="code" href="classdouble.html">double</a>&gt;( </div><div class="line">      <span class="stringliteral">&quot;frequency&quot;</span>, </div><div class="line">      <a class="code" href="namespacestd.html">std</a>::vector&lt;hsize_t&gt;{parameters.nb_frequency_points})) </div><div class="line">  , probe_positions_dataset(parameters.data.template create_dataset&lt;double&gt;( </div><div class="line">      <span class="stringliteral">&quot;position&quot;</span>, </div><div class="line">      std::vector&lt;hsize_t&gt;{parameters.nb_probe_points, dim})) </div><div class="line">  , displacement( </div><div class="line">      parameters.data.template create_dataset&lt;std::complex&lt;double&gt;&gt;( </div><div class="line">        <span class="stringliteral">&quot;displacement&quot;</span>, </div><div class="line">        std::vector&lt;hsize_t&gt;{parameters.nb_probe_points, </div><div class="line">                             parameters.nb_frequency_points})) </div><div class="line">  , pcout(std::cout, </div><div class="line">          (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)) </div><div class="line">  , computing_timer(mpi_communicator, </div><div class="line">                    pcout, </div><div class="line">                    <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, </div><div class="line">                    <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>) </div><div class="line">{} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWavesetup_system"></a> </p><h4>ElasticWave::setup_system</h4>
<p>这个函数没有什么新内容，与 <a class="el" href="step_40.html">step-40</a> 的唯一区别是，我们不需要应用边界条件，因为我们使用PML来截断域。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::setup_system() </div><div class="line">{ </div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup&quot;</span>); </div><div class="line"></div><div class="line">  dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe); </div><div class="line"></div><div class="line">  locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>(); </div><div class="line">  <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs); </div><div class="line"></div><div class="line">  locally_relevant_solution.reinit(locally_owned_dofs, </div><div class="line">                                   locally_relevant_dofs, </div><div class="line">                                   mpi_communicator); </div><div class="line"></div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(locally_owned_dofs, mpi_communicator); </div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>(); </div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs); </div><div class="line">  <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints); </div><div class="line"></div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>(); </div><div class="line"></div><div class="line">  <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(locally_relevant_dofs); </div><div class="line"></div><div class="line">  <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>); </div><div class="line">  <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(dsp, </div><div class="line">                                             locally_owned_dofs, </div><div class="line">                                             mpi_communicator, </div><div class="line">                                             locally_relevant_dofs); </div><div class="line"></div><div class="line">  system_matrix.reinit(locally_owned_dofs, </div><div class="line">                       locally_owned_dofs, </div><div class="line">                       dsp, </div><div class="line">                       mpi_communicator); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWaveassemble_system"></a> </p><h4>ElasticWave::assemble_system</h4>
<p>这个函数也与 <a class="el" href="step_40.html">step-40</a> 非常相似，尽管有明显的区别。我们为每个频率/欧米茄步骤组装系统。在第一步中，我们设置<code>calculate_quadrature_data = True</code>，然后我们计算质量和刚度矩阵以及右手边的矢量。在随后的步骤中，我们将使用这些数据来加速计算。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, </div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">bool</span>   calculate_quadrature_data) </div><div class="line">{ </div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembly&quot;</span>); </div><div class="line"></div><div class="line">  <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values(fe, </div><div class="line">                          quadrature_formula, </div><div class="line">                          <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); </div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); </div><div class="line"></div><div class="line">  <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell); </div><div class="line">  <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt;     cell_rhs(dofs_per_cell); </div><div class="line"></div><div class="line">  std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </div></div><!-- fragment --><p>这里我们存储右手边的值，rho和PML的值。</p>
<div class="fragment"><div class="line">std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, Vector&lt;double&gt;(dim)); </div><div class="line">std::vector&lt;double&gt;         rho_values(n_q_points); </div><div class="line">std::vector&lt;Vector&lt;std::complex&lt;double&gt;&gt;&gt; pml_values( </div><div class="line">  n_q_points, <a class="code" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt;(dim)); </div></div><!-- fragment --><p>我们计算已经在jupyter笔记本中定义的 \(\lambda\) 和 \(\mu\) 的刚度张量。请注意，与 \(\rho\) 相反，刚度在整个领域中是恒定的。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stiffness_tensor = </div><div class="line">  get_stiffness_tensor&lt;dim&gt;(parameters.lambda, parameters.mu); </div></div><!-- fragment --><p>我们使用与 <a class="el" href="step_20.html">step-20</a> 相同的方法处理矢量值问题。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0); </div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>()) </div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned()) </div><div class="line">    { </div><div class="line">      cell_matrix = 0; </div><div class="line">      cell_rhs    = 0; </div></div><!-- fragment --><p>只有当我们要计算质量和刚度矩阵时，我们才必须计算右手边的rho和PML的值。否则我们可以跳过这个计算，这样可以大大减少总的计算时间。</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (calculate_quadrature_data) </div><div class="line">  { </div><div class="line">    fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">    parameters.right_hand_side.vector_value_list( </div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values); </div><div class="line">    parameters.rho.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), </div><div class="line">                              rho_values); </div><div class="line">    parameters.pml.vector_value_list( </div><div class="line">      fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pml_values); </div><div class="line">  } </div></div><!-- fragment --><p>我们已经在 <a class="el" href="step_18.html">step-18</a> 中做了这个工作。获得一个指向当前单元本地正交缓存数据的指针，作为防御措施，确保这个指针在全局数组的范围内。</p>
<div class="fragment"><div class="line">QuadratureCache&lt;dim&gt; *local_quadrature_points_data = </div><div class="line">  <span class="keyword">reinterpret_cast&lt;</span>QuadratureCache&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer()); </div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(local_quadrature_points_data &gt;= &amp;quadrature_cache.front(), </div><div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line"><a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(local_quadrature_points_data &lt;= &amp;quadrature_cache.back(), </div><div class="line">       <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) </div><div class="line">  { </div></div><!-- fragment --><p>quadrature_data变量用于存储质量和刚度矩阵、右手边向量和<code>JxW</code>的值。</p>
<div class="fragment"><div class="line">QuadratureCache&lt;dim&gt; &amp;quadrature_data = </div><div class="line">  local_quadrature_points_data[q]; </div></div><!-- fragment --><p>下面我们声明力向量和PML的参数 \(s\) 和 \(\xi\) 。</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>                       force; </div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;1, dim, std::complex&lt;double&gt;</a>&gt; s; </div><div class="line">std::complex&lt;double&gt;                 xi(1, 0); </div></div><!-- fragment --><p>下面的块只在第一个频率步骤中计算。</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (calculate_quadrature_data) </div><div class="line">  { </div></div><!-- fragment --><p>存储<code>JxW</code>的值。</p>
<div class="fragment"><div class="line">quadrature_data.JxW = fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q); </div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0; component &lt; dim; ++component) </div><div class="line">  { </div></div><!-- fragment --><p>将向量转换为张量，并计算出xi</p>
<div class="fragment"><div class="line">  force[component] = rhs_values[q][component]; </div><div class="line">  s[component]     = pml_values[q][component]; </div><div class="line">  xi *= s[component]; </div><div class="line">} </div></div><!-- fragment --><p>这里我们计算 \(\alpha_{mnkl}\) 和 \(\beta_{mnkl}\) 张量。</p>
<div class="fragment"><div class="line"><a class="code" href="classTensor.html">Tensor&lt;4, dim, std::complex&lt;double&gt;</a>&gt; alpha; </div><div class="line"><a class="code" href="classTensor.html">Tensor&lt;4, dim, std::complex&lt;double&gt;</a>&gt; beta; </div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; dim; ++m) </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; dim; ++n) </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k) </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) </div><div class="line">        { </div><div class="line">          alpha[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] = xi * </div><div class="line">                              stiffness_tensor[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] / </div><div class="line">                              (2.0 * s[n] * s[k]); </div><div class="line">          beta[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] = xi * </div><div class="line">                             stiffness_tensor[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] / </div><div class="line">                             (2.0 * s[n] * s[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>]); </div><div class="line">        } </div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">  { </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i = </div><div class="line">      fe_values[displacement].value(i, q); </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_phi_i = </div><div class="line">      fe_values[displacement].gradient(i, q); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j = </div><div class="line">          fe_values[displacement].value(j, q); </div><div class="line">        <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_phi_j = </div><div class="line">          fe_values[displacement].gradient(j, q); </div></div><!-- fragment --><p>计算质量矩阵的值。</p>
<div class="fragment"><div class="line">quadrature_data.mass_coefficient[i][j] = </div><div class="line">  rho_values[q] * xi * phi_i * phi_j; </div></div><!-- fragment --><p>在刚度张量的 \(mnkl\) 指数上循环。</p>
<div class="fragment"><div class="line">std::complex&lt;double&gt; stiffness_coefficient = 0; </div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; dim; ++m) </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; dim; ++n) </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k) </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) </div><div class="line">        { </div></div><!-- fragment --><p>这里我们计算刚度矩阵。 注意，由于PML的存在，刚度矩阵不是对称的。我们使用梯度函数（见<a href="https:www.dealii.org/current/doxygen/deal.II/group__vector__valued.html">文档</a>），它是一个 <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim&gt;</code> 。 矩阵 \(G_{ij}\) 由条目 </p><p class="formulaDsp">
\[ G_{ij}= \frac{\partial\phi_i}{\partial x_j} =\partial_j \phi_i \]
</p>
<p> 组成 注意指数 \(i\) 和 \(j\) 的位置以及我们在本教程中使用的符号。 \(\partial_j\phi_i\) . 由于刚度张量不是对称的，所以很容易出错。</p>
<div class="fragment"><div class="line">  stiffness_coefficient += </div><div class="line">    grad_phi_i[m][n] * </div><div class="line">    (alpha[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * grad_phi_j[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>][k] + </div><div class="line">     beta[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * grad_phi_j[k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>]); </div><div class="line">} </div></div><!-- fragment --><p>我们将刚度矩阵的值保存在quadrature_data中。</p>
<div class="fragment"><div class="line">  quadrature_data.stiffness_coefficient[i][j] = </div><div class="line">    stiffness_coefficient; </div><div class="line">} </div></div><!-- fragment --><p>和正交数据中的右手边的值。</p>
<div class="fragment"><div class="line">        phi_i * force * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q); </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p>我们再次循环单元的自由度来计算系统矩阵。这些循环非常快，因为我们已经计算了刚度和质量矩阵，只有 \(\omega\) 的值发生了变化。</p>
<div class="fragment"><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">              { </div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">                  { </div><div class="line">                    std::complex&lt;double&gt; matrix_sum = 0; </div><div class="line">                    matrix_sum += -<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(omega, 2) * </div><div class="line">                                  quadrature_data.mass_coefficient[i][j]; </div><div class="line">                    matrix_sum += quadrature_data.stiffness_coefficient[i][j]; </div><div class="line">                    <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += matrix_sum * quadrature_data.JxW; </div><div class="line">                  } </div><div class="line">                cell_rhs(i) += quadrature_data.right_hand_side[i]; </div><div class="line">              } </div><div class="line">          } </div><div class="line">        cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line">        constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix, </div><div class="line">                                               cell_rhs, </div><div class="line">                                               local_dof_indices, </div><div class="line">                                               system_matrix, </div><div class="line">                                               system_rhs); </div><div class="line">      } </div><div class="line"></div><div class="line">  system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>); </div><div class="line">  system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWavesolve"></a> </p><h4>ElasticWave::solve</h4>
<p>这比 <a class="el" href="step_40.html">step-40</a> 更加简单。我们使用并行的直接求解器MUMPS，它比迭代求解器需要更少的选项。缺点是它不能很好地扩展。用迭代求解器来解决Helmholtz方程并不简单。移位拉普拉斯多网格法是一种众所周知的预处理该系统的方法，但这超出了本教程的范围。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::solve() </div><div class="line">{ </div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>              t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>); </div><div class="line">  <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">LinearAlgebraPETSc::MPI::Vector</a> completely_distributed_solution( </div><div class="line">    locally_owned_dofs, mpi_communicator); </div><div class="line"></div><div class="line">  <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control; </div><div class="line">  <a class="code" href="classPETScWrappers_1_1SparseDirectMUMPS.html">PETScWrappers::SparseDirectMUMPS</a> solver(solver_control, mpi_communicator); </div><div class="line">  solver.solve(system_matrix, completely_distributed_solution, system_rhs); </div><div class="line"></div><div class="line">  pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> </div><div class="line">        &lt;&lt; std::endl; </div><div class="line">  constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(completely_distributed_solution); </div><div class="line">  locally_relevant_solution = completely_distributed_solution; </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWaveinitialize_position_vector"></a> </p><h4>ElasticWave::initialize_position_vector</h4>
<p>我们用这个函数来计算位置向量的值。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::initialize_probe_positions_vector() </div><div class="line">{ </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> position_idx = 0; </div><div class="line">       position_idx &lt; parameters.nb_probe_points; </div><div class="line">       ++position_idx) </div><div class="line">    { </div></div><!-- fragment --><p>由于运算符+和</p>
<p>-被重载来减去两个点，所以必须做如下操作。<code>Point_b&lt;dim&gt; + (-Point_a&lt;dim&gt;)</code>。</p>
<div class="fragment"><div class="line">      <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p = </div><div class="line">        (position_idx / ((<a class="code" href="classdouble.html">double</a>)(parameters.nb_probe_points - 1))) * </div><div class="line">          (parameters.probe_stop_point + (-parameters.probe_start_point)) + </div><div class="line">        parameters.probe_start_point; </div><div class="line">      probe_positions[position_idx][0] = p[0]; </div><div class="line">      probe_positions[position_idx][1] = p[1]; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          probe_positions[position_idx][2] = p[2]; </div><div class="line">        } </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWavestore_frequency_step_data"></a> </p><h4>ElasticWave::store_frequency_step_data</h4>
<p>该函数在HDF5文件中存储探头测量的能量。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> </div><div class="line">ElasticWave&lt;dim&gt;::store_frequency_step_data(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frequency_idx) </div><div class="line">{ </div><div class="line">  <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;store_frequency_step_data&quot;</span>); </div></div><!-- fragment --><p>我们存储 \(x\) 方向的位移； \(y\) 方向的位移可以忽略不计。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> probe_displacement_component = 0; </div></div><!-- fragment --><p>向量坐标包含HDF5文件中位于本地所有单元中的探测点的坐标。向量displacement_data包含这些点的位移值。</p>
<div class="fragment"><div class="line">std::vector&lt;hsize_t&gt;              coordinates; </div><div class="line">std::vector&lt;std::complex&lt;double&gt;&gt; displacement_data; </div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> &amp;mapping = <a class="code" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>(triangulation); </div><div class="line"><a class="code" href="classGridTools_1_1Cache.html">GridTools::Cache&lt;dim, dim&gt;</a> cache(triangulation, mapping); </div><div class="line"><span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim, dim&gt;::active_cell_iterator</a> cell_hint{}; </div><div class="line">std::vector&lt;bool&gt;                                      marked_vertices = {}; </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span>                                           tolerance = 1.e-10; </div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> position_idx = 0; </div><div class="line">     position_idx &lt; parameters.nb_probe_points; </div><div class="line">     ++position_idx) </div><div class="line">  { </div><div class="line">    <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>; </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">      { </div><div class="line">        point[dim_idx] = probe_positions[position_idx][dim_idx]; </div><div class="line">      } </div><div class="line">    <span class="keywordtype">bool</span> point_in_locally_owned_cell = <span class="keyword">false</span>; </div><div class="line">    { </div><div class="line">      <span class="keyword">auto</span> cell_and_ref_point = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>( </div><div class="line">        cache, point, cell_hint, marked_vertices, tolerance); </div><div class="line">      <span class="keywordflow">if</span> (cell_and_ref_point.first.state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>) </div><div class="line">        { </div><div class="line">          cell_hint = cell_and_ref_point.first; </div><div class="line">          point_in_locally_owned_cell = </div><div class="line">            cell_and_ref_point.first-&gt;is_locally_owned(); </div><div class="line">        } </div><div class="line">    } </div><div class="line">    <span class="keywordflow">if</span> (point_in_locally_owned_cell) </div><div class="line">      { </div></div><!-- fragment --><p>然后，我们可以在<code>displacement_data</code>中存储探头各点的位移值。</p>
<div class="fragment"><div class="line">      <a class="code" href="classVector.html">Vector&lt;std::complex&lt;double&gt;</a>&gt; tmp_vector(dim); </div><div class="line">      <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, </div><div class="line">                               locally_relevant_solution, </div><div class="line">                               point, </div><div class="line">                               tmp_vector); </div><div class="line">      coordinates.emplace_back(position_idx); </div><div class="line">      coordinates.emplace_back(frequency_idx); </div><div class="line">      displacement_data.emplace_back( </div><div class="line">        tmp_vector(probe_displacement_component)); </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p>我们在HDF5文件中写入位移数据。调用 HDF5::DataSet::write_selection() 是MPI集体的，这意味着所有进程都要参与。</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (coordinates.size() &gt; 0) </div><div class="line">  { </div><div class="line">    displacement.write_selection(displacement_data, coordinates); </div><div class="line">  } </div></div><!-- fragment --><p>因此，即使进程没有数据可写，它也必须参与集体调用。为此我们可以使用 HDF5::DataSet::write_none(). 注意，我们必须指定数据类型，在这种情况下 <code>std::complex&lt;double&gt;</code>. 。</p>
<div class="fragment"><div class="line"><span class="keywordflow">else</span> </div><div class="line">  { </div><div class="line">    displacement.write_none&lt;std::complex&lt;double&gt;&gt;(); </div><div class="line">  } </div></div><!-- fragment --><p>如果输入文件中的变量<code>save_vtu_files</code>等于<code>True</code>，那么所有数据将被保存为vtu。写入`vtu'文件的过程已经在 <a class="el" href="step_40.html">step-40</a> 中描述。</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (parameters.save_vtu_files) </div><div class="line">  { </div><div class="line">    std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;displacement&quot;</span>); </div><div class="line">    std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt; </div><div class="line">      interpretation( </div><div class="line">        dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>); </div><div class="line"></div><div class="line">    <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; </div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, </div><div class="line">                             locally_relevant_solution, </div><div class="line">                             solution_names, </div><div class="line">                             interpretation); </div><div class="line">    <a class="code" href="classVector.html">Vector&lt;float&gt;</a> subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i) </div><div class="line">      subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(); </div><div class="line">    data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>); </div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; force( </div><div class="line">      dim, Vector&lt;double&gt;(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>())); </div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; pml( </div><div class="line">      dim, Vector&lt;double&gt;(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>())); </div><div class="line">    Vector&lt;double&gt; rho(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>()) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">if</span> (cell-&gt;is_locally_owned()) </div><div class="line">          { </div><div class="line">            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">              { </div><div class="line">                force[dim_idx](cell-&gt;active_cell_index()) = </div><div class="line">                  parameters.right_hand_side.value(cell-&gt;center(), dim_idx); </div><div class="line">                pml[dim_idx](cell-&gt;active_cell_index()) = </div><div class="line">                  parameters.pml.value(cell-&gt;center(), dim_idx).imag(); </div><div class="line">              } </div><div class="line">            rho(cell-&gt;active_cell_index()) = </div><div class="line">              parameters.rho.value(cell-&gt;center()); </div><div class="line">          } </div></div><!-- fragment --><p>在我们不感兴趣的单元格上，将各自的值设置为一个假值，以确保如果我们的假设有什么错误，我们会通过查看图形输出发现。</p>
<div class="fragment"><div class="line">          <span class="keywordflow">else</span> </div><div class="line">            { </div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">                { </div><div class="line">                  force[dim_idx](cell-&gt;active_cell_index()) = -1e+20; </div><div class="line">                  pml[dim_idx](cell-&gt;active_cell_index())   = -1e+20; </div><div class="line">                } </div><div class="line">              rho(cell-&gt;active_cell_index()) = -1e+20; </div><div class="line">            } </div><div class="line">        } </div><div class="line"></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">        { </div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(force[dim_idx], </div><div class="line">                                   <span class="stringliteral">&quot;force_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim_idx)); </div><div class="line">          data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(pml[dim_idx], </div><div class="line">                                   <span class="stringliteral">&quot;pml_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim_idx)); </div><div class="line">        } </div><div class="line">      data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(rho, <span class="stringliteral">&quot;rho&quot;</span>); </div><div class="line"></div><div class="line">      data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(); </div><div class="line"></div><div class="line">      std::stringstream  frequency_idx_stream; </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_number_positions = </div><div class="line">        ((<span class="keywordtype">unsigned</span> int)<a class="code" href="namespaceDifferentiation_1_1SD.html#af3073c01113bca5a5e9a1b921643ced4">std::log10</a>(parameters.nb_frequency_points)) + 1; </div><div class="line">      frequency_idx_stream &lt;&lt; std::setw(nb_number_positions) </div><div class="line">                           &lt;&lt; std::setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; frequency_idx; </div><div class="line">      std::string filename = (parameters.simulation_name + <span class="stringliteral">&quot;_&quot;</span> + </div><div class="line">                              frequency_idx_stream.str() + <span class="stringliteral">&quot;.vtu&quot;</span>); </div><div class="line">      data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(filename.c_str(), mpi_communicator); </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWaveoutput_results"></a> </p><h4>ElasticWave::output_results</h4>
<p>该函数写入尚未写入的数据集。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::output_results() </div><div class="line">{ </div></div><!-- fragment --><p>向量<code>频率</code>和<code>位置</code>对所有进程都是一样的。因此任何一个进程都可以写入相应的`数据集'。因为调用 HDF5::DataSet::write 是MPI集体的，其余进程将不得不调用 HDF5::DataSet::write_none. 。</p>
<div class="fragment"><div class="line">  <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0) </div><div class="line">    { </div><div class="line">      frequency_dataset.write(frequency); </div><div class="line">      probe_positions_dataset.write(probe_positions); </div><div class="line">    } </div><div class="line">  <span class="keywordflow">else</span> </div><div class="line">    { </div><div class="line">      frequency_dataset.write_none&lt;<span class="keywordtype">double</span>&gt;(); </div><div class="line">      probe_positions_dataset.write_none&lt;<span class="keywordtype">double</span>&gt;(); </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWavesetup_quadrature_cache"></a> </p><h4>ElasticWave::setup_quadrature_cache</h4>
<p>我们在计算开始时使用这个函数来设置缓存变量的初始值。这个函数在 <a class="el" href="step_18.html">step-18</a> 中已经描述过。与 <a class="el" href="step_18.html">step-18</a> 的函数没有区别。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::setup_quadrature_cache() </div><div class="line">{ </div><div class="line">  triangulation.<a class="code" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a>(); </div><div class="line"></div><div class="line">  { </div><div class="line">    std::vector&lt;QuadratureCache&lt;dim&gt;&gt; tmp; </div><div class="line">    quadrature_cache.swap(tmp); </div><div class="line">  } </div><div class="line"></div><div class="line">  quadrature_cache.resize(triangulation.n_locally_owned_active_cells() * </div><div class="line">                            quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(), </div><div class="line">                          QuadratureCache&lt;dim&gt;(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>())); </div><div class="line">  <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cache_index = 0; </div><div class="line">  <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>()) </div><div class="line">    <span class="keywordflow">if</span> (cell-&gt;is_locally_owned()) </div><div class="line">      { </div><div class="line">        cell-&gt;set_user_pointer(&amp;quadrature_cache[cache_index]); </div><div class="line">        cache_index += quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); </div><div class="line">      } </div><div class="line">  <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache_index == quadrature_cache.size(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWavefrequency_sweep"></a> </p><h4>ElasticWave::frequency_sweep</h4>
<p>为了清楚起见，我们将 <a class="el" href="step_40.html">step-40</a> 的函数<code>run</code>分为函数<code>run</code>和<code>frequency_sweep</code>。在函数<code>frequency_sweep</code>中，我们把迭代放在频率向量上。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line"><span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::frequency_sweep() </div><div class="line">{ </div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frequency_idx = 0; </div><div class="line">       frequency_idx &lt; parameters.nb_frequency_points; </div><div class="line">       ++frequency_idx) </div><div class="line">    { </div><div class="line">      pcout &lt;&lt; parameters.simulation_name + <span class="stringliteral">&quot; frequency idx: &quot;</span> </div><div class="line">            &lt;&lt; frequency_idx &lt;&lt; <span class="charliteral">&#39;/&#39;</span> &lt;&lt; parameters.nb_frequency_points - 1 </div><div class="line">            &lt;&lt; std::endl; </div><div class="line"></div><div class="line">      setup_system(); </div><div class="line">      <span class="keywordflow">if</span> (frequency_idx == 0) </div><div class="line">        { </div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells :       &quot;</span> </div><div class="line">                &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl; </div><div class="line">          pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom : &quot;</span> </div><div class="line">                &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl; </div><div class="line">        } </div><div class="line"></div><div class="line">      <span class="keywordflow">if</span> (frequency_idx == 0) </div><div class="line">        { </div></div><!-- fragment --><p>只写一次模拟参数</p>
<div class="fragment"><div class="line">  parameters.data.set_attribute(<span class="stringliteral">&quot;active_cells&quot;</span>, </div><div class="line">                                triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line">  parameters.data.set_attribute(<span class="stringliteral">&quot;degrees_of_freedom&quot;</span>, </div><div class="line">                                dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">} </div></div><!-- fragment --><p>我们计算出这个特定步骤的频率和欧米茄值。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> current_loop_frequency = </div><div class="line">  (parameters.start_frequency + </div><div class="line">   frequency_idx * </div><div class="line">     (parameters.stop_frequency - parameters.start_frequency) / </div><div class="line">     (parameters.nb_frequency_points - 1)); </div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> current_loop_omega = </div><div class="line">  2 * numbers::PI * current_loop_frequency; </div></div><!-- fragment --><p>在第一个频率步骤中，我们计算出质量和刚度矩阵以及右手边的数据。在随后的频率步骤中，我们将使用这些值。这大大改善了计算时间。</p>
<div class="fragment"><div class="line">      assemble_system(current_loop_omega, </div><div class="line">                      (frequency_idx == 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>); </div><div class="line">      solve(); </div><div class="line"></div><div class="line">      frequency[frequency_idx] = current_loop_frequency; </div><div class="line">      store_frequency_step_data(frequency_idx); </div><div class="line"></div><div class="line">      computing_timer.print_summary(); </div><div class="line">      computing_timer.reset(); </div><div class="line">      pcout &lt;&lt; std::endl; </div><div class="line">    } </div><div class="line">} </div></div><!-- fragment --><p><a class="anchor" id="ElasticWaverun"></a> </p><h4>ElasticWave::run</h4>
<p>这个函数与 <a class="el" href="step_40.html">step-40</a> 中的函数非常相似。</p>
<div class="fragment"><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ElasticWave&lt;dim&gt;::run</a>() </div><div class="line">  { </div><div class="line"><span class="preprocessor">#ifdef DEBUG </span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Debug mode&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="preprocessor">#else </span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Release mode&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="preprocessor">#endif </span></div><div class="line"></div><div class="line">    { </div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1; </div><div class="line">      p1(0) = -parameters.dimension_x / 2; </div><div class="line">      p1(1) = -parameters.dimension_y / 2; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          p1(2) = -parameters.dimension_y / 2; </div><div class="line">        } </div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2; </div><div class="line">      p2(0) = parameters.dimension_x / 2; </div><div class="line">      p2(1) = parameters.dimension_y / 2; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          p2(2) = parameters.dimension_y / 2; </div><div class="line">        } </div><div class="line">      std::vector&lt;unsigned int&gt; divisions(dim); </div><div class="line">      divisions[0] = int(parameters.dimension_x / parameters.dimension_y); </div><div class="line">      divisions[1] = 1; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          divisions[2] = 1; </div><div class="line">        } </div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation, </div><div class="line">                                                divisions, </div><div class="line">                                                p1, </div><div class="line">                                                p2); </div><div class="line">    } </div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(parameters.grid_level); </div><div class="line"></div><div class="line">    setup_quadrature_cache(); </div><div class="line"></div><div class="line">    initialize_probe_positions_vector(); </div><div class="line"></div><div class="line">    frequency_sweep(); </div><div class="line"></div><div class="line">    output_results(); </div><div class="line">  } </div><div class="line">} <span class="comment">// namespace step62 </span></div></div><!-- fragment --><p><a class="anchor" id="Themainfunction"></a> </p><h4>The main function</h4>
<p>主函数与 <a class="el" href="step_40.html">step-40</a> 中的函数非常相似。</p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) </div><div class="line">{ </div><div class="line">  <span class="keywordflow">try</span> </div><div class="line">    { </div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2; </div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1); </div><div class="line"></div><div class="line">      HDF5::File data_file(<span class="stringliteral">&quot;results.h5&quot;</span>, </div><div class="line">                           HDF5::File::FileAccessMode::create, </div><div class="line">                           MPI_COMM_WORLD); </div><div class="line">      <span class="keyword">auto</span>       data = data_file.create_group(<span class="stringliteral">&quot;data&quot;</span>); </div></div><!-- fragment --><p>每个模拟（位移和校准）都存储在一个单独的HDF5组中。</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> std::vector&lt;std::string&gt; group_names = {<span class="stringliteral">&quot;displacement&quot;</span>, </div><div class="line">                                              <span class="stringliteral">&quot;calibration&quot;</span>}; </div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> group_name : group_names) </div><div class="line">  { </div></div><!-- fragment --><p>对于这两个组名中的每一个，我们现在创建组并将属性放入这些组。具体来说，这些是。</p>
<ul>
<li>波导的尺寸（在 \(x\) 和 \(y\) 方向）。</li>
<li>探头的位置（在 \(x\) 和 \(y\) 方向）。</li>
<li>探针中的点的数量</li>
<li>全局细化水平</li>
<li>腔体谐振频率</li>
<li>镜像对的数量</li>
<li>镜子的数量</li>
<li>材料特性</li>
<li>力的参数</li>
<li>PML参数</li>
<li>频率参数</li>
</ul>
<div class="fragment"><div class="line">    <span class="keyword">auto</span> group = data.create_group(group_name); </div><div class="line"></div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;dimension_x&quot;</span>, 2e-5); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>, 2e-8); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;probe_pos_x&quot;</span>, 8e-6); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;probe_pos_y&quot;</span>, 0); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;probe_width_y&quot;</span>, 2e-08); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_probe_points&quot;</span>, 5); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;grid_level&quot;</span>, 1); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;cavity_resonance_frequency&quot;</span>, 20e9); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_mirror_pairs&quot;</span>, 15); </div><div class="line"></div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>, 0.27); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;youngs_modulus&quot;</span>, 270000000000.0); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;material_a_rho&quot;</span>, 3200); </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (group_name == std::string(<span class="stringliteral">&quot;displacement&quot;</span>)) </div><div class="line">      group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;material_b_rho&quot;</span>, 2000); </div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;material_b_rho&quot;</span>, 3200); </div><div class="line"></div><div class="line">    group.set_attribute( </div><div class="line">      <span class="stringliteral">&quot;lambda&quot;</span>, </div><div class="line">      group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;youngs_modulus&quot;</span>) * </div><div class="line">        group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>) / </div><div class="line">        ((1 + group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>)) * </div><div class="line">         (1 - 2 * group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>)))); </div><div class="line">    group.set_attribute(<span class="stringliteral">&quot;mu&quot;</span>, </div><div class="line">                        group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;youngs_modulus&quot;</span>) / </div><div class="line">                          (2 * (1 + group.get_attribute&lt;<span class="keywordtype">double</span>&gt;( </div><div class="line">                                      <span class="stringliteral">&quot;poissons_ratio&quot;</span>)))); </div><div class="line"></div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;max_force_amplitude&quot;</span>, 1e26); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_sigma_x&quot;</span>, 1e-7); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_sigma_y&quot;</span>, 1); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;max_force_width_x&quot;</span>, 3e-7); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;max_force_width_y&quot;</span>, 2e-8); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_x_pos&quot;</span>, -8e-6); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_y_pos&quot;</span>, 0); </div><div class="line"></div><div class="line">    group.set_attribute&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;pml_x&quot;</span>, <span class="keyword">true</span>); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;pml_y&quot;</span>, <span class="keyword">false</span>); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;pml_width_x&quot;</span>, 1.8e-6); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;pml_width_y&quot;</span>, 5e-7); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;pml_coeff&quot;</span>, 1.6); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;pml_coeff_degree&quot;</span>, 2); </div><div class="line"></div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;center_frequency&quot;</span>, 20e9); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;frequency_range&quot;</span>, 0.5e9); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;( </div><div class="line">      <span class="stringliteral">&quot;start_frequency&quot;</span>, </div><div class="line">      group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;center_frequency&quot;</span>) - </div><div class="line">        group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;frequency_range&quot;</span>) / 2); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">double</span>&gt;( </div><div class="line">      <span class="stringliteral">&quot;stop_frequency&quot;</span>, </div><div class="line">      group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;center_frequency&quot;</span>) + </div><div class="line">        group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;frequency_range&quot;</span>) / 2); </div><div class="line">    group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_frequency_points&quot;</span>, 400); </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (group_name == std::string(<span class="stringliteral">&quot;displacement&quot;</span>)) </div><div class="line">      group.set_attribute&lt;std::string&gt;( </div><div class="line">        <span class="stringliteral">&quot;simulation_name&quot;</span>, std::string(<span class="stringliteral">&quot;phononic_cavity_displacement&quot;</span>)); </div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      group.set_attribute&lt;std::string&gt;( </div><div class="line">        <span class="stringliteral">&quot;simulation_name&quot;</span>, std::string(<span class="stringliteral">&quot;phononic_cavity_calibration&quot;</span>)); </div><div class="line"></div><div class="line">    group.set_attribute&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;save_vtu_files&quot;</span>, <span class="keyword">false</span>); </div><div class="line">  } </div><div class="line"></div><div class="line">{ </div></div><!-- fragment --><p>位移模拟。参数从位移HDF5组中读取，结果保存在同一HDF5组中。</p>
<div class="fragment"><div class="line">  <span class="keyword">auto</span>                    displacement = data.open_group(<span class="stringliteral">&quot;displacement&quot;</span>); </div><div class="line">  step62::Parameters&lt;dim&gt; parameters(displacement); </div><div class="line"></div><div class="line">  step62::ElasticWave&lt;dim&gt; elastic_problem(parameters); </div><div class="line">  elastic_problem.run(); </div><div class="line">} </div><div class="line"></div><div class="line">{ </div></div><!-- fragment --><p>校准模拟。参数从校准HDF5组中读取，结果保存在同一HDF5组中。</p>
<div class="fragment"><div class="line">        <span class="keyword">auto</span>                    calibration = data.open_group(<span class="stringliteral">&quot;calibration&quot;</span>); </div><div class="line">        step62::Parameters&lt;dim&gt; parameters(calibration); </div><div class="line"></div><div class="line">        step62::ElasticWave&lt;dim&gt; elastic_problem(parameters); </div><div class="line">        elastic_problem.run(); </div><div class="line">      } </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (...) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">} </div></div><!-- fragment --><p> examples/step-62/doc/results.dox</p>
<p><a class="anchor" id="Results"></a></p><h1>Results</h1>
<p><a class="anchor" id="Resonancefrequencyandbandgap"></a></p><h3>Resonance frequency and bandgap</h3>
<p>在<a href="https://github.com/dealii/dealii/blob/master/example/step-62/step-62.ipynb">jupyter notebook</a>中用以下代码分析了结果</p>
<div class="fragment"><div class="line">h5_file = h5py.File(<span class="stringliteral">&#39;results.h5&#39;</span>, <span class="stringliteral">&#39;r&#39;)</span></div><div class="line"><span class="stringliteral">data = h5_file[&#39;data&#39;</span>]</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Gaussian function that we use to fit the resonance</span></div><div class="line"><span class="keyword">def </span>resonance_f(freq, freq_m, quality_factor, max_amplitude):</div><div class="line">    omega = 2 * constants.pi * freq</div><div class="line">    omega_m = 2 * constants.pi * freq_m</div><div class="line">    gamma = omega_m / quality_factor</div><div class="line">    <span class="keywordflow">return</span> max_amplitude * omega_m**2 * gamma**2 / (((omega_m**2 - omega**2)**2 + gamma**2 * omega**2))</div><div class="line"></div><div class="line"></div><div class="line">frequency = data[<span class="stringliteral">&#39;displacement&#39;</span>][<span class="stringliteral">&#39;frequency&#39;</span>][...]</div><div class="line"><span class="comment"># Average the probe points</span></div><div class="line">displacement = np.mean(data[<span class="stringliteral">&#39;displacement&#39;</span>][<span class="stringliteral">&#39;displacement&#39;</span>], axis=0)</div><div class="line">calibration_displacement = np.mean(data[<span class="stringliteral">&#39;calibration&#39;</span>][<span class="stringliteral">&#39;displacement&#39;</span>], axis=0)</div><div class="line">reflection_coefficient = displacement / calibration_displacement</div><div class="line">reflectivity = (np.abs(np.mean(data[<span class="stringliteral">&#39;displacement&#39;</span>][<span class="stringliteral">&#39;displacement&#39;</span>][...]**2, axis=0))/</div><div class="line">                np.abs(np.mean(data[<span class="stringliteral">&#39;calibration&#39;</span>][<span class="stringliteral">&#39;displacement&#39;</span>][...]**2, axis=0)))</div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordflow">try</span>:</div><div class="line">    x_data = frequency</div><div class="line">    y_data = reflectivity</div><div class="line">    quality_factor_guess = 1e3</div><div class="line">    freq_guess = x_data[np.argmax(y_data)]</div><div class="line">    amplitude_guess = np.max(y_data)</div><div class="line">    fit_result, covariance = scipy.optimize.curve_fit(resonance_f, x_data, y_data,</div><div class="line">                                                      [freq_guess, quality_factor_guess, amplitude_guess])</div><div class="line">    freq_m = fit_result[0]</div><div class="line">    quality_factor = np.abs(fit_result[1])</div><div class="line">    max_amplitude = fit_result[2]</div><div class="line">    y_data_fit = resonance_f(x_data, freq_m, quality_factor, max_amplitude)</div><div class="line"></div><div class="line"></div><div class="line">    fig = plt.figure()</div><div class="line">    plt.plot(frequency / 1e9, reflectivity, frequency / 1e9, y_data_fit)</div><div class="line">    plt.xlabel(<span class="stringliteral">&#39;frequency (GHz)&#39;</span>)</div><div class="line">    plt.ylabel(<span class="stringliteral">&#39;amplitude^2 (a.u.)&#39;</span>)</div><div class="line">    plt.title(<span class="stringliteral">&#39;Transmission\n&#39;</span> + <span class="stringliteral">&#39;freq = &#39;</span> + <span class="stringliteral">&quot;%.7g&quot;</span> % (freq_guess / 1e9) + <span class="stringliteral">&#39;GHz Q = &#39;</span> + <span class="stringliteral">&quot;%.6g&quot;</span> % quality_factor)</div><div class="line"><span class="keywordflow">except</span>:</div><div class="line">    fig = plt.figure()</div><div class="line">    plt.plot(frequency / 1e9, reflectivity)</div><div class="line">    plt.xlabel(<span class="stringliteral">&#39;frequency (GHz)&#39;</span>)</div><div class="line">    plt.ylabel(<span class="stringliteral">&#39;amplitude^2 (a.u.)&#39;</span>)</div><div class="line">    plt.title(<span class="stringliteral">&#39;Transmission&#39;</span>)</div><div class="line"></div><div class="line"></div><div class="line">fig = plt.figure()</div><div class="line">plt.plot(frequency / 1e9, np.angle(reflection_coefficient))</div><div class="line">plt.xlabel(<span class="stringliteral">&#39;frequency (GHz)&#39;</span>)</div><div class="line">plt.ylabel(<span class="stringliteral">&#39;phase (rad)&#39;</span>)</div><div class="line">plt.title(<span class="stringliteral">&#39;Phase (transmission coefficient)\n&#39;</span>)</div><div class="line"></div><div class="line"></div><div class="line">plt.show()</div><div class="line">h5_file.close()</div></div><!-- fragment --><p>一个声腔的特点是<a href="https://en.wikipedia.org/wiki/Resonance">共振频率</a>和<a href="https://en.wikipedia.org/wiki/Q_factor">品质因子</a>。质量因子等于谐振器中储存的能量与每周期耗散的能量之间的比率，这大约相当于谐振频率与<a href="https://en.wikipedia.org/wiki/Full_width_at_half_maximum">半满宽度（FWHM）</a>之间的比率。FWHM等于振动功率大于谐振频率的一半的带宽。</p>
<p class="formulaDsp">
\[ Q = \frac{f_r}{\Delta f} = \frac{\omega_r}{\Delta \omega} = 2 \pi \times \frac{\text{energy stored}}{\text{energy dissipated per cycle}} \]
</p>
<p>机械共振 \(a^2\) 的振幅的平方作为频率的函数有一个高斯形状</p>
<p class="formulaDsp">
\[ a^2 = a_\textrm{max}^2\frac{\omega^2\Gamma^2}{(\omega_r^2-\omega^2)^2+\Gamma^2\omega^2} \]
</p>
<p>其中 \(f_r = \frac{\omega_r}{2\pi}\) 是共振频率， \(\Gamma=\frac{\omega_r}{Q}\) 是耗损率。我们在jupyter笔记本中使用前面的方程式来拟合机械共振。</p>
<p>鉴于我们所选择的参数值，人们可以通过分析来估计谐振频率。事实上，我们在这个程序中得到的结果证实了这一点：声子超晶格空腔在20GHz时表现出机械共振，质量系数为5046。下面的图片显示了在共振频率附近的传输振幅和相位与频率的关系。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-62.05.png" alt="Phononic superlattice cavity" height="400"/>
</div>
 <div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-62.06.png" alt="Phononic superlattice cavity" height="400"/>
</div>
<p> 。</p>
<p>上面的图片表明，周期性结构有其预期的效果：它实际上只让一个非常特定频率的波通过，而所有其他的波都被反射。当然，这正是人们建造这类设备的目的。但这并不十分容易。在实践中，实际上只有一个 "带隙"，也就是说，该设备只在一定的频率范围内阻止20GHz频率以外的波。事实上，要想知道这个被阻挡的 "间隙 "有多大，我们可以通过输入文件中的适当参数将频率范围扩大到16GHz。然后我们得到以下图像。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-62.07.png" alt="Phononic superlattice cavity" height="400"/>
</div>
<p>这张图片表明的是，在18到22GHz左右的范围内，确实只有频率为20GHz的波被允许通过，但在这个范围之外，还有很多其他频率可以通过该设备。</p>
<p><a class="anchor" id="Modeprofile"></a></p><h3>Mode profile</h3>
<p>我们可以用Paraview或VisIt检查模态轮廓。正如我们所讨论的，在共振时，所有的机械能都被传递，运动的振幅在腔内被放大。可以看出，PML对于截断解决方案是非常有效的。下图显示了共振时的模式轮廓。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-62.08.png" alt="Phononic superlattice cavity" height="400"/>
</div>
<p>另一方面，在共振之外，所有的机械能都被反射。下面的图片显示了19.75GHz时的轮廓。注意力脉冲和反射波在位置 \(x=-8\mu\textrm{m}\) 的干扰。</p>
<div class="image">
<img src="https://www.dealii.org/images/steps/developer/step-62.09.png" alt="Phononic superlattice cavity" height="400"/>
</div>
<p><a class="anchor" id="Experimentalapplications"></a></p><h3>Experimental applications</h3>
<p>声波超晶格空腔在<a href="https://journals.aps.org/rmp/abstract/10.1103/RevModPhys.86.1391">量子光学机械学</a>中找到了应用。这里我们介绍了二维超晶格空腔的模拟，但这个代码也可以用来模拟 "现实世界 "的三维设备，如<a href="https://journals.aps.org/prb/abstract/10.1103/PhysRevB.99.060101">微柱超晶格空腔</a>，它是研究宏观量子现象的有希望的候选者。微柱超晶格空腔的20GHz模式本质上是一个机械谐波振荡器，与环境隔离得非常好。如果该装置在稀释冰箱中被冷却到20mK，那么该模式就会成为一个宏观的量子谐波振荡器。</p>
<p><a class="anchor" id="Possibilitiesforextensions"></a></p><h3>Possibilities for extensions</h3>
<p>我们可以不在C++文件中设置参数，而是用一个Python脚本来设置参数，并将其保存在HDF5文件中，我们将使用该文件进行模拟。然后deal.II程序将从HDF5文件中读取参数。</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</div><div class="line"><span class="keyword">import</span> h5py</div><div class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</div><div class="line"><span class="keyword">import</span> subprocess</div><div class="line"><span class="keyword">import</span> scipy.constants <span class="keyword">as</span> constants</div><div class="line"><span class="keyword">import</span> scipy.optimize</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># This considerably reduces the size of the svg data</span></div><div class="line">plt.rcParams[<span class="stringliteral">&#39;svg.fonttype&#39;</span>] = <span class="stringliteral">&#39;none&#39;</span></div><div class="line"></div><div class="line"></div><div class="line">h5_file = h5py.File(<span class="stringliteral">&#39;results.h5&#39;</span>, <span class="stringliteral">&#39;w&#39;</span>)</div><div class="line">data = h5_file.create_group(<span class="stringliteral">&#39;data&#39;</span>)</div><div class="line">displacement = data.create_group(<span class="stringliteral">&#39;displacement&#39;</span>)</div><div class="line">calibration = data.create_group(<span class="stringliteral">&#39;calibration&#39;</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># Set the parameters</span></div><div class="line"><span class="keywordflow">for</span> group <span class="keywordflow">in</span> [displacement, calibration]:</div><div class="line">    <span class="comment"># Dimensions of the domain</span></div><div class="line">    <span class="comment"># The waveguide length is equal to dimension_x</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;dimension_x&#39;</span>] = 2e-5</div><div class="line">    <span class="comment"># The waveguide width is equal to dimension_y</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;dimension_y&#39;</span>] = 2e-8</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Position of the probe that we use to measure the flux</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;probe_pos_x&#39;</span>]   = 8e-6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;probe_pos_y&#39;</span>]   = 0</div><div class="line">    group.attrs[<span class="stringliteral">&#39;probe_width_y&#39;</span>] = 2e-08</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Number of points in the probe</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;nb_probe_points&#39;</span>] = 5</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Global refinement</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;grid_level&#39;</span>] = 1</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Cavity</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;cavity_resonance_frequency&#39;</span>] = 20e9</div><div class="line">    group.attrs[<span class="stringliteral">&#39;nb_mirror_pairs&#39;</span>]            = 15</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Material</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>] = 0.27</div><div class="line">    group.attrs[<span class="stringliteral">&#39;youngs_modulus&#39;</span>] = 270000000000.0</div><div class="line">    group.attrs[<span class="stringliteral">&#39;material_a_rho&#39;</span>] = 3200</div><div class="line">    <span class="keywordflow">if</span> group == displacement:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;material_b_rho&#39;</span>] = 2000</div><div class="line">    <span class="keywordflow">else</span>:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;material_b_rho&#39;</span>] = 3200</div><div class="line">    group.attrs[<span class="stringliteral">&#39;lambda&#39;</span>] = (group.attrs[<span class="stringliteral">&#39;youngs_modulus&#39;</span>] * group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>] /</div><div class="line">                           ((1 + group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>]) *</div><div class="line">                           (1 - 2 * group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>])))</div><div class="line">    group.attrs[<span class="stringliteral">&#39;mu&#39;</span>]= (group.attrs[<span class="stringliteral">&#39;youngs_modulus&#39;</span>] / (2 * (1 + group.attrs[<span class="stringliteral">&#39;poissons_ratio&#39;</span>])))</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Force</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;max_force_amplitude&#39;</span>] = 1e26</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_sigma_x&#39;</span>]       = 1e-7</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_sigma_y&#39;</span>]       = 1</div><div class="line">    group.attrs[<span class="stringliteral">&#39;max_force_width_x&#39;</span>]   = 3e-7</div><div class="line">    group.attrs[<span class="stringliteral">&#39;max_force_width_y&#39;</span>]   = 2e-8</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_x_pos&#39;</span>]         = -8e-6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;force_y_pos&#39;</span>]         = 0</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># PML</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_x&#39;</span>]            = <span class="keyword">True</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_y&#39;</span>]            = <span class="keyword">False</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_width_x&#39;</span>]      = 1.8e-6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_width_y&#39;</span>]      = 5e-7</div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_coeff&#39;</span>]        = 1.6</div><div class="line">    group.attrs[<span class="stringliteral">&#39;pml_coeff_degree&#39;</span>] = 2</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Frequency sweep</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;center_frequency&#39;</span>]    = 20e9</div><div class="line">    group.attrs[<span class="stringliteral">&#39;frequency_range&#39;</span>]     = 0.5e9</div><div class="line">    group.attrs[<span class="stringliteral">&#39;start_frequency&#39;</span>]     = group.attrs[<span class="stringliteral">&#39;center_frequency&#39;</span>] - group.attrs[<span class="stringliteral">&#39;frequency_range&#39;</span>] / 2</div><div class="line">    group.attrs[<span class="stringliteral">&#39;stop_frequency&#39;</span>]      = group.attrs[<span class="stringliteral">&#39;center_frequency&#39;</span>] + group.attrs[<span class="stringliteral">&#39;frequency_range&#39;</span>] / 2</div><div class="line">    group.attrs[<span class="stringliteral">&#39;nb_frequency_points&#39;</span>] = 400</div><div class="line"></div><div class="line"></div><div class="line">    <span class="comment"># Other parameters</span></div><div class="line">    <span class="keywordflow">if</span> group == displacement:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;simulation_name&#39;</span>] = <span class="stringliteral">&#39;phononic_cavity_displacement&#39;</span></div><div class="line">    <span class="keywordflow">else</span>:</div><div class="line">        group.attrs[<span class="stringliteral">&#39;simulation_name&#39;</span>] = <span class="stringliteral">&#39;phononic_cavity_calibration&#39;</span></div><div class="line">    group.attrs[<span class="stringliteral">&#39;save_vtu_files&#39;</span>] = <span class="keyword">False</span></div><div class="line"></div><div class="line"></div><div class="line">h5_file.close()</div></div><!-- fragment --><p>为了读取HDF5参数，我们必须使用 HDF5::File::FileAccessMode::open 标志。</p>
<div class="fragment"><div class="line">HDF5::File data_file(<span class="stringliteral">&quot;results.h5&quot;</span>,</div><div class="line">                     HDF5::File::FileAccessMode::open,</div><div class="line">                     MPI_COMM_WORLD);</div><div class="line">auto       data = data_file.open_group(<span class="stringliteral">&quot;data&quot;</span>);</div></div><!-- fragment --><p><a class="anchor" id="PlainProg"></a> </p><h1>The plain program</h1>
<div class="fragment"><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/* --------------------------------------------------------------------- </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Copyright (C) 2018 - 2021 by the deal.II authors </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * This file is part of the deal.II library. </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * The deal.II library is free software; you can use it, redistribute </span></div><div class="line"><span class="comment"> * it, and/or modify it under the terms of the GNU Lesser General </span></div><div class="line"><span class="comment"> * Public License as published by the Free Software Foundation; either </span></div><div class="line"><span class="comment"> * version 2.1 of the License, or (at your option) any later version. </span></div><div class="line"><span class="comment"> * The full text of the license can be found in the file LICENSE at </span></div><div class="line"><span class="comment"> * the top level of the deal.II distribution. </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * --------------------------------------------------------------------- </span></div><div class="line"><span class="comment"> * </span></div><div class="line"><span class="comment"> * Author: Daniel Garcia-Sanchez, CNRS, 2019 </span></div><div class="line"><span class="comment"> */</span> </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="conditional__ostream_8h.html">deal.II/base/conditional_ostream.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="function_8h.html">deal.II/base/function.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="index__set_8h.html">deal.II/base/index_set.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="quadrature__lib_8h.html">deal.II/base/quadrature_lib.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="timer_8h.html">deal.II/base/timer.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="include_2deal_8II_2base_2utilities_8h.html">deal.II/base/utilities.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dofs_2dof__handler_8h.html">deal.II/dofs/dof_handler.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dof__tools_8h.html">deal.II/dofs/dof_tools.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__q_8h.html">deal.II/fe/fe_q.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe__system_8h.html">deal.II/fe/fe_system.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="fe_2fe__values_8h.html">deal.II/fe/fe_values.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__generator_8h.html">deal.II/grid/grid_generator.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid_2grid__refinement_8h.html">deal.II/grid/grid_refinement.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="affine__constraints_8h.html">deal.II/lac/affine_constraints.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="dynamic__sparsity__pattern_8h.html">deal.II/lac/dynamic_sparsity_pattern.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="full__matrix_8h.html">deal.II/lac/full_matrix.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="generic__linear__algebra_8h.html">deal.II/lac/generic_linear_algebra.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="petsc__solver_8h.html">deal.II/lac/petsc_solver.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector_8h.html">deal.II/lac/vector.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="numerics_2data__out_8h.html">deal.II/numerics/data_out.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="error__estimator_8h.html">deal.II/numerics/error_estimator.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;fstream&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="tensor_8h.html">deal.II/base/tensor.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="hdf5_8h.html">deal.II/base/hdf5.h</a>&gt;</span> </div><div class="line"></div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="vector__tools_8h.html">deal.II/numerics/vector_tools.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools_8h.html">deal.II/grid/grid_tools.h</a>&gt;</span> </div><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="grid__tools__cache_8h.html">deal.II/grid/grid_tools_cache.h</a>&gt;</span> </div><div class="line"></div><div class="line"><span class="keyword">namespace </span>step62 </div><div class="line">{ </div><div class="line">  <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>RightHandSide : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    RightHandSide(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>; </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line"></div><div class="line"></div><div class="line">    HDF5::Group data; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     max_force_amplitude; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     force_sigma_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     force_sigma_y; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     max_force_width_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>     max_force_width_y; </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> force_center; </div><div class="line"></div><div class="line">  <span class="keyword">public</span>: </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> force_component = 0; </div><div class="line">  }; </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>PML : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim, std::complex&lt;double&gt;&gt; </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    PML(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> std::complex&lt;double&gt; </div><div class="line">    value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component) <span class="keyword">const override</span>; </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line"></div><div class="line">    HDF5::Group data; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pml_coeff; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">int</span>    pml_coeff_degree; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dimension_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> dimension_y; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>   pml_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>   pml_y; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pml_width_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> pml_width_y; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_coeff_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> a_coeff_y; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>Rho : <span class="keyword">public</span> <a class="code" href="classFunction.html">Function</a>&lt;dim&gt; </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    Rho(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">    <span class="keyword">virtual</span> <span class="keywordtype">double</span> value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0) <span class="keyword">const override</span>; </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line"></div><div class="line">    HDF5::Group data; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       lambda; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       mu; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       material_a_rho; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       material_b_rho; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       cavity_resonance_frequency; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_mirror_pairs; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>       dimension_y; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> grid_level; </div><div class="line">    <span class="keywordtype">double</span>             average_rho_width; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>Parameters </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    Parameters(HDF5::Group &amp;data); </div><div class="line"></div><div class="line">    HDF5::Group data; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> std::string        simulation_name; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">bool</span>               save_vtu_files; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>             start_frequency; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>             stop_frequency; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       nb_frequency_points; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>             lambda; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>             mu; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>             dimension_x; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>             dimension_y; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       nb_probe_points; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>       grid_level; </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>         probe_start_point; </div><div class="line">    <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>         probe_stop_point; </div><div class="line">    <span class="keyword">const</span> RightHandSide&lt;dim&gt; right_hand_side; </div><div class="line">    <span class="keyword">const</span> PML&lt;dim&gt;           pml; </div><div class="line">    <span class="keyword">const</span> Rho&lt;dim&gt;           rho; </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> comparison_float_constant = 1e-12; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>QuadratureCache </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    QuadratureCache(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell); </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell; </div><div class="line"></div><div class="line">  <span class="keyword">public</span>: </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt;  mass_coefficient; </div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt;  stiffness_coefficient; </div><div class="line">    std::vector&lt;std::complex&lt;double&gt;&gt; right_hand_side; </div><div class="line">    <span class="keywordtype">double</span>                            JxW; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> get_stiffness_tensor(<span class="keyword">const</span> <span class="keywordtype">double</span> lambda, </div><div class="line">                                               <span class="keyword">const</span> <span class="keywordtype">double</span> mu) </div><div class="line">  { </div><div class="line">    <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stiffness_tensor; </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dim; ++i) </div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dim; ++j) </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k) </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) </div><div class="line">            stiffness_tensor[i][j][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] = </div><div class="line">              (((i == k) &amp;&amp; (j == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) ? mu : 0.0) + </div><div class="line">               ((i == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) &amp;&amp; (j == k) ? mu : 0.0) + </div><div class="line">               ((i == j) &amp;&amp; (k == <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) ? lambda : 0.0)); </div><div class="line">    <span class="keywordflow">return</span> stiffness_tensor; </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keyword">class </span>ElasticWave </div><div class="line">  { </div><div class="line">  <span class="keyword">public</span>: </div><div class="line">    ElasticWave(<span class="keyword">const</span> Parameters&lt;dim&gt; &amp;parameters); </div><div class="line">    <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">run</a>(); </div><div class="line"></div><div class="line">  <span class="keyword">private</span>: </div><div class="line">    <span class="keywordtype">void</span> setup_system(); </div><div class="line">    <span class="keywordtype">void</span> assemble_system(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, </div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">bool</span>   calculate_quadrature_data); </div><div class="line">    <span class="keywordtype">void</span> solve(); </div><div class="line">    <span class="keywordtype">void</span> initialize_probe_positions_vector(); </div><div class="line">    <span class="keywordtype">void</span> store_frequency_step_data(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frequency_idx); </div><div class="line">    <span class="keywordtype">void</span> output_results(); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> setup_quadrature_cache(); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">void</span> frequency_sweep(); </div><div class="line"></div><div class="line"></div><div class="line">    Parameters&lt;dim&gt; parameters; </div><div class="line"></div><div class="line">    <a class="code" href="classMPI__Comm.html">MPI_Comm</a> mpi_communicator; </div><div class="line"></div><div class="line">    <a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;dim&gt;</a> <a class="code" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>; </div><div class="line"></div><div class="line">    <a class="code" href="classQGauss.html">QGauss&lt;dim&gt;</a> quadrature_formula; </div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;QuadratureCache&lt;dim&gt;&gt; quadrature_cache; </div><div class="line"></div><div class="line">    <a class="code" href="classFESystem.html">FESystem&lt;dim&gt;</a>   fe; </div><div class="line">    <a class="code" href="classDoFHandler.html">DoFHandler&lt;dim&gt;</a> dof_handler; </div><div class="line"></div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_owned_dofs; </div><div class="line">    <a class="code" href="classIndexSet.html">IndexSet</a> locally_relevant_dofs; </div><div class="line"></div><div class="line">    <a class="code" href="classAffineConstraints.html">AffineConstraints&lt;std::complex&lt;double&gt;</a>&gt; constraints; </div><div class="line"></div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">LinearAlgebraPETSc::MPI::SparseMatrix</a> system_matrix; </div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">LinearAlgebraPETSc::MPI::Vector</a>       locally_relevant_solution; </div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">LinearAlgebraPETSc::MPI::Vector</a>       system_rhs; </div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;double&gt; frequency; </div><div class="line"></div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> probe_positions; </div><div class="line"></div><div class="line"></div><div class="line">    HDF5::DataSet frequency_dataset; </div><div class="line">    HDF5::DataSet probe_positions_dataset; </div><div class="line"></div><div class="line"></div><div class="line">    HDF5::DataSet displacement; </div><div class="line"></div><div class="line">    <a class="code" href="classConditionalOStream.html">ConditionalOStream</a> pcout; </div><div class="line">    <a class="code" href="classTimerOutput.html">TimerOutput</a>        computing_timer; </div><div class="line">  }; </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  RightHandSide&lt;dim&gt;::RightHandSide(HDF5::Group &amp;data) </div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(dim) </div><div class="line">    , data(data) </div><div class="line">    , max_force_amplitude(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;max_force_amplitude&quot;</span>)) </div><div class="line">    , force_sigma_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_sigma_x&quot;</span>)) </div><div class="line">    , force_sigma_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_sigma_y&quot;</span>)) </div><div class="line">    , max_force_width_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;max_force_width_x&quot;</span>)) </div><div class="line">    , max_force_width_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;max_force_width_y&quot;</span>)) </div><div class="line">    , force_center(<a class="code" href="classPoint.html">Point</a>&lt;dim&gt;(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_x_pos&quot;</span>), </div><div class="line">                              data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;force_y_pos&quot;</span>))) </div><div class="line">  {} </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">double</span> RightHandSide&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                                   <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    <span class="keywordflow">if</span> (component == force_component) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[0] - force_center[0]) &lt; max_force_width_x / 2 &amp;&amp; </div><div class="line">            std::abs(p[1] - force_center[1]) &lt; max_force_width_y / 2) </div><div class="line">          { </div><div class="line">            <span class="keywordflow">return</span> max_force_amplitude * </div><div class="line">                   <a class="code" href="vectorization_8h.html#a19f846bda83b7e3f4531daacb40c64e1">std::exp</a>(-(std::pow(p[0] - force_center[0], 2) / </div><div class="line">                                (2 * std::pow(force_sigma_x, 2)) + </div><div class="line">                              std::pow(p[1] - force_center[1], 2) / </div><div class="line">                                (2 * std::pow(force_sigma_y, 2)))); </div><div class="line">          } </div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">          { </div><div class="line">            <span class="keywordflow">return</span> 0; </div><div class="line">          } </div><div class="line">      } </div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      { </div><div class="line">        <span class="keywordflow">return</span> 0; </div><div class="line">      } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  PML&lt;dim&gt;::PML(HDF5::Group &amp;data) </div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim, <a class="code" href="namespacestd.html">std</a>::complex&lt;<a class="code" href="classdouble.html">double</a>&gt;&gt;(dim) </div><div class="line">    , data(data) </div><div class="line">    , pml_coeff(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;pml_coeff&quot;</span>)) </div><div class="line">    , pml_coeff_degree(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;pml_coeff_degree&quot;</span>)) </div><div class="line">    , dimension_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_x&quot;</span>)) </div><div class="line">    , dimension_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>)) </div><div class="line">    , pml_x(data.get_attribute&lt;<a class="code" href="classbool.html">bool</a>&gt;(<span class="stringliteral">&quot;pml_x&quot;</span>)) </div><div class="line">    , pml_y(data.get_attribute&lt;<a class="code" href="classbool.html">bool</a>&gt;(<span class="stringliteral">&quot;pml_y&quot;</span>)) </div><div class="line">    , pml_width_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;pml_width_x&quot;</span>)) </div><div class="line">    , pml_width_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;pml_width_y&quot;</span>)) </div><div class="line">    , a_coeff_x(pml_coeff / <a class="code" href="namespacestd.html">std</a>::<a class="code" href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">pow</a>(pml_width_x, pml_coeff_degree)) </div><div class="line">    , a_coeff_y(pml_coeff / <a class="code" href="namespacestd.html">std</a>::<a class="code" href="numbers_8h.html#af44aee1db5cdcd0bab54e3c011d2be66">pow</a>(pml_width_y, pml_coeff_degree)) </div><div class="line">  {} </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  std::complex&lt;double&gt; PML&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp; p, </div><div class="line">                                       <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line">    <span class="keywordtype">double</span> calculated_pml_x_coeff = 0; </div><div class="line">    <span class="keywordtype">double</span> calculated_pml_y_coeff = 0; </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((component == 0) &amp;&amp; pml_x) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> pml_x_start_position = dimension_x / 2 - pml_width_x; </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[0]) &gt; pml_x_start_position) </div><div class="line">          { </div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> x_prime = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[0]) - pml_x_start_position; </div><div class="line">            calculated_pml_x_coeff = </div><div class="line">              a_coeff_x * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(x_prime, pml_coeff_degree); </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> ((component == 1) &amp;&amp; pml_y) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> pml_y_start_position = dimension_y / 2 - pml_width_y; </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[1]) &gt; pml_y_start_position) </div><div class="line">          { </div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> y_prime = <a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[1]) - pml_y_start_position; </div><div class="line">            calculated_pml_y_coeff = </div><div class="line">              a_coeff_y * <a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(y_prime, pml_coeff_degree); </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> 1. + <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda8e7f5b8545162dccd5ed717792bdf420">std::max</a>(calculated_pml_x_coeff, calculated_pml_y_coeff) * </div><div class="line">                  std::complex&lt;double&gt;(0., 1.); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  Rho&lt;dim&gt;::Rho(HDF5::Group &amp;data) </div><div class="line">    : <a class="code" href="classFunction.html">Function</a>&lt;dim&gt;(1) </div><div class="line">    , data(data) </div><div class="line">    , lambda(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;lambda&quot;</span>)) </div><div class="line">    , mu(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;mu&quot;</span>)) </div><div class="line">    , material_a_rho(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;material_a_rho&quot;</span>)) </div><div class="line">    , material_b_rho(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;material_b_rho&quot;</span>)) </div><div class="line">    , cavity_resonance_frequency( </div><div class="line">        data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;cavity_resonance_frequency&quot;</span>)) </div><div class="line">    , nb_mirror_pairs(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;nb_mirror_pairs&quot;</span>)) </div><div class="line">    , dimension_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>)) </div><div class="line">    , grid_level(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;grid_level&quot;</span>)) </div><div class="line">  { </div><div class="line"></div><div class="line"></div><div class="line">    average_rho_width = dimension_y / (<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(2.0, grid_level)); </div><div class="line">    data.set_attribute(<span class="stringliteral">&quot;average_rho_width&quot;</span>, average_rho_width); </div><div class="line">  } </div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">double</span> Rho&lt;dim&gt;::value(<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> &amp;p, </div><div class="line">                         <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <span class="comment">/*component*/</span>)<span class="keyword"> const </span></div><div class="line"><span class="keyword">  </span>{ </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordtype">double</span> elastic_constant; </div><div class="line">    <span class="keywordflow">if</span> (dim == 2) </div><div class="line">      { </div><div class="line">        elastic_constant = 4 * mu * (lambda + mu) / (lambda + 2 * mu); </div><div class="line">      } </div><div class="line">    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dim == 3) </div><div class="line">      { </div><div class="line">        elastic_constant = mu * (3 * lambda + 2 * mu) / (lambda + mu); </div><div class="line">      } </div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      { </div><div class="line">        <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(<span class="keyword">false</span>, <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line">      } </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> material_a_speed_of_sound = </div><div class="line">      <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(elastic_constant / material_a_rho); </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> material_a_wavelength = </div><div class="line">      material_a_speed_of_sound / cavity_resonance_frequency; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> material_b_speed_of_sound = </div><div class="line">      <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a>(elastic_constant / material_b_rho); </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span> material_b_wavelength = </div><div class="line">      material_b_speed_of_sound / cavity_resonance_frequency; </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> layer_transition_center = </div><div class="line">          material_a_wavelength / 2 + </div><div class="line">          idx * (material_b_wavelength / 4 + material_a_wavelength / 4); </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= </div><div class="line">              (layer_transition_center - average_rho_width / 2) &amp;&amp; </div><div class="line">            std::abs(p[0]) &lt;= (layer_transition_center + average_rho_width / 2)) </div><div class="line">          { </div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = </div><div class="line">              (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[0]) - </div><div class="line">               (layer_transition_center - average_rho_width / 2)) / </div><div class="line">              average_rho_width; </div><div class="line">            <span class="keywordflow">return</span> (1 - coefficient) * material_a_rho + </div><div class="line">                   coefficient * material_b_rho; </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> layer_transition_center = </div><div class="line">          material_a_wavelength / 2 + </div><div class="line">          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + </div><div class="line">          material_b_wavelength / 4; </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= </div><div class="line">              (layer_transition_center - average_rho_width / 2) &amp;&amp; </div><div class="line">            std::abs(p[0]) &lt;= (layer_transition_center + average_rho_width / 2)) </div><div class="line">          { </div><div class="line">            <span class="keyword">const</span> <span class="keywordtype">double</span> coefficient = </div><div class="line">              (<a class="code" href="vectorization_8h.html#aafbdfdd72b6cfe4eae5fa7a16385582f">std::abs</a>(p[0]) - </div><div class="line">               (layer_transition_center - average_rho_width / 2)) / </div><div class="line">              average_rho_width; </div><div class="line">            <span class="keywordflow">return</span> (1 - coefficient) * material_b_rho + </div><div class="line">                   coefficient * material_a_rho; </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (std::abs(p[0]) &lt;= material_a_wavelength / 2) </div><div class="line">      { </div><div class="line">        <span class="keywordflow">return</span> material_a_rho; </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> layer_center = </div><div class="line">          material_a_wavelength / 2 + </div><div class="line">          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + </div><div class="line">          material_b_wavelength / 4 + material_a_wavelength / 8; </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> layer_width = material_a_wavelength / 4; </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= (layer_center - layer_width / 2) &amp;&amp; </div><div class="line">            std::abs(p[0]) &lt;= (layer_center + layer_width / 2)) </div><div class="line">          { </div><div class="line">            <span class="keywordflow">return</span> material_a_rho; </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> idx = 0; idx &lt; nb_mirror_pairs; idx++) </div><div class="line">      { </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> layer_center = </div><div class="line">          material_a_wavelength / 2 + </div><div class="line">          idx * (material_b_wavelength / 4 + material_a_wavelength / 4) + </div><div class="line">          material_b_wavelength / 8; </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> layer_width = material_b_wavelength / 4; </div><div class="line">        <span class="keywordflow">if</span> (std::abs(p[0]) &gt;= (layer_center - layer_width / 2) &amp;&amp; </div><div class="line">            std::abs(p[0]) &lt;= (layer_center + layer_width / 2)) </div><div class="line">          { </div><div class="line">            <span class="keywordflow">return</span> material_b_rho; </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> material_a_rho; </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  Parameters&lt;dim&gt;::Parameters(HDF5::Group &amp;data) </div><div class="line">    : data(data) </div><div class="line">    , simulation_name(data.get_attribute&lt;<a class="code" href="namespacestd.html">std</a>::string&gt;(<span class="stringliteral">&quot;simulation_name&quot;</span>)) </div><div class="line">    , save_vtu_files(data.get_attribute&lt;<a class="code" href="classbool.html">bool</a>&gt;(<span class="stringliteral">&quot;save_vtu_files&quot;</span>)) </div><div class="line">    , start_frequency(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;start_frequency&quot;</span>)) </div><div class="line">    , stop_frequency(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;stop_frequency&quot;</span>)) </div><div class="line">    , nb_frequency_points(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;nb_frequency_points&quot;</span>)) </div><div class="line">    , lambda(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;lambda&quot;</span>)) </div><div class="line">    , mu(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;mu&quot;</span>)) </div><div class="line">    , dimension_x(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_x&quot;</span>)) </div><div class="line">    , dimension_y(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>)) </div><div class="line">    , nb_probe_points(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;nb_probe_points&quot;</span>)) </div><div class="line">    , grid_level(data.get_attribute&lt;int&gt;(<span class="stringliteral">&quot;grid_level&quot;</span>)) </div><div class="line">    , probe_start_point(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_x&quot;</span>), </div><div class="line">                        data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_y&quot;</span>) - </div><div class="line">                          data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_width_y&quot;</span>) / 2) </div><div class="line">    , probe_stop_point(data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_x&quot;</span>), </div><div class="line">                       data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_pos_y&quot;</span>) + </div><div class="line">                         data.get_attribute&lt;<a class="code" href="classdouble.html">double</a>&gt;(<span class="stringliteral">&quot;probe_width_y&quot;</span>) / 2) </div><div class="line">    , right_hand_side(data) </div><div class="line">    , pml(data) </div><div class="line">    , rho(data) </div><div class="line">  {} </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  QuadratureCache&lt;dim&gt;::QuadratureCache(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell) </div><div class="line">    : dofs_per_cell(dofs_per_cell) </div><div class="line">    , mass_coefficient(dofs_per_cell, dofs_per_cell) </div><div class="line">    , stiffness_coefficient(dofs_per_cell, dofs_per_cell) </div><div class="line">    , right_hand_side(dofs_per_cell) </div><div class="line">  {} </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  ElasticWave&lt;dim&gt;::ElasticWave(<span class="keyword">const</span> Parameters&lt;dim&gt; &amp;parameters) </div><div class="line">    : parameters(parameters) </div><div class="line">    , mpi_communicator(MPI_COMM_WORLD) </div><div class="line">    , triangulation(mpi_communicator, </div><div class="line">                    typename <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::MeshSmoothing( </div><div class="line">                      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_refinement | </div><div class="line">                      <a class="code" href="classTriangulation.html">Triangulation</a>&lt;dim&gt;::smoothing_on_coarsening)) </div><div class="line">    , quadrature_formula(2) </div><div class="line">    , fe(<a class="code" href="classFE__Q.html">FE_Q</a>&lt;dim&gt;(1), dim) </div><div class="line">    , dof_handler(triangulation) </div><div class="line">    , frequency(parameters.nb_frequency_points) </div><div class="line">    , probe_positions(parameters.nb_probe_points, dim) </div><div class="line">    , frequency_dataset(parameters.data.template create_dataset&lt;<a class="code" href="classdouble.html">double</a>&gt;( </div><div class="line">        <span class="stringliteral">&quot;frequency&quot;</span>, </div><div class="line">        <a class="code" href="namespacestd.html">std</a>::vector&lt;hsize_t&gt;{parameters.nb_frequency_points})) </div><div class="line">    , probe_positions_dataset(parameters.data.template create_dataset&lt;double&gt;( </div><div class="line">        <span class="stringliteral">&quot;position&quot;</span>, </div><div class="line">        std::vector&lt;hsize_t&gt;{parameters.nb_probe_points, dim})) </div><div class="line">    , displacement( </div><div class="line">        parameters.data.template create_dataset&lt;std::complex&lt;double&gt;&gt;( </div><div class="line">          <span class="stringliteral">&quot;displacement&quot;</span>, </div><div class="line">          std::vector&lt;hsize_t&gt;{parameters.nb_probe_points, </div><div class="line">                               parameters.nb_frequency_points})) </div><div class="line">    , pcout(std::cout, </div><div class="line">            (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0)) </div><div class="line">    , computing_timer(mpi_communicator, </div><div class="line">                      pcout, </div><div class="line">                      <a class="code" href="classTimerOutput.html#a643d0e642b80048e91b37109fe9357cba6e77a7039cabde1578e2aa8fe7d5f726">TimerOutput::summary</a>, </div><div class="line">                      <a class="code" href="classTimerOutput.html#a2405ae1b041a57d11a61a8cbfad3b487aa1bf9100145d06321277979f4ca77ba2">TimerOutput::wall_times</a>) </div><div class="line">  {} </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::setup_system() </div><div class="line">  { </div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;setup&quot;</span>); </div><div class="line"></div><div class="line">    dof_handler.<a class="code" href="classDoFHandler.html#a553ca864aaf70330d9be86bc78f36d1e">distribute_dofs</a>(fe); </div><div class="line"></div><div class="line">    locally_owned_dofs = dof_handler.<a class="code" href="classDoFHandler.html#ad39fd2189568f2f6b7d557237e3372e3">locally_owned_dofs</a>(); </div><div class="line">    <a class="code" href="namespaceDoFTools.html#acad7e0841b9046eaafddc4c617ab1d9d">DoFTools::extract_locally_relevant_dofs</a>(dof_handler, locally_relevant_dofs); </div><div class="line"></div><div class="line">    locally_relevant_solution.reinit(locally_owned_dofs, </div><div class="line">                                     locally_relevant_dofs, </div><div class="line">                                     mpi_communicator); </div><div class="line"></div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#adf4d1d6c3538af95309a95da2ded758c">reinit</a>(locally_owned_dofs, mpi_communicator); </div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#addd15bc409c61d6f795f0132c574335b">clear</a>(); </div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a2c9d71b5b7e8851c25a411ccf34de986">reinit</a>(locally_relevant_dofs); </div><div class="line">    <a class="code" href="group__constraints.html#ga3b4ea7dfd313e388d868c4e4aa685799">DoFTools::make_hanging_node_constraints</a>(dof_handler, constraints); </div><div class="line"></div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a1611aa37f754086388ca76bcd421cce5">close</a>(); </div><div class="line"></div><div class="line">    <a class="code" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a> dsp(locally_relevant_dofs); </div><div class="line"></div><div class="line">    <a class="code" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern</a>(dof_handler, dsp, constraints, <span class="keyword">false</span>); </div><div class="line">    <a class="code" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>(dsp, </div><div class="line">                                               locally_owned_dofs, </div><div class="line">                                               mpi_communicator, </div><div class="line">                                               locally_relevant_dofs); </div><div class="line"></div><div class="line">    system_matrix.reinit(locally_owned_dofs, </div><div class="line">                         locally_owned_dofs, </div><div class="line">                         dsp, </div><div class="line">                         mpi_communicator); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::assemble_system(<span class="keyword">const</span> <span class="keywordtype">double</span> omega, </div><div class="line">                                         <span class="keyword">const</span> <span class="keywordtype">bool</span>   calculate_quadrature_data) </div><div class="line">  { </div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;assembly&quot;</span>); </div><div class="line"></div><div class="line">    <a class="code" href="classFEValues.html">FEValues&lt;dim&gt;</a>      fe_values(fe, </div><div class="line">                            quadrature_formula, </div><div class="line">                            <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa4057ca2f127aa619c65886a9d3ad4aea">update_values</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52facbcc430975fa6af05f75ca786dc6fe20">update_gradients</a> | </div><div class="line">                              <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fad5c9ff886b9615349a5d04a6c782df4a">update_quadrature_points</a> | <a class="code" href="group__feaccess.html#ggaa94b67d2fdcc390690c523f28019e52fa714204722e9eeb43aadbd0d5ddc48c85">update_JxW_values</a>); </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dofs_per_cell = fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>(); </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n_q_points    = quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); </div><div class="line"></div><div class="line">    <a class="code" href="classFullMatrix.html">FullMatrix&lt;std::complex&lt;double&gt;</a>&gt; <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(dofs_per_cell, dofs_per_cell); </div><div class="line">    Vector&lt;std::complex&lt;double&gt;&gt;     cell_rhs(dofs_per_cell); </div><div class="line"></div><div class="line">    std::vector&lt;types::global_dof_index&gt; local_dof_indices(dofs_per_cell); </div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;Vector&lt;double&gt;&gt; rhs_values(n_q_points, Vector&lt;double&gt;(dim)); </div><div class="line">    std::vector&lt;double&gt;         rho_values(n_q_points); </div><div class="line">    std::vector&lt;Vector&lt;std::complex&lt;double&gt;&gt;&gt; pml_values( </div><div class="line">      n_q_points, <a class="code" href="namespaceLinearAlgebraDealII.html#a9fe13d579422411556954ab3f28a59be">Vector</a>&lt;std::complex&lt;double&gt;&gt;(dim)); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="classSymmetricTensor.html">SymmetricTensor&lt;4, dim&gt;</a> stiffness_tensor = </div><div class="line">      get_stiffness_tensor&lt;dim&gt;(parameters.lambda, parameters.mu); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="structFEValuesExtractors_1_1Vector.html">FEValuesExtractors::Vector</a> displacement(0); </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : dof_handler.<a class="code" href="group__CPP11.html#gacdb6d3adec96a13a7079f6c893e1d3ff">active_cell_iterators</a>()) </div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned()) </div><div class="line">        { </div><div class="line">          cell_matrix = 0; </div><div class="line">          cell_rhs    = 0; </div><div class="line"></div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (calculate_quadrature_data) </div><div class="line">            { </div><div class="line">              fe_values.<a class="code" href="classFEValues.html#a21f914e63d588e2652a9514620653d77">reinit</a>(cell); </div><div class="line"></div><div class="line">              parameters.right_hand_side.vector_value_list( </div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), rhs_values); </div><div class="line">              parameters.rho.value_list(fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), </div><div class="line">                                        rho_values); </div><div class="line">              parameters.pml.vector_value_list( </div><div class="line">                fe_values.<a class="code" href="classFEValuesBase.html#ae41b67cfd48e02f6035e39c84f0fb47a">get_quadrature_points</a>(), pml_values); </div><div class="line">            } </div><div class="line"></div><div class="line"></div><div class="line">          QuadratureCache&lt;dim&gt; *local_quadrature_points_data = </div><div class="line">            <span class="keyword">reinterpret_cast&lt;</span>QuadratureCache&lt;dim&gt; *<span class="keyword">&gt;</span>(cell-&gt;user_pointer()); </div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(local_quadrature_points_data &gt;= &amp;quadrature_cache.front(), </div><div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line">          <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(local_quadrature_points_data &lt;= &amp;quadrature_cache.back(), </div><div class="line">                 <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line">          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q = 0; q &lt; n_q_points; ++q) </div><div class="line">            { </div><div class="line"></div><div class="line"></div><div class="line">              QuadratureCache&lt;dim&gt; &amp;quadrature_data = </div><div class="line">                local_quadrature_points_data[q]; </div><div class="line"></div><div class="line"></div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a>                       force; </div><div class="line">              <a class="code" href="classTensor.html">Tensor&lt;1, dim, std::complex&lt;double&gt;</a>&gt; s; </div><div class="line">              std::complex&lt;double&gt;                 xi(1, 0); </div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">if</span> (calculate_quadrature_data) </div><div class="line">                { </div><div class="line"></div><div class="line"></div><div class="line">                  quadrature_data.JxW = fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q); </div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> component = 0; component &lt; dim; ++component) </div><div class="line">                    { </div><div class="line"></div><div class="line"></div><div class="line">                      force[component] = rhs_values[q][component]; </div><div class="line">                      s[component]     = pml_values[q][component]; </div><div class="line">                      xi *= s[component]; </div><div class="line">                    } </div><div class="line"></div><div class="line"></div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;4, dim, std::complex&lt;double&gt;</a>&gt; alpha; </div><div class="line">                  <a class="code" href="classTensor.html">Tensor&lt;4, dim, std::complex&lt;double&gt;</a>&gt; beta; </div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; dim; ++m) </div><div class="line">                    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; dim; ++n) </div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k) </div><div class="line">                        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) </div><div class="line">                          { </div><div class="line">                            alpha[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] = xi * </div><div class="line">                                                stiffness_tensor[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] / </div><div class="line">                                                (2.0 * s[n] * s[k]); </div><div class="line">                            beta[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] = xi * </div><div class="line">                                               stiffness_tensor[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] / </div><div class="line">                                               (2.0 * s[n] * s[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>]); </div><div class="line">                          } </div><div class="line"></div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">                    { </div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_i = </div><div class="line">                        fe_values[displacement].value(i, q); </div><div class="line">                      <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_phi_i = </div><div class="line">                        fe_values[displacement].gradient(i, q); </div><div class="line"></div><div class="line">                      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">                        { </div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;1, dim&gt;</a> phi_j = </div><div class="line">                            fe_values[displacement].value(j, q); </div><div class="line">                          <span class="keyword">const</span> <a class="code" href="classTensor.html">Tensor&lt;2, dim&gt;</a> grad_phi_j = </div><div class="line">                            fe_values[displacement].gradient(j, q); </div><div class="line"></div><div class="line"></div><div class="line">                          quadrature_data.mass_coefficient[i][j] = </div><div class="line">                            rho_values[q] * xi * phi_i * phi_j; </div><div class="line"></div><div class="line"></div><div class="line">                          std::complex&lt;double&gt; stiffness_coefficient = 0; </div><div class="line">                          <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> m = 0; m &lt; dim; ++m) </div><div class="line">                            <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = 0; n &lt; dim; ++n) </div><div class="line">                              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> k = 0; k &lt; dim; ++k) </div><div class="line">                                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> = 0; <a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a> &lt; dim; ++<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>) </div><div class="line">                                  { </div><div class="line"></div><div class="line"></div><div class="line">                                    stiffness_coefficient += </div><div class="line">                                      grad_phi_i[m][n] * </div><div class="line">                                      (alpha[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * grad_phi_j[<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>][k] + </div><div class="line">                                       beta[m][n][k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>] * grad_phi_j[k][<a class="code" href="namespacePhysics_1_1Elasticity_1_1Kinematics.html#adb1b44ad6f1741fbbbecc43f95d26baf">l</a>]); </div><div class="line">                                  } </div><div class="line"></div><div class="line"></div><div class="line">                          quadrature_data.stiffness_coefficient[i][j] = </div><div class="line">                            stiffness_coefficient; </div><div class="line">                        } </div><div class="line"></div><div class="line"></div><div class="line"> </div><div class="line">                        phi_i * force * fe_values.<a class="code" href="classFEValuesBase.html#abade89efb068b71b7ced7082012a2441">JxW</a>(q); </div><div class="line">                    } </div><div class="line">                } </div><div class="line"></div><div class="line"></div><div class="line">              <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; dofs_per_cell; ++i) </div><div class="line">                { </div><div class="line">                  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> j = 0; j &lt; dofs_per_cell; ++j) </div><div class="line">                    { </div><div class="line">                      std::complex&lt;double&gt; matrix_sum = 0; </div><div class="line">                      matrix_sum += -<a class="code" href="vectorization_8h.html#ae5c8b2cd70b2640bab8f1ee4ccb7f4cc">std::pow</a>(omega, 2) * </div><div class="line">                                    quadrature_data.mass_coefficient[i][j]; </div><div class="line">                      matrix_sum += quadrature_data.stiffness_coefficient[i][j]; </div><div class="line">                      <a class="code" href="namespaceLocalIntegrators_1_1Advection.html#a8bc7b8136646134f73a4193adefe15f8">cell_matrix</a>(i, j) += matrix_sum * quadrature_data.JxW; </div><div class="line">                    } </div><div class="line">                  cell_rhs(i) += quadrature_data.right_hand_side[i]; </div><div class="line">                } </div><div class="line">            } </div><div class="line">          cell-&gt;get_dof_indices(local_dof_indices); </div><div class="line">          constraints.<a class="code" href="classAffineConstraints.html#a373fbdacd8c486e675b8d2bff8943192">distribute_local_to_global</a>(cell_matrix, </div><div class="line">                                                 cell_rhs, </div><div class="line">                                                 local_dof_indices, </div><div class="line">                                                 system_matrix, </div><div class="line">                                                 system_rhs); </div><div class="line">        } </div><div class="line"></div><div class="line">    system_matrix.compress(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>); </div><div class="line">    system_rhs.<a class="code" href="classBlockVector.html#ad581edc4d3b86a88c4277117c4fae57a">compress</a>(<a class="code" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::solve() </div><div class="line">  { </div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a>              t(computing_timer, <span class="stringliteral">&quot;solve&quot;</span>); </div><div class="line">    <a class="code" href="classPETScWrappers_1_1MPI_1_1Vector.html">LinearAlgebraPETSc::MPI::Vector</a> completely_distributed_solution( </div><div class="line">      locally_owned_dofs, mpi_communicator); </div><div class="line"></div><div class="line">    <a class="code" href="classSolverControl.html">SolverControl</a>                    solver_control; </div><div class="line">    <a class="code" href="classPETScWrappers_1_1SparseDirectMUMPS.html">PETScWrappers::SparseDirectMUMPS</a> solver(solver_control, mpi_communicator); </div><div class="line">    solver.solve(system_matrix, completely_distributed_solution, system_rhs); </div><div class="line"></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;   Solved in &quot;</span> &lt;&lt; solver_control.<a class="code" href="classSolverControl.html#a42aeae81cd6b67ce93b5fbea3328371f">last_step</a>() &lt;&lt; <span class="stringliteral">&quot; iterations.&quot;</span> </div><div class="line">          &lt;&lt; std::endl; </div><div class="line">    constraints.<a class="code" href="classAffineConstraints.html#a7b3d3f295bb56d6cd6856bdc6cbe8a01">distribute</a>(completely_distributed_solution); </div><div class="line">    locally_relevant_solution = completely_distributed_solution; </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::initialize_probe_positions_vector() </div><div class="line">  { </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> position_idx = 0; </div><div class="line">         position_idx &lt; parameters.nb_probe_points; </div><div class="line">         ++position_idx) </div><div class="line">      { </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p = </div><div class="line">          (position_idx / ((<a class="code" href="classdouble.html">double</a>)(parameters.nb_probe_points - 1))) * </div><div class="line">            (parameters.probe_stop_point + (-parameters.probe_start_point)) + </div><div class="line">          parameters.probe_start_point; </div><div class="line">        probe_positions[position_idx][0] = p[0]; </div><div class="line">        probe_positions[position_idx][1] = p[1]; </div><div class="line">        <span class="keywordflow">if</span> (dim == 3) </div><div class="line">          { </div><div class="line">            probe_positions[position_idx][2] = p[2]; </div><div class="line">          } </div><div class="line">      } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> </div><div class="line">  ElasticWave&lt;dim&gt;::store_frequency_step_data(<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frequency_idx) </div><div class="line">  { </div><div class="line">    <a class="code" href="classTimerOutput_1_1Scope.html">TimerOutput::Scope</a> t(computing_timer, <span class="stringliteral">&quot;store_frequency_step_data&quot;</span>); </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> probe_displacement_component = 0; </div><div class="line"></div><div class="line"></div><div class="line">    std::vector&lt;hsize_t&gt;              coordinates; </div><div class="line">    std::vector&lt;std::complex&lt;double&gt;&gt; displacement_data; </div><div class="line"></div><div class="line">    <span class="keyword">const</span> <span class="keyword">auto</span> &amp;mapping = <a class="code" href="mapping_8h.html#a37bc014c9df991ae1a0fd959ede60039">get_default_linear_mapping</a>(triangulation); </div><div class="line">    <a class="code" href="classGridTools_1_1Cache.html">GridTools::Cache&lt;dim, dim&gt;</a> cache(triangulation, mapping); </div><div class="line">    <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim, dim&gt;::active_cell_iterator</a> cell_hint{}; </div><div class="line">    std::vector&lt;bool&gt;                                      marked_vertices = {}; </div><div class="line">    <span class="keyword">const</span> <span class="keywordtype">double</span>                                           tolerance = 1.e-10; </div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> position_idx = 0; </div><div class="line">         position_idx &lt; parameters.nb_probe_points; </div><div class="line">         ++position_idx) </div><div class="line">      { </div><div class="line">        <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> <a class="code" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>; </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">          { </div><div class="line">            point[dim_idx] = probe_positions[position_idx][dim_idx]; </div><div class="line">          } </div><div class="line">        <span class="keywordtype">bool</span> point_in_locally_owned_cell = <span class="keyword">false</span>; </div><div class="line">        { </div><div class="line">          <span class="keyword">auto</span> cell_and_ref_point = <a class="code" href="namespaceGridTools.html#a2e10aeb1c8e76110a84b6945eac3aaf0">GridTools::find_active_cell_around_point</a>( </div><div class="line">            cache, point, cell_hint, marked_vertices, tolerance); </div><div class="line">          <span class="keywordflow">if</span> (cell_and_ref_point.first.state() == <a class="code" href="namespaceIteratorState.html#a4e92f4a9d339ff987cc3eb5b0a1ac507a457da025bc5a3a2231a667bd5c6f3c92">IteratorState::valid</a>) </div><div class="line">            { </div><div class="line">              cell_hint = cell_and_ref_point.first; </div><div class="line">              point_in_locally_owned_cell = </div><div class="line">                cell_and_ref_point.first-&gt;is_locally_owned(); </div><div class="line">            } </div><div class="line">        } </div><div class="line">        <span class="keywordflow">if</span> (point_in_locally_owned_cell) </div><div class="line">          { </div><div class="line"></div><div class="line"></div><div class="line">            Vector&lt;std::complex&lt;double&gt;&gt; tmp_vector(dim); </div><div class="line">            <a class="code" href="namespaceVectorTools.html#acd358e9b110ccbf4a7f76796d206b9c7">VectorTools::point_value</a>(dof_handler, </div><div class="line">                                     locally_relevant_solution, </div><div class="line">                                     point, </div><div class="line">                                     tmp_vector); </div><div class="line">            coordinates.emplace_back(position_idx); </div><div class="line">            coordinates.emplace_back(frequency_idx); </div><div class="line">            displacement_data.emplace_back( </div><div class="line">              tmp_vector(probe_displacement_component)); </div><div class="line">          } </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (coordinates.size() &gt; 0) </div><div class="line">      { </div><div class="line">        displacement.write_selection(displacement_data, coordinates); </div><div class="line">      } </div><div class="line"></div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      { </div><div class="line">        displacement.write_none&lt;std::complex&lt;double&gt;&gt;(); </div><div class="line">      } </div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (parameters.save_vtu_files) </div><div class="line">      { </div><div class="line">        std::vector&lt;std::string&gt; solution_names(dim, <span class="stringliteral">&quot;displacement&quot;</span>); </div><div class="line">        std::vector&lt;DataComponentInterpretation::DataComponentInterpretation&gt; </div><div class="line">          interpretation( </div><div class="line">            dim, <a class="code" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>); </div><div class="line"></div><div class="line">        <a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out; </div><div class="line">        data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(dof_handler, </div><div class="line">                                 locally_relevant_solution, </div><div class="line">                                 solution_names, </div><div class="line">                                 interpretation); </div><div class="line">        Vector&lt;float&gt; subdomain(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i = 0; i &lt; subdomain.size(); ++i) </div><div class="line">          subdomain(i) = triangulation.<a class="code" href="classTriangulation.html#a44ea82a097d8317c98fa422307aff874">locally_owned_subdomain</a>(); </div><div class="line">        data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(subdomain, <span class="stringliteral">&quot;subdomain&quot;</span>); </div><div class="line"></div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; force( </div><div class="line">          dim, Vector&lt;double&gt;(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>())); </div><div class="line">        std::vector&lt;Vector&lt;double&gt;&gt; pml( </div><div class="line">          dim, Vector&lt;double&gt;(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>())); </div><div class="line">        Vector&lt;double&gt; rho(triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>()) </div><div class="line">          { </div><div class="line">            <span class="keywordflow">if</span> (cell-&gt;is_locally_owned()) </div><div class="line">              { </div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">                  { </div><div class="line">                    force[dim_idx](cell-&gt;active_cell_index()) = </div><div class="line">                      parameters.right_hand_side.value(cell-&gt;center(), dim_idx); </div><div class="line">                    pml[dim_idx](cell-&gt;active_cell_index()) = </div><div class="line">                      parameters.pml.value(cell-&gt;center(), dim_idx).imag(); </div><div class="line">                  } </div><div class="line">                rho(cell-&gt;active_cell_index()) = </div><div class="line">                  parameters.rho.value(cell-&gt;center()); </div><div class="line">              } </div><div class="line"></div><div class="line"></div><div class="line">            <span class="keywordflow">else</span> </div><div class="line">              { </div><div class="line">                <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">                  { </div><div class="line">                    force[dim_idx](cell-&gt;active_cell_index()) = -1e+20; </div><div class="line">                    pml[dim_idx](cell-&gt;active_cell_index())   = -1e+20; </div><div class="line">                  } </div><div class="line">                rho(cell-&gt;active_cell_index()) = -1e+20; </div><div class="line">              } </div><div class="line">          } </div><div class="line"></div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim_idx = 0; dim_idx &lt; dim; ++dim_idx) </div><div class="line">          { </div><div class="line">            data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(force[dim_idx], </div><div class="line">                                     <span class="stringliteral">&quot;force_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim_idx)); </div><div class="line">            data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(pml[dim_idx], </div><div class="line">                                     <span class="stringliteral">&quot;pml_&quot;</span> + <a class="code" href="namespacePatterns_1_1Tools.html#a72743302dcb1a0fb1f2f8dc5122d299e">std::to_string</a>(dim_idx)); </div><div class="line">          } </div><div class="line">        data_out.<a class="code" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a>(rho, <span class="stringliteral">&quot;rho&quot;</span>); </div><div class="line"></div><div class="line">        data_out.<a class="code" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a>(); </div><div class="line"></div><div class="line">        std::stringstream  frequency_idx_stream; </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> nb_number_positions = </div><div class="line">          ((<span class="keywordtype">unsigned</span> int)<a class="code" href="namespaceDifferentiation_1_1SD.html#af3073c01113bca5a5e9a1b921643ced4">std::log10</a>(parameters.nb_frequency_points)) + 1; </div><div class="line">        frequency_idx_stream &lt;&lt; std::setw(nb_number_positions) </div><div class="line">                             &lt;&lt; std::setfill(<span class="charliteral">&#39;0&#39;</span>) &lt;&lt; frequency_idx; </div><div class="line">        std::string filename = (parameters.simulation_name + <span class="stringliteral">&quot;_&quot;</span> + </div><div class="line">                                frequency_idx_stream.str() + <span class="stringliteral">&quot;.vtu&quot;</span>); </div><div class="line">        data_out.<a class="code" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a>(filename.c_str(), mpi_communicator); </div><div class="line">      } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::output_results() </div><div class="line">  { </div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (<a class="code" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">Utilities::MPI::this_mpi_process</a>(mpi_communicator) == 0) </div><div class="line">      { </div><div class="line">        frequency_dataset.write(frequency); </div><div class="line">        probe_positions_dataset.write(probe_positions); </div><div class="line">      } </div><div class="line">    <span class="keywordflow">else</span> </div><div class="line">      { </div><div class="line">        frequency_dataset.write_none&lt;<span class="keywordtype">double</span>&gt;(); </div><div class="line">        probe_positions_dataset.write_none&lt;<span class="keywordtype">double</span>&gt;(); </div><div class="line">      } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::setup_quadrature_cache() </div><div class="line">  { </div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a26562806fd764afdffb973dce92554e8">clear_user_data</a>(); </div><div class="line"></div><div class="line">    { </div><div class="line">      std::vector&lt;QuadratureCache&lt;dim&gt;&gt; tmp; </div><div class="line">      quadrature_cache.swap(tmp); </div><div class="line">    } </div><div class="line"></div><div class="line">    quadrature_cache.resize(triangulation.n_locally_owned_active_cells() * </div><div class="line">                              quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(), </div><div class="line">                            QuadratureCache&lt;dim&gt;(fe.<a class="code" href="classFiniteElementData.html#a33b522422da89e5c080e7405ad49d7c7">n_dofs_per_cell</a>())); </div><div class="line">    <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> cache_index = 0; </div><div class="line">    <span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : triangulation.<a class="code" href="group__CPP11.html#ga4288670ae5bd80367e24918d542cb2d8">active_cell_iterators</a>()) </div><div class="line">      <span class="keywordflow">if</span> (cell-&gt;is_locally_owned()) </div><div class="line">        { </div><div class="line">          cell-&gt;set_user_pointer(&amp;quadrature_cache[cache_index]); </div><div class="line">          cache_index += quadrature_formula.<a class="code" href="classQuadrature.html#af9f7d82770fa8126e19113f3e3db755b">size</a>(); </div><div class="line">        } </div><div class="line">    <a class="code" href="group__Exceptions.html#ga70a0bb353656e704acf927945277bbc6">Assert</a>(cache_index == quadrature_cache.size(), <a class="code" href="group__Exceptions.html#ga31978c026b8b6b5116df30b8e748f6b7">ExcInternalError</a>()); </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> ElasticWave&lt;dim&gt;::frequency_sweep() </div><div class="line">  { </div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> frequency_idx = 0; </div><div class="line">         frequency_idx &lt; parameters.nb_frequency_points; </div><div class="line">         ++frequency_idx) </div><div class="line">      { </div><div class="line">        pcout &lt;&lt; parameters.simulation_name + <span class="stringliteral">&quot; frequency idx: &quot;</span> </div><div class="line">              &lt;&lt; frequency_idx &lt;&lt; <span class="charliteral">&#39;/&#39;</span> &lt;&lt; parameters.nb_frequency_points - 1 </div><div class="line">              &lt;&lt; std::endl; </div><div class="line"></div><div class="line">        setup_system(); </div><div class="line">        <span class="keywordflow">if</span> (frequency_idx == 0) </div><div class="line">          { </div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;   Number of active cells :       &quot;</span> </div><div class="line">                  &lt;&lt; triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>() &lt;&lt; std::endl; </div><div class="line">            pcout &lt;&lt; <span class="stringliteral">&quot;   Number of degrees of freedom : &quot;</span> </div><div class="line">                  &lt;&lt; dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>() &lt;&lt; std::endl; </div><div class="line">          } </div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (frequency_idx == 0) </div><div class="line">          { </div><div class="line"></div><div class="line"></div><div class="line">            parameters.data.set_attribute(<span class="stringliteral">&quot;active_cells&quot;</span>, </div><div class="line">                                          triangulation.<a class="code" href="classTriangulation.html#a5ea5c9957dbb566a562bbe2c0f3971e9">n_active_cells</a>()); </div><div class="line">            parameters.data.set_attribute(<span class="stringliteral">&quot;degrees_of_freedom&quot;</span>, </div><div class="line">                                          dof_handler.<a class="code" href="classDoFHandler.html#aa5b8d3c4b9deb0774dde5c2851e07e1e">n_dofs</a>()); </div><div class="line">          } </div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_loop_frequency = </div><div class="line">          (parameters.start_frequency + </div><div class="line">           frequency_idx * </div><div class="line">             (parameters.stop_frequency - parameters.start_frequency) / </div><div class="line">             (parameters.nb_frequency_points - 1)); </div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">double</span> current_loop_omega = </div><div class="line">          2 * numbers::PI * current_loop_frequency; </div><div class="line"></div><div class="line"></div><div class="line">        assemble_system(current_loop_omega, </div><div class="line">                        (frequency_idx == 0) ? <span class="keyword">true</span> : <span class="keyword">false</span>); </div><div class="line">        solve(); </div><div class="line"></div><div class="line">        frequency[frequency_idx] = current_loop_frequency; </div><div class="line">        store_frequency_step_data(frequency_idx); </div><div class="line"></div><div class="line">        computing_timer.print_summary(); </div><div class="line">        computing_timer.reset(); </div><div class="line">        pcout &lt;&lt; std::endl; </div><div class="line">      } </div><div class="line">  } </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt; </div><div class="line">  <span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">ElasticWave&lt;dim&gt;::run</a>() </div><div class="line">  { </div><div class="line"><span class="preprocessor">#ifdef DEBUG </span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Debug mode&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="preprocessor">#else </span></div><div class="line">    pcout &lt;&lt; <span class="stringliteral">&quot;Release mode&quot;</span> &lt;&lt; std::endl; </div><div class="line"><span class="preprocessor">#endif </span></div><div class="line"></div><div class="line">    { </div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p1; </div><div class="line">      p1(0) = -parameters.dimension_x / 2; </div><div class="line">      p1(1) = -parameters.dimension_y / 2; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          p1(2) = -parameters.dimension_y / 2; </div><div class="line">        } </div><div class="line">      <a class="code" href="classPoint.html">Point&lt;dim&gt;</a> p2; </div><div class="line">      p2(0) = parameters.dimension_x / 2; </div><div class="line">      p2(1) = parameters.dimension_y / 2; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          p2(2) = parameters.dimension_y / 2; </div><div class="line">        } </div><div class="line">      std::vector&lt;unsigned int&gt; divisions(dim); </div><div class="line">      divisions[0] = int(parameters.dimension_x / parameters.dimension_y); </div><div class="line">      divisions[1] = 1; </div><div class="line">      <span class="keywordflow">if</span> (dim == 3) </div><div class="line">        { </div><div class="line">          divisions[2] = 1; </div><div class="line">        } </div><div class="line">      <a class="code" href="namespaceGridGenerator.html#ac76417d7404b75cf53c732f456e6e971">GridGenerator::subdivided_hyper_rectangle</a>(triangulation, </div><div class="line">                                                divisions, </div><div class="line">                                                p1, </div><div class="line">                                                p2); </div><div class="line">    } </div><div class="line"></div><div class="line">    triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a>(parameters.grid_level); </div><div class="line"></div><div class="line">    setup_quadrature_cache(); </div><div class="line"></div><div class="line">    initialize_probe_positions_vector(); </div><div class="line"></div><div class="line">    frequency_sweep(); </div><div class="line"></div><div class="line">    output_results(); </div><div class="line">  } </div><div class="line">} <span class="comment">// namespace step62 </span></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]) </div><div class="line">{ </div><div class="line">  <span class="keywordflow">try</span> </div><div class="line">    { </div><div class="line">      <span class="keyword">using namespace </span><a class="code" href="namespacedealii.html">dealii</a>; </div><div class="line">      <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> dim = 2; </div><div class="line"></div><div class="line">      <a class="code" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> mpi_initialization(argc, argv, 1); </div><div class="line"></div><div class="line">      HDF5::File data_file(<span class="stringliteral">&quot;results.h5&quot;</span>, </div><div class="line">                           HDF5::File::FileAccessMode::create, </div><div class="line">                           MPI_COMM_WORLD); </div><div class="line">      <span class="keyword">auto</span>       data = data_file.create_group(<span class="stringliteral">&quot;data&quot;</span>); </div><div class="line"></div><div class="line"></div><div class="line">      <span class="keyword">const</span> std::vector&lt;std::string&gt; group_names = {<span class="stringliteral">&quot;displacement&quot;</span>, </div><div class="line">                                                    <span class="stringliteral">&quot;calibration&quot;</span>}; </div><div class="line">      <span class="keywordflow">for</span> (<span class="keyword">auto</span> group_name : group_names) </div><div class="line">        { </div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">          <span class="keyword">auto</span> group = data.create_group(group_name); </div><div class="line"></div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;dimension_x&quot;</span>, 2e-5); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;dimension_y&quot;</span>, 2e-8); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;probe_pos_x&quot;</span>, 8e-6); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;probe_pos_y&quot;</span>, 0); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;probe_width_y&quot;</span>, 2e-08); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_probe_points&quot;</span>, 5); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;grid_level&quot;</span>, 1); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;cavity_resonance_frequency&quot;</span>, 20e9); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_mirror_pairs&quot;</span>, 15); </div><div class="line"></div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>, 0.27); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;youngs_modulus&quot;</span>, 270000000000.0); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;material_a_rho&quot;</span>, 3200); </div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (group_name == std::string(<span class="stringliteral">&quot;displacement&quot;</span>)) </div><div class="line">            group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;material_b_rho&quot;</span>, 2000); </div><div class="line">          <span class="keywordflow">else</span> </div><div class="line">            group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;material_b_rho&quot;</span>, 3200); </div><div class="line"></div><div class="line">          group.set_attribute( </div><div class="line">            <span class="stringliteral">&quot;lambda&quot;</span>, </div><div class="line">            group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;youngs_modulus&quot;</span>) * </div><div class="line">              group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>) / </div><div class="line">              ((1 + group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>)) * </div><div class="line">               (1 - 2 * group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;poissons_ratio&quot;</span>)))); </div><div class="line">          group.set_attribute(<span class="stringliteral">&quot;mu&quot;</span>, </div><div class="line">                              group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;youngs_modulus&quot;</span>) / </div><div class="line">                                (2 * (1 + group.get_attribute&lt;<span class="keywordtype">double</span>&gt;( </div><div class="line">                                            <span class="stringliteral">&quot;poissons_ratio&quot;</span>)))); </div><div class="line"></div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;max_force_amplitude&quot;</span>, 1e26); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_sigma_x&quot;</span>, 1e-7); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_sigma_y&quot;</span>, 1); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;max_force_width_x&quot;</span>, 3e-7); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;max_force_width_y&quot;</span>, 2e-8); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_x_pos&quot;</span>, -8e-6); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;force_y_pos&quot;</span>, 0); </div><div class="line"></div><div class="line">          group.set_attribute&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;pml_x&quot;</span>, <span class="keyword">true</span>); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;pml_y&quot;</span>, <span class="keyword">false</span>); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;pml_width_x&quot;</span>, 1.8e-6); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;pml_width_y&quot;</span>, 5e-7); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;pml_coeff&quot;</span>, 1.6); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;pml_coeff_degree&quot;</span>, 2); </div><div class="line"></div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;center_frequency&quot;</span>, 20e9); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;frequency_range&quot;</span>, 0.5e9); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;( </div><div class="line">            <span class="stringliteral">&quot;start_frequency&quot;</span>, </div><div class="line">            group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;center_frequency&quot;</span>) - </div><div class="line">              group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;frequency_range&quot;</span>) / 2); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">double</span>&gt;( </div><div class="line">            <span class="stringliteral">&quot;stop_frequency&quot;</span>, </div><div class="line">            group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;center_frequency&quot;</span>) + </div><div class="line">              group.get_attribute&lt;<span class="keywordtype">double</span>&gt;(<span class="stringliteral">&quot;frequency_range&quot;</span>) / 2); </div><div class="line">          group.set_attribute&lt;<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>&gt;(<span class="stringliteral">&quot;nb_frequency_points&quot;</span>, 400); </div><div class="line"></div><div class="line">          <span class="keywordflow">if</span> (group_name == std::string(<span class="stringliteral">&quot;displacement&quot;</span>)) </div><div class="line">            group.set_attribute&lt;std::string&gt;( </div><div class="line">              <span class="stringliteral">&quot;simulation_name&quot;</span>, std::string(<span class="stringliteral">&quot;phononic_cavity_displacement&quot;</span>)); </div><div class="line">          <span class="keywordflow">else</span> </div><div class="line">            group.set_attribute&lt;std::string&gt;( </div><div class="line">              <span class="stringliteral">&quot;simulation_name&quot;</span>, std::string(<span class="stringliteral">&quot;phononic_cavity_calibration&quot;</span>)); </div><div class="line"></div><div class="line">          group.set_attribute&lt;<span class="keywordtype">bool</span>&gt;(<span class="stringliteral">&quot;save_vtu_files&quot;</span>, <span class="keyword">false</span>); </div><div class="line">        } </div><div class="line"></div><div class="line">      { </div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">auto</span>                    displacement = data.open_group(<span class="stringliteral">&quot;displacement&quot;</span>); </div><div class="line">        step62::Parameters&lt;dim&gt; parameters(displacement); </div><div class="line"></div><div class="line">        step62::ElasticWave&lt;dim&gt; elastic_problem(parameters); </div><div class="line">        elastic_problem.run(); </div><div class="line">      } </div><div class="line"></div><div class="line">      { </div><div class="line"></div><div class="line"></div><div class="line">        <span class="keyword">auto</span>                    calibration = data.open_group(<span class="stringliteral">&quot;calibration&quot;</span>); </div><div class="line">        step62::Parameters&lt;dim&gt; parameters(calibration); </div><div class="line"></div><div class="line">        step62::ElasticWave&lt;dim&gt; elastic_problem(parameters); </div><div class="line">        elastic_problem.run(); </div><div class="line">      } </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (std::exception &amp;exc) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Exception on processing: &quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; exc.what() &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line"></div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line">  <span class="keywordflow">catch</span> (...) </div><div class="line">    { </div><div class="line">      std::cerr &lt;&lt; std::endl </div><div class="line">                &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      std::cerr &lt;&lt; <span class="stringliteral">&quot;Unknown exception!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;Aborting!&quot;</span> &lt;&lt; std::endl </div><div class="line">                &lt;&lt; <span class="stringliteral">&quot;----------------------------------------------------&quot;</span> </div><div class="line">                &lt;&lt; std::endl; </div><div class="line">      <span class="keywordflow">return</span> 1; </div><div class="line">    } </div><div class="line"></div><div class="line">  <span class="keywordflow">return</span> 0; </div><div class="line">} </div><div class="line"></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
