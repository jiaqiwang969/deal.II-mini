<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceUtilities_1_1MPI.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Utilities::MPI Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceUtilities.html">Utilities</a></li><li class="navelem"><a class="el" href="namespaceUtilities_1_1MPI.html">MPI</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utilities::MPI Namespace Reference<div class="ingroups"><a class="el" href="group__utilities.html">Utility functions and classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceUtilities_1_1MPI_1_1ConsensusAlgorithms"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI_1_1ConsensusAlgorithms.html">ConsensusAlgorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceUtilities_1_1MPI_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1CollectiveMutex.html">CollectiveMutex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">CommunicationPatternBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1ConsensusAlgorithmsProcessTargets.html">ConsensusAlgorithmsProcessTargets</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1DuplicatedCommunicator.html">DuplicatedCommunicator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">MPI_InitFinalize</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1NoncontiguousPartitioner.html">NoncontiguousPartitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Partitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1ProcessGrid.html">ProcessGrid</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classUtilities_1_1MPI_1_1RemotePointEvaluation.html">RemotePointEvaluation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac26de0c059200523177bb1d92cc25d00"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#ac26de0c059200523177bb1d92cc25d00">n_mpi_processes</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:ac26de0c059200523177bb1d92cc25d00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895dcd8223a0ee6f0e6a80b80e2d5982"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a895dcd8223a0ee6f0e6a80b80e2d5982">this_mpi_process</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a895dcd8223a0ee6f0e6a80b80e2d5982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd4ad9a11431f676413e44c4db6e7998"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#abd4ad9a11431f676413e44c4db6e7998">mpi_processes_within_communicator</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm_large, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm_small)</td></tr>
<tr class="separator:abd4ad9a11431f676413e44c4db6e7998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b9a3309dffffe1447758157a33dbb6"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a89b9a3309dffffe1447758157a33dbb6">compute_point_to_point_communication_pattern</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;destinations)</td></tr>
<tr class="separator:a89b9a3309dffffe1447758157a33dbb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78909ee75d2de673a70554e356c833b2"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a78909ee75d2de673a70554e356c833b2">compute_n_point_to_point_communications</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;destinations)</td></tr>
<tr class="separator:a78909ee75d2de673a70554e356c833b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa94c66b4997bb4b8cc67022baefcc08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#aa94c66b4997bb4b8cc67022baefcc08c">duplicate_communicator</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:aa94c66b4997bb4b8cc67022baefcc08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1994cd0f2168ced4026e601eabda0f82"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a1994cd0f2168ced4026e601eabda0f82">free_communicator</a> (<a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a1994cd0f2168ced4026e601eabda0f82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71d4b9497936fedf1398c0b6fba2ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#af71d4b9497936fedf1398c0b6fba2ee7">create_group</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const MPI_Group &amp;group, const <a class="el" href="classint.html">int</a> tag, <a class="el" href="classMPI__Comm.html">MPI_Comm</a> *new_comm)</td></tr>
<tr class="separator:af71d4b9497936fedf1398c0b6fba2ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7af3310f5e0246f93c75f60805ca9089"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a7af3310f5e0246f93c75f60805ca9089">create_ascending_partitioning</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> locally_owned_size)</td></tr>
<tr class="separator:a7af3310f5e0246f93c75f60805ca9089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810a7bbb660da1347eca2d01364bf6f8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a810a7bbb660da1347eca2d01364bf6f8">create_evenly_distributed_partitioning</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a> total_size)</td></tr>
<tr class="separator:a810a7bbb660da1347eca2d01364bf6f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02e3d15595d7880f5facf4bbfc2bd669"><td class="memTemplParams" colspan="2">template&lt;class Iterator , typename Number  = long double&gt; </td></tr>
<tr class="memitem:a02e3d15595d7880f5facf4bbfc2bd669"><td class="memTemplItemLeft" align="right" valign="top">std::pair&lt; Number, typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::real_type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a02e3d15595d7880f5facf4bbfc2bd669">mean_and_standard_deviation</a> (const Iterator begin, const Iterator end, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm)</td></tr>
<tr class="separator:a02e3d15595d7880f5facf4bbfc2bd669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab544a3bf3301a6dd3e705ee352c5551b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ab544a3bf3301a6dd3e705ee352c5551b"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#ab544a3bf3301a6dd3e705ee352c5551b">sum</a> (const T &amp;t, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:ab544a3bf3301a6dd3e705ee352c5551b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45adfbc2f2e3b9bdf41db0c923062878"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a45adfbc2f2e3b9bdf41db0c923062878"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a45adfbc2f2e3b9bdf41db0c923062878">sum</a> (const T &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, U &amp;sums)</td></tr>
<tr class="separator:a45adfbc2f2e3b9bdf41db0c923062878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaf69c2cc054b615707da05e05239b1c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:afaf69c2cc054b615707da05e05239b1c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#afaf69c2cc054b615707da05e05239b1c">sum</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;sums)</td></tr>
<tr class="separator:afaf69c2cc054b615707da05e05239b1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add36cb2862973c06be029415bc72c524"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:add36cb2862973c06be029415bc72c524"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#add36cb2862973c06be029415bc72c524">sum</a> (const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:add36cb2862973c06be029415bc72c524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc189f054cee2690962d6a76eb62eb35"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:adc189f054cee2690962d6a76eb62eb35"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#adc189f054cee2690962d6a76eb62eb35">sum</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:adc189f054cee2690962d6a76eb62eb35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d907910113b680b91b8374edcbb41a"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a22d907910113b680b91b8374edcbb41a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a22d907910113b680b91b8374edcbb41a">sum</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;global)</td></tr>
<tr class="separator:a22d907910113b680b91b8374edcbb41a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2f716b789abe53715d6659f38aa7815"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad2f716b789abe53715d6659f38aa7815"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#ad2f716b789abe53715d6659f38aa7815">max</a> (const T &amp;t, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:ad2f716b789abe53715d6659f38aa7815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a483afd638220cc834b4bdd8015e19b81"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a483afd638220cc834b4bdd8015e19b81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a483afd638220cc834b4bdd8015e19b81">max</a> (const T &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, U &amp;maxima)</td></tr>
<tr class="separator:a483afd638220cc834b4bdd8015e19b81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc6e56338671db4b65dd9e2e811f6a6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8cc6e56338671db4b65dd9e2e811f6a6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a8cc6e56338671db4b65dd9e2e811f6a6">max</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;maxima)</td></tr>
<tr class="separator:a8cc6e56338671db4b65dd9e2e811f6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ac5275c3c74902f8a9d6e7bdb514179"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9ac5275c3c74902f8a9d6e7bdb514179"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a9ac5275c3c74902f8a9d6e7bdb514179">min</a> (const T &amp;t, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a9ac5275c3c74902f8a9d6e7bdb514179"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a7c0e2d38176841a2ea95eb334ab7e"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a62a7c0e2d38176841a2ea95eb334ab7e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a62a7c0e2d38176841a2ea95eb334ab7e">min</a> (const T &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, U &amp;minima)</td></tr>
<tr class="separator:a62a7c0e2d38176841a2ea95eb334ab7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3354767069b32a6827a5c9e5212babae"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a3354767069b32a6827a5c9e5212babae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a3354767069b32a6827a5c9e5212babae">min</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;minima)</td></tr>
<tr class="separator:a3354767069b32a6827a5c9e5212babae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32879e6c2f20242f7fa2b4f16ebf674a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a32879e6c2f20242f7fa2b4f16ebf674a"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a32879e6c2f20242f7fa2b4f16ebf674a">logical_or</a> (const T &amp;t, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a32879e6c2f20242f7fa2b4f16ebf674a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b046a6551d0ad156a2ec6c140562440"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a9b046a6551d0ad156a2ec6c140562440"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a9b046a6551d0ad156a2ec6c140562440">logical_or</a> (const T &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, U &amp;results)</td></tr>
<tr class="separator:a9b046a6551d0ad156a2ec6c140562440"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a274f8c95bfdbbf4c7fee1213706fb62b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a274f8c95bfdbbf4c7fee1213706fb62b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a274f8c95bfdbbf4c7fee1213706fb62b">logical_or</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;values, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;results)</td></tr>
<tr class="separator:a274f8c95bfdbbf4c7fee1213706fb62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac99815842a50d26e069a62fd01212c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#ac99815842a50d26e069a62fd01212c41">min_max_avg</a> (const <a class="el" href="classdouble.html">double</a> my_value, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:ac99815842a50d26e069a62fd01212c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad857b6e771a00fd962803b62486edb81"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#ad857b6e771a00fd962803b62486edb81">min_max_avg</a> (const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;my_value, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:ad857b6e771a00fd962803b62486edb81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06db7b273e3a952c8a55133ed77d0340"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a06db7b273e3a952c8a55133ed77d0340">min_max_avg</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;my_values, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a> &gt; &amp;result, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:a06db7b273e3a952c8a55133ed77d0340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e632a701db5e1ba05c4656a914e82b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#aa8e632a701db5e1ba05c4656a914e82b">job_supports_mpi</a> ()</td></tr>
<tr class="separator:aa8e632a701db5e1ba05c4656a914e82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0acdfd4af3a4d9d8fe0067a1e604cd80"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0acdfd4af3a4d9d8fe0067a1e604cd80"><td class="memTemplItemLeft" align="right" valign="top">std::map&lt; unsigned <a class="el" href="classint.html">int</a>, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a0acdfd4af3a4d9d8fe0067a1e604cd80">some_to_some</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, T &gt; &amp;objects_to_send)</td></tr>
<tr class="separator:a0acdfd4af3a4d9d8fe0067a1e604cd80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5a7433f594a19070add2afa0f769efb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac5a7433f594a19070add2afa0f769efb"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#ac5a7433f594a19070add2afa0f769efb">all_gather</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const T &amp;object_to_send)</td></tr>
<tr class="separator:ac5a7433f594a19070add2afa0f769efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d4560fb9a0712a910b9e613591ffedc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1d4560fb9a0712a910b9e613591ffedc"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a1d4560fb9a0712a910b9e613591ffedc">gather</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const T &amp;object_to_send, const unsigned <a class="el" href="classint.html">int</a> root_process=0)</td></tr>
<tr class="separator:a1d4560fb9a0712a910b9e613591ffedc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128aed5c46be49d692bbbc3a23424c36"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a128aed5c46be49d692bbbc3a23424c36"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a128aed5c46be49d692bbbc3a23424c36">broadcast</a> (const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const T &amp;object_to_send, const unsigned <a class="el" href="classint.html">int</a> root_process=0)</td></tr>
<tr class="separator:a128aed5c46be49d692bbbc3a23424c36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e963546bd81b0cdd88e1840cfa8f227"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a9e963546bd81b0cdd88e1840cfa8f227"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a9e963546bd81b0cdd88e1840cfa8f227">reduce</a> (const T &amp;local_value, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const std::function&lt; T(const T &amp;, const T &amp;)&gt; &amp;combiner, const unsigned <a class="el" href="classint.html">int</a> root_process=0)</td></tr>
<tr class="separator:a9e963546bd81b0cdd88e1840cfa8f227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7973dfb3b425cd551dcb12085e8b4cfb"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7973dfb3b425cd551dcb12085e8b4cfb"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a7973dfb3b425cd551dcb12085e8b4cfb">all_reduce</a> (const T &amp;local_value, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const std::function&lt; T(const T &amp;, const T &amp;)&gt; &amp;combiner)</td></tr>
<tr class="separator:a7973dfb3b425cd551dcb12085e8b4cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19d5bdd546cc6440259a4df6f945f3d9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a19d5bdd546cc6440259a4df6f945f3d9">compute_index_owner</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;owned_indices, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;indices_to_look_up, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm)</td></tr>
<tr class="separator:a19d5bdd546cc6440259a4df6f945f3d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58671b36907e18de1a24efa3aea12f45"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a58671b36907e18de1a24efa3aea12f45"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a58671b36907e18de1a24efa3aea12f45">compute_set_union</a> (const std::vector&lt; T &gt; &amp;vec, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm)</td></tr>
<tr class="separator:a58671b36907e18de1a24efa3aea12f45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7835fa8da9f189681b62287b5c1481d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a7835fa8da9f189681b62287b5c1481d7"><td class="memTemplItemLeft" align="right" valign="top">std::set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceUtilities_1_1MPI.html#a7835fa8da9f189681b62287b5c1481d7">compute_set_union</a> (const std::set&lt; T &gt; &amp;set, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm)</td></tr>
<tr class="separator:a7835fa8da9f189681b62287b5c1481d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>一个命名空间，用于抽象使用消息传递接口（MPI）的某些操作，或者在deal.II被配置为完全不使用MPI的情况下提供后备操作的实用函数。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="ac26de0c059200523177bb1d92cc25d00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac26de0c059200523177bb1d92cc25d00">&#9670;&nbsp;</a></span>n_mpi_processes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Utilities::MPI::n_mpi_processes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回给定的 communicator  对象中存在的MPI进程的数量。如果这是一个顺序作业（即，程序根本没有使用MPI，或者使用了MPI但只启动了一个MPI进程），那么通信器必然只涉及一个进程，函数返回1。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00117">117</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a895dcd8223a0ee6f0e6a80b80e2d5982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a895dcd8223a0ee6f0e6a80b80e2d5982">&#9670;&nbsp;</a></span>this_mpi_process()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Utilities::MPI::this_mpi_process </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00128">128</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="abd4ad9a11431f676413e44c4db6e7998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd4ad9a11431f676413e44c4db6e7998">&#9670;&nbsp;</a></span>mpi_processes_within_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; Utilities::MPI::mpi_processes_within_communicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_large</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_small</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个行列向量（在 <code>comm_large</code>) 指定的进程子集的 <code>comm_small</code>. 内）。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00140">140</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a89b9a3309dffffe1447758157a33dbb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b9a3309dffffe1447758157a33dbb6">&#9670;&nbsp;</a></span>compute_point_to_point_communication_pattern()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; Utilities::MPI::compute_point_to_point_communication_pattern </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>考虑一个非结构化的通信模式，MPI宇宙中的每个进程都想向其他进程的一个子集发送一些数据。要做到这一点，其他处理器需要知道从谁那里期待消息。这个函数可以计算这个信息。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>一个 通信器 ，描述要相互通信的处理器。 </td></tr>
    <tr><td class="paramname">destinations</td><td>当前进程想要发送信息的处理器列表。这个列表不需要以任何方式进行排序。如果它包含重复的条目，那就意味着有多条信息是要发给某个目的地的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>已表示要向当前处理器发送东西的处理器的列表。由此产生的列表没有被排序。 如果处理器在其目的地列表中多次输入同一个目的地，它可能包含重复的条目。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00359">359</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a78909ee75d2de673a70554e356c833b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78909ee75d2de673a70554e356c833b2">&#9670;&nbsp;</a></span>compute_n_point_to_point_communications()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Utilities::MPI::compute_n_point_to_point_communications </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>destinations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceUtilities_1_1MPI.html#a89b9a3309dffffe1447758157a33dbb6">compute_point_to_point_communication_pattern()</a>的简化版本（为了提高效率），它只计算MPI宇宙中期待通信的进程数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>一个 通信器 ，描述要相互通信的处理器。 </td></tr>
    <tr><td class="paramname">destinations</td><td>当前进程想要发送信息的处理器的列表。这个列表不需要以任何方式进行排序。如果它包含重复的条目，那就意味着有多条信息是要发给某个目的地的。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>想要向当前处理器发送东西的处理器的数量。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00497">497</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="aa94c66b4997bb4b8cc67022baefcc08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa94c66b4997bb4b8cc67022baefcc08c">&#9670;&nbsp;</a></span>duplicate_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> Utilities::MPI::duplicate_communicator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个 通信器 ，生成一个新的通信器，该通信器包含相同的处理器集合，但有一个不同的、唯一的标识。 这个功能可以用来确保不同的对象，如分布式矩阵，都有唯一的通信器，它们可以在上面进行交互而不互相干扰。 当不再需要时，这里创建的通信器需要用free_communicator()来销毁。 这个函数等同于调用 <code>MPI_Comm_dup(mpi_communicator, &amp;return_value);</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00160">160</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a1994cd0f2168ced4026e601eabda0f82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1994cd0f2168ced4026e601eabda0f82">&#9670;&nbsp;</a></span>free_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::free_communicator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放给定的 通信器 <code>mpi_communicator</code> ，该通信器是使用diplicate_communicator()复制的。 参数是通过引用传递的，并且将被无效化并设置为MPI空手柄。这个函数等同于调用 <code>MPI_Comm_free(&amp;mpi_communicator);</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00171">171</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="af71d4b9497936fedf1398c0b6fba2ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71d4b9497936fedf1398c0b6fba2ee7">&#9670;&nbsp;</a></span>create_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classint.html">int</a> Utilities::MPI::create_group </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const MPI_Group &amp;&#160;</td>
          <td class="paramname"><em>group</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> *&#160;</td>
          <td class="paramname"><em>new_comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果 <code>comm</code> 是一个内部通信器，这个函数返回一个新的通信器 <code>newcomm</code> ，其通信组由 <code>group</code> 参数定义。该函数只对实际想要创建通信器的进程组进行集合，即在 <code>group</code> 参数中被命名的进程。如果一个给定进程的多个线程同时执行create_group()操作，用户必须通过提供不同的 <code>tag</code> 或 <code>comm</code> 参数来区分这些操作。 这个函数是在MPI-3.0标准中引入的。如果可用，则使用所提供的MPI实现中的相应函数。 否则，该实现遵循以下出版物中描述的实现。 </p><div class="fragment"><div class="line">@inproceedings{dinan2011noncollective,</div><div class="line">title        = {Noncollective communicator creation in MPI},</div><div class="line">author       = {Dinan, James and Krishnamoorthy, Sriram and Balaji,</div><div class="line">                Pavan and Hammond, Jeff R and Krishnan, Manojkumar and</div><div class="line">                Tipparaju, Vinod and Vishnu, Abhinav},</div><div class="line">booktitle    = {European MPI Users&#39; Group Meeting},</div><div class="line">pages        = {282--291},</div><div class="line">year         = {2011},</div><div class="line">organization = {Springer}</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00181">181</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a7af3310f5e0246f93c75f60805ca9089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7af3310f5e0246f93c75f60805ca9089">&#9670;&nbsp;</a></span>create_ascending_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; Utilities::MPI::create_ascending_partitioning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a>&#160;</td>
          <td class="paramname"><em>locally_owned_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>考虑到本地拥有的元素数量 <code>locally_owned_size</code>, ，在整个MPI通信器中创建一个1:1的元素分区 <code>comm</code>. ，元素的总大小是整个MPI通信器中 <code>locally_owned_size</code> 的总和。 每个进程将存储连续的索引子集，进程p+1上的索引集从比进程p上存储的最后一个索引大的一个索引开始。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00263">263</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a810a7bbb660da1347eca2d01364bf6f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810a7bbb660da1347eca2d01364bf6f8">&#9670;&nbsp;</a></span>create_evenly_distributed_partitioning()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> Utilities::MPI::create_evenly_distributed_partitioning </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html#afd0c161cdaaa0600f22339af5900ac77">IndexSet::size_type</a>&#160;</td>
          <td class="paramname"><em>total_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定元素总数 <code>total_size</code>, 在MPI通信器上创建一个均匀分布的1:1的元素分区 <code>comm</code>. 使用 <code>comm</code> 来确定分区数量和处理器ID，以调用上述 <code><a class="el" href="namespaceUtilities_1_1MPI.html#a810a7bbb660da1347eca2d01364bf6f8">create_evenly_distributed_partitioning()</a></code> 函数。 </p>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00285">285</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a02e3d15595d7880f5facf4bbfc2bd669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02e3d15595d7880f5facf4bbfc2bd669">&#9670;&nbsp;</a></span>mean_and_standard_deviation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Iterator , typename Number  = long double&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;Number, typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::real_type&gt; Utilities::MPI::mean_and_standard_deviation </td>
          <td>(</td>
          <td class="paramtype">const Iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算整个MPI通信器 <code>comm</code> 的平均值和标准偏差，提供的数值为一个范围<code>[begin,end)</code>。 平均值计算为 \(\bar x=\frac 1N \sum x_k\) ，其中 \(x_k\) 是所有处理器上的<code>begin'和</code>end'迭代器所指向的元素（即，每个处理器的`[begin,end]范围指向整体元素数量的一个子集）。标准偏差的计算方法是 \(\sigma=\sqrt{\frac {1}{N-1} \sum |x_k -\bar x|^2}\) ，这被称为无偏的样本方差。 </p><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Number指定了存储均值的类型。</td><td>标准偏差被存储为相应的实数类型。 例如，这允许从整数输入值计算统计数据。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab544a3bf3301a6dd3e705ee352c5551b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab544a3bf3301a6dd3e705ee352c5551b">&#9670;&nbsp;</a></span>sum() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::sum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所有处理器上的数值之和 <code>t</code>. 这个函数是在 通信器  中给出的所有处理器上的集体。 如果deal.II没有被配置为使用MPI，这个函数只是返回 <code>t</code>. 这个函数对应于 <code>MPI_Allreduce</code> 函数，即所有处理器都收到这个操作的结果。 </p><dl class="section note"><dt>Note</dt><dd>有时，并非所有处理器都需要一个结果，在这种情况下，人们会调用 <code>MPI_Reduce</code> 函数而不是 <code>MPI_Allreduce</code> 函数。后者的费用最多是前者的两倍，所以如果你关心性能，可能值得调查一下你的算法是否确实到处需要结果。 </dd>
<dd>
这个函数只对某些模板参数实现 <code>T</code>, namely <code>float, double, int, unsigned int</code> 。 </dd></dl>

</div>
</div>
<a id="a45adfbc2f2e3b9bdf41db0c923062878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45adfbc2f2e3b9bdf41db0c923062878">&#9670;&nbsp;</a></span>sum() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::sum </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>sums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是对T类型的数组的元素进行求和。换句话说，结果数组的第i个元素是每个处理器的输入数组的第i个条目之和。T和U必须衰减到相同的类型，例如，它们的区别只是其中一个有const类型限定符，另一个没有。 输入和输出数组可以是相同的。 </p>

</div>
</div>
<a id="afaf69c2cc054b615707da05e05239b1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaf69c2cc054b615707da05e05239b1c">&#9670;&nbsp;</a></span>sum() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>sums</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是要对ArrayView参数指定的数组元素进行求和。 换句话说，结果数组的第i个元素是每个处理器的输入数组的第i个条目之和。 输入和输出数组可以是相同的。 </p>

</div>
</div>
<a id="add36cb2862973c06be029415bc72c524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add36cb2862973c06be029415bc72c524">&#9670;&nbsp;</a></span>sum() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; Utilities::MPI::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对一个对称张量的条目进行MPI求和。 <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> </p>

</div>
</div>
<a id="adc189f054cee2690962d6a76eb62eb35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc189f054cee2690962d6a76eb62eb35">&#9670;&nbsp;</a></span>sum() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; Utilities::MPI::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对一个张量的条目进行MPI求和。 张量 </p>

</div>
</div>
<a id="a22d907910113b680b91b8374edcbb41a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d907910113b680b91b8374edcbb41a">&#9670;&nbsp;</a></span>sum() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>global</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对稀疏矩阵的条目进行MPI求和。 </p><dl class="section note"><dt>Note</dt><dd><code>local</code> 和 <code>global</code> 应该具有相同的稀疏模式，而且对所有MPI进程都应该是相同的。 </dd></dl>

</div>
</div>
<a id="ad2f716b789abe53715d6659f38aa7815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2f716b789abe53715d6659f38aa7815">&#9670;&nbsp;</a></span>max() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所有处理器上的最大值 <code>t</code>. 这个函数是在 通信器  中给出的所有处理器上的集合。 如果deal.II没有被配置为使用MPI，这个函数只是返回 <code>t</code>. 的值，这个函数对应于 <code>MPI_Allreduce</code> 函数，即所有处理器都收到这个操作的结果。 </p><dl class="section note"><dt>Note</dt><dd>有时，并非所有处理器都需要一个结果，在这种情况下，人们会调用 <code>MPI_Reduce</code> 函数而不是 <code>MPI_Allreduce</code> 函数。后者的费用最多是前者的两倍，所以如果你关心性能，可能值得调查一下你的算法是否确实到处需要结果。 </dd>
<dd>
这个函数只对某些模板参数实现 <code>T</code>, namely <code>float, double, int, unsigned int</code> 。 </dd></dl>

</div>
</div>
<a id="a483afd638220cc834b4bdd8015e19b81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a483afd638220cc834b4bdd8015e19b81">&#9670;&nbsp;</a></span>max() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::max </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>maxima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是在一个T类型的数组的元素上取最大值。换句话说，结果数组的第i个元素是每个处理器的输入数组的第i个条目的最大值。T和U必须衰减到相同的类型，例如，它们的区别只是其中一个有const类型限定符，另一个没有。 输入和输出向量可以是相同的。 </p>

</div>
</div>
<a id="a8cc6e56338671db4b65dd9e2e811f6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc6e56338671db4b65dd9e2e811f6a6">&#9670;&nbsp;</a></span>max() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>maxima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但在ArrayView参数指定的数组元素上取最大值。 换句话说，结果数组的第i个元素是每个处理器的输入数组的第i个条目上的最大值。 输入和输出数组可以是相同的。 </p>

</div>
</div>
<a id="a9ac5275c3c74902f8a9d6e7bdb514179"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ac5275c3c74902f8a9d6e7bdb514179">&#9670;&nbsp;</a></span>min() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回所有处理器上的最小值 <code>t</code>. 这个函数是在 通信器  中给出的所有处理器上的集合。 如果deal.II没有被配置为使用MPI，这个函数只是返回 <code>t</code>. 这个函数对应于 <code>MPI_Allreduce</code> 函数，即所有处理器都收到这个操作的结果。 </p><dl class="section note"><dt>Note</dt><dd>有时，并非所有处理器都需要一个结果，在这种情况下，人们会调用 <code>MPI_Reduce</code> 函数而不是 <code>MPI_Allreduce</code> 函数。后者的费用最多是前者的两倍，所以如果你关心性能，可能值得调查一下你的算法是否确实到处需要结果。 </dd>
<dd>
这个函数只对某些模板参数实现 <code>T</code>, namely <code>float, double, int, unsigned int</code> 。 </dd></dl>

</div>
</div>
<a id="a62a7c0e2d38176841a2ea95eb334ab7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a7c0e2d38176841a2ea95eb334ab7e">&#9670;&nbsp;</a></span>min() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::min </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>minima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但在一个T类型的数组的元素上取最小值。换句话说，结果数组的第i个元素是每个处理器的输入数组的第i个条目的最小值。T和U必须衰减到相同的类型，例如，它们的区别只是其中一个有const类型限定符，另一个没有。 输入和输出数组可以是相同的。 </p>

</div>
</div>
<a id="a3354767069b32a6827a5c9e5212babae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3354767069b32a6827a5c9e5212babae">&#9670;&nbsp;</a></span>min() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>minima</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是在ArrayView参数指定的数组元素中取最小值。 换句话说，结果数组的第i个元素是每个处理器的输入数组的第i个条目上的最小值。 输入和输出数组可以是相同的。 </p>

</div>
</div>
<a id="a32879e6c2f20242f7fa2b4f16ebf674a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32879e6c2f20242f7fa2b4f16ebf674a">&#9670;&nbsp;</a></span>logical_or() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::logical_or </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在数值为 <code>t</code>. 的所有处理器上执行<em>logical or</em>的操作。 <em>logical or</em>操作符<code>||</code>如果任一或所有操作数为<code>真'，则返回布尔值</code>真'，否则返回<code>假</code>。如果提供的值 <code>t</code> 在其相关的数据类型<code>T</code>中对应于<code>0</code>，它将被解释为<code>false</code>，否则为<code>true</code>。数据类型<code>T</code>必须是<code>integral</code>类型，即<code>bool</code>、<code>char</code>、<code>short</code>、<code>int</code>、<code>long</code>，或它们的任何变化。 这个函数是在 通信器  中给出的所有处理器上的集体。 如果deal.II没有被配置为使用MPI，这个函数只是返回 <code>value</code>. 的值，这个函数对应于 <code>MPI_Allreduce</code> 函数，即所有处理器都收到这个操作的结果。 </p><dl class="section note"><dt>Note</dt><dd>有时，并非所有处理器都需要一个结果，在这种情况下，人们会调用 <code>MPI_Reduce</code> 函数而不是 <code>MPI_Allreduce</code> 函数。后者的费用最多是前者的两倍，所以如果你关心性能，可能值得调查一下你的算法是否确实到处需要结果。 </dd></dl>

</div>
</div>
<a id="a9b046a6551d0ad156a2ec6c140562440"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b046a6551d0ad156a2ec6c140562440">&#9670;&nbsp;</a></span>logical_or() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::logical_or </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">U &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是对数组中的每个元素执行<em>logical or</em>操作。换句话说，结果数组的第i个元素是对每个处理器的输入数组的第i个条目应用<em>logical or</em>操作的结果。T和U必须衰减到相同的类型，例如，它们只是因其中一个有const类型限定符而另一个没有而不同。 输入和输出数组可以是相同的。 </p><dl class="section note"><dt>Note</dt><dd>根据你的标准库，这个函数可能无法与数据类型<code>bool</code>的 <code>std::vector</code> 的特殊化一起工作。在这种情况下，请使用一个不同的容器或数据类型。 </dd></dl>

</div>
</div>
<a id="a274f8c95bfdbbf4c7fee1213706fb62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a274f8c95bfdbbf4c7fee1213706fb62b">&#9670;&nbsp;</a></span>logical_or() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::logical_or </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const T &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>results</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和前面的函数一样，但是对ArrayView参数指定的数组中的每个元素执行<em>logical or</em>操作。 换句话说，结果数组的第i个元素是对每个处理器的输入数组的第i个条目应用<em>logical or</em>操作的结果。 输入和输出数组可以是相同的。 </p>

</div>
</div>
<a id="ac99815842a50d26e069a62fd01212c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac99815842a50d26e069a62fd01212c41">&#9670;&nbsp;</a></span>min_max_avg() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a> Utilities::MPI::min_max_avg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>my_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的MPI communicator <code>mpi_communicator</code>. 的集体操作中，返回总和、平均值、最小值、最大值、最小和最大值的处理器ID，并将返回结果。该结果在所有机器上都可用。 </p><dl class="section note"><dt>Note</dt><dd>有时，并非所有处理器都需要结果，在这种情况下，人们会调用 <code>MPI_Reduce</code> 函数而不是 <code>MPI_Allreduce</code> 函数。后者最多只有两倍的费用，所以如果你关心性能，可能值得调查一下你的算法是否确实到处需要结果。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00091">91</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="ad857b6e771a00fd962803b62486edb81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad857b6e771a00fd962803b62486edb81">&#9670;&nbsp;</a></span>min_max_avg() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a> &gt; Utilities::MPI::min_max_avg </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>my_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但在给定的MPI communicator <code>mpi_communicator</code> 上对向量的每个条目返回总和、平均数、最小值、最大值、最小和最大值的进程ID作为集体操作。 </p><dl class="section note"><dt>Note</dt><dd>该函数执行一次缩减扫频。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>输入向量的大小在所有进程中必须是相同的。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00104">104</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a06db7b273e3a952c8a55133ed77d0340"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06db7b273e3a952c8a55133ed77d0340">&#9670;&nbsp;</a></span>min_max_avg() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utilities::MPI::min_max_avg </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>my_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="structUtilities_1_1MPI_1_1MinMaxAvg.html">MinMaxAvg</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但是在给定的MPI communicator <code>mpi_communicator</code> 上对ArrayView的每个条目返回sum, average, minimum, maximum, process id of minimum and maximum作为一个集体操作。 </p><dl class="section note"><dt>Note</dt><dd>该函数执行一次缩减扫频。 </dd></dl>
<dl class="section pre"><dt>Precondition</dt><dd>输入ArrayView的大小在所有进程中必须是相同的，并且输入和输出ArrayVew必须有相同的大小。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l00604">604</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="aa8e632a701db5e1ba05c4656a914e82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e632a701db5e1ba05c4656a914e82b">&#9670;&nbsp;</a></span>job_supports_mpi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> Utilities::MPI::job_supports_mpi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回(i)deal.II是否已被编译为支持MPI（例如用 <code>CXX=mpiCC</code> 编译），如果是，是否(ii) <code>MPI_Init()</code> 已被调用（例如使用 <a class="el" href="classUtilities_1_1MPI_1_1MPI__InitFinalize.html">Utilities::MPI::MPI_InitFinalize</a> 类）。换句话说，该结果表明当前作业是否在MPI下运行。 </p><dl class="section note"><dt>Note</dt><dd>该函数没有考虑到一个MPI作业是否实际运行在一个以上的处理器上，或者实际上是一个恰好在MPI下运行的单节点作业。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l01097">1097</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a0acdfd4af3a4d9d8fe0067a1e604cd80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0acdfd4af3a4d9d8fe0067a1e604cd80">&#9670;&nbsp;</a></span>some_to_some()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt;unsigned <a class="el" href="classint.html">int</a>, T&gt; Utilities::MPI::some_to_some </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; unsigned <a class="el" href="classint.html">int</a>, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>objects_to_send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>发起一个某某通信，并在处理器之间交换任意对象（类T应该是可序列化的，使用 boost::serialize) 。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI通信器。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">objects_to_send</td><td>从意在接收数据的进程的等级（无符号int）和要发送的对象的映射（类型<code>T</code>必须是可序列化的，这个函数才能正常工作）。如果这个映射包含一个键值等于当前进程等级的条目（即一个向进程发送数据给自己的指令），那么这个数据项就被简单地复制到返回的对象中。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>从发送数据的进程的等级（无符号int）和收到的对象的映射。 </dd></dl>

</div>
</div>
<a id="ac5a7433f594a19070add2afa0f769efb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5a7433f594a19070add2afa0f769efb">&#9670;&nbsp;</a></span>all_gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Utilities::MPI::all_gather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object_to_send</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>经典MPI_Allgather函数的泛化，它接受任意的数据类型T，只要 boost::serialize 接受T作为参数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI通信器。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">object_to_send</td><td>一个要发送给所有其他进程的对象 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>一个对象的向量，其大小等于MPI通信器中的进程数。每个条目包含从处理器收到的对象，在通信器中具有相应的等级。 </dd></dl>

</div>
</div>
<a id="a1d4560fb9a0712a910b9e613591ffedc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d4560fb9a0712a910b9e613591ffedc">&#9670;&nbsp;</a></span>gather()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Utilities::MPI::gather </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object_to_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>root_process</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>经典MPI_Gather函数的泛化，它接受任意的数据类型T，只要 boost::serialize 接受T作为参数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI通信器。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">object_to_send</td><td>一个要发送给根进程的对象 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_process</td><td>进程，它接收来自所有进程的对象。默认情况下，等级为0的进程是根进程。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>root_process</code> 接收一个对象的向量，其大小等于MPI通信器中的进程数。每个条目包含从通信器中具有相应等级的处理器接收的对象。所有其他进程收到一个空的向量。 </dd></dl>

</div>
</div>
<a id="a128aed5c46be49d692bbbc3a23424c36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128aed5c46be49d692bbbc3a23424c36">&#9670;&nbsp;</a></span>broadcast()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::broadcast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>object_to_send</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>root_process</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从进程 <code>root_process</code> 发送一个对象 <code>object_to_send</code> 到所有其他进程。 经典的<code>MPI_Bcast</code>函数的泛化，接受任意的数据类型<code>T</code>，只要 <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack()</a> （它反过来使用 <code>boost::serialize</code>, ，详见 <a class="el" href="namespaceUtilities.html#a1ebf9e8745b1c1c0f314d24a1ec90921">Utilities::pack()</a> ）接受<code>T</code>作为参数。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI通信器。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">object_to_send</td><td>一个要发送给所有进程的对象。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">root_process</td><td>向所有进程发送对象的进程。默认情况下，等级为0的进程是根进程。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>在根进程上，返回一份 <code>object_to_send</code>. 在其他每个进程上，返回一份由 <code>root_process</code>. 发送的对象的副本。 </dd></dl>

</div>
</div>
<a id="a9e963546bd81b0cdd88e1840cfa8f227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e963546bd81b0cdd88e1840cfa8f227">&#9670;&nbsp;</a></span>reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::reduce </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>local_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(const T &amp;, const T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>combiner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>root_process</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个通过用户指定的二进制操作 <code>combiner</code> 在 <code>root_process</code>. 上结合所有进程的值 <code>local_value</code> 的函数，因此，这个函数类似于MPI_Reduce（和 <a class="el" href="namespaceUtilities_1_1MPI.html#a9ac5275c3c74902f8a9d6e7bdb514179">Utilities::MPI::min</a>/max()): 然而，一方面由于用户指定的二进制操作，它对内置类型较慢，但另一方面，可以处理一般对象类型，包括存储可变数量数据的对象。 与all_reduce相反，结果将只在单一等级上可用。在所有其他进程中，返回值是未定义的。 </p>

</div>
</div>
<a id="a7973dfb3b425cd551dcb12085e8b4cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7973dfb3b425cd551dcb12085e8b4cfb">&#9670;&nbsp;</a></span>all_reduce()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T Utilities::MPI::all_reduce </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>local_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(const T &amp;, const T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>combiner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个通过用户指定的二进制操作 <code>combiner</code> 将所有进程的值 <code>local_value</code> 结合起来并将结果分配给所有进程的函数。因此，这个函数类似于MPI_Allreduce（如果它是由一个全局还原和一个广播步骤实现的），但由于用户指定的二进制操作，也可以处理一般的对象类型，包括那些存储可变数量的数据的对象。 </p>

</div>
</div>
<a id="a19d5bdd546cc6440259a4df6f945f3d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19d5bdd546cc6440259a4df6f945f3d9">&#9670;&nbsp;</a></span>compute_index_owner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; Utilities::MPI::compute_index_owner </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>owned_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>indices_to_look_up</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个分割的索引集空间，根据分割的索引集，计算第二个索引集的每个元素的自有MPI进程等级。这个函数的一个自然用法是为每个鬼魂的自由度计算拥有该索引的进程的MPI等级。 人们可能会想："但是我们知道一个鬼魂自由度属于哪个等级，基于它所在单元的子域ID"。但是这种启发式方法对于不同子域ID的幽灵单元之间的接口上的DoF，或者幽灵单元和人工单元之间的接口上的DoF是失败的。此外，这个函数可以实现完全抽象的信息交换，而不需要借助于网格中的邻居。 传给这个函数的第一个参数， <code>owned_indices</code>, 必须在所有进程之间唯一地划分一个索引空间。 否则，对这个参数没有任何限制。特别是，没有必要将索引空间划分为连续的子集。此外，对第二个索引集 <code>indices_to_look_up</code> 没有任何限制，只要其大小与第一个索引集相符。它可以在每个进程上任意独立选择。在第二个索引集也包含本地拥有的索引的情况下，这些索引将被正确处理，并为这些条目返回本进程的等级。 </p><dl class="section note"><dt>Note</dt><dd>这是一个集体操作：给定通信器内的所有进程都必须调用这个函数。由于这个函数不使用MPI_Alltoall或MPI_Allgather，而是使用非阻塞的点对点通信来代替，并且只使用一个非阻塞的屏障，所以它大大减少了内存消耗。这个函数适合于具有&gt;100k MPI行列的大规模模拟。 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">owned_indices</td><td>指数集，包含本进程本地拥有的指数。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">indices_to_look_up</td><td>包含用户对拥有的进程的等级感兴趣的指数的索引集。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">comm</td><td>MPI通信器。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>包含索引集中每个条目的MPI进程等级的列表 <code>indices_to_look_up</code>. 顺序与ElementIterator中的顺序相吻合。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpi_8cc_source.html#l01113">1113</a> of file <a class="el" href="mpi_8cc_source.html">mpi.cc</a>.</p>

</div>
</div>
<a id="a58671b36907e18de1a24efa3aea12f45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58671b36907e18de1a24efa3aea12f45">&#9670;&nbsp;</a></span>compute_set_union() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;T&gt; Utilities::MPI::compute_set_union </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算MPI通信器中所有进程的输入向量 <code>vec</code> 的联合 <code>comm</code>. 。 </p><dl class="section note"><dt>Note</dt><dd>这是一个集体操作。其结果将在所有进程中可用。 </dd></dl>

</div>
</div>
<a id="a7835fa8da9f189681b62287b5c1481d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7835fa8da9f189681b62287b5c1481d7">&#9670;&nbsp;</a></span>compute_set_union() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::set&lt;T&gt; Utilities::MPI::compute_set_union </td>
          <td>(</td>
          <td class="paramtype">const std::set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但对 std::set. 而言。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
