<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__Concepts.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Concepts, or expectations on template parameters</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Concepts, or expectations on template parameters</div>  </div>
</div><!--header-->
<div class="contents">
<p>Sometimes imposing constraints on the type of an object without requiring it to belong to a specific inheritance hierarchy is useful. These are usually referred to as <em>concepts</em> in the C++ community. This module lists the concepts commonly used in deal.II with brief descriptions of their intent. The convention in deal.II for listing constraints on a type is to provide the name of the concept as a <code>typename</code> in a template: for example, the type of a <a class="el" href="classVector.html">Vector</a> depends on the type of the underlying field, and so it is defined as a template: </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Number&gt;</div><div class="line"><span class="keyword">class </span><a class="code" href="classVector.html">Vector</a>;</div></div><!-- fragment --><p> The point here is that you are creating a vector that can store elements of type <code>Number</code>. But there are some underlying assumptions on this. For example, the deal.II <a class="el" href="classVector.html">Vector</a> class is not intended to be used just as a collection (unlike <code>std::vector</code>) but defines vector space operations such as addition of vectors, or the norm of vectors. Consequently, the data type users can specify for <code>Number</code> must satisfy certain conditions (i.e., it must conform to or "model" a "concept"): Specifically, the type must denote objects that represent the elements of what mathematically call a "field" (which you can think of as, well, "numbers": things we can add, multiply, divide, take the absolute value of, etc). The point of a concept is then to describe <em>what conditions a type must satisfy</em> to be a valid template argument in a given context.</p>
<p>This page describes these conditions for a number of concepts used throughout deal.II. Specifically, in the example above, the <a class="el" href="group__Concepts.html#ConceptNumber">Number concept</a> discussed below describes the types that could be used as argument for the <a class="el" href="classVector.html">Vector</a> class.</p>
<p>Concepts have been proposed as a language extension to C++ for a long time already. They would allow us to describe that a class or function has certain properties in order to be a qualified template argument. For example, it would allow us to express in C++ code that the first argument to, say, <a class="el" href="namespaceGridTools.html#a1f49d6a42c3dbabc53a86571e874cc3f">GridTools::find_closest_vertex()</a>, must have a type that represents an actual mesh &ndash; which we can currently only describe in words, see below. Using C++ concepts would allow us to describe this in code and trying to call such a function with an object as first argument that is not, in fact, a mesh would yield a compiler error that makes the mismatch clear.</p>
<p>Unfortunately, these proposals to C++ have never made it into any official C++ standard; they are proposed for C++20 however. We may start to use them once the vast majority of our users have compilers that support this standard.</p>
<p>More information on the topic can be found at <a href="https://en.wikipedia.org/wiki/Concepts_(C%2B%2B)">this wikipedia page</a>.</p>
<dl>
<dt class="concepts"><a class="anchor" id="ConceptDoFHandlerType"></a><b>DoFHandlerType</b> </dt>
<dd><p class="startdd">deal.II includes both <a class="el" href="classDoFHandler.html">DoFHandler</a> and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> as objects which manage degrees of freedom on a mesh. Though the two do not share any sort of inheritance relationship, they are similar enough that many functions just need something which resembles a <a class="el" href="classDoFHandler.html">DoFHandler</a> to work correctly. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMatrixType"></a><b>MatrixType</b> </dt>
<dd><p class="startdd">Many functions and classes in deal.II require an object which knows how to calculate matrix-vector products (the member function <code>vmult</code>), transposed matrix-vector products (the member function <code>Tvmult</code>), as well as the `multiply and add' equivalents <code>vmult_add</code> and <code>Tvmult_add</code>. Some functions only require <code>vmult</code> and <code>Tvmult</code>, but an object should implement all four member functions if the template requires a MatrixType argument. Writing classes that satisfy these conditions is a sufficiently common occurrence that the <a class="el" href="classLinearOperator.html">LinearOperator</a> class was written to make things easier; see <a class="el" href="group__LAOperators.html">Linear Operators</a> for more information.</p>
<p>One way to think of <code>MatrixType</code> is to pretend it is a base class with the following signature (this is nearly the interface provided by <a class="el" href="classSparseMatrix.html">SparseMatrix</a>):</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MatrixType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;u, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult(<a class="code" href="classVectorType.html">VectorType</a> &amp;u, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> vmult_add(<a class="code" href="classVectorType.html">VectorType</a> &amp;u, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tvmult_add(<a class="code" href="classVectorType.html">VectorType</a> &amp;u, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p>Template functions in C++ cannot be virtual (which is the main reason why this approach is not used in deal.II), so implementing this interface with inheritance will not work, but it is still a good way to think about this template concept. One can use the <a class="el" href="classLinearOperator.html">LinearOperator</a> class to implement <code>vmult_add</code> and <code>Tvmult_add</code> instead of implementing them manually. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptMeshType"></a><b>MeshType</b> </dt>
<dd><p class="startdd">Meshes can be thought of as arrays of vertices and connectivities, but a more fruitful view is to consider them as <em>collections of cells</em>. In C++, collections are often called <em>containers</em> (typical containers are std::vector, std::list, etc.) and they are characterized by the ability to iterate over the elements of the collection. The <code>MeshType</code> concept refers to any container which defines appropriate methods (such as <a class="el" href="classDoFHandler.html#a9a3bef554c6d22abe312e10e9475eecf">DoFHandler::begin_active()</a>) and <code>typedefs</code> (such as <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a>) for managing collections of cells.</p>
<p>Instances of <a class="el" href="classTriangulation.html">Triangulation</a>, <a class="el" href="classDoFHandler.html">DoFHandler</a>, and <a class="el" href="group__dofs.html#ga768cd565b5c25f1ac235586e36ac94d6">hp::DoFHandler</a> may all be considered as containers of cells. In fact, the most important parts of the public interface of these classes consists simply of the ability to get iterators to their elements. Since these parts of the interface are generic, i.e., the functions have the same name in all classes, it is possible to write operations that do not actually care whether they work on a triangulation or a DoF handler object. Examples abound, for example, in the <a class="el" href="namespaceGridTools.html">GridTools</a> namespace, underlining the power of the abstraction that meshes and DoF handlers can all be considered simply as collections (containers) of cells.</p>
<p>On the other hand, meshes are non-standard containers unlike std::vector or std::list in that they can be sliced several ways. For example, one can iterate over the subset of active cells or over all cells; likewise, cells are organized into levels and one can get iterator ranges for only the cells on one level. Generally, however, all classes that implement the containers-of-cells concept use the same function names to provide the same functionality.</p>
<p>Functions that may be called with either class indicate this by accepting a template parameter like </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">template</span> &lt;<span class="keywordtype">int</span>, <span class="keywordtype">int</span>&gt; <span class="keyword">class </span>MeshType&gt;</div></div><!-- fragment --><p> or </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> MeshType&gt;</div></div><!-- fragment --><p> The classes that satisfy this concept are collectively referred to as <em>mesh classes</em>. The exact definition of <code>MeshType</code> relies a lot on library internals, but it can be summarized as any class with the following properties: </p><ol>
<li>
A <code>typedef</code> named <code>active_cell_iterator</code>.  </li>
<li>
A method <code>get_triangulation()</code> which returns a reference to the underlying geometrical description (one of the <a class="el" href="classTriangulation.html">Triangulation</a> classes) of the collection of cells. If the mesh happens to be a <a class="el" href="classTriangulation.html">Triangulation</a>, then the mesh just returns a reference to itself.  </li>
<li>
A method <code>begin_active()</code> which returns an iterator pointing to the first active cell.  </li>
<li>
A static member value <code>dimension</code> containing the dimension in which the object lives.  </li>
<li>
A static member value <code>space_dimension</code> containing the dimension of the object (e.g., a 2D surface in a 3D setting would have <code>space_dimension = 2</code>).  </li>
</ol>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptNumber"></a><b>Number</b> </dt>
<dd><p class="startdd">This concept describes scalars which make sense as vector or matrix entries, which is usually some finite precision approximation of a field element. The canonical examples are <code>double</code> and <code>float</code>, but deal.II supports <code>std::complex&lt;T&gt;</code> for floating point type <code>T</code> in many places as well. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPolynomialType"></a><b>PolynomialType</b> </dt>
<dd><p class="startdd">See the description in <a class="el" href="group__Polynomials.html">Polynomials and polynomial spaces</a> for more information. In some contexts, anything that satisfies the interface resembling </p><div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keyword">class </span>PolynomialType</div><div class="line">{</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> compute (<span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;dim&gt;</a>            &amp;unit_point,</div><div class="line">                        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;1,dim&gt;</a> &gt; &amp;<a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>,</div><div class="line">                        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;2,dim&gt;</a> &gt; &amp;grads,</div><div class="line">                        std::vector&lt;<a class="code" href="classTensor.html">Tensor&lt;3,dim&gt;</a> &gt; &amp;grad_grads) <span class="keyword">const</span> =0;</div><div class="line">}</div></div><!-- fragment --><p>may be considered as a polynomial for the sake of implementing finite elements. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptPreconditionerType"></a><b>PreconditionerType</b> </dt>
<dd><p class="startdd">This is essentially a synonym for <code>MatrixType</code>, but usually only requires that <code>vmult()</code> and <code>Tvmult()</code> be defined. Most of the time defining <code>Tvmult()</code> is not necessary. One should think of <code>vmult()</code> as applying some approximation of the inverse of a linear operator to a vector, instead of the action of a linear operator to a vector, for the preconditioner classes. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptRelaxationType"></a><b>RelaxationType</b> </dt>
<dd><p class="startdd">This is an object capable of relaxation for multigrid methods. One can think of an object satisfying this constraint as having the following interface as well as the constraints required by <a class="el" href="group__Concepts.html#ConceptMatrixType">MatrixType</a>: </p><div class="fragment"><div class="line"><span class="keyword">class </span>RelaxationType</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> step(<a class="code" href="classVectorType.html">VectorType</a> &amp;u, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;v) <span class="keyword">const</span> =0;</div><div class="line"></div><div class="line">  <span class="keyword">template</span> &lt;<span class="keyword">typename</span> VectorType&gt;</div><div class="line">  <span class="keyword">virtual</span> <span class="keywordtype">void</span> Tstep(<a class="code" href="classVectorType.html">VectorType</a> &amp;u, <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;v) <span class="keyword">const</span> =0;</div><div class="line">};</div></div><!-- fragment --><p> where these two member functions perform one step (or the transpose of such a step) of the smoothing scheme. In other words, the operations performed by these functions are \(u = u - P^{-1} (A u - v)\) and \(u = u - P^{-T} (A u - v)\). </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptSparsityPatternType"></a><b>SparsityPatternType</b> </dt>
<dd><p class="startdd">Almost all functions (with the notable exception of <a class="el" href="namespaceSparsityTools.html#afbc0c7a206ced91b154666215ea3c218">SparsityTools::distribute_sparsity_pattern</a>) which take a sparsity pattern as an argument can take either a regular <a class="el" href="classSparsityPattern.html">SparsityPattern</a> or a <a class="el" href="classDynamicSparsityPattern.html">DynamicSparsityPattern</a>, or even one of the block sparsity patterns. See <a class="el" href="group__Sparsity.html">Sparsity patterns</a> for more information. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptStreamType"></a><b>StreamType</b> </dt>
<dd><p class="startdd">Deriving new stream classes in C++ is well-known to be difficult. To get around this, some functions accept a parameter which defines <code>operator&lt;&lt;</code>, which allows for easy output to any kind of output stream. </p>
<p class="enddd"></p>
</dd>
<dt class="concepts"><a class="anchor" id="ConceptVectorType"></a><b>VectorType</b> </dt>
<dd><p class="startdd">deal.II supports many different vector classes, including bindings to vectors in other libraries. These are similar to standard library vectors (i.e., they define <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#ad88a9499e01173b35d78413e5945e020">begin()</a></code>, <code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">end()</a></code>, <code>operator[]</code>, and <code>size()</code>) but also define numerical operations like <code>add()</code>. Some examples of VectorType include <a class="el" href="classVector.html">Vector</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a>, and <a class="el" href="classBlockVector.html">BlockVector</a>. </p>
<p class="enddd"></p>
</dd>
</dl>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
