<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTrilinosWrappers_1_1MPI_1_1Vector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::MPI::Vector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classTrilinosWrappers_1_1MPI_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::MPI::Vector Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__vector_8h_source.html">deal.II/lac/trilinos_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::MPI::Vector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1MPI_1_1Vector__inherit__graph.svg" width="163" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab55a7083697b5f4d48ed0b712ac6c0d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> = <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td></tr>
<tr class="separator:ab55a7083697b5f4d48ed0b712ac6c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aaae66bd475507a3964b87b385267e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> = <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td></tr>
<tr class="separator:a96aaae66bd475507a3964b87b385267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90eb8c6eab28c4bc432390c87baea00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> = ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ad90eb8c6eab28c4bc432390c87baea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d5260bbf09c1f64d74d19f50fa0ab4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a> = <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td></tr>
<tr class="separator:a96d5260bbf09c1f64d74d19f50fa0ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3279b30b041311561be433d3c74d4c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a> = const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td></tr>
<tr class="separator:ab3279b30b041311561be433d3c74d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fc5a6639c4690d21e0ac1a6281c511"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a> = internal::VectorReference</td></tr>
<tr class="separator:a85fc5a6639c4690d21e0ac1a6281c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649cb858f21cbfd5512395fbf726822f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a649cb858f21cbfd5512395fbf726822f">const_reference</a> = const internal::VectorReference</td></tr>
<tr class="separator:a649cb858f21cbfd5512395fbf726822f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43b630c9142014fa08cf90a4bd89522b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a43b630c9142014fa08cf90a4bd89522b">DeclException0</a> (ExcDifferentParallelPartitioning)</td></tr>
<tr class="separator:a43b630c9142014fa08cf90a4bd89522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da1d5ccd69890ceac0add39c84ba89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a05da1d5ccd69890ceac0add39c84ba89">DeclException1</a> (ExcTrilinosError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;)</td></tr>
<tr class="separator:a05da1d5ccd69890ceac0add39c84ba89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70f2b8c2724bbc5691da251a036320"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a3c70f2b8c2724bbc5691da251a036320">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>,&lt;&lt; &quot;You are trying to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>, but this element is not stored &quot;&lt;&lt; &quot;on the current processor. Note: There are &quot;&lt;&lt; arg2&lt;&lt; &quot; elements stored &quot;&lt;&lt; &quot;on the current processor from within the range [&quot;&lt;&lt; arg3&lt;&lt; &quot;,&quot;&lt;&lt; arg4&lt;&lt; &quot;] but Trilinos vectors need not store contiguous &quot;&lt;&lt; &quot;ranges on each processor, and not every element in &quot;&lt;&lt; &quot;this range may in fact be stored locally.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> into a function &quot;&lt;&lt; &quot;that needs read access to <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells (or at least to &quot;&lt;&lt; &quot;'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot;'locally owned'). You need to pass a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;)</td></tr>
<tr class="separator:a3c70f2b8c2724bbc5691da251a036320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Basic Object-handling</div></td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e4685e7a2a5dd43d67c3541ba67574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a34e4685e7a2a5dd43d67c3541ba67574">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:a34e4685e7a2a5dd43d67c3541ba67574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68136a6b67841a5afc1548373cc6161"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab68136a6b67841a5afc1548373cc6161">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:ab68136a6b67841a5afc1548373cc6161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac149f1474536140b65eb3eeef3d71590"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac149f1474536140b65eb3eeef3d71590">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:ac149f1474536140b65eb3eeef3d71590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978deda236f930277fcc661c0a04c59f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a978deda236f930277fcc661c0a04c59f">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:a978deda236f930277fcc661c0a04c59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee12823e00f598de8f255e915c5e5243"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aee12823e00f598de8f255e915c5e5243"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aee12823e00f598de8f255e915c5e5243">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;v, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:aee12823e00f598de8f255e915c5e5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0f17bf5ad5737ad817550cee718752"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2f0f17bf5ad5737ad817550cee718752">Vector</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a2f0f17bf5ad5737ad817550cee718752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5d5494efdf43a043d41ccbc8be9c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7b5d5494efdf43a043d41ccbc8be9c96">~Vector</a> () override=default</td></tr>
<tr class="separator:a7b5d5494efdf43a043d41ccbc8be9c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bce94882ecb65b2ccc8250b23d1b5ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5bce94882ecb65b2ccc8250b23d1b5ce">clear</a> ()</td></tr>
<tr class="separator:a5bce94882ecb65b2ccc8250b23d1b5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ae9c8d3595133abe1131fcbb97b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false, const <a class="el" href="classbool.html">bool</a> allow_different_maps=false)</td></tr>
<tr class="separator:a655ae9c8d3595133abe1131fcbb97b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74a39fa88174f63767d510416c09e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af74a39fa88174f63767d510416c09e6f">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:af74a39fa88174f63767d510416c09e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21ce9067c23a1e1838c41a6a5f2bfb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad21ce9067c23a1e1838c41a6a5f2bfb4">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_entries, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_entries, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> vector_writable=false)</td></tr>
<tr class="separator:ad21ce9067c23a1e1838c41a6a5f2bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c714a8a7631f0a41e474a1481c3ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a79c714a8a7631f0a41e474a1481c3ebd">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;v, const <a class="el" href="classbool.html">bool</a> import_data=false)</td></tr>
<tr class="separator:a79c714a8a7631f0a41e474a1481c3ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7221ae06689832b475206ef54efaf0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a7221ae06689832b475206ef54efaf0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211406f759dc392950d077edaccc9bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac211406f759dc392950d077edaccc9bb">operator=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s)</td></tr>
<tr class="separator:ac211406f759dc392950d077edaccc9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe7192a480321cb76a2271dd1886123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#adbe7192a480321cb76a2271dd1886123">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:adbe7192a480321cb76a2271dd1886123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f586e2bb89eace98f639fc9d218add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a17f586e2bb89eace98f639fc9d218add">operator=</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a17f586e2bb89eace98f639fc9d218add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fc85797cce1e944be10daef76292ec"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ac2fc85797cce1e944be10daef76292ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac2fc85797cce1e944be10daef76292ec">operator=</a> (const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ac2fc85797cce1e944be10daef76292ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437913068a4ab813d0a955376073ad74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a437913068a4ab813d0a955376073ad74">import_nonlocal_data_for_fe</a> (const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>)</td></tr>
<tr class="separator:a437913068a4ab813d0a955376073ad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37486c4cfabda6714e6dd3184126205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad37486c4cfabda6714e6dd3184126205">import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rwv, const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ad37486c4cfabda6714e6dd3184126205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa363aa1eab397fc873db21871d653564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa363aa1eab397fc873db21871d653564">operator==</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:aa363aa1eab397fc873db21871d653564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788edd01c013ad9e44d75166738f5f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a788edd01c013ad9e44d75166738f5f44">operator!=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:a788edd01c013ad9e44d75166738f5f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fa29403bbd6da7795fd25700267d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size</a> () const</td></tr>
<tr class="separator:a78fa29403bbd6da7795fd25700267d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4936b9f1043fa560dd217d06ea81603d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4936b9f1043fa560dd217d06ea81603d">local_size</a> () const</td></tr>
<tr class="separator:a4936b9f1043fa560dd217d06ea81603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc37c8685838f91d6104373d292d0348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abc37c8685838f91d6104373d292d0348">locally_owned_size</a> () const</td></tr>
<tr class="separator:abc37c8685838f91d6104373d292d0348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc22742227d63950cb0995223e6ee32"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abcc22742227d63950cb0995223e6ee32">local_range</a> () const</td></tr>
<tr class="separator:abcc22742227d63950cb0995223e6ee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b65857b3e328451fc2f4cfa7c103c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a482b65857b3e328451fc2f4cfa7c103c">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index) const</td></tr>
<tr class="separator:a482b65857b3e328451fc2f4cfa7c103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f6096b67b2787a85622e4d0296b927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a50f6096b67b2787a85622e4d0296b927">locally_owned_elements</a> () const</td></tr>
<tr class="separator:a50f6096b67b2787a85622e4d0296b927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f28d2bf6737db19cd076abbb1aee51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a68f28d2bf6737db19cd076abbb1aee51">has_ghost_elements</a> () const</td></tr>
<tr class="separator:a68f28d2bf6737db19cd076abbb1aee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361ec774d40d22bf10497eb1623e4ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a361ec774d40d22bf10497eb1623e4ac3">update_ghost_values</a> () const</td></tr>
<tr class="separator:a361ec774d40d22bf10497eb1623e4ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadf555e8a9d0a32a35fe978a32e804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#adbadf555e8a9d0a32a35fe978a32e804">operator*</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;vec) const</td></tr>
<tr class="separator:adbadf555e8a9d0a32a35fe978a32e804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bfeaeafc63a9b98e4141dd272e2652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a72bfeaeafc63a9b98e4141dd272e2652">norm_sqr</a> () const</td></tr>
<tr class="separator:a72bfeaeafc63a9b98e4141dd272e2652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bcdfb5d20d5372131575898e42685a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a15bcdfb5d20d5372131575898e42685a">mean_value</a> () const</td></tr>
<tr class="separator:a15bcdfb5d20d5372131575898e42685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d82fe3f26d3e9da96a408d316c994d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a93d82fe3f26d3e9da96a408d316c994d">min</a> () const</td></tr>
<tr class="separator:a93d82fe3f26d3e9da96a408d316c994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54afaac60585457ed278c13399fda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#afc54afaac60585457ed278c13399fda5">max</a> () const</td></tr>
<tr class="separator:afc54afaac60585457ed278c13399fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0120da4bfb59f70ff1e2ed58a3a154f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a0120da4bfb59f70ff1e2ed58a3a154f1">l1_norm</a> () const</td></tr>
<tr class="separator:a0120da4bfb59f70ff1e2ed58a3a154f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5680a0f82a28f0b980d83f3443cc20ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5680a0f82a28f0b980d83f3443cc20ca">l2_norm</a> () const</td></tr>
<tr class="separator:a5680a0f82a28f0b980d83f3443cc20ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c88df6b68850adc65db3af5921d994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a50c88df6b68850adc65db3af5921d994">lp_norm</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> p) const</td></tr>
<tr class="separator:a50c88df6b68850adc65db3af5921d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859581ff681293d06cc447e0f5ef9040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a859581ff681293d06cc447e0f5ef9040">linfty_norm</a> () const</td></tr>
<tr class="separator:a859581ff681293d06cc447e0f5ef9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ca7e695d3750caede04b42cb3ca279"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac4ca7e695d3750caede04b42cb3ca279">add_and_dot</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;W)</td></tr>
<tr class="separator:ac4ca7e695d3750caede04b42cb3ca279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Data-Access</div></td></tr>
<tr class="memitem:a42a1cf7a4d6504237eda2ebcd6366ec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a42a1cf7a4d6504237eda2ebcd6366ec0">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index)</td></tr>
<tr class="separator:a42a1cf7a4d6504237eda2ebcd6366ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5811320c572716dfa2766629de688a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5811320c572716dfa2766629de688a37">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index) const</td></tr>
<tr class="separator:a5811320c572716dfa2766629de688a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1475a7fcfd819e77b8879bc79bec9c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab1475a7fcfd819e77b8879bc79bec9c1">operator[]</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index)</td></tr>
<tr class="separator:ab1475a7fcfd819e77b8879bc79bec9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6e23df1fdc75e59c235219436a4c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abd6e23df1fdc75e59c235219436a4c56">operator[]</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index) const</td></tr>
<tr class="separator:abd6e23df1fdc75e59c235219436a4c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395e6c657e16c72642b93bef7d712d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7395e6c657e16c72642b93bef7d712d2">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values) const</td></tr>
<tr class="separator:a7395e6c657e16c72642b93bef7d712d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a063a13f80f1a322183f8b0a204bec"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ae6a063a13f80f1a322183f8b0a204bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ae6a063a13f80f1a322183f8b0a204bec">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:ae6a063a13f80f1a322183f8b0a204bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2353314d473eb8d4caf527a6cc7ebab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af2353314d473eb8d4caf527a6cc7ebab">begin</a> ()</td></tr>
<tr class="separator:af2353314d473eb8d4caf527a6cc7ebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833030283c73c3df899289c39025eb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a833030283c73c3df899289c39025eb47">begin</a> () const</td></tr>
<tr class="separator:a833030283c73c3df899289c39025eb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b837c54b42d4ac79199ce2455116649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a8b837c54b42d4ac79199ce2455116649">end</a> ()</td></tr>
<tr class="separator:a8b837c54b42d4ac79199ce2455116649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf9f6f5996a97ed39f64b4c80438c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#afdf9f6f5996a97ed39f64b4c80438c9a">end</a> () const</td></tr>
<tr class="separator:afdf9f6f5996a97ed39f64b4c80438c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Modification of vectors</div></td></tr>
<tr class="memitem:af5f439d6638ce898866fc2dfabf0ec35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af5f439d6638ce898866fc2dfabf0ec35">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:af5f439d6638ce898866fc2dfabf0ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c87a236c193c4e0029a9eb774078907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a9c87a236c193c4e0029a9eb774078907">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:a9c87a236c193c4e0029a9eb774078907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f49865d04ffd53c6da98c11663a6b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a9f49865d04ffd53c6da98c11663a6b3d">set</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> n_elements, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values)</td></tr>
<tr class="separator:a9f49865d04ffd53c6da98c11663a6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a969a05c9492ade98682528f2b1de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a251a969a05c9492ade98682528f2b1de">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:a251a969a05c9492ade98682528f2b1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add83be5ae97dca366c1c4ab69fa32da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#add83be5ae97dca366c1c4ab69fa32da3">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:add83be5ae97dca366c1c4ab69fa32da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768924d2b6f63dec5d5976b8ab74384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a1768924d2b6f63dec5d5976b8ab74384">add</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> n_elements, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values)</td></tr>
<tr class="separator:a1768924d2b6f63dec5d5976b8ab74384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac080d00d53d41d659972ca60eb4eb687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac080d00d53d41d659972ca60eb4eb687">operator*=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:ac080d00d53d41d659972ca60eb4eb687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38edbce1fed1fdc7afb621ee7bbe3b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa38edbce1fed1fdc7afb621ee7bbe3b2">operator/=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:aa38edbce1fed1fdc7afb621ee7bbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658e1cb71eb4b76fa3211065e8b718bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a658e1cb71eb4b76fa3211065e8b718bb">operator+=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:a658e1cb71eb4b76fa3211065e8b718bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c953516561451f062b142106f21de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ae1c953516561451f062b142106f21de7">operator-=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:ae1c953516561451f062b142106f21de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f695f6d00f487acad11a7760191b7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2f695f6d00f487acad11a7760191b7fe">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s)</td></tr>
<tr class="separator:a2f695f6d00f487acad11a7760191b7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9d676a56a02948342ec7b989338d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a06e9d676a56a02948342ec7b989338d8">add</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V, const <a class="el" href="classbool.html">bool</a> allow_different_maps=false)</td></tr>
<tr class="separator:a06e9d676a56a02948342ec7b989338d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea1dd6795724b992526a6355612dda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aeea1dd6795724b992526a6355612dda1">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:aeea1dd6795724b992526a6355612dda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2210a85849b80f6217aeeaaa5aa5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aee2210a85849b80f6217aeeaaa5aa5c1">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> b, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;W)</td></tr>
<tr class="separator:aee2210a85849b80f6217aeeaaa5aa5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106d1dbdc934bdea77688f47c838d256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a106d1dbdc934bdea77688f47c838d256">sadd</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:a106d1dbdc934bdea77688f47c838d256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c8d36a34528d2772630c2f9e46064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa61c8d36a34528d2772630c2f9e46064">sadd</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:aa61c8d36a34528d2772630c2f9e46064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa172107cb120b8cafae22063517cfbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa172107cb120b8cafae22063517cfbd1">scale</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;scaling_factors)</td></tr>
<tr class="separator:aa172107cb120b8cafae22063517cfbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a3b93459cf0c884354875debd3797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa17a3b93459cf0c884354875debd3797">equ</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:aa17a3b93459cf0c884354875debd3797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">4: Mixed stuff</div></td></tr>
<tr class="memitem:aa1c56ab16d8756970c3819758a2b7534"><td class="memItemLeft" align="right" valign="top">const Epetra_MultiVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa1c56ab16d8756970c3819758a2b7534">trilinos_vector</a> () const</td></tr>
<tr class="separator:aa1c56ab16d8756970c3819758a2b7534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7e20b239d0473c5696fa0b47857d3e"><td class="memItemLeft" align="right" valign="top">Epetra_FEVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2d7e20b239d0473c5696fa0b47857d3e">trilinos_vector</a> ()</td></tr>
<tr class="separator:a2d7e20b239d0473c5696fa0b47857d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa62b203d7dda29e58df23ff2af75c"><td class="memItemLeft" align="right" valign="top">const Epetra_BlockMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a21aa62b203d7dda29e58df23ff2af75c">trilinos_partitioner</a> () const</td></tr>
<tr class="separator:a21aa62b203d7dda29e58df23ff2af75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1da096b2348e75220c08a90aab9df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a8e1da096b2348e75220c08a90aab9df4">swap</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:a8e1da096b2348e75220c08a90aab9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26356cd57970e2743751293562eba7f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a26356cd57970e2743751293562eba7f1">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a26356cd57970e2743751293562eba7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa67d7e4c3d36aaa9453c7cff19469021"><td class="memItemLeft" align="right" valign="top">Epetra_CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa67d7e4c3d36aaa9453c7cff19469021">last_action</a></td></tr>
<tr class="separator:aa67d7e4c3d36aaa9453c7cff19469021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72accdda3a9f644f17990418bac9957d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a72accdda3a9f644f17990418bac9957d">compressed</a></td></tr>
<tr class="separator:a72accdda3a9f644f17990418bac9957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219e009dbd1a7fcadca2ddbbeeabc9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a219e009dbd1a7fcadca2ddbbeeabc9b4">has_ghosts</a></td></tr>
<tr class="separator:a219e009dbd1a7fcadca2ddbbeeabc9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440bb709fa8f29542402392e55aed634"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_FEVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a></td></tr>
<tr class="separator:a440bb709fa8f29542402392e55aed634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad797d2f106217e5e17dc7746052075"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_MultiVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2ad797d2f106217e5e17dc7746052075">nonlocal_vector</a></td></tr>
<tr class="separator:a2ad797d2f106217e5e17dc7746052075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad9cd2c869cbd47284ceac109f637dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7ad9cd2c869cbd47284ceac109f637dc">owned_elements</a></td></tr>
<tr class="separator:a7ad9cd2c869cbd47284ceac109f637dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4d77f4705993156218463a6698808bca"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4d77f4705993156218463a6698808bca">internal::VectorReference</a></td></tr>
<tr class="separator:a4d77f4705993156218463a6698808bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af853f838d421f8a008f6a57f3231bdc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af853f838d421f8a008f6a57f3231bdc3">swap</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;u, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:af853f838d421f8a008f6a57f3231bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This class implements a wrapper to use the Trilinos distributed vector class Epetra_FEVector, the (parallel) partitioning of which is governed by an Epetra_Map. The Epetra_FEVector is precisely the kind of vector we deal with all the time - we probably get it from some assembly process, where also entries not locally owned might need to written and hence need to be forwarded to the owner.</p>
<p>The interface of this class is modeled after the existing <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> class in deal.II. It has almost the same member functions, and is often exchangeable. However, since Trilinos only supports a single scalar type (double), it is not templated, and only works with that type.</p>
<p>Note that Trilinos only guarantees that operations do what you expect if the function <code>GlobalAssemble</code> has been called after vector assembly in order to distribute the data. This is necessary since some processes might have accumulated data of elements that are not owned by themselves, but must be sent to the owning process. In order to avoid using the wrong data, you need to call <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">Vector::compress()</a> before you actually use the vectors.</p>
<h3>Parallel communication model</h3>
<p>The parallel functionality of Trilinos is built on top of the Message Passing Interface (<a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>). <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>'s communication model is built on collective communications: if one process wants something from another, that other process has to be willing to accept this communication. A process cannot query data from another process by calling a remote function, without that other process expecting such a transaction. The consequence is that most of the operations in the base class of this class have to be called collectively. For example, if you want to compute the l2 norm of a parallel vector, <em>all</em> processes across which this vector is shared have to call the <code>l2_norm</code> function. If you don't do this, but instead only call the <code>l2_norm</code> function on one process, then the following happens: This one process will call one of the collective <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> functions and wait for all the other processes to join in on this. Since the other processes don't call this function, you will either get a time-out on the first process, or, worse, by the time the next a call to a Trilinos function generates an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> message on the other processes, you will get a cryptic message that only a subset of processes attempted a communication. These bugs can be very hard to figure out, unless you are well-acquainted with the communication model of <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, and know which functions may generate <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> messages.</p>
<p>One particular case, where an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> message may be generated unexpectedly is discussed below.</p>
<h3>Accessing individual elements of a vector</h3>
<p>Trilinos does of course allow read access to individual elements of a vector, but in the distributed case only to elements that are stored locally. We implement this through calls like <code>d=vec(i)</code>. However, if you access an element outside the locally stored range, an exception is generated.</p>
<p>In contrast to read access, Trilinos (and the respective deal.II wrapper classes) allow to write (or add) to individual elements of vectors, even if they are stored on a different process. You can do this by writing into or adding to elements using the syntax <code>vec(i)=d</code> or <code>vec(i)+=d</code>, or similar operations. There is one catch, however, that may lead to very confusing error messages: Trilinos requires application programs to call the <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> function when they switch from performing a set of operations that add to elements, to performing a set of operations that write to elements. The reasoning is that all processes might accumulate addition operations to elements, even if multiple processes write to the same elements. By the time we call <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> the next time, all these additions are executed. However, if one process adds to an element, and another overwrites to it, the order of execution would yield non-deterministic behavior if we don't make sure that a synchronization with <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> happens in between.</p>
<p>In order to make sure these calls to <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> happen at the appropriate time, the deal.II wrappers keep a state variable that store which is the presently allowed operation: additions or writes. If it encounters an operation of the opposite kind, it calls <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> and flips the state. This can sometimes lead to very confusing behavior, in code that may for example look like this:</p>
<div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>;</div><div class="line"><span class="comment">// do some write operations on the vector</span></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> i=0; i&lt;vector-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size</a>(); ++i)</div><div class="line">  <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>(i) = i;</div><div class="line"></div><div class="line">                  <span class="comment">// do some additions to vector elements, but</span></div><div class="line">                  <span class="comment">// only for some elements</span></div><div class="line">  <span class="keywordflow">for</span> (<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> i=0; i&lt;vector-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size</a>(); ++i)</div><div class="line">    <span class="keywordflow">if</span> (some_condition(i) == <span class="keyword">true</span>)</div><div class="line">      <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>(i) += 1;</div><div class="line"></div><div class="line">                  <span class="comment">// do another collective operation</span></div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a> = vector-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5680a0f82a28f0b980d83f3443cc20ca">l2_norm</a>();</div></div><!-- fragment --><p>This code can run into trouble: by the time we see the first addition operation, we need to flush the overwrite buffers for the vector, and the deal.II library will do so by calling <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a>. However, it will only do so for all processes that actually do an addition &ndash; if the condition is never true for one of the processes, then this one will not get to the actual <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> call, whereas all the other ones do. This gets us into trouble, since all the other processes hang in the call to flush the write buffers, while the one other process advances to the call to compute the l2 norm. At this time, you will get an error that some operation was attempted by only a subset of processes. This behavior may seem surprising, unless you know that write/addition operations on single elements may trigger this behavior.</p>
<p>The problem described here may be avoided by placing additional calls to <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a>, or making sure that all processes do the same type of operations at the same time, for example by placing zero additions if necessary.</p>
<h3>Ghost elements of vectors</h3>
<p>Parallel vectors come in two kinds: without and with ghost elements. Vectors without ghost elements uniquely partition the vector elements between processors: each vector entry has exactly one processor that owns it. For such vectors, you can read those elements that the processor you are currently on owns, and you can write into any element whether you own it or not: if you don't own it, the value written or added to a vector element will be shipped to the processor that owns this vector element the next time you call <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a>, as described above.</p>
<p>What we call a 'ghosted' vector (see <a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> ) is simply a view of the parallel vector where the element distributions overlap. The 'ghosted' Trilinos vector in itself has no idea of which entries are ghosted and which are locally owned. In fact, a ghosted vector may not even store all of the elements a non- ghosted vector would store on the current processor. Consequently, for Trilinos vectors, there is no notion of an 'owner' of vector elements in the way we have it in the non-ghost case view.</p>
<p>This explains why we do not allow writing into ghosted vectors on the Trilinos side: Who would be responsible for taking care of the duplicated entries, given that there is not such information as locally owned indices? In other words, since a processor doesn't know which other processors own an element, who would it send a value to if one were to write to it? The only possibility would be to send this information to <em>all</em> other processors, but that is clearly not practical. Thus, we only allow reading from ghosted vectors, which however we do very often.</p>
<p>So how do you fill a ghosted vector if you can't write to it? This only happens through the assignment with a non-ghosted vector. It can go both ways (non-ghosted is assigned to a ghosted vector, and a ghosted vector is assigned to a non-ghosted one; the latter one typically only requires taking out the locally owned part as most often ghosted vectors store a superset of elements of non-ghosted ones). In general, you send data around with that operation and it all depends on the different views of the two vectors. Trilinos also allows you to get subvectors out of a big vector that way.</p>
<h3>Thread safety of Trilinos vectors</h3>
<p>When writing into Trilinos vectors from several threads in shared memory, several things must be kept in mind as there is no built-in locks in this class to prevent data races. Simultaneous access to the same vector entry at the same time results in data races and must be explicitly avoided by the user. However, it is possible to access <b>different</b> entries of the vector from several threads simultaneously when only one <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process is present or the vector has been constructed with an additional index set for ghost entries in write mode.</p>
<pre class="fragment">    2008, 2009, 2017</pre> 
<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00399">399</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab55a7083697b5f4d48ed0b712ac6c0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7083697b5f4d48ed0b712ac6c0d7">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">TrilinosWrappers::MPI::Vector::value_type</a> =  <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare some of the standard types used in all containers. These types parallel those in the <code>C</code> standard libraries <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector&lt;...&gt;</a></code> class. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00407">407</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a96aaae66bd475507a3964b87b385267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aaae66bd475507a3964b87b385267e">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">TrilinosWrappers::MPI::Vector::real_type</a> =  <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00408">408</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="ad90eb8c6eab28c4bc432390c87baea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90eb8c6eab28c4bc432390c87baea00">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">TrilinosWrappers::MPI::Vector::size_type</a> =  ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00409">409</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a96d5260bbf09c1f64d74d19f50fa0ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d5260bbf09c1f64d74d19f50fa0ab4">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">TrilinosWrappers::MPI::Vector::iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00410">410</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="ab3279b30b041311561be433d3c74d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3279b30b041311561be433d3c74d4c2">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">TrilinosWrappers::MPI::Vector::const_iterator</a> =  const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00411">411</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a85fc5a6639c4690d21e0ac1a6281c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fc5a6639c4690d21e0ac1a6281c511">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">TrilinosWrappers::MPI::Vector::reference</a> =  internal::VectorReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00412">412</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a649cb858f21cbfd5512395fbf726822f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649cb858f21cbfd5512395fbf726822f">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a649cb858f21cbfd5512395fbf726822f">TrilinosWrappers::MPI::Vector::const_reference</a> =  const internal::VectorReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00413">413</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor that generates an empty (zero size) vector. The function <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit()</a></code> will have to give the vector the correct size and distribution among processes in case of an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> run. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00070">70</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a34e4685e7a2a5dd43d67c3541ba67574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e4685e7a2a5dd43d67c3541ba67574">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor using the given vector. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00090">90</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ab68136a6b67841a5afc1548373cc6161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68136a6b67841a5afc1548373cc6161">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor takes an <a class="el" href="classIndexSet.html">IndexSet</a> that defines how to distribute the individual components among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processors. Since it also includes information about the size of the vector, this is all we need to generate a parallel vector.</p>
<p>Depending on whether the <code>parallel_partitioning</code> argument uniquely subdivides elements among processors or not, the resulting vector may or may not have ghost elements. See the general documentation of this class for more information.</p>
<p>In case the provided <a class="el" href="classIndexSet.html">IndexSet</a> forms an overlapping partitioning, it is not clear which elements are owned by which process and <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a50f6096b67b2787a85622e4d0296b927">locally_owned_elements()</a> will return an <a class="el" href="classIndexSet.html">IndexSet</a> of size zero.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00081">81</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ac149f1474536140b65eb3eeef3d71590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac149f1474536140b65eb3eeef3d71590">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a ghosted parallel vector.</p>
<p>Depending on whether the <code>ghost</code> argument uniquely subdivides elements among processors or not, the resulting vector may or may not have ghost elements. See the general documentation of this class for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00128">128</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a978deda236f930277fcc661c0a04c59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978deda236f930277fcc661c0a04c59f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor from the <a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a> vector class. Since a vector of this class does not necessarily need to be distributed among processes, the user needs to supply us with an <a class="el" href="classIndexSet.html">IndexSet</a> and an <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator that set the partitioning details.</p>
<p>Depending on whether the <code>parallel_partitioning</code> argument uniquely subdivides elements among processors or not, the resulting vector may or may not have ghost elements. See the general documentation of this class for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00109">109</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aee12823e00f598de8f255e915c5e5243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee12823e00f598de8f255e915c5e5243">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::Vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy-constructor from deal.II vectors. Sets the dimension to that of the given vector, and copies all the elements.</p>
<p>Depending on whether the <code>parallel_partitioning</code> argument uniquely subdivides elements among processors or not, the resulting vector may or may not have ghost elements. See the general documentation of this class for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="a2f0f17bf5ad5737ad817550cee718752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0f17bf5ad5737ad817550cee718752">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. Creates a new vector by stealing the internal data of the vector <code>v</code>. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00100">100</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a7b5d5494efdf43a043d41ccbc8be9c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5d5494efdf43a043d41ccbc8be9c96">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::~Vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5bce94882ecb65b2ccc8250b23d1b5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bce94882ecb65b2ccc8250b23d1b5ce">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Release all memory and return to a state just like after having called the default constructor. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00139">139</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a655ae9c8d3595133abe1131fcbb97b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655ae9c8d3595133abe1131fcbb97b6d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_different_maps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit functionality. This function sets the calling vector to the dimension and the parallel distribution of the input vector, but does not copy the elements in <code>v</code>. If <code>omit_zeroing_entries</code> is not <code>true</code>, the elements in the vector are initialized with zero. If it is set to <code>true</code>, the vector entries are in an unspecified state and the user has to set all elements. In the current implementation, this method does not touch the vector entries in case the vector layout is unchanged from before, otherwise entries are set to zero. Note that this behavior might change between releases without notification.</p>
<p>This function has a third argument, <code>allow_different_maps</code>, that allows for an exchange of data between two equal-sized vectors (but being distributed differently among the processors). A trivial application of this function is to generate a replication of a whole vector on each machine, when the calling vector is built with a map consisting of all indices on each process, and <code>v</code> is a distributed vector. In this case, the variable <code>omit_zeroing_entries</code> needs to be set to <code>false</code>, since it does not make sense to exchange data between differently parallelized vectors without touching the elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00194">194</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="af74a39fa88174f63767d510416c09e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74a39fa88174f63767d510416c09e6f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit functionality. This function destroys the old vector content and generates a new one based on the input partitioning. The flag <code>omit_zeroing_entries</code> determines whether the vector should be filled with zero (false). If the flag is set to <code>true</code>, the vector entries are in an unspecified state and the user has to set all elements. In the current implementation, this method still sets the entries to zero, but this might change between releases without notification.</p>
<p>Depending on whether the <code>parallel_partitioning</code> argument uniquely subdivides elements among processors or not, the resulting vector may or may not have ghost elements. See the general documentation of this class for more information.</p>
<p>In case <code>parallel_partitioning</code> is overlapping, it is not clear which process should own which elements. Hence, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a50f6096b67b2787a85622e4d0296b927">locally_owned_elements()</a> returns an empty <a class="el" href="classIndexSet.html">IndexSet</a> in this case.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00153">153</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ad21ce9067c23a1e1838c41a6a5f2bfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21ce9067c23a1e1838c41a6a5f2bfb4">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_writable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit functionality. This function destroys the old vector content and generates a new one based on the input partitioning. In addition to just specifying one index set as in all the other methods above, this method allows to supply an additional set of ghost entries. There are two different versions of a vector that can be created. If the flag <code>vector_writable</code> is set to <code>false</code>, the vector only allows read access to the joint set of <code>parallel_partitioning</code> and <code>ghost_entries</code>. The effect of the reinit method is then equivalent to calling the other reinit method with an index set containing both the locally owned entries and the ghost entries.</p>
<p>If the flag <code>vector_writable</code> is set to true, this creates an alternative storage scheme for ghost elements that allows multiple threads to write into the vector (for the other reinit methods, only one thread is allowed to write into the ghost entries at a time).</p>
<p>Depending on whether the <code>ghost_entries</code> argument uniquely subdivides elements among processors or not, the resulting vector may or may not have ghost elements. See the general documentation of this class for more information.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00352">352</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a79c714a8a7631f0a41e474a1481c3ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c714a8a7631f0a41e474a1481c3ebd">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>import_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create vector by merging components from a block vector. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00275">275</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a7221ae06689832b475206ef54efaf0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7221ae06689832b475206ef54efaf0a6">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compress the underlying representation of the Trilinos object, i.e. flush the buffers of the vector object if it has any. This function is necessary after writing into a vector element-by-element and before anything else can be done on it.</p>
<p>The (defaulted) argument can be used to specify the compress mode (<code>Add</code> or <code>Insert</code>) in case the vector has not been written to since the last time this function was called. The argument is ignored if the vector has been added or written to since the last time <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress()</a> was called.</p>
<p>See <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed objects</a> for more information. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00570">570</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ac211406f759dc392950d077edaccc9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211406f759dc392950d077edaccc9bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set all components of the vector to the given number <code>s</code>. Simply pass this down to the base class, but we still need to declare this function to make the example given in the discussion about making the constructor explicit work. the constructor explicit work.</p>
<p>Since the semantics of assigning a scalar to a vector are not immediately clear, this operator can only be used if you want to set the entire vector to zero. This allows the intuitive notation <code>v=0</code>. </p>

</div>
</div>
<a id="adbe7192a480321cb76a2271dd1886123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe7192a480321cb76a2271dd1886123">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the given vector. Resize the present vector if necessary. In this case, also the Epetra_Map that designs the parallel partitioning is taken from the input vector. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00410">410</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a17f586e2bb89eace98f639fc9d218add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f586e2bb89eace98f639fc9d218add">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move the given vector. This operator replaces the present vector with <code>v</code> by efficiently swapping the internal data structures. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00486">486</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ac2fc85797cce1e944be10daef76292ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fc85797cce1e944be10daef76292ec">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Another copy function. This one takes a deal.II vector and copies it into a TrilinosWrapper vector. Note that since we do not provide any Epetra_map that tells about the partitioning of the vector among the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> processes, the size of the TrilinosWrapper vector has to be the same as the size of the input vector. </p>

</div>
</div>
<a id="a437913068a4ab813d0a955376073ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437913068a4ab813d0a955376073ad74">&#9670;&nbsp;</a></span>import_nonlocal_data_for_fe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::import_nonlocal_data_for_fe </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This reinit function is meant to be used for parallel calculations where some non-local data has to be used. The typical situation where one needs this function is the call of the <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues&lt;dim&gt;::get_function_values</a> function (or of some derivatives) in parallel. Since it is usually faster to retrieve the data in advance, this function can be called before the assembly forks out to the different processors. What this function does is the following: It takes the information in the columns of the given matrix and looks which data couples between the different processors. That data is then queried from the input vector. Note that you should not write to the resulting vector any more, since the some data can be stored several times on different processors, leading to unpredictable results. In particular, such a vector cannot be used for matrix- vector products as for example done during the solution of linear systems. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00515">515</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ad37486c4cfabda6714e6dd3184126205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37486c4cfabda6714e6dd3184126205">&#9670;&nbsp;</a></span>import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rwv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Imports all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>rwv</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>rwv</code> should be added to the current vector or replace the current elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00539">539</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aa363aa1eab397fc873db21871d653564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa363aa1eab397fc873db21871d653564">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00702">702</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a788edd01c013ad9e44d75166738f5f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788edd01c013ad9e44d75166738f5f44">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality. This function assumes that the present vector and the one to compare with have the same size already, since comparing vectors of different sizes makes not much sense anyway. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00719">719</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a78fa29403bbd6da7795fd25700267d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fa29403bbd6da7795fd25700267d47">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> TrilinosWrappers::MPI::Vector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the global dimension of the vector. </p>

</div>
</div>
<a id="a4936b9f1043fa560dd217d06ea81603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4936b9f1043fa560dd217d06ea81603d">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> TrilinosWrappers::MPI::Vector::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local dimension of the vector, i.e. the number of elements stored on the present <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> process. For sequential vectors, this number is the same as <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size()</a>, but for parallel vectors it may be smaller.</p>
<p>To figure out which elements exactly are stored locally, use <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abcc22742227d63950cb0995223e6ee32">local_range()</a>.</p>
<p>If the vector contains ghost elements, they are included in this number.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000058">Deprecated:</a></b></dt><dd>This function is deprecated. </dd></dl>

</div>
</div>
<a id="abc37c8685838f91d6104373d292d0348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc37c8685838f91d6104373d292d0348">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> TrilinosWrappers::MPI::Vector::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local size of the vector, i.e., the number of indices owned locally. </p>

</div>
</div>
<a id="abcc22742227d63950cb0995223e6ee32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc22742227d63950cb0995223e6ee32">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&gt; TrilinosWrappers::MPI::Vector::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pair of indices indicating which elements of this vector are stored locally. The first number is the index of the first element stored, the second the index of the one past the last one that is stored locally. If this is a sequential vector, then the result will be the pair <code>(0,N)</code>, otherwise it will be a pair <code>(i,i+n)</code>, where <code>n=<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4936b9f1043fa560dd217d06ea81603d">local_size()</a></code> and <code>i</code> is the first element of the vector stored on this processor, corresponding to the half open interval \([i,i+n)\)</p>
<dl class="section note"><dt>Note</dt><dd>The description above is true most of the time, but not always. In particular, Trilinos vectors need not store contiguous ranges of elements such as \([i,i+n)\). Rather, it can store vectors where the elements are distributed in an arbitrary way across all processors and each processor simply stores a particular subset, not necessarily contiguous. In this case, this function clearly makes no sense since it could, at best, return a range that includes all elements that are stored locally. Thus, the function only succeeds if the locally stored range is indeed contiguous. It will trigger an assertion if the local portion of the vector is not contiguous. </dd></dl>

</div>
</div>
<a id="a482b65857b3e328451fc2f4cfa7c103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482b65857b3e328451fc2f4cfa7c103c">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether <code>index</code> is in the local range or not, see also <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abcc22742227d63950cb0995223e6ee32">local_range()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>The same limitation for the applicability of this function applies as listed in the documentation of <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abcc22742227d63950cb0995223e6ee32">local_range()</a>. </dd></dl>

</div>
</div>
<a id="a50f6096b67b2787a85622e4d0296b927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f6096b67b2787a85622e4d0296b927">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::MPI::Vector::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. Note that this index set does not include elements this vector may store locally as ghost elements but that are in fact owned by another processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (vec.size())</div></div><!-- fragment --> 
</div>
</div>
<a id="a68f28d2bf6737db19cd076abbb1aee51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f28d2bf6737db19cd076abbb1aee51">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return if the vector contains ghost elements. This answer is true if there are ghost elements on at least one process.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="a361ec774d40d22bf10497eb1623e4ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361ec774d40d22bf10497eb1623e4ac3">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function only exists for compatibility with the <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a></code> class and does nothing: this class implements ghost value updates in a different way that is a better fit with the underlying Trilinos vector object. </p>

</div>
</div>
<a id="adbadf555e8a9d0a32a35fe978a32e804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadf555e8a9d0a32a35fe978a32e804">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the scalar (inner) product of two vectors. The vectors must have the same size. </p>

</div>
</div>
<a id="a72bfeaeafc63a9b98e4141dd272e2652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bfeaeafc63a9b98e4141dd272e2652">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\)-norm. </p>

</div>
</div>
<a id="a15bcdfb5d20d5372131575898e42685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bcdfb5d20d5372131575898e42685a">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mean value of the elements of this vector. </p>

</div>
</div>
<a id="a93d82fe3f26d3e9da96a408d316c994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d82fe3f26d3e9da96a408d316c994d">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the minimal value of the elements of this vector. </p>

</div>
</div>
<a id="afc54afaac60585457ed278c13399fda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54afaac60585457ed278c13399fda5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the maximal value of the elements of this vector. </p>

</div>
</div>
<a id="a0120da4bfb59f70ff1e2ed58a3a154f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0120da4bfb59f70ff1e2ed58a3a154f1">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_1\)-norm of the vector. The sum of the absolute values. </p>

</div>
</div>
<a id="a5680a0f82a28f0b980d83f3443cc20ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5680a0f82a28f0b980d83f3443cc20ca">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\)-norm of the vector. The square root of the sum of the squares of the elements. </p>

</div>
</div>
<a id="a50c88df6b68850adc65db3af5921d994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c88df6b68850adc65db3af5921d994">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The <em>p</em>th root of the sum of the <em>p</em>th powers of the absolute values of the elements. </p>

</div>
</div>
<a id="a859581ff681293d06cc447e0f5ef9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859581ff681293d06cc447e0f5ef9040">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maximum absolute value of the elements. </p>

</div>
</div>
<a id="ac4ca7e695d3750caede04b42cb3ca279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ca7e695d3750caede04b42cb3ca279">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a251a969a05c9492ade98682528f2b1de">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value = *<span class="keyword">this</span> * W;</div></div><!-- fragment --><p>The reason this function exists is for compatibility with deal.II's own vector classes which can implement this functionality with less memory transfer. However, for Trilinos vectors such a combined operation is not natively supported and thus the cost is completely equivalent as calling the two methods separately.</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

</div>
</div>
<a id="ae72a04de37cc5ba8f0263809a59ec99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a04de37cc5ba8f0263809a59ec99e">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This is a collective operation. This function is expensive, because potentially all elements have to be checked. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00729">729</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ad8e23a22888630c9874cbddf8bcccdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e23a22888630c9874cbddf8bcccdf5">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vector has no negative entries, i.e. all entries are zero or positive. This function is used, for example, to check whether refinement indicators are really all positive (or zero). </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00758">758</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a42a1cf7a4d6504237eda2ebcd6366ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a1cf7a4d6504237eda2ebcd6366ec0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a> TrilinosWrappers::MPI::Vector::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide access to a given element, both read and write.</p>
<p>When using a vector distributed with <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, this operation only makes sense for elements that are actually present on the calling processor. Otherwise, an exception is thrown. </p>

</div>
</div>
<a id="a5811320c572716dfa2766629de688a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5811320c572716dfa2766629de688a37">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide read-only access to an element.</p>
<p>When using a vector distributed with <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a>, this operation only makes sense for elements that are actually present on the calling processor. Otherwise, an exception is thrown. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00641">641</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ab1475a7fcfd819e77b8879bc79bec9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1475a7fcfd819e77b8879bc79bec9c1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a> TrilinosWrappers::MPI::Vector::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide access to a given element, both read and write.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="abd6e23df1fdc75e59c235219436a4c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6e23df1fdc75e59c235219436a4c56">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Provide read-only access to an element.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="a7395e6c657e16c72642b93bef7d712d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7395e6c657e16c72642b93bef7d712d2">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="ae6a063a13f80f1a322183f8b0a204bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a063a13f80f1a322183f8b0a204bec">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line">  *values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="af2353314d473eb8d4caf527a6cc7ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2353314d473eb8d4caf527a6cc7ebab">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a> TrilinosWrappers::MPI::Vector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the locally owned elements of this vector. The ordering of local elements corresponds to the one given by the global indices in case the vector is constructed from an <a class="el" href="classIndexSet.html">IndexSet</a> or other methods in deal.II (note that an Epetra_Map can contain elements in arbitrary orders, though).</p>
<p>It holds that <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a8b837c54b42d4ac79199ce2455116649">end()</a> - <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af2353314d473eb8d4caf527a6cc7ebab">begin()</a> == <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4936b9f1043fa560dd217d06ea81603d">local_size()</a>. </p>

</div>
</div>
<a id="a833030283c73c3df899289c39025eb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833030283c73c3df899289c39025eb47">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a> TrilinosWrappers::MPI::Vector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the locally owned elements of the vector. </p>

</div>
</div>
<a id="a8b837c54b42d4ac79199ce2455116649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b837c54b42d4ac79199ce2455116649">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a> TrilinosWrappers::MPI::Vector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array of locally owned entries. </p>

</div>
</div>
<a id="afdf9f6f5996a97ed39f64b4c80438c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf9f6f5996a97ed39f64b4c80438c9a">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a> TrilinosWrappers::MPI::Vector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array of the locally owned entries. </p>

</div>
</div>
<a id="af5f439d6638ce898866fc2dfabf0ec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f439d6638ce898866fc2dfabf0ec35">&#9670;&nbsp;</a></span>set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective set operation: instead of setting individual elements of a vector, this function allows to set a whole set of elements at once. The indices of the elements to be set are stated in the first argument, the corresponding values in the second. </p>

</div>
</div>
<a id="a9c87a236c193c4e0029a9eb774078907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c87a236c193c4e0029a9eb774078907">&#9670;&nbsp;</a></span>set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective set operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="a9f49865d04ffd53c6da98c11663a6b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f49865d04ffd53c6da98c11663a6b3d">&#9670;&nbsp;</a></span>set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This collective set operation is of lower level and can handle anything else &mdash; the only thing you have to provide is an address where all the indices are stored and the number of elements to be set. </p>

</div>
</div>
<a id="a251a969a05c9492ade98682528f2b1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a969a05c9492ade98682528f2b1de">&#9670;&nbsp;</a></span>add() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="add83be5ae97dca366c1c4ab69fa32da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add83be5ae97dca366c1c4ab69fa32da3">&#9670;&nbsp;</a></span>add() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="a1768924d2b6f63dec5d5976b8ab74384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1768924d2b6f63dec5d5976b8ab74384">&#9670;&nbsp;</a></span>add() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a251a969a05c9492ade98682528f2b1de">add()</a></code> functions above. </p>

</div>
</div>
<a id="ac080d00d53d41d659972ca60eb4eb687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac080d00d53d41d659972ca60eb4eb687">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

</div>
</div>
<a id="aa38edbce1fed1fdc7afb621ee7bbe3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38edbce1fed1fdc7afb621ee7bbe3b2">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

</div>
</div>
<a id="a658e1cb71eb4b76fa3211065e8b718bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658e1cb71eb4b76fa3211065e8b718bb">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add the given vector to the present one. </p>

</div>
</div>
<a id="ae1c953516561451f062b142106f21de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c953516561451f062b142106f21de7">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract the given vector from the present one. </p>

</div>
</div>
<a id="a2f695f6d00f487acad11a7760191b7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f695f6d00f487acad11a7760191b7fe">&#9670;&nbsp;</a></span>add() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector. </p>

</div>
</div>
<a id="a06e9d676a56a02948342ec7b989338d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e9d676a56a02948342ec7b989338d8">&#9670;&nbsp;</a></span>add() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_different_maps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple vector addition, equal to the <code>operator+=</code>.</p>
<p>Though, if the second argument <code>allow_different_maps</code> is set, then it is possible to add data from a vector that uses a different map, i.e., a vector whose elements are split across processors differently. This may include vectors with ghost elements, for example. In general, however, adding vectors with a different element-to- processor map requires communicating data among processors and, consequently, is a slower operation than when using vectors using the same map. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00667">667</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aeea1dd6795724b992526a6355612dda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea1dd6795724b992526a6355612dda1">&#9670;&nbsp;</a></span>add() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

</div>
</div>
<a id="aee2210a85849b80f6217aeeaaa5aa5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2210a85849b80f6217aeeaaa5aa5c1">&#9670;&nbsp;</a></span>add() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V + b*W</code>. </p>

</div>
</div>
<a id="a106d1dbdc934bdea77688f47c838d256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106d1dbdc934bdea77688f47c838d256">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this) + V</code>. </p>

</div>
</div>
<a id="aa61c8d36a34528d2772630c2f9e46064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c8d36a34528d2772630c2f9e46064">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple addition, i.e. <code>*this = s*(*this) + a*V</code>. </p>

</div>
</div>
<a id="aa172107cb120b8cafae22063517cfbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa172107cb120b8cafae22063517cfbd1">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

</div>
</div>
<a id="aa17a3b93459cf0c884354875debd3797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a3b93459cf0c884354875debd3797">&#9670;&nbsp;</a></span>equ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::equ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

</div>
</div>
<a id="aa1c56ab16d8756970c3819758a2b7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c56ab16d8756970c3819758a2b7534">&#9670;&nbsp;</a></span>trilinos_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_MultiVector&amp; TrilinosWrappers::MPI::Vector::trilinos_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_MultiVector class. </p>

</div>
</div>
<a id="a2d7e20b239d0473c5696fa0b47857d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7e20b239d0473c5696fa0b47857d3e">&#9670;&nbsp;</a></span>trilinos_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_FEVector&amp; TrilinosWrappers::MPI::Vector::trilinos_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a (modifiable) reference to the underlying Trilinos Epetra_FEVector class. </p>

</div>
</div>
<a id="a21aa62b203d7dda29e58df23ff2af75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa62b203d7dda29e58df23ff2af75c">&#9670;&nbsp;</a></span>trilinos_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_BlockMap&amp; TrilinosWrappers::MPI::Vector::trilinos_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const reference to the underlying Trilinos Epetra_BlockMap that sets the parallel partitioning of the vector. </p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print to a stream. <code>precision</code> denotes the desired precision with which values shall be printed, <code>scientific</code> whether scientific notation shall be used. If <code>across</code> is <code>true</code> then the vector is printed in a line, while if <code>false</code> then the elements are printed on a separate line each. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00795">795</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a8e1da096b2348e75220c08a90aab9df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1da096b2348e75220c08a90aab9df4">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around. Note that the vectors need to be of the same size and base on the same map.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00843">843</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aea73d2cb54e87b69a9b7cdb17ed274df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea73d2cb54e87b69a9b7cdb17ed274df">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate for the memory consumption in bytes. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00856">856</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a26356cd57970e2743751293562eba7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26356cd57970e2743751293562eba7f1">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; TrilinosWrappers::MPI::Vector::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the <a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a> communicator object in use with this object. </p>

</div>
</div>
<a id="a43b630c9142014fa08cf90a4bd89522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b630c9142014fa08cf90a4bd89522b">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcDifferentParallelPartitioning&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a05da1d5ccd69890ceac0add39c84ba89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da1d5ccd69890ceac0add39c84ba89">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcTrilinosError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a3c70f2b8c2724bbc5691da251a036320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70f2b8c2724bbc5691da251a036320">&#9670;&nbsp;</a></span>DeclException4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcAccessToNonLocalElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You are trying to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this element is not stored &quot;&lt;&lt; &quot;on the current processor. Note:There are &quot;&lt;&lt; arg2&lt;&lt; &quot; elements stored &quot;&lt;&lt; &quot;on the current processor from within the range but Trilinos vectors need not store contiguous &quot;&lt;&lt; &quot;ranges on each&#160;</td>
          <td class="paramname"><em>processor</em>[&quot;&lt;&lt; arg3&lt;&lt; &quot;,&quot;&lt;&lt; arg4&lt;&lt; &quot;], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and not every element in &quot;&lt;&lt; &quot;this range may in fact be stored locally.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> into a function &quot;&lt;&lt; &quot;that needs read access to <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells(or at least to &quot;&lt;&lt; &quot; 'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot; 'locally owned'). You need to pass a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4d77f4705993156218463a6698808bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d77f4705993156218463a6698808bca">&#9670;&nbsp;</a></span>internal::VectorReference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::VectorReference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01346">1346</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="af853f838d421f8a008f6a57f3231bdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af853f838d421f8a008f6a57f3231bdc3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Global function <code>swap</code> which overloads the default implementation of the C++ standard library which uses a temporary object. The function simply exchanges the data of the two vectors. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01362">1362</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa67d7e4c3d36aaa9453c7cff19469021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67d7e4c3d36aaa9453c7cff19469021">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CombineMode TrilinosWrappers::MPI::Vector::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos doesn't allow to mix additions to matrix entries and overwriting them (to make synchronization of parallel computations simpler). The way we do it is to, for each access operation, store whether it is an insertion or an addition. If the previous one was of different type, then we first have to flush the Trilinos buffers; otherwise, we can simply go on. Luckily, Trilinos has an object for this which does already all the parallel communications in such a case, so we simply use their model, which stores whether the last operation was an addition or an insertion. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01312">1312</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a72accdda3a9f644f17990418bac9957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72accdda3a9f644f17990418bac9957d">&#9670;&nbsp;</a></span>compressed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A boolean variable to hold information on whether the vector is compressed or not. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01318">1318</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a219e009dbd1a7fcadca2ddbbeeabc9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219e009dbd1a7fcadca2ddbbeeabc9b4">&#9670;&nbsp;</a></span>has_ghosts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::has_ghosts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Whether this vector has ghost elements. This is true on all processors even if only one of them has any ghost elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01324">1324</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a440bb709fa8f29542402392e55aed634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440bb709fa8f29542402392e55aed634">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_FEVector&gt; TrilinosWrappers::MPI::Vector::vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the actual Epetra vector object. This may represent a vector that is in fact distributed among multiple processors. The object requires an existing Epetra_Map for storing data when setting it up. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01331">1331</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a2ad797d2f106217e5e17dc7746052075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad797d2f106217e5e17dc7746052075">&#9670;&nbsp;</a></span>nonlocal_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_MultiVector&gt; TrilinosWrappers::MPI::Vector::nonlocal_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector object in Trilinos to be used for collecting the non-local elements if the vector was constructed with an additional <a class="el" href="classIndexSet.html">IndexSet</a> describing ghost elements. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01338">1338</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a7ad9cd2c869cbd47284ceac109f637dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad9cd2c869cbd47284ceac109f637dc">&#9670;&nbsp;</a></span>owned_elements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::MPI::Vector::owned_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>An <a class="el" href="classIndexSet.html">IndexSet</a> storing the indices this vector owns exclusively. </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01343">1343</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a></li>
<li>source/lac/<a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
