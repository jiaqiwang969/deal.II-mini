<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTrilinosWrappers_1_1MPI_1_1Vector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TrilinosWrappers::MPI::Vector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceTrilinosWrappers.html">TrilinosWrappers</a></li><li class="navelem"><a class="el" href="namespaceTrilinosWrappers_1_1MPI.html">MPI</a></li><li class="navelem"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classTrilinosWrappers_1_1MPI_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TrilinosWrappers::MPI::Vector Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__TrilinosWrappers.html">TrilinosWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="trilinos__vector_8h_source.html">deal.II/lac/trilinos_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for TrilinosWrappers::MPI::Vector:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTrilinosWrappers_1_1MPI_1_1Vector__inherit__graph.svg" width="171" height="127"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ab55a7083697b5f4d48ed0b712ac6c0d7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> = <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td></tr>
<tr class="separator:ab55a7083697b5f4d48ed0b712ac6c0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96aaae66bd475507a3964b87b385267e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> = <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td></tr>
<tr class="separator:a96aaae66bd475507a3964b87b385267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad90eb8c6eab28c4bc432390c87baea00"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> = ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:ad90eb8c6eab28c4bc432390c87baea00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d5260bbf09c1f64d74d19f50fa0ab4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a> = <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td></tr>
<tr class="separator:a96d5260bbf09c1f64d74d19f50fa0ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3279b30b041311561be433d3c74d4c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a> = const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td></tr>
<tr class="separator:ab3279b30b041311561be433d3c74d4c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85fc5a6639c4690d21e0ac1a6281c511"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a> = internal::VectorReference</td></tr>
<tr class="separator:a85fc5a6639c4690d21e0ac1a6281c511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649cb858f21cbfd5512395fbf726822f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a649cb858f21cbfd5512395fbf726822f">const_reference</a> = const internal::VectorReference</td></tr>
<tr class="separator:a649cb858f21cbfd5512395fbf726822f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a43b630c9142014fa08cf90a4bd89522b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a43b630c9142014fa08cf90a4bd89522b">DeclException0</a> (ExcDifferentParallelPartitioning)</td></tr>
<tr class="separator:a43b630c9142014fa08cf90a4bd89522b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05da1d5ccd69890ceac0add39c84ba89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a05da1d5ccd69890ceac0add39c84ba89">DeclException1</a> (ExcTrilinosError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;)</td></tr>
<tr class="separator:a05da1d5ccd69890ceac0add39c84ba89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c70f2b8c2724bbc5691da251a036320"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a3c70f2b8c2724bbc5691da251a036320">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>,&lt;&lt; &quot;You are trying to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>, but this element is not stored &quot;&lt;&lt; &quot;on the current processor. Note: There are &quot;&lt;&lt; arg2&lt;&lt; &quot; elements stored &quot;&lt;&lt; &quot;on the current processor from within the range [&quot;&lt;&lt; arg3&lt;&lt; &quot;,&quot;&lt;&lt; arg4&lt;&lt; &quot;] but Trilinos vectors need not store contiguous &quot;&lt;&lt; &quot;ranges on each processor, and not every element in &quot;&lt;&lt; &quot;this range may in fact be stored locally.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> into a function &quot;&lt;&lt; &quot;that needs read access to <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells (or at least to &quot;&lt;&lt; &quot;'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot;'locally owned'). You need to pass a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;)</td></tr>
<tr class="separator:a3c70f2b8c2724bbc5691da251a036320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: 基本对象处理</div></td></tr>
<tr class="memitem:a5424155269bd22011e9ff796e0c77e69"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5424155269bd22011e9ff796e0c77e69">Vector</a> ()</td></tr>
<tr class="separator:a5424155269bd22011e9ff796e0c77e69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34e4685e7a2a5dd43d67c3541ba67574"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a34e4685e7a2a5dd43d67c3541ba67574">Vector</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:a34e4685e7a2a5dd43d67c3541ba67574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab68136a6b67841a5afc1548373cc6161"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab68136a6b67841a5afc1548373cc6161">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:ab68136a6b67841a5afc1548373cc6161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac149f1474536140b65eb3eeef3d71590"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac149f1474536140b65eb3eeef3d71590">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:ac149f1474536140b65eb3eeef3d71590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978deda236f930277fcc661c0a04c59f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a978deda236f930277fcc661c0a04c59f">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:a978deda236f930277fcc661c0a04c59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee12823e00f598de8f255e915c5e5243"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:aee12823e00f598de8f255e915c5e5243"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aee12823e00f598de8f255e915c5e5243">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;v, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD)</td></tr>
<tr class="separator:aee12823e00f598de8f255e915c5e5243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0f17bf5ad5737ad817550cee718752"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2f0f17bf5ad5737ad817550cee718752">Vector</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a2f0f17bf5ad5737ad817550cee718752"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b5d5494efdf43a043d41ccbc8be9c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7b5d5494efdf43a043d41ccbc8be9c96">~Vector</a> () override=default</td></tr>
<tr class="separator:a7b5d5494efdf43a043d41ccbc8be9c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bce94882ecb65b2ccc8250b23d1b5ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5bce94882ecb65b2ccc8250b23d1b5ce">clear</a> ()</td></tr>
<tr class="separator:a5bce94882ecb65b2ccc8250b23d1b5ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a655ae9c8d3595133abe1131fcbb97b6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false, const <a class="el" href="classbool.html">bool</a> allow_different_maps=false)</td></tr>
<tr class="separator:a655ae9c8d3595133abe1131fcbb97b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af74a39fa88174f63767d510416c09e6f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af74a39fa88174f63767d510416c09e6f">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;parallel_partitioning, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:af74a39fa88174f63767d510416c09e6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad21ce9067c23a1e1838c41a6a5f2bfb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad21ce9067c23a1e1838c41a6a5f2bfb4">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;locally_owned_entries, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_entries, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator=MPI_COMM_WORLD, const <a class="el" href="classbool.html">bool</a> vector_writable=false)</td></tr>
<tr class="separator:ad21ce9067c23a1e1838c41a6a5f2bfb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c714a8a7631f0a41e474a1481c3ebd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a79c714a8a7631f0a41e474a1481c3ebd">reinit</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;v, const <a class="el" href="classbool.html">bool</a> import_data=false)</td></tr>
<tr class="separator:a79c714a8a7631f0a41e474a1481c3ebd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7221ae06689832b475206ef54efaf0a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:a7221ae06689832b475206ef54efaf0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac211406f759dc392950d077edaccc9bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac211406f759dc392950d077edaccc9bb">operator=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s)</td></tr>
<tr class="separator:ac211406f759dc392950d077edaccc9bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe7192a480321cb76a2271dd1886123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#adbe7192a480321cb76a2271dd1886123">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:adbe7192a480321cb76a2271dd1886123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17f586e2bb89eace98f639fc9d218add"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a17f586e2bb89eace98f639fc9d218add">operator=</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;v) noexcept</td></tr>
<tr class="separator:a17f586e2bb89eace98f639fc9d218add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fc85797cce1e944be10daef76292ec"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ac2fc85797cce1e944be10daef76292ec"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac2fc85797cce1e944be10daef76292ec">operator=</a> (const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:ac2fc85797cce1e944be10daef76292ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437913068a4ab813d0a955376073ad74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a437913068a4ab813d0a955376073ad74">import_nonlocal_data_for_fe</a> (const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>)</td></tr>
<tr class="separator:a437913068a4ab813d0a955376073ad74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37486c4cfabda6714e6dd3184126205"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad37486c4cfabda6714e6dd3184126205">import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rwv, const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ad37486c4cfabda6714e6dd3184126205"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa363aa1eab397fc873db21871d653564"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa363aa1eab397fc873db21871d653564">operator==</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:aa363aa1eab397fc873db21871d653564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a788edd01c013ad9e44d75166738f5f44"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a788edd01c013ad9e44d75166738f5f44">operator!=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v) const</td></tr>
<tr class="separator:a788edd01c013ad9e44d75166738f5f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fa29403bbd6da7795fd25700267d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size</a> () const</td></tr>
<tr class="separator:a78fa29403bbd6da7795fd25700267d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4936b9f1043fa560dd217d06ea81603d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4936b9f1043fa560dd217d06ea81603d">local_size</a> () const</td></tr>
<tr class="separator:a4936b9f1043fa560dd217d06ea81603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc37c8685838f91d6104373d292d0348"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abc37c8685838f91d6104373d292d0348">locally_owned_size</a> () const</td></tr>
<tr class="separator:abc37c8685838f91d6104373d292d0348"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc22742227d63950cb0995223e6ee32"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abcc22742227d63950cb0995223e6ee32">local_range</a> () const</td></tr>
<tr class="separator:abcc22742227d63950cb0995223e6ee32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482b65857b3e328451fc2f4cfa7c103c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a482b65857b3e328451fc2f4cfa7c103c">in_local_range</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index) const</td></tr>
<tr class="separator:a482b65857b3e328451fc2f4cfa7c103c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50f6096b67b2787a85622e4d0296b927"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a50f6096b67b2787a85622e4d0296b927">locally_owned_elements</a> () const</td></tr>
<tr class="separator:a50f6096b67b2787a85622e4d0296b927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f28d2bf6737db19cd076abbb1aee51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a68f28d2bf6737db19cd076abbb1aee51">has_ghost_elements</a> () const</td></tr>
<tr class="separator:a68f28d2bf6737db19cd076abbb1aee51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361ec774d40d22bf10497eb1623e4ac3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a361ec774d40d22bf10497eb1623e4ac3">update_ghost_values</a> () const</td></tr>
<tr class="separator:a361ec774d40d22bf10497eb1623e4ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbadf555e8a9d0a32a35fe978a32e804"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#adbadf555e8a9d0a32a35fe978a32e804">operator*</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;vec) const</td></tr>
<tr class="separator:adbadf555e8a9d0a32a35fe978a32e804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72bfeaeafc63a9b98e4141dd272e2652"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a72bfeaeafc63a9b98e4141dd272e2652">norm_sqr</a> () const</td></tr>
<tr class="separator:a72bfeaeafc63a9b98e4141dd272e2652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bcdfb5d20d5372131575898e42685a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a15bcdfb5d20d5372131575898e42685a">mean_value</a> () const</td></tr>
<tr class="separator:a15bcdfb5d20d5372131575898e42685a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d82fe3f26d3e9da96a408d316c994d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a93d82fe3f26d3e9da96a408d316c994d">min</a> () const</td></tr>
<tr class="separator:a93d82fe3f26d3e9da96a408d316c994d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc54afaac60585457ed278c13399fda5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#afc54afaac60585457ed278c13399fda5">max</a> () const</td></tr>
<tr class="separator:afc54afaac60585457ed278c13399fda5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0120da4bfb59f70ff1e2ed58a3a154f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a0120da4bfb59f70ff1e2ed58a3a154f1">l1_norm</a> () const</td></tr>
<tr class="separator:a0120da4bfb59f70ff1e2ed58a3a154f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5680a0f82a28f0b980d83f3443cc20ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5680a0f82a28f0b980d83f3443cc20ca">l2_norm</a> () const</td></tr>
<tr class="separator:a5680a0f82a28f0b980d83f3443cc20ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50c88df6b68850adc65db3af5921d994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a50c88df6b68850adc65db3af5921d994">lp_norm</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> p) const</td></tr>
<tr class="separator:a50c88df6b68850adc65db3af5921d994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a859581ff681293d06cc447e0f5ef9040"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a859581ff681293d06cc447e0f5ef9040">linfty_norm</a> () const</td></tr>
<tr class="separator:a859581ff681293d06cc447e0f5ef9040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4ca7e695d3750caede04b42cb3ca279"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac4ca7e695d3750caede04b42cb3ca279">add_and_dot</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;W)</td></tr>
<tr class="separator:ac4ca7e695d3750caede04b42cb3ca279"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ae72a04de37cc5ba8f0263809a59ec99e">all_zero</a> () const</td></tr>
<tr class="separator:ae72a04de37cc5ba8f0263809a59ec99e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad8e23a22888630c9874cbddf8bcccdf5">is_non_negative</a> () const</td></tr>
<tr class="separator:ad8e23a22888630c9874cbddf8bcccdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2：数据-获取</div></td></tr>
<tr class="memitem:a42a1cf7a4d6504237eda2ebcd6366ec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a42a1cf7a4d6504237eda2ebcd6366ec0">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index)</td></tr>
<tr class="separator:a42a1cf7a4d6504237eda2ebcd6366ec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5811320c572716dfa2766629de688a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5811320c572716dfa2766629de688a37">operator()</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index) const</td></tr>
<tr class="separator:a5811320c572716dfa2766629de688a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1475a7fcfd819e77b8879bc79bec9c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab1475a7fcfd819e77b8879bc79bec9c1">operator[]</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index)</td></tr>
<tr class="separator:ab1475a7fcfd819e77b8879bc79bec9c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd6e23df1fdc75e59c235219436a4c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#abd6e23df1fdc75e59c235219436a4c56">operator[]</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> index) const</td></tr>
<tr class="separator:abd6e23df1fdc75e59c235219436a4c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7395e6c657e16c72642b93bef7d712d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7395e6c657e16c72642b93bef7d712d2">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values) const</td></tr>
<tr class="separator:a7395e6c657e16c72642b93bef7d712d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a063a13f80f1a322183f8b0a204bec"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ae6a063a13f80f1a322183f8b0a204bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ae6a063a13f80f1a322183f8b0a204bec">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:ae6a063a13f80f1a322183f8b0a204bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2353314d473eb8d4caf527a6cc7ebab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af2353314d473eb8d4caf527a6cc7ebab">begin</a> ()</td></tr>
<tr class="separator:af2353314d473eb8d4caf527a6cc7ebab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a833030283c73c3df899289c39025eb47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a833030283c73c3df899289c39025eb47">begin</a> () const</td></tr>
<tr class="separator:a833030283c73c3df899289c39025eb47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b837c54b42d4ac79199ce2455116649"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a8b837c54b42d4ac79199ce2455116649">end</a> ()</td></tr>
<tr class="separator:a8b837c54b42d4ac79199ce2455116649"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdf9f6f5996a97ed39f64b4c80438c9a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#afdf9f6f5996a97ed39f64b4c80438c9a">end</a> () const</td></tr>
<tr class="separator:afdf9f6f5996a97ed39f64b4c80438c9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: 修改向量</div></td></tr>
<tr class="memitem:af5f439d6638ce898866fc2dfabf0ec35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af5f439d6638ce898866fc2dfabf0ec35">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:af5f439d6638ce898866fc2dfabf0ec35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c87a236c193c4e0029a9eb774078907"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a9c87a236c193c4e0029a9eb774078907">set</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:a9c87a236c193c4e0029a9eb774078907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f49865d04ffd53c6da98c11663a6b3d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a9f49865d04ffd53c6da98c11663a6b3d">set</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> n_elements, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values)</td></tr>
<tr class="separator:a9f49865d04ffd53c6da98c11663a6b3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a251a969a05c9492ade98682528f2b1de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a251a969a05c9492ade98682528f2b1de">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:a251a969a05c9492ade98682528f2b1de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add83be5ae97dca366c1c4ab69fa32da3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#add83be5ae97dca366c1c4ab69fa32da3">add</a> (const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;values)</td></tr>
<tr class="separator:add83be5ae97dca366c1c4ab69fa32da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1768924d2b6f63dec5d5976b8ab74384"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a1768924d2b6f63dec5d5976b8ab74384">add</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> n_elements, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *indices, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *values)</td></tr>
<tr class="separator:a1768924d2b6f63dec5d5976b8ab74384"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac080d00d53d41d659972ca60eb4eb687"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ac080d00d53d41d659972ca60eb4eb687">operator*=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:ac080d00d53d41d659972ca60eb4eb687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38edbce1fed1fdc7afb621ee7bbe3b2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa38edbce1fed1fdc7afb621ee7bbe3b2">operator/=</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> factor)</td></tr>
<tr class="separator:aa38edbce1fed1fdc7afb621ee7bbe3b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a658e1cb71eb4b76fa3211065e8b718bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a658e1cb71eb4b76fa3211065e8b718bb">operator+=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:a658e1cb71eb4b76fa3211065e8b718bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c953516561451f062b142106f21de7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ae1c953516561451f062b142106f21de7">operator-=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:ae1c953516561451f062b142106f21de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f695f6d00f487acad11a7760191b7fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2f695f6d00f487acad11a7760191b7fe">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s)</td></tr>
<tr class="separator:a2f695f6d00f487acad11a7760191b7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e9d676a56a02948342ec7b989338d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a06e9d676a56a02948342ec7b989338d8">add</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V, const <a class="el" href="classbool.html">bool</a> allow_different_maps=false)</td></tr>
<tr class="separator:a06e9d676a56a02948342ec7b989338d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea1dd6795724b992526a6355612dda1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aeea1dd6795724b992526a6355612dda1">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:aeea1dd6795724b992526a6355612dda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2210a85849b80f6217aeeaaa5aa5c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aee2210a85849b80f6217aeeaaa5aa5c1">add</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> b, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;W)</td></tr>
<tr class="separator:aee2210a85849b80f6217aeeaaa5aa5c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a106d1dbdc934bdea77688f47c838d256"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a106d1dbdc934bdea77688f47c838d256">sadd</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:a106d1dbdc934bdea77688f47c838d256"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa61c8d36a34528d2772630c2f9e46064"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa61c8d36a34528d2772630c2f9e46064">sadd</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> s, const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:aa61c8d36a34528d2772630c2f9e46064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa172107cb120b8cafae22063517cfbd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa172107cb120b8cafae22063517cfbd1">scale</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;scaling_factors)</td></tr>
<tr class="separator:aa172107cb120b8cafae22063517cfbd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa17a3b93459cf0c884354875debd3797"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa17a3b93459cf0c884354875debd3797">equ</a> (const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> a, const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;V)</td></tr>
<tr class="separator:aa17a3b93459cf0c884354875debd3797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">4：混合东西</div></td></tr>
<tr class="memitem:aa1c56ab16d8756970c3819758a2b7534"><td class="memItemLeft" align="right" valign="top">const Epetra_MultiVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa1c56ab16d8756970c3819758a2b7534">trilinos_vector</a> () const</td></tr>
<tr class="separator:aa1c56ab16d8756970c3819758a2b7534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d7e20b239d0473c5696fa0b47857d3e"><td class="memItemLeft" align="right" valign="top">Epetra_FEVector &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2d7e20b239d0473c5696fa0b47857d3e">trilinos_vector</a> ()</td></tr>
<tr class="separator:a2d7e20b239d0473c5696fa0b47857d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21aa62b203d7dda29e58df23ff2af75c"><td class="memItemLeft" align="right" valign="top">const Epetra_BlockMap &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a21aa62b203d7dda29e58df23ff2af75c">trilinos_partitioner</a> () const</td></tr>
<tr class="separator:a21aa62b203d7dda29e58df23ff2af75c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4d43302d459c7cb6ae4b5bad13d31507">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const</td></tr>
<tr class="separator:a4d43302d459c7cb6ae4b5bad13d31507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e1da096b2348e75220c08a90aab9df4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a8e1da096b2348e75220c08a90aab9df4">swap</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:a8e1da096b2348e75220c08a90aab9df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aea73d2cb54e87b69a9b7cdb17ed274df">memory_consumption</a> () const</td></tr>
<tr class="separator:aea73d2cb54e87b69a9b7cdb17ed274df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26356cd57970e2743751293562eba7f1"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a26356cd57970e2743751293562eba7f1">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a26356cd57970e2743751293562eba7f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa67d7e4c3d36aaa9453c7cff19469021"><td class="memItemLeft" align="right" valign="top">Epetra_CombineMode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#aa67d7e4c3d36aaa9453c7cff19469021">last_action</a></td></tr>
<tr class="separator:aa67d7e4c3d36aaa9453c7cff19469021"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72accdda3a9f644f17990418bac9957d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a72accdda3a9f644f17990418bac9957d">compressed</a></td></tr>
<tr class="separator:a72accdda3a9f644f17990418bac9957d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219e009dbd1a7fcadca2ddbbeeabc9b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a219e009dbd1a7fcadca2ddbbeeabc9b4">has_ghosts</a></td></tr>
<tr class="separator:a219e009dbd1a7fcadca2ddbbeeabc9b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a440bb709fa8f29542402392e55aed634"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_FEVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a></td></tr>
<tr class="separator:a440bb709fa8f29542402392e55aed634"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad797d2f106217e5e17dc7746052075"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; Epetra_MultiVector &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a2ad797d2f106217e5e17dc7746052075">nonlocal_vector</a></td></tr>
<tr class="separator:a2ad797d2f106217e5e17dc7746052075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ad9cd2c869cbd47284ceac109f637dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7ad9cd2c869cbd47284ceac109f637dc">owned_elements</a></td></tr>
<tr class="separator:a7ad9cd2c869cbd47284ceac109f637dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a4d77f4705993156218463a6698808bca"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4d77f4705993156218463a6698808bca">internal::VectorReference</a></td></tr>
<tr class="separator:a4d77f4705993156218463a6698808bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af853f838d421f8a008f6a57f3231bdc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af853f838d421f8a008f6a57f3231bdc3">swap</a> (<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;u, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;v)</td></tr>
<tr class="separator:af853f838d421f8a008f6a57f3231bdc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>该类实现了一个包装器，用于使用Trilinos分布式向量类Epetra_FEVector，其（并行）分区由Epetra_Map管理。 Epetra_FEVector正是我们一直在处理的那种矢量。</p>
<ul>
<li>我们可能从一些装配过程中得到它，在那里，不属于本地的条目也可能需要被写入，因此需要转发给所有者。 这个类的接口是以deal.II中现有的Vector类为模型的。它有几乎相同的成员函数，并且通常是可交换的。然而，由于Trilinos只支持单一的标量类型（double），所以它不是模板化的，只对这种类型起作用。 请注意，只有在向量装配后调用了函数 <code>GlobalAssemble</code> 以分配数据的情况下，Trilinos才会保证操作能达到你预期的效果。这是必要的，因为一些进程可能积累了不属于自己的元素数据，但必须被发送到拥有进程中。为了避免使用错误的数据，你需要在实际使用向量之前调用 <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a7221ae06689832b475206ef54efaf0a6">Vector::compress()</a> 。 <h3>Parallel communication model</h3>
</li>
</ul>
<p>Trilinos的并行功能是建立在消息传递接口（MPI）之上的。MPI的通信模型建立在集体通信的基础上：如果一个进程想从另一个进程得到什么，另一个进程必须愿意接受这种通信。一个进程不能通过调用一个远程函数从另一个进程查询数据，而另一个进程不期望有这种交易。其结果是，这个类的基类中的大多数操作都必须被集体调用。例如，如果你想计算一个平行向量的l2准则， <em>所有共享这个向量的进程都必须调用</em> <code>l2_norm</code> 函数。如果你不这样做，而只是在一个进程上调用 <code>l2_norm</code> 函数，那么会发生以下情况。这一个进程将调用一个集体MPI函数，并等待所有其他进程加入到这个过程中。由于其他进程不调用这个函数，你将在第一个进程上得到一个超时，或者更糟糕的是，当下一个对Trilinos函数的调用在其他进程上产生MPI消息时，你将得到一个神秘的消息，即只有一个子集的进程试图进行通信。这些错误是很难搞清楚的，除非你对MPI的通信模型非常熟悉，并且知道哪些函数可能产生MPI消息。 下面将讨论一个特殊的情况，即可能会意外地产生MPI消息的情况。 </p><h3>Accessing individual elements of a vector</h3>
<p>Trilinos当然允许读取矢量的单个元素，但在分布式情况下，只允许读取本地存储的元素。我们通过<code>d=vec(i)</code>这样的调用来实现。 然而，如果你访问本地存储范围之外的元素，就会产生一个异常。 与读访问相反，Trilinos（以及相应的deal.II包装类）允许对向量的单个元素进行写入（或添加），即使它们存储在不同的进程中。你可以通过使用语法&lt;tt&gt;vec(i)=d或<code>vec(i)+=d</code>，或类似的操作写入或添加到元素中。然而，有一个问题，可能会导致非常混乱的错误信息。 Trilinos要求应用程序在从执行一组向元素添加的操作转换到执行一组向元素写入的操作时调用compress()函数。其理由是，所有进程都可能积累对元素的加法操作，即使是多个进程写到相同的元素。当我们下次调用compress()时，所有这些加法操作都被执行了。然而，如果一个进程对一个元素进行添加，而另一个进程对其进行覆盖，如果我们不确保在这中间发生与compress()的同步，那么执行的顺序将产生非确定性的行为。 为了确保这些对compress()的调用在适当的时间发生，deal.II包装器保留了一个状态变量，用于存储当前允许的操作：添加或写入。如果它遇到了相反的操作，它就会调用compress()并翻转状态。这有时会导致非常混乱的行为，例如，代码可能看起来像这样。 </p><div class="fragment"><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>;</div><div class="line"><span class="comment">// do some write operations on the vector</span></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> i=0; i&lt;vector-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size</a>(); ++i)</div><div class="line"><a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>(i) = i;</div><div class="line"></div><div class="line">                <span class="comment">// do some additions to vector elements, but</span></div><div class="line">                <span class="comment">// only for some elements</span></div><div class="line"><span class="keywordflow">for</span> (<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> i=0; i&lt;vector-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a78fa29403bbd6da7795fd25700267d47">size</a>(); ++i)</div><div class="line">  <span class="keywordflow">if</span> (some_condition(i) == <span class="keyword">true</span>)</div><div class="line">    <a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a>(i) += 1;</div><div class="line"></div><div class="line">                <span class="comment">// do another collective operation</span></div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> <a class="code" href="namespaceLocalIntegrators_1_1Divergence.html#a8bcfc37d2a2be8faa18628a601ecf112">norm</a> = vector-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a5680a0f82a28f0b980d83f3443cc20ca">l2_norm</a>();</div></div><!-- fragment --><p> 这段代码可能会遇到麻烦：当我们看到第一个加法运算时，我们需要冲刷向量的覆盖缓冲区，而deal.II库会通过调用compress()来实现。然而，它只对所有实际进行加法运算的进程进行这样的操作。</p>
<p>2008, 2009, 2017 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00262">262</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ab55a7083697b5f4d48ed0b712ac6c0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab55a7083697b5f4d48ed0b712ac6c0d7">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">TrilinosWrappers::MPI::Vector::value_type</a> =  <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一些在所有容器中使用的标准类型。这些类型与<code>C</code>标准库中的<code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector&lt;...&gt;</a></code>类中的类型平行。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00269">269</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a96aaae66bd475507a3964b87b385267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96aaae66bd475507a3964b87b385267e">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">TrilinosWrappers::MPI::Vector::real_type</a> =  <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00270">270</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="ad90eb8c6eab28c4bc432390c87baea00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad90eb8c6eab28c4bc432390c87baea00">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">TrilinosWrappers::MPI::Vector::size_type</a> =  ::<a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00271">271</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a96d5260bbf09c1f64d74d19f50fa0ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d5260bbf09c1f64d74d19f50fa0ab4">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">TrilinosWrappers::MPI::Vector::iterator</a> =  <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00272">272</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="ab3279b30b041311561be433d3c74d4c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3279b30b041311561be433d3c74d4c2">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">TrilinosWrappers::MPI::Vector::const_iterator</a> =  const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab55a7083697b5f4d48ed0b712ac6c0d7">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00273">273</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a85fc5a6639c4690d21e0ac1a6281c511"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85fc5a6639c4690d21e0ac1a6281c511">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">TrilinosWrappers::MPI::Vector::reference</a> =  internal::VectorReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00274">274</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a649cb858f21cbfd5512395fbf726822f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649cb858f21cbfd5512395fbf726822f">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a649cb858f21cbfd5512395fbf726822f">TrilinosWrappers::MPI::Vector::const_reference</a> =  const internal::VectorReference</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l00275">275</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5424155269bd22011e9ff796e0c77e69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5424155269bd22011e9ff796e0c77e69">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数，生成一个空的（零大小）向量。在MPI运行的情况下，函数<code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a655ae9c8d3595133abe1131fcbb97b6d">reinit()</a></code>将必须给向量以正确的大小和在进程中的分布。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00070">70</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a34e4685e7a2a5dd43d67c3541ba67574"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34e4685e7a2a5dd43d67c3541ba67574">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用给定向量的复制构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00090">90</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ab68136a6b67841a5afc1548373cc6161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab68136a6b67841a5afc1548373cc6161">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个构造函数接受一个IndexSet，它定义了如何在MPI处理器之间分配各个组件。由于它还包括关于向量大小的信息，这就是我们生成一个并行向量所需要的全部内容。 根据 <code>parallel_partitioning</code> 参数是否在处理器之间唯一地细分了元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。 如果提供的IndexSet形成了一个重叠的分区，就不清楚哪些元素被哪个进程拥有，local_owned_elements()将返回一个大小为0的IndexSet。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00081">81</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ac149f1474536140b65eb3eeef3d71590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac149f1474536140b65eb3eeef3d71590">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个有重影的平行向量。 根据 <code>ghost</code> 参数是否在处理器之间唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见这个类的一般文档。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00128">128</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a978deda236f930277fcc661c0a04c59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a978deda236f930277fcc661c0a04c59f">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从TrilinosWrappers向量类复制构造函数。由于这个类的向量不一定需要在进程间分配，用户需要向我们提供一个IndexSet和一个设置分区细节的MPI通信器。 根据 <code>parallel_partitioning</code> 参数是否在处理器之间唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00109">109</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aee12823e00f598de8f255e915c5e5243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee12823e00f598de8f255e915c5e5243">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::Vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从deal.II向量中复制出来的构造函数。将维数设置为给定向量的维数，并复制所有的元素。 根据 <code>parallel_partitioning</code> 参数是否在处理器中唯一地划分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

</div>
</div>
<a id="a2f0f17bf5ad5737ad817550cee718752"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0f17bf5ad5737ad817550cee718752">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动构造函数。通过窃取向量的内部数据创建一个新的向量 <code>v</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00100">100</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a7b5d5494efdf43a043d41ccbc8be9c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b5d5494efdf43a043d41ccbc8be9c96">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::~Vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5bce94882ecb65b2ccc8250b23d1b5ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bce94882ecb65b2ccc8250b23d1b5ce">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00139">139</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a655ae9c8d3595133abe1131fcbb97b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a655ae9c8d3595133abe1131fcbb97b6d">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_different_maps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>重新启动功能。这个函数将调用向量设置为输入向量的维度和平行分布，但不复制<code>v</code>中的元素。如果<code>omit_zeroing_entries</code>不是<code>true</code>，向量中的元素将被初始化为0。如果它被设置为<code>true</code>，那么向量的条目就处于一个未指定的状态，用户必须设置所有元素。在目前的实现中，如果矢量的布局与之前相比没有变化，这个方法不会触及矢量的条目，否则条目会被设置为零。 请注意，这种行为在不同的版本中可能会发生变化而不被通知。 这个函数有第三个参数，<code>allow_different_maps</code>，它允许在两个同等大小的向量之间交换数据（但在处理器之间的分布不同）。这个函数的一个微不足道的应用是在每台机器上生成整个向量的复制，当调用的向量是由每个进程上的所有索引组成的映射建立的，并且<code>v</code>是一个分布式向量。在这种情况下，变量<code>omit_zeroing_entries</code>需要被设置为<code>false</code>，因为在不同的并行化向量之间交换数据而不接触元素是没有意义的。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00198">198</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="af74a39fa88174f63767d510416c09e6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af74a39fa88174f63767d510416c09e6f">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>parallel_partitioning</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit功能。这个功能销毁了旧的向量内容，并根据输入的分区生成一个新的向量。 标志<code>omit_zeroing_entries</code>决定了向量是否应该被填充为零（false）。如果该标志被设置为<code>true</code>，则向量条目处于未指定的状态，用户必须设置所有元素。在目前的实现中，这个方法仍然将条目设置为零，但这可能会在没有通知的情况下在不同的版本中发生变化。 根据 <code>parallel_partitioning</code> 参数是否在处理器中唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。 在 <code>parallel_partitioning</code> 重叠的情况下，不清楚哪个进程应该拥有哪些元素。因此，在这种情况下，local_owned_elements()返回一个空的索引集。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00157">157</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ad21ce9067c23a1e1838c41a6a5f2bfb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad21ce9067c23a1e1838c41a6a5f2bfb4">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>locally_owned_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em> = <code>MPI_COMM_WORLD</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>vector_writable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>重新启动功能。这个功能销毁了旧的向量内容，并根据输入的分区生成一个新的向量。除了像上面所有其他方法一样只指定一个索引集外，这个方法还允许提供一个额外的鬼魂条目集。 有两个不同版本的向量可以被创建。如果标志 <code>vector_writable</code> 被设置为 <code>false</code>, ，该向量只允许读取 <code>parallel_partitioning</code> 和 <code>ghost_entries</code>. 的联合集合，那么reinit方法的效果相当于调用其他的reinit方法，其索引集包含本地拥有的条目和幽灵条目。 如果标志 <code>vector_writable</code> 被设置为true，这就为ghost元素创建了一个替代性的存储方案，允许多个线程写入向量（对于其他reinit方法，一次只允许一个线程写入ghost条目）。 根据 <code>ghost_entries</code> 参数是否在处理器之间唯一地细分元素，产生的向量可能有也可能没有鬼魂元素。更多信息请参见该类的一般文档。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00360">360</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a79c714a8a7631f0a41e474a1481c3ebd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c714a8a7631f0a41e474a1481c3ebd">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>import_data</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过合并块状向量的成分来创建向量。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00283">283</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a7221ae06689832b475206ef54efaf0a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7221ae06689832b475206ef54efaf0a6">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>压缩Trilinos对象的底层表示，即刷新向量对象的缓冲区（如果它有的话）。在逐一写入矢量元素后，在对其进行其他操作之前，这个函数是必要的。 参数（缺省）可用于指定压缩模式（ <code>Add</code> or <code>Insert</code> ），以防在上次调用此函数后，没有对向量进行过写入。如果在上次调用compress()后，向量被添加或写入，则该参数被忽略。 更多信息见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00582">582</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ac211406f759dc392950d077edaccc9bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac211406f759dc392950d077edaccc9bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量的所有分量设置为给定的数字 <code>s</code>. 只需将其传递给基类，但我们仍然需要声明这个函数，以使关于使构造函数显式的讨论中给出的例子发挥作用。 由于将标量分配给向量的语义并不立即明确，所以只有当你想将整个向量设为0时，才能使用这个操作符。这样就可以使用直观的符号<code>v=0</code>。 </p>

</div>
</div>
<a id="adbe7192a480321cb76a2271dd1886123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe7192a480321cb76a2271dd1886123">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制给定的向量。如果有必要，可以调整现在的向量的大小。在这种情况下，设计平行分区的Epetra_Map也是从输入矢量中提取的。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00418">418</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a17f586e2bb89eace98f639fc9d218add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17f586e2bb89eace98f639fc9d218add">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>移动给定的向量。该操作符通过有效地交换内部数据结构，用 <code>v</code> 替换当前的向量。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00498">498</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ac2fc85797cce1e944be10daef76292ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fc85797cce1e944be10daef76292ec">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator= </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>另一个复制函数。这个函数接收一个deal.II向量并将其复制到一个TrilinosWrapper向量中。请注意，由于我们没有提供任何Epetra_map来告诉MPI进程之间的向量划分，TrilinosWrapper向量的大小必须与输入向量的大小相同。 </p>

</div>
</div>
<a id="a437913068a4ab813d0a955376073ad74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437913068a4ab813d0a955376073ad74">&#9670;&nbsp;</a></span>import_nonlocal_data_for_fe()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::import_nonlocal_data_for_fe </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vector</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个reinit函数是为了用于必须使用一些非本地数据的并行计算。需要这个函数的典型情况是并行调用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValues&lt;dim&gt;::get_function_values</a> 函数（或一些导数）。由于提前检索数据通常更快，这个函数可以在汇编分叉到不同处理器之前被调用。这个函数的作用如下。 它获取给定矩阵的列中的信息，并寻找不同处理器之间的数据耦合。然后从输入向量中查询这些数据。注意，你不应该再向结果向量写入数据，因为有些数据可以在不同的处理器上存储多次，导致不可预测的结果。特别是，这样的向量不能用于矩阵-向量乘积，例如在线性系统的求解过程中。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00527">527</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ad37486c4cfabda6714e6dd3184126205"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37486c4cfabda6714e6dd3184126205">&#9670;&nbsp;</a></span>import()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rwv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从输入向量 <code>rwv</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> 中导入向量的IndexSet中存在的所有元素，用于决定 <code>rwv</code> 中的元素是否应该添加到当前向量中或替换当前元素。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00551">551</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aa363aa1eab397fc873db21871d653564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa363aa1eab397fc873db21871d653564">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检验是否相等。这个函数假定目前的向量和要比较的向量已经具有相同的大小，因为无论如何比较不同大小的向量没有什么意义。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00715">715</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a788edd01c013ad9e44d75166738f5f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a788edd01c013ad9e44d75166738f5f44">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>测试不平等。这个函数假定现在的向量和要比较的向量已经有相同的大小，因为比较不同大小的向量反正没有什么意义。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00732">732</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a78fa29403bbd6da7795fd25700267d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fa29403bbd6da7795fd25700267d47">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> TrilinosWrappers::MPI::Vector::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的全局尺寸。 </p>

</div>
</div>
<a id="a4936b9f1043fa560dd217d06ea81603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4936b9f1043fa560dd217d06ea81603d">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> TrilinosWrappers::MPI::Vector::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的局部尺寸，即存储在当前MPI进程中的元素数量。对于顺序向量，这个数字与size()相同，但对于并行向量，它可能更小。 要想知道到底哪些元素是存储在本地的，可以使用local_range()。 如果向量包含鬼魂元素，它们会被包括在这个数字中。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000060">Deprecated:</a></b></dt><dd>这个函数已被废弃。</dd></dl>

</div>
</div>
<a id="abc37c8685838f91d6104373d292d0348"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc37c8685838f91d6104373d292d0348">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> TrilinosWrappers::MPI::Vector::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的本地大小，即本地拥有的索引数。 </p>

</div>
</div>
<a id="abcc22742227d63950cb0995223e6ee32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc22742227d63950cb0995223e6ee32">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt;<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&gt; TrilinosWrappers::MPI::Vector::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一对索引，表明这个向量的哪些元素是本地存储的。第一个数字是存储的第一个元素的索引，第二个是本地存储的超过最后一个元素的索引。如果这是一个连续的向量，那么结果将是一对 <code>(0,N)</code> ，否则将是一对 <code>(i,i+n)</code>, where <code>n=<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4936b9f1043fa560dd217d06ea81603d">local_size()</a></code> 和 <code>i</code> 是存储在这个处理器上的向量的第一个元素，对应于半开区间 \([i,i+n)\) </p><dl class="section note"><dt>Note</dt><dd>上面的描述在大多数时候是正确的，但并不总是。 特别是，Trilinos向量不需要存储连续的元素范围，如 \([i,i+n)\) 。相反，它可以存储元素以任意的方式分布在所有处理器上的向量，每个处理器只是存储一个特定的子集，不一定是连续的。在这种情况下，这个函数显然是没有意义的，因为它最多只能返回一个包括本地存储的所有元素的范围。因此，这个函数只有在本地存储的范围确实是连续的情况下才会成功。如果向量的本地部分不是连续的，它将触发一个断言。 </dd></dl>

</div>
</div>
<a id="a482b65857b3e328451fc2f4cfa7c103c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482b65857b3e328451fc2f4cfa7c103c">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p><dl class="section note"><dt>Note</dt><dd>这个函数的适用性限制与local_range()的文档中所列相同。 </dd></dl>

</div>
</div>
<a id="a50f6096b67b2787a85622e4d0296b927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50f6096b67b2787a85622e4d0296b927">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::MPI::Vector::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个索引集，描述这个向量的哪些元素是由当前处理器拥有的。请注意，这个索引集不包括这个向量可能在本地存储为幽灵元素，但实际上由另一个处理器拥有的元素。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。 很明显，如果一个向量只在一个处理器上创建，那么结果将满足 </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a> (vec.size())</div></div><!-- fragment --> 
</div>
</div>
<a id="a68f28d2bf6737db19cd076abbb1aee51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f28d2bf6737db19cd076abbb1aee51">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果向量包含鬼魂元素，则返回。如果至少有一个进程上有鬼魂元素，这个答案就是真的。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">含有幽灵元素的向量</a> </dd></dl>

</div>
</div>
<a id="a361ec774d40d22bf10497eb1623e4ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361ec774d40d22bf10497eb1623e4ac3">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数只是为了与 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a></code> 类兼容而存在，并不做任何事情：这个类以不同的方式实现了鬼魂值的更新，与底层的Trilinos向量对象更加匹配。 </p>

</div>
</div>
<a id="adbadf555e8a9d0a32a35fe978a32e804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbadf555e8a9d0a32a35fe978a32e804">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回两个向量的标量（内）积。这些向量必须具有相同的大小。 </p>

</div>
</div>
<a id="a72bfeaeafc63a9b98e4141dd272e2652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72bfeaeafc63a9b98e4141dd272e2652">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回 \(l_2\) -norm的平方。 </p>

</div>
</div>
<a id="a15bcdfb5d20d5372131575898e42685a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bcdfb5d20d5372131575898e42685a">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个向量的元素的平均值。 </p>

</div>
</div>
<a id="a93d82fe3f26d3e9da96a408d316c994d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d82fe3f26d3e9da96a408d316c994d">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算这个向量的元素的最小值。 </p>

</div>
</div>
<a id="afc54afaac60585457ed278c13399fda5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc54afaac60585457ed278c13399fda5">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算这个向量的元素的最大值。 </p>

</div>
</div>
<a id="a0120da4bfb59f70ff1e2ed58a3a154f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0120da4bfb59f70ff1e2ed58a3a154f1">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_1\) -矢量的规范。 绝对值的总和。 </p>

</div>
</div>
<a id="a5680a0f82a28f0b980d83f3443cc20ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5680a0f82a28f0b980d83f3443cc20ca">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_2\) - 矢量的规范。 各个元素的平方根之和。 </p>

</div>
</div>
<a id="a50c88df6b68850adc65db3af5921d994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50c88df6b68850adc65db3af5921d994">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\) - 矢量的规范。元素绝对值的<em>p</em>次幂之和的<em>p</em>根。 </p>

</div>
</div>
<a id="a859581ff681293d06cc447e0f5ef9040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a859581ff681293d06cc447e0f5ef9040">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96aaae66bd475507a3964b87b385267e">real_type</a> TrilinosWrappers::MPI::Vector::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>元素的最大绝对值。 </p>

</div>
</div>
<a id="ac4ca7e695d3750caede04b42cb3ca279"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4ca7e695d3750caede04b42cb3ca279">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行矢量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的 </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a251a969a05c9492ade98682528f2b1de">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value =<span class="keyword">this</span> W;</div></div><!-- fragment --><p> 这个函数存在的原因是为了与deal.II自己的向量类兼容，后者可以用较少的内存传输实现这个功能。然而，对于Trilinos向量来说，原生不支持这样的组合操作，因此成本完全等同于单独调用这两个方法。 对于复值向量，第二步中的标量乘积被实现为 \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) . </p>

</div>
</div>
<a id="ae72a04de37cc5ba8f0263809a59ec99e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a04de37cc5ba8f0263809a59ec99e">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该向量是否只包含数值为0的元素。这是一个集体操作。这个函数很昂贵，因为有可能所有的元素都要被检查。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00742">742</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ad8e23a22888630c9874cbddf8bcccdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e23a22888630c9874cbddf8bcccdf5">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果向量没有负的条目，即所有条目都是零或正，则返回 <code>true</code> 。例如，这个函数用于检查细化指标是否真的都是正的（或零）。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00775">775</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a42a1cf7a4d6504237eda2ebcd6366ec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a1cf7a4d6504237eda2ebcd6366ec0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a> TrilinosWrappers::MPI::Vector::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个给定元素的访问，包括读和写。 当使用一个用MPI分布的向量时，这个操作只对调用处理器上实际存在的元素有意义。 否则，会产生一个异常。 </p>

</div>
</div>
<a id="a5811320c572716dfa2766629de688a37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5811320c572716dfa2766629de688a37">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个元素的只读访问。 当使用MPI分布的向量时，这个操作只对调用处理器上实际存在的元素有意义。 否则，会产生一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00654">654</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="ab1475a7fcfd819e77b8879bc79bec9c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1475a7fcfd819e77b8879bc79bec9c1">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a85fc5a6639c4690d21e0ac1a6281c511">reference</a> TrilinosWrappers::MPI::Vector::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个给定元素的访问，包括读和写。 与operator()完全相同。 </p>

</div>
</div>
<a id="abd6e23df1fdc75e59c235219436a4c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd6e23df1fdc75e59c235219436a4c56">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> TrilinosWrappers::MPI::Vector::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>提供对一个元素的只读访问。 与operator()完全相同。 </p>

</div>
</div>
<a id="a7395e6c657e16c72642b93bef7d712d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7395e6c657e16c72642b93bef7d712d2">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与通过operator()获取向量中的单个元素不同，这个函数允许一次性获取一整组元素。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd><code>indices</code> 和 <code>values</code> 数组的大小必须是一致的。 </dd></dl>

</div>
</div>
<a id="ae6a063a13f80f1a322183f8b0a204bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a063a13f80f1a322183f8b0a204bec">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数不是通过operator()获得向量的单个元素，而是允许一次获得整个元素集。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line"> values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>必须能够写进从 <code>values_begin</code> 开始的尽可能多的内存位置，因为有 <code>indices_begin</code> 和 <code>indices_end</code>. 之间的迭代器。 </dd></dl>

</div>
</div>
<a id="af2353314d473eb8d4caf527a6cc7ebab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2353314d473eb8d4caf527a6cc7ebab">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a> TrilinosWrappers::MPI::Vector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过返回该向量中本地拥有的元素的开始和结束的迭代器，使Vector类有点像C++标准库中的<code>vector&lt;&gt;/tt&gt;类。如果向量是由IndexSet或deal.II中的其他方法构造的，则本地元素的排序与全局索引给出的排序一致（注意，Epetra_Map可以包含任意排序的元素）。 它认为end()</code></p>
<p><code></p><ul>
<li><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#af2353314d473eb8d4caf527a6cc7ebab">begin()</a> == <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a4936b9f1043fa560dd217d06ea81603d">local_size()</a>。 </li>
</ul>
<p></code></p>

</div>
</div>
<a id="a833030283c73c3df899289c39025eb47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a833030283c73c3df899289c39025eb47">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a> TrilinosWrappers::MPI::Vector::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回常数迭代器到向量中本地拥有的元素的起点。 </p>

</div>
</div>
<a id="a8b837c54b42d4ac79199ce2455116649"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b837c54b42d4ac79199ce2455116649">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a96d5260bbf09c1f64d74d19f50fa0ab4">iterator</a> TrilinosWrappers::MPI::Vector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个迭代器，指向本地拥有的条目数组结束后的元素。 </p>

</div>
</div>
<a id="afdf9f6f5996a97ed39f64b4c80438c9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdf9f6f5996a97ed39f64b4c80438c9a">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ab3279b30b041311561be433d3c74d4c2">const_iterator</a> TrilinosWrappers::MPI::Vector::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个恒定的迭代器，指向本地拥有的条目数组结束后的元素。 </p>

</div>
</div>
<a id="af5f439d6638ce898866fc2dfabf0ec35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f439d6638ce898866fc2dfabf0ec35">&#9670;&nbsp;</a></span>set() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个集体的设置操作：这个函数允许一次性设置一整组元素，而不是设置一个向量中的单个元素。 要设置的元素的索引在第一个参数中说明，相应的值在第二个参数中说明。 </p>

</div>
</div>
<a id="a9c87a236c193c4e0029a9eb774078907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c87a236c193c4e0029a9eb774078907">&#9670;&nbsp;</a></span>set() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是第二个集体设置操作。作为区别，这个函数需要一个deal.II的数值向量。 </p>

</div>
</div>
<a id="a9f49865d04ffd53c6da98c11663a6b3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f49865d04ffd53c6da98c11663a6b3d">&#9670;&nbsp;</a></span>set() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个集合操作级别较低，可以处理其他任何事情&amp;mdash；你唯一需要提供的是一个存放所有索引的地址和要设置的元素数量。 </p>

</div>
</div>
<a id="a251a969a05c9492ade98682528f2b1de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a251a969a05c9492ade98682528f2b1de">&#9670;&nbsp;</a></span>add() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个集体添加操作。这个函数将存储在 <code>values</code> 中的整组值添加到 <code>indices</code>. 指定的向量成分中。 </p>

</div>
</div>
<a id="add83be5ae97dca366c1c4ab69fa32da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add83be5ae97dca366c1c4ab69fa32da3">&#9670;&nbsp;</a></span>add() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是第二次集体添加操作。作为区别，这个函数需要一个deal.II的数值向量。 </p>

</div>
</div>
<a id="a1768924d2b6f63dec5d5976b8ab74384"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1768924d2b6f63dec5d5976b8ab74384">&#9670;&nbsp;</a></span>add() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取一个<code>n_elements</code>连续存储的地址，并将其添加到向量中。处理上述其他两个<code><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a251a969a05c9492ade98682528f2b1de">add()</a></code>函数未涵盖的所有情况。 </p>

</div>
</div>
<a id="ac080d00d53d41d659972ca60eb4eb687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac080d00d53d41d659972ca60eb4eb687">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个向量乘以一个固定系数。 </p>

</div>
</div>
<a id="aa38edbce1fed1fdc7afb621ee7bbe3b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38edbce1fed1fdc7afb621ee7bbe3b2">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将整个向量除以一个固定的因子。 </p>

</div>
</div>
<a id="a658e1cb71eb4b76fa3211065e8b718bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a658e1cb71eb4b76fa3211065e8b718bb">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的向量添加到当前的向量中。 </p>

</div>
</div>
<a id="ae1c953516561451f062b142106f21de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c953516561451f062b142106f21de7">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&amp; TrilinosWrappers::MPI::Vector::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从现在的向量中减去给定的向量。 </p>

</div>
</div>
<a id="a2f695f6d00f487acad11a7760191b7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f695f6d00f487acad11a7760191b7fe">&#9670;&nbsp;</a></span>add() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将 <code>s</code> 加到所有组件上。注意 <code>s</code> 是一个标量而不是一个向量。 </p>

</div>
</div>
<a id="a06e9d676a56a02948342ec7b989338d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e9d676a56a02948342ec7b989338d8">&#9670;&nbsp;</a></span>add() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>allow_different_maps</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>简单的向量加法，等于<code>运算符+=</code>。 不过，如果第二个参数<code>allow_different_maps</code>被设置，那么就有可能从一个使用不同地图的向量中添加数据，也就是说，一个向量的元素被不同的处理器分割。例如，这可能包括有幽灵元素的向量。 然而，一般来说，添加具有不同元素对处理器映射的向量需要在处理器之间进行数据通信，因此，比使用相同映射的向量的操作要慢。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00680">680</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aeea1dd6795724b992526a6355612dda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeea1dd6795724b992526a6355612dda1">&#9670;&nbsp;</a></span>add() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矢量的倍数的简单加法，即<code>*this += a*V</code>。 </p>

</div>
</div>
<a id="aee2210a85849b80f6217aeeaaa5aa5c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2210a85849b80f6217aeeaaa5aa5c1">&#9670;&nbsp;</a></span>add() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放向量的多重加法，即<code>*this += a*V + b*W</code>。 </p>

</div>
</div>
<a id="a106d1dbdc934bdea77688f47c838d256"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a106d1dbdc934bdea77688f47c838d256">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放和简单的向量相加，即<code>*this = s*(*this) + V</code>。 </p>

</div>
</div>
<a id="aa61c8d36a34528d2772630c2f9e46064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa61c8d36a34528d2772630c2f9e46064">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放和简单加法，即：<code>*this = s*(*this) + a*V</code>。 </p>

</div>
</div>
<a id="aa172107cb120b8cafae22063517cfbd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa172107cb120b8cafae22063517cfbd1">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。 </p>

</div>
</div>
<a id="aa17a3b93459cf0c884354875debd3797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa17a3b93459cf0c884354875debd3797">&#9670;&nbsp;</a></span>equ()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TrilinosWrappers::MPI::Vector::equ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>赋值 <code>*this = a*V</code>. </p>

</div>
</div>
<a id="aa1c56ab16d8756970c3819758a2b7534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c56ab16d8756970c3819758a2b7534">&#9670;&nbsp;</a></span>trilinos_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_MultiVector&amp; TrilinosWrappers::MPI::Vector::trilinos_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对底层Trilinos Epetra_MultiVector类的常量引用。 </p>

</div>
</div>
<a id="a2d7e20b239d0473c5696fa0b47857d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d7e20b239d0473c5696fa0b47857d3e">&#9670;&nbsp;</a></span>trilinos_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_FEVector&amp; TrilinosWrappers::MPI::Vector::trilinos_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个（可修改的）对底层Trilinos Epetra_FEVector类的引用。 </p>

</div>
</div>
<a id="a21aa62b203d7dda29e58df23ff2af75c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21aa62b203d7dda29e58df23ff2af75c">&#9670;&nbsp;</a></span>trilinos_partitioner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const Epetra_BlockMap&amp; TrilinosWrappers::MPI::Vector::trilinos_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对底层Trilinos Epetra_BlockMap的常量引用，它设置了向量的平行分区。 </p>

</div>
</div>
<a id="a4d43302d459c7cb6ae4b5bad13d31507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d43302d459c7cb6ae4b5bad13d31507">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印到一个流。 <code>precision</code> 表示打印数值所需的精度， <code>scientific</code> 是否应使用科学符号。如果 <code>across</code> 是 <code>true</code> ，那么向量将被打印在一行中，而如果 <code>false</code> 则元素被打印在单独的一行中。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00814">814</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a8e1da096b2348e75220c08a90aab9df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e1da096b2348e75220c08a90aab9df4">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换这个向量和另一个向量的内容 <code>v</code>. 人们可以用一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换了两个向量的数据指针，因此不需要分配临时存储和移动数据。注意，两个向量需要有相同的大小，并以同一地图为基础。 这个函数类似于所有C++标准容器的 <code>swap</code> 函数。此外，还有一个全局函数<code>swap(u,v)</code>，它简单地调用<code>u.swap(v)</code>，同样与标准函数相类似。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00862">862</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="aea73d2cb54e87b69a9b7cdb17ed274df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea73d2cb54e87b69a9b7cdb17ed274df">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对内存消耗的估计，以字节为单位。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00875">875</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a26356cd57970e2743751293562eba7f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26356cd57970e2743751293562eba7f1">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; TrilinosWrappers::MPI::Vector::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对与此对象一起使用的MPI通信器对象的引用。 </p>

</div>
</div>
<a id="a43b630c9142014fa08cf90a4bd89522b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43b630c9142014fa08cf90a4bd89522b">&#9670;&nbsp;</a></span>DeclException0()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcDifferentParallelPartitioning&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a05da1d5ccd69890ceac0add39c84ba89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05da1d5ccd69890ceac0add39c84ba89">&#9670;&nbsp;</a></span>DeclException1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcTrilinosError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;An error with error number &quot;&lt;&lt; arg1&lt;&lt; &quot; occurred while calling a Trilinos function&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a3c70f2b8c2724bbc5691da251a036320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c70f2b8c2724bbc5691da251a036320">&#9670;&nbsp;</a></span>DeclException4()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TrilinosWrappers::MPI::Vector::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcAccessToNonLocalElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#ad90eb8c6eab28c4bc432390c87baea00">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You are trying to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this element is not stored &quot;&lt;&lt; &quot;on the current processor. Note:There are &quot;&lt;&lt; arg2&lt;&lt; &quot; elements stored &quot;&lt;&lt; &quot;on the current processor from within the range but Trilinos vectors need not store contiguous &quot;&lt;&lt; &quot;ranges on each&#160;</td>
          <td class="paramname"><em>processor</em>[&quot;&lt;&lt; arg3&lt;&lt; &quot;,&quot;&lt;&lt; arg4&lt;&lt; &quot;], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and not every element in &quot;&lt;&lt; &quot;this range may in fact be stored locally.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> into a function &quot;&lt;&lt; &quot;that needs read access to <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells(or at least to &quot;&lt;&lt; &quot; 'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot; 'locally owned'). You need to pass a <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html#a440bb709fa8f29542402392e55aed634">vector</a> that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a4d77f4705993156218463a6698808bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d77f4705993156218463a6698808bca">&#9670;&nbsp;</a></span>internal::VectorReference</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class internal::VectorReference</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01043">1043</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="af853f838d421f8a008f6a57f3231bdc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af853f838d421f8a008f6a57f3231bdc3">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>全局函数 <code>swap</code> ，它重载了C++标准库的默认实现，它使用一个临时对象。该函数简单地交换了两个向量的数据。</p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01058">1058</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa67d7e4c3d36aaa9453c7cff19469021"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67d7e4c3d36aaa9453c7cff19469021">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Epetra_CombineMode TrilinosWrappers::MPI::Vector::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos不允许混合添加矩阵条目和覆盖它们（以使并行计算的同步更简单）。我们的方法是，对于每个访问操作，存储它是插入还是添加。如果之前的操作是不同的类型，那么我们首先要刷新Trilinos缓冲区；否则，我们可以简单地继续下去。 幸运的是，Trilinos有一个这样的对象，在这种情况下已经完成了所有的并行通信，所以我们只需使用他们的模型，存储最后一个操作是加法还是插入。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01010">1010</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a72accdda3a9f644f17990418bac9957d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72accdda3a9f644f17990418bac9957d">&#9670;&nbsp;</a></span>compressed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::compressed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个布尔变量，用来保存向量是否被压缩的信息。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01016">1016</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a219e009dbd1a7fcadca2ddbbeeabc9b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a219e009dbd1a7fcadca2ddbbeeabc9b4">&#9670;&nbsp;</a></span>has_ghosts</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> TrilinosWrappers::MPI::Vector::has_ghosts</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个向量是否有鬼魂元素。这在所有的处理器上都是真的，即使只有一个处理器有任何鬼魂元素。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01022">1022</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a440bb709fa8f29542402392e55aed634"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a440bb709fa8f29542402392e55aed634">&#9670;&nbsp;</a></span>vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_FEVector&gt; TrilinosWrappers::MPI::Vector::vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向实际Epetra向量对象的指针。这可能代表一个事实上分布在多个处理器上的向量。该对象在设置时需要一个现有的Epetra_Map来存储数据。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01028">1028</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a2ad797d2f106217e5e17dc7746052075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad797d2f106217e5e17dc7746052075">&#9670;&nbsp;</a></span>nonlocal_vector</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;Epetra_MultiVector&gt; TrilinosWrappers::MPI::Vector::nonlocal_vector</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trilinos中的一个向量对象，用于收集非本地元素，如果该向量是用描述鬼魂元素的额外IndexSet构造的。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01034">1034</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<a id="a7ad9cd2c869cbd47284ceac109f637dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ad9cd2c869cbd47284ceac109f637dc">&#9670;&nbsp;</a></span>owned_elements</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classIndexSet.html">IndexSet</a> TrilinosWrappers::MPI::Vector::owned_elements</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个IndexSet，存储这个向量专门拥有的索引。 </p>

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8h_source.html#l01040">1040</a> of file <a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="trilinos__vector_8h_source.html">trilinos_vector.h</a></li>
<li>source/lac/<a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
