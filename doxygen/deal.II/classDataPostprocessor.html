<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataPostprocessor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataPostprocessor&lt; dim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classDataPostprocessor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataPostprocessor&lt; dim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="data__postprocessor_8h_source.html">deal.II/numerics/data_postprocessor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataPostprocessor&lt; dim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataPostprocessor__inherit__graph.svg" width="642" height="248"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4318b8e3c698851564f429ed4d1399ee"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a4318b8e3c698851564f429ed4d1399ee">~DataPostprocessor</a> () override=default</td></tr>
<tr class="separator:a4318b8e3c698851564f429ed4d1399ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07ebcf764cf911c6d78f21c32ea1d2d0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">evaluate_scalar_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a07ebcf764cf911c6d78f21c32ea1d2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba57b598d24d64365d469a854271c68"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">evaluate_vector_field</a> (const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;input_data, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;computed_quantities) const</td></tr>
<tr class="separator:a1ba57b598d24d64365d469a854271c68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a254f38bcdf4bdb5aa94231b695da7d55"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#a254f38bcdf4bdb5aa94231b695da7d55">get_names</a> () const =0</td></tr>
<tr class="separator:a254f38bcdf4bdb5aa94231b695da7d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae994223acf8a16471ab5e579a4d75053"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#ae994223acf8a16471ab5e579a4d75053">get_data_component_interpretation</a> () const</td></tr>
<tr class="separator:ae994223acf8a16471ab5e579a4d75053"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadecdd040447b395164397ea1196f721"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataPostprocessor.html#aadecdd040447b395164397ea1196f721">get_needed_update_flags</a> () const =0</td></tr>
<tr class="separator:aadecdd040447b395164397ea1196f721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim&gt;<br />
class DataPostprocessor&lt; dim &gt;</h3>

<p>该类提供了一个接口，用于计算来自解决方案的派生量，然后可以使用诸如DataOut类的设施，以图形格式输出，用于可视化。 对于FE解决方案的（图形）输出，人们经常希望包括派生量，这些派生量是由解决方案的值和可能的解决方案的第一和第二导数计算出来的。例如，在超声速流动计算中，根据速度和密度计算马赫数，或者如 <a class="el" href="step_29.html">step-29</a> 和 <a class="el" href="step_58.html">step-58</a> 中所示，计算复值解的幅度（实际上是幅度的平方）。其他的用途在 <a class="el" href="step_32.html">step-32</a> 和 <a class="el" href="step_33.html">step-33</a> 中显示。这个类提供了执行这种后处理的接口。给出解的值和导数，在我们想要生成输出的那些点上，这个类的函数可以被重载以计算新的数量。 可以给 <a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">DataOut::add_data_vector()</a> 函数提供一个数据向量和一个从当前类派生出来的对象（对DataOutRotation和DataOutFaces也是如此）。这将导致 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> 计算派生量，而不是使用数据向量提供的数据（通常是解向量）。注意，DataPostprocessor对象（即实际上是你的派生类的对象）必须活到DataOut对象被销毁为止，因为后者保持着一个指向前者的指针，如果指向的对象被销毁，而后者仍有一个指向它的指针，它就会抱怨。如果数据后处理器和DataOut对象都是一个函数的局部变量（例如，在 <a class="el" href="step_29.html">step-29</a> 中就是如此），那么你可以通过在DataOut变量之前声明数据后处理器变量来避免这个错误，因为对象的销毁顺序是相反的。 为了不进行不必要的计算，DataPostprocessor必须提供计算派生量所需的输入数据的信息，即它是否需要所提供数据的值、一阶导数和/或二阶导数。与DataOutFaces对象结合使用的DataPostprocessor对象也可以要求提供每个点的法向量。需要哪些数据的信息必须通过虚拟函数get_need_update_flags()返回的UpdateFlags来提供。你有责任在计算派生量时只使用那些被更新的值。DataOut对象将在调用evaluate_scalar_field()或evaluate_vector_field()时提供对请求数据的引用（DataOut决定调用这两个函数中的哪一个，取决于所使用的有限元是只有一个，还是有多个矢量成分；注意，这只由所使用的有限元的成分数量决定，而不是由当前派生类计算的数据是标量还是矢量值）。 此外，派生类必须实现get_names()函数，后者函数返回的输出变量的数量必须与前者返回的向量的大小相匹配。此外，这个数字还必须与计算量的数量相匹配，当然了。</p>
<h3>Use in simpler cases</h3>
<p>从当前的类派生出来，可以实现非常普遍的后处理程序。例如，在 <a class="el" href="step_32.html">step-32</a> 程序中，我们实现了一个后处理器，它接收一个由速度、压力和温度（dim+2分量）组成的解决方案，并计算出各种输出量，其中一些是矢量值，一些是标量。另一方面，在 <a class="el" href="step_29.html">step-29</a> 中，我们实现了一个后处理器，只计算由双分量有限元给出的复数的大小。为此必须实现四个虚拟函数（evaluate_scalar_field()或evaluate_vector_field()、get_names()、get_update_flags()和get_data_component_interpretation()）似乎很愚蠢。 为此，有三个类DataPostprocessorScalar、DataPostprocessorVector和DataPostprocessorTensor，如果输出量是一个单一的标量、一个单一的向量（这里用来指正好有 <code>dim</code> 个分量）或一个单一的张量（这里用来指正好有 <code>dim*dim</code> 个分量），就可以使用它们。当使用这些类时，人们只需要编写一个构造函数，将输出变量的名称和更新标志传递给基类的构造函数，并重载实际计算结果的函数。 DataPostprocessorVector和DataPostprocessorTensor类的文档也包含了大量关于如何使用它们的例子。 <a class="el" href="step_29.html">step-29</a> 教程程序包含了一个使用DataPostprocessorScalar类的例子。</p>
<h3>Complex-valued solutions</h3>
<p>有一些PDEs的解是复值的。例如， <a class="el" href="step_58.html">step-58</a> 和 <a class="el" href="step_62.html">step-62</a> 解决的问题，其每一点的解都是由一个 <code>std::complex&lt;double&gt;</code> 变量代表的复数组成。( <a class="el" href="step_29.html">step-29</a> 也解决了这样的问题，但在那里我们选择用两个实值场来表示解。) 在这种情况下，交给 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> 的向量是 <code><a class="el" href="classVector.html">Vector</a>&lt;std::complex&lt;double&gt;&gt;</code>, 类型或基本等同于此的东西。这方面的问题，在DataOut本身的文档中也讨论过，最广泛使用的可视化文件格式（特别是VTK和VTU格式）实际上不能表示复数量。在这些数据文件中唯一可以存储的是实值量。 因此，DataOut被迫将事物拆成实数和虚数部分，并将两者作为单独的量输出。这是由DataOut直接写入文件的数据的情况，但它也是首先通过DataPostprocessor对象（或其派生类的对象）的情况。这些对象所看到的都是实值的集合，即使底层的解决方案向量是复值的。 所有这些都有两个含义。</p>
<ul>
<li>如果一个求解向量是复值的，那么这就导致在每个评估点至少有两个输入分量。因此， <a class="el" href="classDataPostprocessor.html#a07ebcf764cf911c6d78f21c32ea1d2d0">DataPostprocessor::evaluate_scalar_field()</a> 函数永远不会被调用，即使底层有限元只有一个解分量。相反，DataOut将一直*调用 <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a>. 。</li>
<li>派生类中的 <a class="el" href="classDataPostprocessor.html#a1ba57b598d24d64365d469a854271c68">DataPostprocessor::evaluate_vector_field()</a> 的实现必须理解解值是如何安排在他们作为输入收到的 <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a> 对象中。 这里的规则是。如果有限元有 \(N\) 矢量成分（包括 \(N=1\) 的情况，即标量元素），那么复值解向量的输入将有 \(2N\) 成分。这些分量首先包含所有求解分量的实部的值（或梯度，或Hessians），然后是所有求解分量的虚部的值（或梯度，或Hessians）。 <a class="el" href="step_58.html">step-58</a> 提供了一个例子，说明这个类（或者说，派生的DataPostprocessorScalar类）是如何在复值情况下使用。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8h_source.html#l00341">341</a> of file <a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4318b8e3c698851564f429ed4d1399ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4318b8e3c698851564f429ed4d1399ee">&#9670;&nbsp;</a></span>~DataPostprocessor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::~<a class="el" href="classDataPostprocessor.html">DataPostprocessor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>销毁器。这个函数实际上不做任何事情，但被标记为虚拟，以确保数据后处理器可以通过指向基类的指针被销毁。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a07ebcf764cf911c6d78f21c32ea1d2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07ebcf764cf911c6d78f21c32ea1d2d0">&#9670;&nbsp;</a></span>evaluate_scalar_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_scalar_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Scalar.html">DataPostprocessorInputs::Scalar</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是个主函数，实际执行后处理。第二个参数是对后处理数据的引用，它已经有了正确的大小，必须由这个函数来填充。 该函数通过第一个参数获取所有评估点的解的值、梯度和高阶导数，以及其他数据，如单元格。并非这个参数的所有成员向量都会被填充数据</p>
<ul>
<li>事实上，只有当相应的标志被get_need_update_flags()函数（在用户的派生类中实现）的覆盖版本返回时，导数和其他数量才会包含有效的数据。 否则，这些向量将处于一个未指定的状态。 当被DataOut或类似类转换为图形数据的有限元字段代表标量数据时，即如果使用的有限元只有一个实值矢量分量，则调用此函数。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00026">26</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a1ba57b598d24d64365d469a854271c68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba57b598d24d64365d469a854271c68">&#9670;&nbsp;</a></span>evaluate_vector_field()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::evaluate_vector_field </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structDataPostprocessorInputs_1_1Vector.html">DataPostprocessorInputs::Vector</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>input_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>computed_quantities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与evaluate_scalar_field()函数相同，但当原始数据矢量代表矢量数据，即使用中的有限元有多个矢量分量时，该函数被调用。如果有限元是标量的，但是解向量是复值的，也会调用这个函数。如果要可视化的解向量是复值的（无论标量与否），那么输入数据首先包含解向量在每个评估点的所有实部，然后是所有虚部。 </p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00037">37</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="a254f38bcdf4bdb5aa94231b695da7d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a254f38bcdf4bdb5aa94231b695da7d55">&#9670;&nbsp;</a></span>get_names()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回描述计算量名称的字符串向量。 </p>

<p>Implemented in <a class="el" href="classDataPostprocessorTensor.html#a90a96637bbaa3011861981e98e8a5aa7">DataPostprocessorTensor&lt; dim &gt;</a>, <a class="el" href="classDataPostprocessorVector.html#a350aec4ea84ab349ce6813f4a76d75cb">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#a8b7dcc04f50dbd68419c3707dec1d502">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="ae994223acf8a16471ab5e579a4d75053"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae994223acf8a16471ab5e579a4d75053">&#9670;&nbsp;</a></span>get_data_component_interpretation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_data_component_interpretation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数返回关于如何解释由一个以上数据集组成的输出文件的各个组成部分的信息。 例如，如果一个人有一个2d的斯托克斯方程的有限元，代表分量（u,v,p），我们希望表明前两个，u和v，代表一个逻辑矢量，这样以后当我们生成图形输出时，我们可以把它们交给一个可视化程序，该程序将自动知道把它们作为一个矢量场来渲染，而不是作为两个独立的标量场。 这个函数的默认实现返回一个值的向量 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, ，表示所有的输出组件都是独立的标量场。然而，如果一个派生类产生的数据表示向量，它可以返回一个包含数值的向量 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. 在上面的例子中，对于(u,v,p)，人们会返回一个包含组件 (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) 的向量。 </p>

<p>Reimplemented in <a class="el" href="classDataPostprocessorTensor.html#a9d4da33ead3f195ab7475ced4cf05a10">DataPostprocessorTensor&lt; dim &gt;</a>, <a class="el" href="classDataPostprocessorVector.html#ad54b87c6838f11069cdee5cc387f8959">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#ad4b6672eeffa2cea792f60370f02244e">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

<p class="definition">Definition at line <a class="el" href="data__postprocessor_8cc_source.html#l00048">48</a> of file <a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a>.</p>

</div>
</div>
<a id="aadecdd040447b395164397ea1196f721"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadecdd040447b395164397ea1196f721">&#9670;&nbsp;</a></span>get_needed_update_flags()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a> <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; dim &gt;::get_needed_update_flags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回，必须提供哪些数据来计算派生量。 这必须是 <code>update_values</code>, <code>update_gradients</code>, <code>update_hessians</code> 和 <code>update_quadrature_points</code>. 的组合。注意，标志 <code>update_quadrature_points</code> 更新 <a class="el" href="structDataPostprocessorInputs_1_1CommonInputs.html#a9941db2917f9b597d25fa6e60bb2d2ec">DataPostprocessorInputs::CommonInputs::evaluation_points</a>. 如果DataPostprocessor要与DataOutFaces结合使用，你也可以通过 <code>update_normal_vectors</code> 标志要求更新法线。 这些标志的描述可以在 <a class="el" href="group__feaccess.html#gaa94b67d2fdcc390690c523f28019e52f">UpdateFlags</a>. 中找到。 </p>

<p>Implemented in <a class="el" href="classDataPostprocessorTensor.html#aaf55a054599aac4956ea3752b9e349ae">DataPostprocessorTensor&lt; dim &gt;</a>, <a class="el" href="classDataPostprocessorVector.html#a448822561480fa0ed83e94c8953c0ae7">DataPostprocessorVector&lt; dim &gt;</a>, and <a class="el" href="classDataPostprocessorScalar.html#a8d6a7b1ae63fe9689b48fcae27757a48">DataPostprocessorScalar&lt; dim &gt;</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="data__postprocessor_8h_source.html">data_postprocessor.h</a></li>
<li>source/numerics/<a class="el" href="data__postprocessor_8cc_source.html">data_postprocessor.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
