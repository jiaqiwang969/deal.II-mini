<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSUNDIALS_1_1IDA.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SUNDIALS::IDA&lt; VectorType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a></li><li class="navelem"><a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSUNDIALS_1_1IDA-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SUNDIALS::IDA&lt; VectorType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ida_8h_source.html">deal.II/sundials/ida.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a6b32226d589c5daeae7da5743541e0fc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a6b32226d589c5daeae7da5743541e0fc">IDA</a> (const <a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a> &amp;<a class="el" href="classSUNDIALS_1_1IDA.html#a43c2bcf05ea0708fa48cd3753c52cd1f">data</a>=<a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a>(), const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_comm=MPI_COMM_WORLD)</td></tr>
<tr class="separator:a6b32226d589c5daeae7da5743541e0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89293a7489a9b4e2a4485496476bb841"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a89293a7489a9b4e2a4485496476bb841">~IDA</a> ()</td></tr>
<tr class="separator:a89293a7489a9b4e2a4485496476bb841"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf08b8f950f0ceae93e36572fe68f6c"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a1bf08b8f950f0ceae93e36572fe68f6c">solve_dae</a> (<a class="el" href="classVectorType.html">VectorType</a> &amp;solution, <a class="el" href="classVectorType.html">VectorType</a> &amp;solution_dot)</td></tr>
<tr class="separator:a1bf08b8f950f0ceae93e36572fe68f6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455ea8c99f97bb9e2b922ebf949aa9c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a455ea8c99f97bb9e2b922ebf949aa9c5">reset</a> (const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classdouble.html">double</a> h, <a class="el" href="classVectorType.html">VectorType</a> &amp;y, <a class="el" href="classVectorType.html">VectorType</a> &amp;yp)</td></tr>
<tr class="separator:a455ea8c99f97bb9e2b922ebf949aa9c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e85c5a918ef8fa0ec3aa34410ccb871"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a5e85c5a918ef8fa0ec3aa34410ccb871">DeclException1</a> (ExcIDAError, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;One of the SUNDIALS <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> internal functions &quot;&lt;&lt; &quot; returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;)</td></tr>
<tr class="separator:a5e85c5a918ef8fa0ec3aa34410ccb871"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aced6949ce8865d9d82259c283358898a"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#aced6949ce8865d9d82259c283358898a">reinit_vector</a></td></tr>
<tr class="separator:aced6949ce8865d9d82259c283358898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78b91eaafef6bd96ce4795b06dae791f"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y_dot, <a class="el" href="classVectorType.html">VectorType</a> &amp;res)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a78b91eaafef6bd96ce4795b06dae791f">residual</a></td></tr>
<tr class="separator:a78b91eaafef6bd96ce4795b06dae791f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c4ded920ff794a03324465edcc7b83e"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y_dot, const <a class="el" href="classdouble.html">double</a> alpha)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian</a></td></tr>
<tr class="separator:a8c4ded920ff794a03324465edcc7b83e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02db69ba06c11374048eda8faf8eca96"><td class="memItemLeft" align="right" valign="top"><a class="el" href="config_8h.html#a31651bfd4404c3cd66729f29b0ed36c4">DEAL_II_DEPRECATED</a> std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a02db69ba06c11374048eda8faf8eca96">solve_jacobian_system</a></td></tr>
<tr class="separator:a02db69ba06c11374048eda8faf8eca96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad44e912a96bfae82c9fa16de638d06ce"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classdouble.html">double</a> tolerance)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#ad44e912a96bfae82c9fa16de638d06ce">solve_with_jacobian</a></td></tr>
<tr class="separator:ad44e912a96bfae82c9fa16de638d06ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a861e344f1a36a87ff575f2d7d4c9d1d9"><td class="memItemLeft" align="right" valign="top">std::function&lt; void(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;sol, const <a class="el" href="classVectorType.html">VectorType</a> &amp;sol_dot, const unsigned <a class="el" href="classint.html">int</a> step_number)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a861e344f1a36a87ff575f2d7d4c9d1d9">output_step</a></td></tr>
<tr class="separator:a861e344f1a36a87ff575f2d7d4c9d1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88e30f20f68db8208a5095dac8b55c06"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classbool.html">bool</a>(const <a class="el" href="classdouble.html">double</a> t, <a class="el" href="classVectorType.html">VectorType</a> &amp;sol, <a class="el" href="classVectorType.html">VectorType</a> &amp;sol_dot)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a88e30f20f68db8208a5095dac8b55c06">solver_should_restart</a></td></tr>
<tr class="separator:a88e30f20f68db8208a5095dac8b55c06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d3e3210adcead3f3aee298fdf11955f"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classIndexSet.html">IndexSet</a>()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a5d3e3210adcead3f3aee298fdf11955f">differential_components</a></td></tr>
<tr class="separator:a5d3e3210adcead3f3aee298fdf11955f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79fada696e3f8468bf5f8e8f1e54f9ea"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a79fada696e3f8468bf5f8e8f1e54f9ea">get_local_tolerances</a></td></tr>
<tr class="separator:a79fada696e3f8468bf5f8e8f1e54f9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a614ec632102a65b6331478a3e432a3b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a614ec632102a65b6331478a3e432a3b6">DeclException1</a> (ExcFunctionNotProvided, std::string,&lt;&lt; &quot;Please provide an implementation for the function &lt;&lt; arg1&lt;&lt; &quot;\&quot;)</td></tr>
<tr class="separator:a614ec632102a65b6331478a3e432a3b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a364c774e9357185d99a3f3c570d961b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a364c774e9357185d99a3f3c570d961b9">set_functions_to_trigger_an_assert</a> ()</td></tr>
<tr class="separator:a364c774e9357185d99a3f3c570d961b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a43c2bcf05ea0708fa48cd3753c52cd1f"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a43c2bcf05ea0708fa48cd3753c52cd1f">data</a></td></tr>
<tr class="separator:a43c2bcf05ea0708fa48cd3753c52cd1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81db920117132c3699973bda1d3eeeff"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#a81db920117132c3699973bda1d3eeeff">ida_mem</a></td></tr>
<tr class="separator:a81db920117132c3699973bda1d3eeeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92aacc6fb63cebf839520142ca4eaf2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#ae92aacc6fb63cebf839520142ca4eaf2">communicator</a></td></tr>
<tr class="separator:ae92aacc6fb63cebf839520142ca4eaf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88b7fa23845ada839700f552f910cfd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSUNDIALS_1_1IDA.html#ac88b7fa23845ada839700f552f910cfd">mem</a></td></tr>
<tr class="separator:ac88b7fa23845ada839700f552f910cfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename VectorType = Vector&lt;double&gt;&gt;<br />
class SUNDIALS::IDA&lt; VectorType &gt;</h3>

<p>Interface to <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> Implicit Differential-Algebraic (<a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a>) solver.</p>
<p>The class <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> is a wrapper to <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> Implicit Differential-Algebraic solver which is a general purpose solver for systems of Differential-Algebraic Equations (DAEs).</p>
<p>The user has to provide the implementation of the following std::functions:</p><ul>
<li>reinit_vector;</li>
<li>residual;</li>
<li>setup_jacobian;</li>
<li>solve_jacobian_system/solve_with_jacobian;</li>
</ul>
<p>The function <code>solve_jacobian_system</code> should be implemented for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> &lt; 4.0.0. For later versions, you should use <code>solve_with_jacobian</code> to leverage better non-linear algorithms.</p>
<p>Optionally, also the following functions could be provided. By default they do nothing, or are not required. If you call the constructor in a way that requires a not-implemented function, an Assertion will be thrown.</p><ul>
<li>solver_should_restart;</li>
<li>differential_components;</li>
<li>get_local_tolerances;</li>
</ul>
<p>To output steps, connect a function to the signal</p><ul>
<li>output_step;</li>
</ul>
<p>Citing from the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> documentation:</p>
<p>Consider a system of Differential-Algebraic Equations written in the general form</p>
<p class="formulaDsp">
\[ \begin{cases} F(t,y,\dot y) = 0\, , \\ y(t_0) = y_0\, , \\ \dot y (t_0) = \dot y_0\, . \end{cases} \]
</p>
<p>where \(y,\dot y\) are vectors in \(\mathbb{R}^n\), \(t\) is often the time (but can also be a parametric quantity), and \(F:\mathbb{R}\times\mathbb{R}^n\times \mathbb{R}^n\rightarrow\mathbb{R}^n\). Such problem is solved using Newton iteration augmented with a line search global strategy. The integration method used in <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> is the variable-order, variable-coefficient BDF (Backward <a class="el" href="namespaceDifferentiation.html">Differentiation</a> Formula), in fixed-leading-coefficient. The method order ranges from 1 to 5, with the BDF of order \(q\) given by the multistep formula</p>
<p class="formulaDsp">
\[ \sum_{i=0}^q \alpha_{n,i}\,y_{n-i}=h_n\,\dot y_n\, , \label{eq:bdf} \]
</p>
<p>where \(y_n\) and \(\dot y_n\) are the computed approximations of \(y(t_n)\) and \(\dot y(t_n)\), respectively, and the step size is \(h_n=t_n-t_{n-1}\). The coefficients \(\alpha_{n,i}\) are uniquely determined by the order \(q\), and the history of the step sizes. The application of the BDF method to the DAE system results in a nonlinear algebraic system to be solved at each time step:</p>
<p class="formulaDsp">
\[ G(y_n)\equiv F\left(t_n,y_n,\dfrac{1}{h_n}\sum_{i=0}^q \alpha_{n,i}\,y_{n-i}\right)=0\, . \]
</p>
<p> The Newton method leads to a linear system of the form </p><p class="formulaDsp">
\[ J[y_{n(m+1)}-y_{n(m)}]=-G(y_{n(m)})\, , \]
</p>
<p>where \(y_{n(m)}\) is the \(m\)-th approximation to \(y_n\), and \(J\) is the approximation of the system Jacobian</p>
<p class="formulaDsp">
\[ J=\dfrac{\partial G}{\partial y} = \dfrac{\partial F}{\partial y} + \alpha \dfrac{\partial F}{\partial \dot y}\, , \]
</p>
<p>and \(\alpha = \alpha_{n,0}/h_n\). It is worth mentioning that the scalar \(\alpha\) changes whenever the step size or method order changes.</p>
<p>To provide a simple example, consider the following harmonic oscillator problem: </p><p class="formulaDsp">
\[ \begin{split} u&#39;&#39; &amp; = -k^2 u \\ u (0) &amp; = 0 \\ u&#39;(0) &amp; = k \end{split} \]
</p>
<p>We write it in terms of a first order ode: </p><p class="formulaDsp">
\[ \begin{matrix} y_0&#39; &amp; -y_1 &amp; = 0 \\ y_1&#39; &amp; + k^2 y_0 &amp; = 0 \end{matrix} \]
</p>
<p>That is \(F(y&#39;, y, t) = y&#39; + A y = 0 \) where </p><p class="formulaDsp">
\[ \begin{matrix} 0 &amp; -1 \\ k^2 &amp;0 \end{matrix} \]
</p>
<p> and \(y(0)=(0, k)\), \(y&#39;(0) = (k, 0)\).</p>
<p>The exact solution is \(y_0(t) = \sin(k t)\), \(y_1(t) = y_0&#39;(t) = k \cos(k *t)\), \(y_1&#39;(t) = -k^2 \sin(k t)\).</p>
<p>The Jacobian to assemble is the following: \(J = \alpha I + A\).</p>
<p>This is achieved by the following snippet of code: </p><div class="fragment"><div class="line"><span class="keyword">using</span> <a class="code" href="classVectorType.html">VectorType</a> = <a class="code" href="classVector.html">Vector&lt;double&gt;</a>;</div><div class="line"></div><div class="line"><a class="code" href="classVectorType.html">VectorType</a> y(2);</div><div class="line"><a class="code" href="classVectorType.html">VectorType</a> y_dot(2);</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> kappa = 1.0;</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(2,2);</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(0,1) = -1.0;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(1,0) = kappa*kappa;</div><div class="line"></div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> J(2,2);</div><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> Jinv(2,2);</div><div class="line"></div><div class="line"><a class="code" href="classSUNDIALS_1_1IDA.html#a6b32226d589c5daeae7da5743541e0fc">IDA</a> time_stepper;</div><div class="line"></div><div class="line">time_stepper.reinit_vector = [&amp;] (<a class="code" href="classVectorType.html">VectorType</a>&amp;v)</div><div class="line">{</div><div class="line">  v.reinit(2);</div><div class="line">};</div><div class="line"></div><div class="line">time_stepper.residual = [&amp;](<span class="keyword">const</span> <span class="keywordtype">double</span> t,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;y,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;y_dot,</div><div class="line">                            <a class="code" href="classVectorType.html">VectorType</a> &amp;res) -&gt;<span class="keywordtype">int</span></div><div class="line">{</div><div class="line">  res = y_dot;</div><div class="line">  <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>.vmult_add(res, y);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">};</div><div class="line"></div><div class="line">time_stepper.setup_jacobian = [&amp;](<span class="keyword">const</span> <a class="code" href="classdouble.html">double</a> ,</div><div class="line">                                  <span class="keyword">const</span> <a class="code" href="classVectorType.html">VectorType</a> &amp;,</div><div class="line">                                  <span class="keyword">const</span> VectorType &amp;,</div><div class="line">                                  <span class="keyword">const</span> <span class="keywordtype">double</span> alpha) -&gt;<span class="keywordtype">int</span></div><div class="line">{</div><div class="line">  J = <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>;</div><div class="line"></div><div class="line">  J(0,0) = alpha;</div><div class="line">  J(1,1) = alpha;</div><div class="line"></div><div class="line">  Jinv.invert(J);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">};</div><div class="line"></div><div class="line">time_stepper.solve_jacobian_system = [&amp;](<span class="keyword">const</span> VectorType &amp;src,</div><div class="line">                                         VectorType &amp;dst) -&gt;<span class="keywordtype">int</span></div><div class="line">{</div><div class="line">  Jinv.vmult(dst,src);</div><div class="line">  <span class="keywordflow">return</span> 0;</div><div class="line">};</div><div class="line"></div><div class="line">y[1] = kappa;</div><div class="line">y_dot[0] = kappa;</div><div class="line">time_stepper.solve_dae(y,y_dot);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00239">239</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a6b32226d589c5daeae7da5743541e0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b32226d589c5daeae7da5743541e0fc">&#9670;&nbsp;</a></span>IDA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::<a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em> = <code><a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_comm</em> = <code>MPI_COMM_WORLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. It is possible to fine tune the <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> solver by passing an AdditionalData() object that sets all of the solver parameters.</p>
<p><a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> is a Differential Algebraic solver. As such, it requires initial conditions also for the first order derivatives. If you do not provide consistent initial conditions, (i.e., conditions for which F(y_dot(0), y(0), 0) = 0), you can ask <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> to compute initial conditions for you by using the <code>ic_type</code> parameter at construction time.</p>
<p>You have three options</p><ul>
<li>none: do not try to make initial conditions consistent.</li>
<li>use_y_diff: compute the algebraic components of y and differential components of y_dot, given the differential components of y. This option requires that the user specifies differential and algebraic components in the function get_differential_components.</li>
<li>use_y_dot: compute all components of y, given y_dot.</li>
</ul>
<p>By default, this class assumes that all components are differential, and that you want to solve a standard ode. In this case, the initial component type is set to <code>use_y_diff</code>, so that the <code>y_dot</code> at time t=<code>initial_time</code> is computed by solving the nonlinear problem \(F(y_dot, y(t0), t0) = 0\) in the variable <code>y_dot</code>.</p>
<p>Notice that a Newton solver is used for this computation. The Newton solver parameters can be tweaked by acting on <code>ic_alpha</code> and <code>ic_max_iter</code>.</p>
<p>If you reset the solver at some point, you may want to select a different computation for the initial conditions after reset. Say, for example, that you have refined a grid, and after transferring the solution to the new grid, the initial conditions are no longer consistent. Then you can choose how these are made consistent, using the same three options that you used for the initial conditions in <code>reset_type</code>.</p>
<p>The MPI communicator is simply ignored in the serial case.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td><a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> configuration data </td></tr>
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a89293a7489a9b4e2a4485496476bb841"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89293a7489a9b4e2a4485496476bb841">&#9670;&nbsp;</a></span>~IDA()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::~<a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1bf08b8f950f0ceae93e36572fe68f6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf08b8f950f0ceae93e36572fe68f6c">&#9670;&nbsp;</a></span>solve_dae()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_dae </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution_dot</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Integrate differential-algebraic equations. This function returns the final number of computed steps. </p>

</div>
</div>
<a id="a455ea8c99f97bb9e2b922ebf949aa9c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455ea8c99f97bb9e2b922ebf949aa9c5">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::reset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>yp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear internal memory and start with clean objects. This function is called when the simulation start and when the user returns true to a call to <a class="el" href="classSUNDIALS_1_1IDA.html#a88e30f20f68db8208a5095dac8b55c06">solver_should_restart()</a>.</p>
<p>By default <a class="el" href="classSUNDIALS_1_1IDA.html#a88e30f20f68db8208a5095dac8b55c06">solver_should_restart()</a> returns false. If the user needs to implement, for example, local adaptivity in space, he or she may assign a different function to <a class="el" href="classSUNDIALS_1_1IDA.html#a88e30f20f68db8208a5095dac8b55c06">solver_should_restart()</a> that performs all mesh changes, transfers the solution and the solution dot to the new mesh, and returns true.</p>
<p>During <a class="el" href="classSUNDIALS_1_1IDA.html#a455ea8c99f97bb9e2b922ebf949aa9c5">reset()</a>, both y and yp are checked for consistency, and according to what was specified as ic_type (if t==initial_time) or reset_type (if t&gt;initial_time), yp, y, or both are modified to obtain a consistent set of initial data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">t</td><td>The new starting time </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">h</td><td>The new (tentative) starting time step </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">y</td><td>The new (tentative) initial solution </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">yp</td><td>The new (tentative) initial solution_dot </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e85c5a918ef8fa0ec3aa34410ccb871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e85c5a918ef8fa0ec3aa34410ccb871">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcIDAError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;One of the SUNDIALS <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; internal functions &quot;&lt;&lt; &quot; returned a negative error code: &quot;&lt;&lt; arg1&lt;&lt; &quot;. Please consult SUNDIALS manual.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Handle <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> exceptions. </p>

</div>
</div>
<a id="a614ec632102a65b6331478a3e432a3b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ec632102a65b6331478a3e432a3b6">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcFunctionNotProvided&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Please provide an implementation for the function \ arg1&lt;&lt; &quot;\&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Throw an exception when a function with the given name is not implemented. </p>

</div>
</div>
<a id="a364c774e9357185d99a3f3c570d961b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a364c774e9357185d99a3f3c570d961b9">&#9670;&nbsp;</a></span>set_functions_to_trigger_an_assert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::set_functions_to_trigger_an_assert </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function is executed at construction time to set the std::function above to trigger an assert if they are not implemented. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aced6949ce8865d9d82259c283358898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aced6949ce8865d9d82259c283358898a">&#9670;&nbsp;</a></span>reinit_vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(<a class="el" href="classVectorType.html">VectorType</a> &amp;)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::reinit_vector</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinit vector to have the right size, MPI communicator, etc. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00644">644</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a78b91eaafef6bd96ce4795b06dae791f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78b91eaafef6bd96ce4795b06dae791f">&#9670;&nbsp;</a></span>residual</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y_dot, <a class="el" href="classVectorType.html">VectorType</a> &amp; res)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::residual</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute residual. Return \(F(t, y, \dot y)\).</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (IDAReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00660">660</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a8c4ded920ff794a03324465edcc7b83e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c4ded920ff794a03324465edcc7b83e">&#9670;&nbsp;</a></span>setup_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y, const <a class="el" href="classVectorType.html">VectorType</a> &amp;y_dot, const <a class="el" href="classdouble.html">double</a> alpha)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::setup_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute Jacobian. This function is called by <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> any time a Jacobian update is required. The user should compute the Jacobian (or update all the variables that allow the application of the Jacobian). This function is called by <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> once, before any call to <a class="el" href="classSUNDIALS_1_1IDA.html#a02db69ba06c11374048eda8faf8eca96">solve_jacobian_system()</a> (for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> &lt; 4.0.0) or <a class="el" href="classSUNDIALS_1_1IDA.html#ad44e912a96bfae82c9fa16de638d06ce">solve_with_jacobian()</a> (for <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> &gt;= 4.0.0).</p>
<p>The Jacobian \(J\) should be a (possibly inexact) computation of </p><p class="formulaDsp">
\[ J=\dfrac{\partial G}{\partial y} = \dfrac{\partial F}{\partial y} + \alpha \dfrac{\partial F}{\partial \dot y}. \]
</p>
<p>If the user uses a matrix based computation of the Jacobian, than this is the right place where an assembly routine should be called to assemble both a matrix and a preconditioner for the Jacobian system. Subsequent calls (possibly more than one) to <a class="el" href="classSUNDIALS_1_1IDA.html#a02db69ba06c11374048eda8faf8eca96">solve_jacobian_system()</a> or <a class="el" href="classSUNDIALS_1_1IDA.html#ad44e912a96bfae82c9fa16de638d06ce">solve_with_jacobian()</a> can assume that this function has been called at least once.</p>
<p>Notice that no assumption is made by this interface on what the user should do in this function. <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> only assumes that after a call to <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> it is possible to call <a class="el" href="classSUNDIALS_1_1IDA.html#a02db69ba06c11374048eda8faf8eca96">solve_jacobian_system()</a> or <a class="el" href="classSUNDIALS_1_1IDA.html#ad44e912a96bfae82c9fa16de638d06ce">solve_with_jacobian()</a> to obtain a solution \(x\) to the system \(J x = b\).</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (IDAReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00700">700</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a02db69ba06c11374048eda8faf8eca96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02db69ba06c11374048eda8faf8eca96">&#9670;&nbsp;</a></span>solve_jacobian_system</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="config_8h.html#a31651bfd4404c3cd66729f29b0ed36c4">DEAL_II_DEPRECATED</a> std::function&lt;<a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_jacobian_system</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the Jacobian linear system. This function will be called by <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> the minimum amount of times. If convergence can be achieved without updating the Jacobian, then <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> does not call <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> again. If, on the contrary, internal <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> convergence tests fail, then <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> calls again <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> with updated vectors and coefficients so that successive calls to solve_jacobian_systems() lead to better convergence in the Newton process.</p>
<p>The jacobian \(J\) should be (an approximation of) the system Jacobian </p><p class="formulaDsp">
\[ J=\dfrac{\partial G}{\partial y} = \dfrac{\partial F}{\partial y} + \alpha \dfrac{\partial F}{\partial \dot y}. \]
</p>
<p>A call to this function should store in <code>dst</code> the result of \(J^{-1}\) applied to <code>src</code>, i.e., <code>J*dst = src</code>. It is the users responsibility to set up proper solvers and preconditioners inside this function.</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (IDAReinit will be called if this happens, and then last function will be attempted again</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown.</li>
</ul>
<dl class="section warning"><dt>Warning</dt><dd>Starting with <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> 4.1, <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> provides the possibility of specifying the tolerance for the resolution. A part from the tolerance only <code>rhs</code> is provided and <code>dst</code> needs to be returned. </dd></dl>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00736">736</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="ad44e912a96bfae82c9fa16de638d06ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad44e912a96bfae82c9fa16de638d06ce">&#9670;&nbsp;</a></span>solve_with_jacobian</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt; <a class="el" href="classint.html">int</a>(const <a class="el" href="classVectorType.html">VectorType</a> &amp;rhs, <a class="el" href="classVectorType.html">VectorType</a> &amp;dst, const <a class="el" href="classdouble.html">double</a> tolerance)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solve_with_jacobian</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Solve the Jacobian linear system up to a specified tolerance. This function will be called by <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> (possibly several times) after <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> has been called at least once. <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> tries to do its best to call <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> the minimum number of times. If convergence can be achieved without updating the Jacobian, then <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> does not call <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> again. If, on the contrary, internal <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> convergence tests fail, then <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> calls again <a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a> with updated vectors and coefficients so that successive calls to <a class="el" href="classSUNDIALS_1_1IDA.html#ad44e912a96bfae82c9fa16de638d06ce">solve_with_jacobian()</a> lead to better convergence in the Newton process.</p>
<p>The Jacobian \(J\) should be (an approximation of) the system Jacobian </p><p class="formulaDsp">
\[ J=\dfrac{\partial G}{\partial y} = \dfrac{\partial F}{\partial y} + \alpha \dfrac{\partial F}{\partial \dot y}. \]
</p>
<p>Arguments to the function are:</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">rhs</td><td>The system right hand side to solve for. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">dst</td><td>The solution of \(J^{-1} * src\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">tolerance</td><td>The tolerance with which to solve the linear system of equations.</td></tr>
  </table>
  </dd>
</dl>
<p>A call to this function should store in <code>dst</code> the result of \(J^{-1}\) applied to <code>src</code>, i.e., the solution of the linear system <code>J*dst = src</code>. It is the user's responsibility to set up proper solvers and preconditioners either inside this function, or already within the <code><a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a></code> function. (The latter is, for example, what the step-77 program does: All expensive operations happen in <code><a class="el" href="classSUNDIALS_1_1IDA.html#a8c4ded920ff794a03324465edcc7b83e">setup_jacobian()</a></code>, given that that function is called far less often than the current one.)</p>
<p>This function should return:</p><ul>
<li>0: Success</li>
<li>&gt;0: Recoverable error (IDAReinit will be called if this happens, and then the last function will be attempted again).</li>
<li>&lt;0: Unrecoverable error the computation will be aborted and an assertion will be thrown. </li>
</ul>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00781">781</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a861e344f1a36a87ff575f2d7d4c9d1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a861e344f1a36a87ff575f2d7d4c9d1d9">&#9670;&nbsp;</a></span>output_step</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const <a class="el" href="classdouble.html">double</a> t, const <a class="el" href="classVectorType.html">VectorType</a> &amp; sol, const <a class="el" href="classVectorType.html">VectorType</a> &amp; sol_dot, const unsigned <a class="el" href="classint.html">int</a> step_number)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::output_step</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Process solution. This function is called by <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> at fixed time steps, every <code>output_period</code> seconds, and it is passed a polynomial interpolation of the solution and of its time derivative, computed using the current BDF order and the (internally stored) previously computed solution steps.</p>
<p>Notice that it is well possible that internally <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> computes a time step which is much larger than the <code>output_period</code> step, and therefore calls this function consecutively several times by simply performing all intermediate interpolations. There is no relationship between how many times this function is called and how many time steps have actually been computed. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00801">801</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a88e30f20f68db8208a5095dac8b55c06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88e30f20f68db8208a5095dac8b55c06">&#9670;&nbsp;</a></span>solver_should_restart</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classbool.html">bool</a>(const <a class="el" href="classdouble.html">double</a> t, <a class="el" href="classVectorType.html">VectorType</a> &amp;sol, <a class="el" href="classVectorType.html">VectorType</a> &amp;sol_dot)&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::solver_should_restart</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Evaluate whether the solver should be restarted (for example because the number of degrees of freedom has changed).</p>
<p>This function is supposed to perform all operations that are necessary in <code>sol</code> and <code>sol_dot</code> to make sure that the resulting vectors are consistent, and of the correct final size.</p>
<p>For example, one may decide that a local refinement is necessary at time t. This function should then return true, and change the dimension of both sol and sol_dot to reflect the new dimension. Since <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> does not know about the new dimension, an internal reset is necessary.</p>
<p>The default implementation simply returns <code>false</code>, i.e., no restart is performed during the evolution. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00820">820</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a5d3e3210adcead3f3aee298fdf11955f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d3e3210adcead3f3aee298fdf11955f">&#9670;&nbsp;</a></span>differential_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classIndexSet.html">IndexSet</a>()&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::differential_components</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an index set containing the differential components. Implementation of this function is optional. The default is to return a complete index set. If your equation is also algebraic (i.e., it contains algebraic constraints, or Lagrange multipliers), you should overwrite this function in order to return only the differential components of your system.</p>
<p>When running in parallel, every process will call this function independently, and synchronization will happen at the end of the initialization setup to communicate what components are local. Make sure you only return the locally owned (or locally relevant) components, in order to minimize communication between processes. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00836">836</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a79fada696e3f8468bf5f8e8f1e54f9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79fada696e3f8468bf5f8e8f1e54f9ea">&#9670;&nbsp;</a></span>get_local_tolerances</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classVectorType.html">VectorType</a> &amp;()&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::get_local_tolerances</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a vector whose components are the weights used by <a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> to compute the vector norm. The implementation of this function is optional. If the user does not provide an implementation, the weights are assumed to be all ones. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00844">844</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a43c2bcf05ea0708fa48cd3753c52cd1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c2bcf05ea0708fa48cd3753c52cd1f">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSUNDIALS_1_1IDA_1_1AdditionalData.html">AdditionalData</a> <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> configuration data. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00877">877</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="a81db920117132c3699973bda1d3eeeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81db920117132c3699973bda1d3eeeff">&#9670;&nbsp;</a></span>ida_mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void* <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::ida_mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classSUNDIALS_1_1IDA.html">IDA</a> memory object. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00882">882</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="ae92aacc6fb63cebf839520142ca4eaf2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92aacc6fb63cebf839520142ca4eaf2">&#9670;&nbsp;</a></span>communicator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::communicator</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>MPI communicator. <a class="el" href="namespaceSUNDIALS.html">SUNDIALS</a> solver runs happily in parallel. Note that if the library is compiled without MPI support, MPI_Comm is aliased as int. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00889">889</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<a id="ac88b7fa23845ada839700f552f910cfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac88b7fa23845ada839700f552f910cfd">&#9670;&nbsp;</a></span>mem</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename VectorType  = Vector&lt;double&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classGrowingVectorMemory.html">GrowingVectorMemory</a>&lt;<a class="el" href="classVectorType.html">VectorType</a>&gt; <a class="el" href="classSUNDIALS_1_1IDA.html">SUNDIALS::IDA</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt;::mem</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Memory pool of vectors. </p>

<p class="definition">Definition at line <a class="el" href="ida_8h_source.html#l00894">894</a> of file <a class="el" href="ida_8h_source.html">ida.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/sundials/<a class="el" href="ida_8h_source.html">ida.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
