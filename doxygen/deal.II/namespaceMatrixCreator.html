<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceMatrixCreator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixCreator Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixCreator Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aab6397f114af66efd781f7f4daba22be"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aab6397f114af66efd781f7f4daba22be"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">create_mass_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:aab6397f114af66efd781f7f4daba22be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab541c8fb2af765ed331ab9e6ce090d12"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ab541c8fb2af765ed331ab9e6ce090d12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ab541c8fb2af765ed331ab9e6ce090d12">create_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:ab541c8fb2af765ed331ab9e6ce090d12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ad0f6ce6ddec8f7b90101ee273f303"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a93ad0f6ce6ddec8f7b90101ee273f303"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a93ad0f6ce6ddec8f7b90101ee273f303">create_mass_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:a93ad0f6ce6ddec8f7b90101ee273f303"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7da9f538365a4e5e3990cb426dd7e5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:acd7da9f538365a4e5e3990cb426dd7e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#acd7da9f538365a4e5e3990cb426dd7e5">create_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:acd7da9f538365a4e5e3990cb426dd7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da33adf2f6b96d0f045463a9e4cde87"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a3da33adf2f6b96d0f045463a9e4cde87"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a3da33adf2f6b96d0f045463a9e4cde87">create_mass_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:a3da33adf2f6b96d0f045463a9e4cde87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bdfd4e7d1f174287d017a9d3cb8b44"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a26bdfd4e7d1f174287d017a9d3cb8b44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a26bdfd4e7d1f174287d017a9d3cb8b44">create_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:a26bdfd4e7d1f174287d017a9d3cb8b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2619d21344bde2b095bd3c912ca16659"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a2619d21344bde2b095bd3c912ca16659"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a2619d21344bde2b095bd3c912ca16659">create_mass_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:a2619d21344bde2b095bd3c912ca16659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7351cc6156b6da0eac28ce1f4b1daad"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ab7351cc6156b6da0eac28ce1f4b1daad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ab7351cc6156b6da0eac28ce1f4b1daad">create_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt;())</td></tr>
<tr class="separator:ab7351cc6156b6da0eac28ce1f4b1daad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca36dde8ca70713334dcf438642c6a1f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:aca36dde8ca70713334dcf438642c6a1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aca36dde8ca70713334dcf438642c6a1f">create_boundary_mass_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const weight=0, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:aca36dde8ca70713334dcf438642c6a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27e6ae323215539dcafb898a881f794"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:ae27e6ae323215539dcafb898a881f794"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ae27e6ae323215539dcafb898a881f794">create_boundary_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:ae27e6ae323215539dcafb898a881f794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c31efe89e1599de5986aede7871aa57"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a3c31efe89e1599de5986aede7871aa57"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a3c31efe89e1599de5986aede7871aa57">create_boundary_mass_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:a3c31efe89e1599de5986aede7871aa57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8e646e6ca4d4aecbca026327574f51"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename number &gt; </td></tr>
<tr class="memitem:a6e8e646e6ca4d4aecbca026327574f51"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a6e8e646e6ca4d4aecbca026327574f51">create_boundary_mass_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;boundary_functions, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;rhs_vector, std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;dof_to_boundary_mapping, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const a=nullptr, std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; component_mapping={})</td></tr>
<tr class="separator:a6e8e646e6ca4d4aecbca026327574f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8157122064151d414dc34a22a3ca9c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a7b8157122064151d414dc34a22a3ca9c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">create_laplace_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:a7b8157122064151d414dc34a22a3ca9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa1ec2b8f90387f5ac80ccda364a55d0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:aaa1ec2b8f90387f5ac80ccda364a55d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#aaa1ec2b8f90387f5ac80ccda364a55d0">create_laplace_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:aaa1ec2b8f90387f5ac80ccda364a55d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c665214513b3d36d64089a3f8b350cf"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a4c665214513b3d36d64089a3f8b350cf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a4c665214513b3d36d64089a3f8b350cf">create_laplace_matrix</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:a4c665214513b3d36d64089a3f8b350cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98fa2fa5cc636f54d9132ce1adfdb74"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad98fa2fa5cc636f54d9132ce1adfdb74"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#ad98fa2fa5cc636f54d9132ce1adfdb74">create_laplace_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:ad98fa2fa5cc636f54d9132ce1adfdb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891e092648be84f2c45d47d3d9ffb619"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a891e092648be84f2c45d47d3d9ffb619"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a891e092648be84f2c45d47d3d9ffb619">create_laplace_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:a891e092648be84f2c45d47d3d9ffb619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b0ed883285a57afc53e62734aa0b9d5"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a9b0ed883285a57afc53e62734aa0b9d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a9b0ed883285a57afc53e62734aa0b9d5">create_laplace_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:a9b0ed883285a57afc53e62734aa0b9d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a601aa0d0e08e4e5a86bcc1857b1d13f9"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a601aa0d0e08e4e5a86bcc1857b1d13f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a601aa0d0e08e4e5a86bcc1857b1d13f9">create_laplace_matrix</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:a601aa0d0e08e4e5a86bcc1857b1d13f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf32993f1450efe40208f895bcd8e43c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:abf32993f1450efe40208f895bcd8e43c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#abf32993f1450efe40208f895bcd8e43c">create_laplace_matrix</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;q, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;matrix, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;rhs, <a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;rhs_vector, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const a=nullptr, const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;constraints=<a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt;())</td></tr>
<tr class="separator:abf32993f1450efe40208f895bcd8e43c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4485a61063879b54bb7bd29d54f38954"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixCreator.html#a4485a61063879b54bb7bd29d54f38954">DeclExceptionMsg</a> (ExcComponentMismatch, &quot;You are providing either a right hand side function or a &quot; &quot;coefficient with a number of vector components that is &quot; &quot;inconsistent with the rest of the arguments. If you do &quot; &quot;provide a coefficient or right hand side function, then &quot; &quot;it either needs to have as many components as the finite &quot; &quot;element in use, or only a single vector component. In &quot; &quot;the latter case, the same value will be taken for &quot; &quot;each vector component of the finite element.&quot;)</td></tr>
<tr class="separator:a4485a61063879b54bb7bd29d54f38954"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This namespace provides functions that assemble certain standard matrices for a given triangulation, using a given finite element, a given mapping and a quadrature formula.</p>
<h3>Conventions for all functions</h3>
<p>There exist two versions of almost all functions, one that takes an explicit <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> argument and one that does not. The second one generally calls the first with an implicit \(Q_1\) argument (i.e., with an argument of kind <a class="el" href="classMappingQGeneric.html">MappingQGeneric(1)</a>). If your intend your code to use a different mapping than a (bi-/tri-)linear one, then you need to call the functions <b>with</b> mapping argument should be used.</p>
<p>All functions take a sparse matrix object to hold the matrix to be created. The functions assume that the matrix is initialized with a sparsity pattern (<a class="el" href="classSparsityPattern.html">SparsityPattern</a>) corresponding to the given degree of freedom handler, i.e. the sparsity structure is already as needed. You can do this by calling the <a class="el" href="group__constraints.html#gaf78e864edbfba7e0a7477457bfb96b26">DoFTools::make_sparsity_pattern()</a> function.</p>
<p>Furthermore it is assumed that no relevant data is in the matrix. Some entries will be overwritten and some others will contain invalid data if the matrix wasn't empty before. Therefore you may want to clear the matrix before assemblage.</p>
<p>By default, all created matrices are `raw': they are not condensed, i.e. hanging nodes are not eliminated. The reason is that you may want to add several matrices and could then condense afterwards only once, instead of for every matrix. To actually do computations with these matrices, you have to condense the matrix using the <a class="el" href="classAffineConstraints.html#a5a1bc1bb2d705b582889ebaa24bcae5c">AffineConstraints::condense</a> function; you also have to condense the right hand side accordingly and distribute the solution afterwards. Alternatively, you can give an optional argument <a class="el" href="classAffineConstraints.html">AffineConstraints</a> that writes cell matrix (and vector) entries with distribute_local_to_global into the global matrix and vector. This way, adding several matrices from different sources is more complicated and you should make sure that you do not mix different ways of applying constraints. Particular caution is necessary when the given <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object contains inhomogeneous constraints: In that case, the matrix assembled this way must be the only matrix (or you need to assemble the <b>same</b> right hand side for <b>every</b> matrix you generate and add together).</p>
<p>If you want to use boundary conditions with the matrices generated by the functions of this namespace in addition to the ones in a possible <a class="el" href="classAffineConstraints.html">AffineConstraints</a> object, you have to use a function like <code>apply_boundary_values</code> with the matrix, solution, and right hand side.</p>
<h3>Supported matrices</h3>
<p>At present there are functions to create the following matrices: </p><ul>
<li>
<p class="startli"><code>create_mass_matrix:</code> create the matrix with entries \(m_{ij} = \int_\Omega \phi_i(x) \phi_j(x) dx\) by numerical quadrature. Here, the \(\phi_i\) are the basis functions of the finite element space given.</p>
<p>A coefficient may be given to evaluate \(m_{ij} = \int_\Omega a(x) \phi_i(x) \phi_j(x) dx\) instead.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli"><code>create_laplace_matrix:</code> create the matrix with entries \(a_{ij} = \int_\Omega \nabla\phi_i(x) \nabla\phi_j(x) dx\) by numerical quadrature.</p>
<p class="endli">Again, a coefficient may be given to evaluate \(a_{ij} = \int_\Omega a(x) \nabla\phi_i(x) \nabla\phi_j(x) dx\) instead. </p>
</li>
</ul>
<p>Make sure that the order of the <a class="el" href="classQuadrature.html">Quadrature</a> formula given to these functions is sufficiently high to compute the matrices with the required accuracy. For the choice of this quadrature rule you need to take into account the polynomial degree of the <a class="el" href="classFiniteElement.html">FiniteElement</a> basis functions, the roughness of the coefficient <code>a</code>, as well as the degree of the given <code><a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a></code> (if any).</p>
<p>Note, that for vector-valued elements the mass matrix and the laplace matrix is implemented in such a way that each component couples only with itself, i.e. there is no coupling of shape functions belonging to different components. If the degrees of freedom have been sorted according to their vector component (e.g., using <a class="el" href="namespaceDoFRenumbering.html#a52c1941406d1ce2937e29a46edf111f4">DoFRenumbering::component_wise()</a>), then the resulting matrices will be block diagonal.</p>
<p>If the finite element for which the mass matrix or the Laplace matrix is to be built has more than one component, the functions accept a single coefficient as well as a vector valued coefficient function. For the latter case, the number of components must coincide with the number of components of the system finite element.</p>
<h3>Matrices on the boundary</h3>
<p>The <a class="el" href="namespaceMatrixCreator.html#aca36dde8ca70713334dcf438642c6a1f">create_boundary_mass_matrix()</a> creates the matrix with entries \(m_{ij} = \int_{\Gamma} \phi_i \phi_j dx\), where \(\Gamma\) is the union of boundary parts with indicators contained in a std::map&lt;<a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const Function&lt;spacedim,number&gt;*&gt; passed to the function (i.e. if you want to set up the mass matrix for the parts of the boundary with indicators zero and 2, you pass the function a map with key type <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> as the parameter <code>boundary_functions</code> containing the keys zero and 2). The size of the matrix is equal to the number of degrees of freedom that have support on the boundary, i.e. it is <em>not</em> a matrix on all degrees of freedom, but only a subset. (The \(\phi_i\) in the formula are the subset of basis functions which have at least part of their support on \(\Gamma\).) In order to determine which shape functions are to be considered, and in order to determine in which order, the function takes a <code>dof_to_boundary_mapping</code>; this object maps global DoF numbers to a numbering of the degrees of freedom located on the boundary, and can be obtained using the function <a class="el" href="namespaceDoFTools.html#aa243d4c45775077c674ef6800e5ce215">DoFTools::map_dof_to_boundary_indices()</a>.</p>
<p>In order to work, the function needs a matrix of the correct size, built on top of a corresponding sparsity pattern. Since we only work on a subset of the degrees of freedom, we can't use the matrices and sparsity patterns that are created for the entire set of degrees of freedom. Rather, you should use the <a class="el" href="group__constraints.html#ga9f970db3b035e9813fc7201a2d18d032">DoFHandler::make_boundary_sparsity_pattern()</a> function to create the correct sparsity pattern, and build a matrix on top of it.</p>
<p>Note that at present there is no function that computes the mass matrix for <em>all</em> shape functions, though such a function would be trivial to implement.</p>
<h3>Right hand sides</h3>
<p>In many cases, you will not only want to build the matrix, but also a right hand side, which will give a vector with \(f_i = \int_\Omega f(x) \phi_i(x) dx\). For this purpose, each function exists in two versions, one only building the matrix and one also building the right hand side vector. If you want to create a right hand side vector without creating a matrix, you can use the <a class="el" href="namespaceVectorTools.html#a6e325333a138893e181da47f29ac680a">VectorTools::create_right_hand_side()</a> function. The use of the latter may be useful if you want to create many right hand side vectors. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="aab6397f114af66efd781f7f4daba22be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab6397f114af66efd781f7f4daba22be">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the mass matrix. If no coefficient is given (i.e., if the pointer to a function object is zero as it is by default), the coefficient is taken as being constant and equal to one. In case you want to specify <code>constraints</code> and use the default argument for the coefficient you have to specify the (unused) coefficient argument as <code>(const Function&lt;spacedim,number&gt; *const)nullptr</code>.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Note, however, that this becomes difficult when you have inhomogeneous constraints and later want to add several such matrices, for example in time dependent settings such as the main loop of step-26.</p>
<p>See the general documentation of this namespace for more information. </p>

</div>
</div>
<a id="ab541c8fb2af765ed331ab9e6ce090d12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab541c8fb2af765ed331ab9e6ce090d12">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">create_mass_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a93ad0f6ce6ddec8f7b90101ee273f303"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ad0f6ce6ddec8f7b90101ee273f303">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the mass matrix and a right hand side vector. If no coefficient is given (i.e., if the pointer to a function object is zero as it is by default), the coefficient is taken as being constant and equal to one. In case you want to specify <code>constraints</code> and use the default argument for the coefficient you have to specify the (unused) coefficient argument as <code>(const <a class="el" href="classFunction.html">Function</a> &lt;spacedim,number&gt; *const)nullptr</code>.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Note, however, that this becomes difficult when you have inhomogeneous constraints and later want to add several such matrices, for example in time dependent settings such as the main loop of step-26.</p>
<p>See the general documentation of this namespace for more information. </p>

</div>
</div>
<a id="acd7da9f538365a4e5e3990cb426dd7e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7da9f538365a4e5e3990cb426dd7e5">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceMatrixCreator.html#aab6397f114af66efd781f7f4daba22be">create_mass_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a3da33adf2f6b96d0f045463a9e4cde87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da33adf2f6b96d0f045463a9e4cde87">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp-objects. </p>

</div>
</div>
<a id="a26bdfd4e7d1f174287d017a9d3cb8b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bdfd4e7d1f174287d017a9d3cb8b44">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp-objects. </p>

</div>
</div>
<a id="a2619d21344bde2b095bd3c912ca16659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2619d21344bde2b095bd3c912ca16659">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp-objects. </p>

</div>
</div>
<a id="ab7351cc6156b6da0eac28ce1f4b1daad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7351cc6156b6da0eac28ce1f4b1daad">&#9670;&nbsp;</a></span>create_mass_matrix() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;number&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp-objects. </p>

</div>
</div>
<a id="aca36dde8ca70713334dcf438642c6a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca36dde8ca70713334dcf438642c6a1f">&#9670;&nbsp;</a></span>create_boundary_mass_matrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>weight</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the mass matrix and a right hand side vector along the boundary.</p>
<p>The matrix is assumed to already be initialized with a suiting sparsity pattern (the <a class="el" href="classDoFHandler.html">DoFHandler</a> provides an appropriate function).</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<ul>
<li><code>weight:</code> an optional weight for the computation of the mass matrix. If no weight is given, it is set to one. In case you want to specify <code>component_mapping</code> and use the default argument for the coefficient you have to specify the (unused) coefficient argument as <code>(const <a class="el" href="classFunction.html">Function</a> &lt;spacedim,number&gt; *const)nullptr</code>.</li>
</ul>
<ul>
<li><code>component_mapping:</code> if the components in <code>boundary_functions</code> and <code>dof</code> do not coincide, this vector allows them to be remapped. If the vector is not empty, it has to have one entry for each component in <code>dof</code>. This entry is the component number in <code>boundary_functions</code> that should be used for this component in <code>dof</code>. By default, no remapping is applied.</li>
</ul>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>This function does not work for finite elements with cell-dependent shape functions. </dd></dl>

</div>
</div>
<a id="ae27e6ae323215539dcafb898a881f794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27e6ae323215539dcafb898a881f794">&#9670;&nbsp;</a></span>create_boundary_mass_matrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceMatrixCreator.html#aca36dde8ca70713334dcf438642c6a1f">create_boundary_mass_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a3c31efe89e1599de5986aede7871aa57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c31efe89e1599de5986aede7871aa57">&#9670;&nbsp;</a></span>create_boundary_mass_matrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp-objects. </p>

</div>
</div>
<a id="a6e8e646e6ca4d4aecbca026327574f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e8e646e6ca4d4aecbca026327574f51">&#9670;&nbsp;</a></span>create_boundary_mass_matrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_boundary_mass_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_functions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_to_boundary_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, number &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td>
          <td class="paramname"><em>component_mapping</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same function as above, but for hp-objects. </p>

</div>
</div>
<a id="a7b8157122064151d414dc34a22a3ca9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b8157122064151d414dc34a22a3ca9c">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the Laplace matrix. If no coefficient is given (i.e., if the pointer to a function object is zero as it is by default), the coefficient is taken as being constant and equal to one. In case you want to specify <code>constraints</code> and use the default argument for the coefficient you have to specify the (unused) coefficient argument as <code>(const <a class="el" href="classFunction.html">Function&lt;spacedim&gt;</a> *const)nullptr</code>.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Note, however, that this becomes difficult when you have inhomogeneous constraints and later want to add several such matrices, for example in time dependent settings such as the main loop of step-26.</p>
<p>See the general documentation of this namespace for more information. </p>

</div>
</div>
<a id="aaa1ec2b8f90387f5ac80ccda364a55d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa1ec2b8f90387f5ac80ccda364a55d0">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">create_laplace_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a4c665214513b3d36d64089a3f8b350cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c665214513b3d36d64089a3f8b350cf">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assemble the Laplace matrix and a right hand side vector. If no coefficient is given, it is assumed to be constant one. In case you want to specify <code>constraints</code> and use the default argument for the coefficient you have to specify the (unused) coefficient argument as <code>(const <a class="el" href="classFunction.html">Function&lt;spacedim&gt;</a> *const)nullptr</code>.</p>
<p>If the library is configured to use multithreading, this function works in parallel.</p>
<p>The optional argument <code>constraints</code> allows to apply constraints on the resulting matrix directly. Note, however, that this becomes difficult when you have inhomogeneous constraints and later want to add several such matrices, for example in time dependent settings such as the main loop of step-26.</p>
<p>See the general documentation of this namespace for more information. </p>

</div>
</div>
<a id="ad98fa2fa5cc636f54d9132ce1adfdb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98fa2fa5cc636f54d9132ce1adfdb74">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the <a class="el" href="namespaceMatrixCreator.html#a7b8157122064151d414dc34a22a3ca9c">create_laplace_matrix()</a> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a891e092648be84f2c45d47d3d9ffb619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891e092648be84f2c45d47d3d9ffb619">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp-objects. </p>

</div>
</div>
<a id="a9b0ed883285a57afc53e62734aa0b9d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0ed883285a57afc53e62734aa0b9d5">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp-objects. </p>

</div>
</div>
<a id="a601aa0d0e08e4e5a86bcc1857b1d13f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a601aa0d0e08e4e5a86bcc1857b1d13f9">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp-objects. </p>

</div>
</div>
<a id="abf32993f1450efe40208f895bcd8e43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf32993f1450efe40208f895bcd8e43c">&#9670;&nbsp;</a></span>create_laplace_matrix() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixCreator::create_laplace_matrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *const&#160;</td>
          <td class="paramname"><em>a</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt; <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraints</em> = <code><a class="el" href="classAffineConstraints.html">AffineConstraints</a>&lt;&#160;<a class="el" href="classdouble.html">double</a>&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like the functions above, but for hp-objects. </p>

</div>
</div>
<a id="a4485a61063879b54bb7bd29d54f38954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4485a61063879b54bb7bd29d54f38954">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixCreator::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcComponentMismatch&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are providing either a right hand side function or a &quot; &quot;coefficient with a number of vector components that is &quot; &quot;inconsistent with the rest of the arguments. If you do &quot; &quot;provide a coefficient or right hand side&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">then &quot; &quot;it either needs to have as many components as the finite &quot; &quot;element in&#160;</td>
          <td class="paramname"><em>use</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">or only a single vector component. In &quot; &quot;the latter&#160;</td>
          <td class="paramname"><em>case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the same value will be taken for &quot; &quot;each vector component of the finite element.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
