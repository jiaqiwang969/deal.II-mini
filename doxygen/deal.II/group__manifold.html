<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__manifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Manifold description for triangulations</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Manifold description for triangulations<div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for Manifold description for triangulations:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__manifold.svg" width="292" height="52"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCompositionManifold.html">CompositionManifold&lt; dim, spacedim, chartdim, intermediate_dim, dim1, dim2 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html">Manifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFlatManifold.html">FlatManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classChartManifold.html">ChartManifold&lt; dim, spacedim, chartdim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPolarManifold.html">PolarManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSphericalManifold.html">SphericalManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classCylindricalManifold.html">CylindricalManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classEllipticalManifold.html">EllipticalManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFunctionManifold.html">FunctionManifold&lt; dim, spacedim, chartdim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTorusManifold.html">TorusManifold&lt; dim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation&lt; dim, spacedim &gt;::set_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number, const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;manifold_object)</td></tr>
<tr class="separator:ga9f9d720f5fbdcdf3dcbb445feefbdb9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga644a2152b8f5a6902afdc503d163d950"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">Triangulation&lt; dim, spacedim &gt;::reset_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> manifold_number)</td></tr>
<tr class="separator:ga644a2152b8f5a6902afdc503d163d950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">Triangulation&lt; dim, spacedim &gt;::reset_all_manifolds</a> ()</td></tr>
<tr class="separator:gaaacb68636e7fc0b399310e570a4d7dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2acfbef517fd03855c4b371f3e182f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">Triangulation&lt; dim, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gae2acfbef517fd03855c4b371f3e182f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">Triangulation&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:ga1f1ea841946c94c079388ecf9ad2c00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa4e0af28512cb5f9cc8cb3b95a38c669">Triangulation&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary</a> (const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> b_id, const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number)</td></tr>
<tr class="separator:gaa4e0af28512cb5f9cc8cb3b95a38c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gaa5d4bed3d2ac6148e969a331bde49f63">Triangulation&lt; dim, spacedim &gt;::get_manifold</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> number) const</td></tr>
<tr class="separator:gaa5d4bed3d2ac6148e969a331bde49f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ee729ae049af6f1495d0059d6086e52"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga0ee729ae049af6f1495d0059d6086e52">Triangulation&lt; dim, spacedim &gt;::get_manifold_ids</a> () const</td></tr>
<tr class="separator:ga0ee729ae049af6f1495d0059d6086e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary and manifold ids</h2></td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga2ea00d3c65f290a020a268df8fb50c19">GridTools::copy_boundary_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> reset_boundary_ids=false)</td></tr>
<tr class="separator:ga2ea00d3c65f290a020a268df8fb50c19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5861f4e358367a1e12221a7e6832755f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga5861f4e358367a1e12221a7e6832755f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga5861f4e358367a1e12221a7e6832755f">GridTools::map_boundary_to_manifold_ids</a> (const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;src_boundary_ids, const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;dst_manifold_ids, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;reset_boundary_ids={})</td></tr>
<tr class="separator:ga5861f4e358367a1e12221a7e6832755f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ga306131b2b48ca10bb9a51e189806193c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga306131b2b48ca10bb9a51e189806193c">GridTools::copy_material_to_manifold_id</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const <a class="el" href="classbool.html">bool</a> compute_face_ids=false)</td></tr>
<tr class="separator:ga306131b2b48ca10bb9a51e189806193c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__manifold.html#gae8bdd10dc34f9ebb869b30bfaf70ff32">GridTools::assign_co_dimensional_manifold_indicators</a> (<a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;tria, const std::function&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>(const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;)&gt; &amp;disambiguation_function=[](const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;manifold_ids) { if(manifold_ids.size()==1) return *manifold_ids.begin();else return <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>;}, <a class="el" href="classbool.html">bool</a> overwrite_only_flat_manifold_ids=true)</td></tr>
<tr class="separator:gae8bdd10dc34f9ebb869b30bfaf70ff32"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with manifold indicators</h2></td></tr>
<tr class="memitem:gafbeb21da36433dc2ec117b9694ca2557"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor&lt; structdim, dim, spacedim &gt;::set_manifold_id</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:gafbeb21da36433dc2ec117b9694ca2557"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">TriaAccessor&lt; structdim, dim, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>) const</td></tr>
<tr class="separator:ga160a26ce22b36607556bcdcc20bc6d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Dealing with boundary indicators</h2></td></tr>
<tr class="memitem:ga853633832f20bf91d674749b9ae83827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__manifold.html#ga853633832f20bf91d674749b9ae83827">TriaAccessor&lt; 0, 1, spacedim &gt;::set_all_manifold_ids</a> (const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>)</td></tr>
<tr class="separator:ga853633832f20bf91d674749b9ae83827"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h3>Overview</h3>
<p>The classes in this module are concerned with the description of the manifold in which the domain that a <a class="el" href="classTriangulation.html">Triangulation</a> describes lives. This manifold description is necessary in several contexts:</p>
<ul>
<li>
<p class="startli">Mesh refinement: Whenever a cell is refined, it is necessary to introduce new vertices in the <a class="el" href="classTriangulation.html">Triangulation</a>. In the simplest case, one assumes that the objects that make up the <a class="el" href="classTriangulation.html">Triangulation</a> are straight line segments, a bi-linear surface or a tri-linear volume. The next vertex is then simply put into the middle of the old ones (where "middle" means a suitable average of the locations of the pre-existing vertices). This is the default behavior of the <a class="el" href="classTriangulation.html">Triangulation</a> class, and is described by the <a class="el" href="classFlatManifold.html">FlatManifold</a> class.</p>
<p>On the other hand, if one deals with curved geometries, or geometries which require a denser refinement in some direction, this is not the appropriate thing to do. The classes derived from the <a class="el" href="classManifold.html">Manifold</a> base class therefore describe the geometry of a domain. One can then attach an object of a class derived from this base class to the <a class="el" href="classTriangulation.html">Triangulation</a> object using the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> function associating it with a manifold_id (see <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>), use this manifold_id on the cells, faces or edges of the triangulation that should be described by this manifold using the <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">TriaAccessor::set_manifold_id()</a> function, and then the <a class="el" href="classTriangulation.html">Triangulation</a> will ask the manifold object where a new vertex to be located on a cell, face or edge so attributed should be located upon mesh refinement. Several classes already exist to support the most common geometries, e.g., <a class="el" href="classCylindricalManifold.html">CylindricalManifold</a>, or <a class="el" href="classPolarManifold.html">PolarManifold</a>, which represent respectively the geometry obtained when describing your space in cylindrical coordinates or in polar coordinates. By default, all curved geometries generated using functions in the <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> namespace attach the correct <a class="el" href="classManifold.html">Manifold</a> object to the curved parts of the domain.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Integration: When using higher order finite element methods, it is often necessary to compute cell terms (like cell contributions to the matrix and right hand side of the linear system) using curved approximations of the boundary, rather than the straight line approximation. The actual implementation of such curved elements happens in the <a class="el" href="classMapping.html" title="Abstract base class for mapping classes. ">Mapping</a> class (see the <a class="el" href="group__mapping.html">Mappings between reference and real cell</a> module), which however obtains its information about the boundary of the domain from the classes described here. The same is, of course, true when integrating boundary terms (e.g., inhomogeneous Neumann boundary conditions).</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">Domains with nonzero codimension: In cases where a <a class="el" href="classTriangulation.html">Triangulation</a> is embedded into a higher dimensional space, i.e., whenever the second template argument of the <a class="el" href="classTriangulation.html">Triangulation</a> class is explicitly specified and larger than the first (for an example, see step-34), the manifold description objects serve as a tool to describe the geometry not only of the boundary of the domain but of the domain itself, in case the domain is a manifold that is in fact curved. In these cases, one can use the <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a> function to indicate what manifold description to use when refining the curve, or when computing integrals using high order mappings.</p>
<p class="endli"></p>
</li>
</ul>
<p>Many other examples, as well as much theoretical underpinning for the implementation in deal.II, is provided in the <a class="el" href="DEALGlossary.html#geometry_paper">geometry paper</a>.</p>
<p>In deal.II, a <a class="el" href="classManifold.html">Manifold</a> is seen as a collection of points, together with a notion of distance between points (on the manifold). New points are typically obtained by providing a local coordinate system on the manifold, identifying existing points in the local coordinate system (pulling them back using the local map to obtain their local coordinates), find the new point in the local coordinate system by weighted sums of the existing points, and transforming back the point in the real space (pushing it forward using the local map). The main class that implements this mechanism is the <a class="el" href="classChartManifold.html">ChartManifold</a> class, and this is the class that users will likely overload for complex geometries.</p>
<p>While this process is non trivial in most cases of interest, for most of the trivial geometries, like cylinders, spheres or shells, deal.II provides reasonable implementations. More complicated examples can be described using the techniques shown in step-53 and step-54.</p>
<p>In the grand scheme of things, the classes of this module interact with a variety of other parts of the library: </p><div class="dotgraph">
<iframe scrolling="no" frameborder="0" src="dot_inline_dotgraph_8.svg" width="600" height="535"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<h3>An example</h3>
<p>A simple example why dealing with curved geometries is already provided by step-1, though it is not elaborated there. By default, the functions in <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> will attach manifolds to meshes when needed. In each code snippet below we call <a class="el" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">Triangulation::reset_all_manifolds()</a> to remove these manifolds and handle all <a class="el" href="classManifold.html">Manifold</a> attachment in the example itself to make the impact of the choice of <a class="el" href="classManifold.html">Manifold</a> clear.</p>
<p>Consider this small variation of the <code>second_grid()</code> function shown there, where we simply refine <em>every</em> cell several times: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius,</div><div class="line">                            10);</div><div class="line"><span class="comment">// as noted above: disable all non-Cartesian manifolds</span></div><div class="line"><span class="comment">// for demonstration purposes:</span></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><p> This code leads to a mesh that looks like this:</p>
<div class="image">
<img src="hypershell-nothing.png" alt="hypershell-nothing.png"/>
</div>
<p> Our intention was to get a mesh that resembles a ring. However, since we did not describe this to the triangulation, what happens is that we start with the 10 coarse cells in circumferential direction we told <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> to create, and each of these is then 3 times globally refined. Each time refinement requires a new vertex, it is placed in the middle of the existing ones, regardless of what we may have intended (but omitted to describe in code).</p>
<p>This is easily remedied. Consider this code: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> (1,0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> manifold(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius,</div><div class="line">                            10);</div><div class="line"><span class="comment">// again disable all manifolds for demonstration purposes</span></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><p> This code is better, producing the following mesh:</p>
<div class="image">
<img src="hypershell-boundary-only.png" alt="hypershell-boundary-only.png"/>
</div>
<p> The mesh looks better in that it faithfully reproduces the circular inner and outer boundaries of the domain. However, it is still possible to identify 20 kinks in the tangential lines. They result from the fact that every time a cell is refined, new vertices on interior lines are just placed into the middle of the existing line (the boundary lines are handled differently because we have attached a manifold object). In the first refinement with 10 cells, we got improved points because both outer boundaries have provided a curved description according to the description on blending different manifolds below. In other words, the new points after the first refinement end up in places that may be in the geometric middle of a straight line, but not on a circle around the center.</p>
<p>This can be remedied by assigning a manifold description not only to the lines along the boundary, but also to the radial lines and cells (which, in turn, will inherit it to the new lines that are created upon mesh refinement). This is exactly what <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> does by default. For demonstration purposes, we disable the default <a class="el" href="classManifold.html">Manifold</a> behavior and then duplicate it manually: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> (1,0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> manifold(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius,</div><div class="line">                            10);</div><div class="line"><span class="comment">// again disable all manifolds for demonstration purposes</span></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line"><span class="comment">// reenable the manifold:</span></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gae2acfbef517fd03855c4b371f3e182f7">set_all_manifold_ids</a>(0);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold);</div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><p> This leads to the following mesh:</p>
<div class="image">
<img src="hypershell-all.png" alt="hypershell-all.png"/>
</div>
<p> So why does this matter? After all, the last two meshes describe the exact same domain and we know that upon mesh refinement we obtain the correct solution regardless of the choice of cells, as long as the diameter of the largest cell goes to zero.</p>
<p>There are two answers to this question. First, the numerical effort of solving a partial differential equation to a certain accuracy typically depends on the <em>quality</em> of cells since the constant \(C\) in error estimates of the form \(\|u-u_h\|_{H^1} \le Ch^p \|u\|_{H^{p+1}}\) depends on factors such as the maximal ratio of radii of the smallest circumscribed to largest inscribed circle over all cells (for triangles; or a suitable generalization for other types of cells). Thus, it is worthwhile creating meshes with cells that are as well-formed as possible. This is arguably not so much of an issue for the meshes shown above, but is sometimes an issue. Consider, for example, the following code and mesh: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> (1,0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> manifold(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.5,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius,</div><div class="line">                            3);    <span class="comment">// three circumferential cells</span></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><div class="image">
<img src="hypershell-boundary-only-3.png" alt="hypershell-boundary-only-3.png"/>
</div>
<p> Here, we create only three circumferential cells in the beginning, and refining them leads to the mesh shown. Clearly, we have cells with bad aspect ratios, despite the first refinement that puts the new point into the middle.</p>
<p>If we drive this further and start with a coarse mesh of a much thinner rim between the radii 0.8 and 1.0 and only three cells (which may be inappropriate here, since we know that it is not sufficient, but may also be impossible to avoid for complex geometries generated in mesh generators), we observe the following:</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> (1,0);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classSphericalManifold.html">SphericalManifold&lt;2&gt;</a> manifold(<a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.8,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius,</div><div class="line">                            3);    <span class="comment">// three circumferential cells</span></div><div class="line">triangulation.<a class="code" href="group__manifold.html#gaaacb68636e7fc0b399310e570a4d7dd6">reset_all_manifolds</a>();</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga1f1ea841946c94c079388ecf9ad2c00c">set_all_manifold_ids_on_boundary</a>(0);</div><div class="line">triangulation.<a class="code" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold</a> (0, manifold);</div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><div class="image">
<img src="hypershell-boundary-thin-3.png" alt="hypershell-boundary-thin-3.png"/>
</div>
<p> This mesh neither has the correct geometry after refinement, nor do all cells have positive area as is necessary for the finite element method to work. However, even when starting with such an inopportune mesh, we can make things work by attaching a suitable geometry description not only to the boundary but also to interior cells and edges, using the same code as above: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classPoint.html">Point&lt;2&gt;</a> <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a> (1,0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> inner_radius = 0.8,</div><div class="line">             outer_radius = 1.0;</div><div class="line"><a class="code" href="classTriangulation.html">Triangulation&lt;2&gt;</a> triangulation;</div><div class="line"><a class="code" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell</a> (triangulation,</div><div class="line">                            <a class="code" href="data__out__base_8cc.html#a8188ef4709fc9a4cc076d37447783ba1">center</a>, inner_radius, outer_radius,</div><div class="line">                            3);    <span class="comment">// three circumferential cells</span></div><div class="line"></div><div class="line">triangulation.<a class="code" href="classTriangulation.html#a6ad0b3fb24aae17f4668427a433dea19">refine_global</a> (3);</div></div><!-- fragment --><div class="image">
<img src="hypershell-all-3.png" alt="hypershell-all-3.png"/>
</div>
<p> In this last example we finally let <a class="el" href="namespaceGridGenerator.html">GridGenerator</a> do its job and we keep the default manifold configuration, which is a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> on every cell and face.</p>
<p>Here, even starting with an initial, inappropriately chosen mesh retains our ability to adequately refine the mesh into one that will serve us well. This example may be manufactured here, but it is relevant, for example in the context of what <a class="el" href="namespaceGridGenerator.html#ad85de345ccd86a53e63746709c8e1dfc">GridGenerator::hyper_shell()</a> produces in 3d (see the documentation of this function). It is also germane to the cases discussed in the <a class="el" href="DEALGlossary.html#GlossDistorted">glossary entry on distorted cells</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a></dd></dl>
<h3>Computing the weights for combining different manifold descriptions</h3>
<p>In a realistic application, it happens regularly that different manifold descriptions need to be combined. The simplest case is when a curved description is only available for the boundary but not for the interior of the computational domain. The manifold description for a ball also falls into this category, as it needs to combine a spherical manifold at the circular part with a straight-sided description in the center of the domain where the spherical manifold is not valid.</p>
<p>In general, the process of blending different manifold descriptions in deal.II is achieved by the so-called transfinite interpolation. Its formula in 2D is, for example, described on <a href="https://en.wikipedia.org/wiki/Transfinite_interpolation">Wikipedia</a>. Given a point \((u,v)\) on a chart, the image of this point in real space is given by </p><p class="formulaDsp">
\begin{align*} \mathbf S(u,v) &amp;= (1-v)\mathbf c_0(u)+v \mathbf c_1(u) + (1-u)\mathbf c_2(v) + u \mathbf c_3(v) \\ &amp;\quad - \left[(1-u)(1-v) \mathbf x_0 + u(1-v) \mathbf x_1 + (1-u)v \mathbf x_2 + uv \mathbf x_3 \right] \end{align*}
</p>
<p> where \(\bf x_0, \bf x_1, \bf x_2, \bf x_3\) denote the four vertices bounding the image space and \(\bf c_0, \bf c_1, \bf c_2, \bf c_3\) are the four curves describing the lines of the cell.</p>
<p>If we want to find the center of the cell according to the manifold (that is also used when the grid is refined), the chart is the unit cell \((0,1)^2\) and we want to evaluate this formula in the point \((u,v) = (0.5, 0.5)\). In that case, \(\mathbf c_0(0.5)\) is the position of the midpoint of the lower face (indexed by 2 in deal.II's ordering) that is derived from its own manifold, \(\mathbf c_1(0.5)\) is the position of the midpoint of the upper face (indexed by 3 in deal.II), \(\mathbf c_2(0.5)\) is the midpoint of the face on the left (indexed by 0), and \(\mathbf c_3(0.5)\) is the midpoint of the right face. In this formula, the weights equate to \(\frac{\displaystyle 1}{\displaystyle 2}\) for the four midpoints in the faces and to \(-\frac{\displaystyle 1}{\displaystyle 4}\) for the four vertices. These weights look weird at first sight because the vertices enter with negative weight but the mechanism does what we want: In case of a cell with curved description on two opposite faces but straight lines on the other two faces, the negative weights of \(-\frac{\displaystyle 1}{\displaystyle 4}\) in the vertices balance with the center of the two straight lines in radial direction that get weight \(\frac{\displaystyle 1}{\displaystyle 2}\). Thus, the average is taken over the two center points in curved direction, exactly placing the new point in the middle.</p>
<p>In three spatial dimensions, the weights are \(+\frac{\displaystyle 1}{\displaystyle 2}\) for the face midpoints, \(-\frac{\displaystyle 1}{\displaystyle 4}\) for the line mid points, and \(\frac{\displaystyle 1}{\displaystyle 8}\) for the vertices, again balancing the different entities. In case all the surrounding of a cell is straight, the formula reduces to the obvious weight \(\frac{\displaystyle 1}{\displaystyle 8}\) on each of the eight vertices.</p>
<p>In the <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> class, a generalization of this concept to the support points of a polynomial representation of curved cells, the nodes of the Gauss-Lobatto quadrature, is implemented by evaluating the boundary curves in the respective Gauss-Lobatto points \((u_i,v_i)\) and combining them with the above formula. The weights have been verified to yield optimal convergence rates \(\mathcal O(h^{k+1})\) also for very high polynomial degrees, say \(k=10\).</p>
<p>In the literature, other boundary descriptions are also used. Before version 9.0 deal.II used something called Laplace smoothing where the weights that are applied to the nodes on the circumference to get the position of the interior nodes are determined by solving a Laplace equation on the unit element. However, this led to boundary layers close to the curved description, i.e., singularities in the higher derivatives of the mapping from unit to real cell.</p>
<p>If the transition from a curved boundary description to a straight description in the interior is done wrong, it is typically impossible to achieve high order convergence rates. For example, the Laplace smoothing inside a single cell leads to a singularity in the fourth derivative of the mapping from the reference to the real cell, limiting the convergence rate to 3 in the cells at the boundary (and 3.5 if global L2 errors were measured in 2D). Other more crude strategies, like completely ignoring the presence of two different manifolds and simply computing the additional points of a high-order mapping in a straight coordinate system, could lead to even worse convergence rates. The current implementation in deal.II, on the other hand, has been extensively verified in this respect and should behave optimally.</p>
<p>A bad strategy for blending a curved boundary representation with flat interior representations obviously also reflects mesh quality. For example, the above case with only 3 circumferential cells leads to the following mesh with Laplace manifold smoothing rather than the interpolation from the boundary as is implemented in deal.II:</p>
<div class="image">
<img src="hypershell-boundary-only-3-old.png" alt="hypershell-boundary-only-3-old.png"/>
</div>
<p> To use a more practical example, consider the refinement of a ball with a <a class="el" href="classSphericalManifold.html">SphericalManifold</a> attached to the spherical surface. The Laplace-type smoothing gives the following rather poor mesh:</p>
<div class="image">
<img src="hyperball-mesh-smoothing-laplace.png" alt="hyperball-mesh-smoothing-laplace.png"/>
</div>
<p> If we, instead, use the weights derived from transfinite interpolation, the situation is considerably improved:</p>
<div class="image">
<img src="hyperball-mesh-smoothing-interpolate.png" alt="hyperball-mesh-smoothing-interpolate.png"/>
</div>
<p> Of course, one could get even better meshes by applying the <a class="el" href="classTransfiniteInterpolationManifold.html">TransfiniteInterpolationManifold</a> to the whole domain except the boundary where <a class="el" href="classSphericalManifold.html">SphericalManifold</a> is attached, as shown by the figures in that class, but in principle, the mesh smoothing implemented in deal.II is as good as it can get from a boundary description alone.</p>
<dl class="section author"><dt>Author</dt><dd>Luca Heltai, 2013, Martin Kronbichler, 2017 </dd></dl>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga2ea00d3c65f290a020a268df8fb50c19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2ea00d3c65f290a020a268df8fb50c19">&#9670;&nbsp;</a></span>copy_boundary_to_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::copy_boundary_to_manifold_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>reset_boundary_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy boundary ids to manifold ids on faces and edges at the boundary. The default manifold_id for new <a class="el" href="classTriangulation.html">Triangulation</a> objects is <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>. This function copies the boundary_ids of the boundary faces and edges to the manifold_ids of the same faces and edges, allowing the user to change the boundary_ids and use them for boundary conditions regardless of the geometry, which will use manifold_ids to create new points. Only active cells will be iterated over. This is a function you'd typically call when there is only one active level on your <a class="el" href="classTriangulation.html">Triangulation</a>. Mesh refinement will then inherit these indicators to child cells, faces, and edges.</p>
<p>The optional parameter <code>reset_boundary_ids</code>, indicates whether this function should reset the boundary_ids of boundary faces and edges to its default value 0 after copying its value to the manifold_id. By default, boundary_ids are left untouched. </p>

</div>
</div>
<a id="ga5861f4e358367a1e12221a7e6832755f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5861f4e358367a1e12221a7e6832755f">&#9670;&nbsp;</a></span>map_boundary_to_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::map_boundary_to_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>src_boundary_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst_manifold_ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>reset_boundary_ids</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Map the given boundary ids to the given manifold ids on faces and edges at the boundary.</p>
<p>This function copies the boundary ids of the boundary faces and edges that are present in the parameter <code>src_boundary_ids</code> to the corresponding manifold id in <code>dst_manifold_ids</code>, of the same faces and edges.</p>
<p>If the optional parameter <code>reset_boundary_ids</code> is non empty, each boundary id in <code>src_boundary_ids</code>, is replaced with the corresponding boundary id in <code>reset_boundary_ids</code>.</p>
<p>An exception is thrown if the size of the input vectors do not match. If a boundary id indicated in <code>src_boundary_ids</code> is not present in the triangulation, it is simply ignored during the process. </p>

</div>
</div>
<a id="ga306131b2b48ca10bb9a51e189806193c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga306131b2b48ca10bb9a51e189806193c">&#9670;&nbsp;</a></span>copy_material_to_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::copy_material_to_manifold_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>compute_face_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy material ids to manifold ids. The default manifold_id for new <a class="el" href="classTriangulation.html">Triangulation</a> objects is <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>. When refinements occurs, the <a class="el" href="classTriangulation.html">Triangulation</a> asks where to locate new points to the underlying manifold.</p>
<p>When reading a <a class="el" href="classTriangulation.html">Triangulation</a> from a supported input format, typical information that can be stored in a file are boundary conditions for boundary faces (which we store in the boundary_id of the faces), material types for cells (which we store in the material_id of the cells) and in some cases subdomain ids for cells (which we store in the subdomain_id of the cell).</p>
<p>If you read one of these grids into a <a class="el" href="classTriangulation.html">Triangulation</a>, you might still want to use the material_id specified in the input file as a manifold_id description. In this case you can associate a <a class="el" href="classManifold.html">Manifold</a> object to internal cells, and this object will be used by the <a class="el" href="classTriangulation.html">Triangulation</a> to query <a class="el" href="classManifold.html">Manifold</a> objects for new points. This function iterates over active cells and copies the material_ids to the manifold_ids.</p>
<p>The optional parameter <code>compute_face_ids</code>, indicates whether this function should also set the manifold_ids of the faces (both for internal faces and for faces on the boundary). If set to true, then each face will get a manifold_id equal to the minimum of the surrounding manifold_ids, ensuring that a unique manifold id is selected for each face of the <a class="el" href="classTriangulation.html">Triangulation</a>. By default, face manifold_ids are not computed. </p>

</div>
</div>
<a id="ga9f9d720f5fbdcdf3dcbb445feefbdb9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">&#9670;&nbsp;</a></span>set_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>manifold_object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign a manifold object to a certain part of the triangulation. If an object with manifold number <code>number</code> is refined, this object is used to find the location of new vertices (see the results section of step-49 for a more in-depth discussion of this, with examples). It is also used for non-linear (i.e.: non-Q1) transformations of cells to the unit cell in shape function calculations.</p>
<p>A copy of <code>manifold_object</code> is created using <a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">Manifold&lt;dim, spacedim&gt;::clone()</a> and stored internally.</p>
<p>It is possible to remove or replace a <a class="el" href="classManifold.html">Manifold</a> object during the lifetime of a non-empty triangulation. Usually, this is done before the first refinement and is dangerous afterwards. Removal of a manifold object is done by <a class="el" href="group__manifold.html#ga644a2152b8f5a6902afdc503d163d950">reset_manifold()</a>. This operation then replaces the manifold object given before by a straight manifold approximation.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga644a2152b8f5a6902afdc503d163d950"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga644a2152b8f5a6902afdc503d163d950">&#9670;&nbsp;</a></span>reset_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>manifold_number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset those parts of the triangulation with the given <code>manifold_number</code> to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This is the default state of a non-curved triangulation, and undoes assignment of a different <a class="el" href="classManifold.html">Manifold</a> object by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaaacb68636e7fc0b399310e570a4d7dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaacb68636e7fc0b399310e570a4d7dd6">&#9670;&nbsp;</a></span>reset_all_manifolds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::reset_all_manifolds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all parts of the triangulation, regardless of their manifold_id, to use a <a class="el" href="classFlatManifold.html">FlatManifold</a> object. This undoes assignment of all <a class="el" href="classManifold.html">Manifold</a> objects by the function <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">Triangulation::set_manifold()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gae2acfbef517fd03855c4b371f3e182f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae2acfbef517fd03855c4b371f3e182f7">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold_id of all cells and faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga1f1ea841946c94c079388ecf9ad2c00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f1ea841946c94c079388ecf9ad2c00c">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces to the given argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaa4e0af28512cb5f9cc8cb3b95a38c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4e0af28512cb5f9cc8cb3b95a38c669">&#9670;&nbsp;</a></span>set_all_manifold_ids_on_boundary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::set_all_manifold_ids_on_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname"><em>b_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold_id of all boundary faces and edges with given boundary_id <code>b_id</code> to the given manifold_id <code>number</code>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gaa5d4bed3d2ac6148e969a331bde49f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa5d4bed3d2ac6148e969a331bde49f63">&#9670;&nbsp;</a></span>get_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt;&amp; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"><em>number</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant reference to a <a class="el" href="classManifold.html">Manifold</a> object used for this triangulation. <code>number</code> is the same as in <a class="el" href="group__manifold.html#ga9f9d720f5fbdcdf3dcbb445feefbdb9f">set_manifold()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>If no manifold could be found, the default flat manifold is returned.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga0ee729ae049af6f1495d0059d6086e52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ee729ae049af6f1495d0059d6086e52">&#9670;&nbsp;</a></span>get_manifold_ids()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;<a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&gt; <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::get_manifold_ids </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector containing all manifold indicators assigned to the objects of the active cells of this <a class="el" href="classTriangulation.html">Triangulation</a>. Note, that each manifold indicator is reported only once. The size of the return vector will represent the number of different indicators (which is greater or equal one).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

<p>Reimplemented in <a class="el" href="classparallel_1_1TriangulationBase.html#a51f63aebdfa85dc769c1503c00670a7e">parallel::TriangulationBase&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="gafbeb21da36433dc2ec117b9694ca2557"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafbeb21da36433dc2ec117b9694ca2557">&#9670;&nbsp;</a></span>set_manifold_id()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_manifold_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold indicator. The same applies as for the <code><a class="el" href="classTriaAccessor.html#a6c28dbcfefe0ffe1e51fe315c3565f94">manifold_id()</a></code> function.</p>
<p>Note that it only sets the manifold object of the current object itself, not the indicators of the ones that bound it, nor of its children. For example, in 3d, if this function is called on a face, then the manifold indicator of the 4 edges that bound the face remain unchanged. If you want to set the manifold indicators of face, edges and all children at the same time, use the <a class="el" href="group__manifold.html#ga160a26ce22b36607556bcdcc20bc6d61">set_all_manifold_ids()</a> function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga160a26ce22b36607556bcdcc20bc6d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga160a26ce22b36607556bcdcc20bc6d61">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int structdim, int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; structdim, dim, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do as <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id()</a> but also set the manifold indicators of the objects that bound the current object. For example, in 3d, if <a class="el" href="group__manifold.html#gafbeb21da36433dc2ec117b9694ca2557">set_manifold_id()</a> is called on a face, then the manifold indicator of the 4 edges that bound the face remain unchanged. On the other hand, the manifold indicators of face and edges are all set at the same time using the current function.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="ga853633832f20bf91d674749b9ae83827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga853633832f20bf91d674749b9ae83827">&#9670;&nbsp;</a></span>set_all_manifold_ids() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTriaAccessor.html">TriaAccessor</a>&lt; 0, 1, spacedim &gt;::set_all_manifold_ids </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the manifold indicator of this object and all of its lower- dimensional sub-objects. Since this object only represents a single vertex, there are no lower-dimensional object and this function is equivalent to calling <a class="el" href="classTriaAccessor_3_010_00_011_00_01spacedim_01_4.html#aea37d3b925b8e6a2c02d9ef9c454ed54">set_manifold_id()</a> with the same argument.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossManifoldIndicator">Glossary entry on manifold indicators</a> </dd></dl>

</div>
</div>
<a id="gae8bdd10dc34f9ebb869b30bfaf70ff32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8bdd10dc34f9ebb869b30bfaf70ff32">&#9670;&nbsp;</a></span>assign_co_dimensional_manifold_indicators()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void GridTools::assign_co_dimensional_manifold_indicators </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>(const std::set&lt; <a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a> &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>disambiguation_function</em> = <code>[](const&#160;std::set&lt;&#160;<a class="el" href="namespacetypes.html#a24c02646474836ad4f37ca167e191276">types::manifold_id</a>&#160;&gt;&#160;&amp;manifold_ids)&#160;{&#160;if(manifold_ids.size()==1)&#160;return&#160;*manifold_ids.begin();else&#160;return&#160;<a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>;}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>overwrite_only_flat_manifold_ids</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Propagate manifold indicators associated with the cells of the <a class="el" href="classTriangulation.html">Triangulation</a> <code>tria</code> to their co-dimension one and two objects.</p>
<p>This function sets the <code>manifold_id</code> of faces and edges (both on the interior and on the boundary) to the value returned by the <code>disambiguation_function</code> method, called with the set of manifold indicators of the cells that share the same face or edge.</p>
<p>By default, the <code>disambiguation_function</code> returns <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a> when the set has size greater than one (i.e., when it is not possible to decide what manifold indicator a face or edge should have according to the manifold indicators of the adjacent cells) and it returns the manifold indicator contained in the set when it has dimension one (i.e., when all adjacent cells and faces have the same manifold indicator).</p>
<p>The parameter <code>overwrite_only_flat_manifold_ids</code> allows you to specify what to do when a face or an edge already has a manifold indicator different from <a class="el" href="namespacenumbers.html#a9c39a5de95e4d11173378431dc2131fe">numbers::flat_manifold_id</a>. If the flag is <code>true</code>, the edge or face will maintain its original manifold indicator. If it is <code>false</code>, then also the manifold indicator of these faces and edges is set according to the return value of the <code>disambiguation_function</code>. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
