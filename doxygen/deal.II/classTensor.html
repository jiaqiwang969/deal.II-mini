<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTensor.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Tensor&lt; rank_, dim, Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="classTensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Tensor&lt; rank_, dim, Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__geomprimitives.html">Geometric and other primitives</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="tensor_8h_source.html">deal.II/base/tensor.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Tensor&lt; rank_, dim, Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classTensor__inherit__graph.svg" width="1360" height="1780"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a81d20aa0cc1fc1510b3a10d28842e516"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a81d20aa0cc1fc1510b3a10d28842e516">value_type</a> = typename <a class="el" href="classTensor.html">Tensor</a>&lt; rank_ - 1, dim, Number &gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a></td></tr>
<tr class="separator:a81d20aa0cc1fc1510b3a10d28842e516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1452bf1234bc23a62d9f5fd801535d6a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a1452bf1234bc23a62d9f5fd801535d6a">array_type</a> = typename <a class="el" href="classTensor.html">Tensor</a>&lt; rank_ - 1, dim, Number &gt;::<a class="el" href="classTensor.html#a1452bf1234bc23a62d9f5fd801535d6a">array_type</a>[(dim !=0) ? dim :1]</td></tr>
<tr class="separator:a1452bf1234bc23a62d9f5fd801535d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff8ee52ec395c87107aee5be1b7be3a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a> = <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;</td></tr>
<tr class="separator:acff8ee52ec395c87107aee5be1b7be3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a72139803a5d9c82790b533ad2d966982"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a72139803a5d9c82790b533ad2d966982">Tensor</a> ()</td></tr>
<tr class="separator:a72139803a5d9c82790b533ad2d966982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8a775428e8c476cb85894c5839356e"><td class="memItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#aeb8a775428e8c476cb85894c5839356e">Tensor</a> (const <a class="el" href="classTensor.html#a1452bf1234bc23a62d9f5fd801535d6a">array_type</a> &amp;initializer)</td></tr>
<tr class="separator:aeb8a775428e8c476cb85894c5839356e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0463d8b406ed60b7db0763a508102e8a"><td class="memTemplParams" colspan="2">template&lt;typename ElementType , typename MemorySpace &gt; </td></tr>
<tr class="memitem:a0463d8b406ed60b7db0763a508102e8a"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a0463d8b406ed60b7db0763a508102e8a">Tensor</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; ElementType, MemorySpace &gt; &amp;initializer)</td></tr>
<tr class="separator:a0463d8b406ed60b7db0763a508102e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b581ed73ff2383aa74419b3345ccb24"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a4b581ed73ff2383aa74419b3345ccb24"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a4b581ed73ff2383aa74419b3345ccb24">Tensor</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;initializer)</td></tr>
<tr class="separator:a4b581ed73ff2383aa74419b3345ccb24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66b5d1fd14a1fb52acd273a91dc04d3b"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a66b5d1fd14a1fb52acd273a91dc04d3b"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a66b5d1fd14a1fb52acd273a91dc04d3b">Tensor</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classTensor.html">Tensor</a>&lt; rank_ - 1, dim, OtherNumber &gt;&gt; &amp;initializer)</td></tr>
<tr class="separator:a66b5d1fd14a1fb52acd273a91dc04d3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2dbe01a5c3f92a469c446d54c40abb"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a1f2dbe01a5c3f92a469c446d54c40abb"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a1f2dbe01a5c3f92a469c446d54c40abb">operator Tensor&lt; 1, dim, Tensor&lt; rank_ - 1, dim, OtherNumber &gt;&gt;</a> () const</td></tr>
<tr class="separator:a1f2dbe01a5c3f92a469c446d54c40abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad194bd5ea5dfb608aa6870d528bbd5a5"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html#a81d20aa0cc1fc1510b3a10d28842e516">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#ad194bd5ea5dfb608aa6870d528bbd5a5">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:ad194bd5ea5dfb608aa6870d528bbd5a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e175587b3c7ec3e69dc2389d2e12d1f"><td class="memItemLeft" align="right" valign="top">constexpr const <a class="el" href="classTensor.html#a81d20aa0cc1fc1510b3a10d28842e516">value_type</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a4e175587b3c7ec3e69dc2389d2e12d1f">operator[]</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a4e175587b3c7ec3e69dc2389d2e12d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ad45d5ef39bb19c1781104cfa7f2719"><td class="memItemLeft" align="right" valign="top">constexpr const Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a4ad45d5ef39bb19c1781104cfa7f2719">operator[]</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices) const</td></tr>
<tr class="separator:a4ad45d5ef39bb19c1781104cfa7f2719"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551bc8879285f6fa0c1af8edfe1e97ba"><td class="memItemLeft" align="right" valign="top">constexpr Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a551bc8879285f6fa0c1af8edfe1e97ba">operator[]</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices)</td></tr>
<tr class="separator:a551bc8879285f6fa0c1af8edfe1e97ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf51824501b35657c109b15b24845ade"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#aaf51824501b35657c109b15b24845ade">begin_raw</a> ()</td></tr>
<tr class="separator:aaf51824501b35657c109b15b24845ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aad90204dd22941d557dd847bd991a9"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a7aad90204dd22941d557dd847bd991a9">begin_raw</a> () const</td></tr>
<tr class="separator:a7aad90204dd22941d557dd847bd991a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e9c49f0f76fa957bff112e5cf6973e"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a71e9c49f0f76fa957bff112e5cf6973e">end_raw</a> ()</td></tr>
<tr class="separator:a71e9c49f0f76fa957bff112e5cf6973e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e1c9b494f6133582a0520f7c6246e1"><td class="memItemLeft" align="right" valign="top">const Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#ad4e1c9b494f6133582a0520f7c6246e1">end_raw</a> () const</td></tr>
<tr class="separator:ad4e1c9b494f6133582a0520f7c6246e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a640a9cfc2c7d0e23e5394bce43521ade"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a640a9cfc2c7d0e23e5394bce43521ade"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a640a9cfc2c7d0e23e5394bce43521ade">operator=</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;rhs)</td></tr>
<tr class="separator:a640a9cfc2c7d0e23e5394bce43521ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd585d3cdadbd9bf0fce6ca4a0b25e86"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#acd585d3cdadbd9bf0fce6ca4a0b25e86">operator=</a> (const Number &amp;d)</td></tr>
<tr class="separator:acd585d3cdadbd9bf0fce6ca4a0b25e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064a6aafb0388efbb736370aad64e3c5"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a064a6aafb0388efbb736370aad64e3c5"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a064a6aafb0388efbb736370aad64e3c5">operator==</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;) const</td></tr>
<tr class="separator:a064a6aafb0388efbb736370aad64e3c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f25fcb07d6ce69fe6ca3bf4912d6a84"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a6f25fcb07d6ce69fe6ca3bf4912d6a84"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a6f25fcb07d6ce69fe6ca3bf4912d6a84">operator!=</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;) const</td></tr>
<tr class="separator:a6f25fcb07d6ce69fe6ca3bf4912d6a84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b14f54bb62c5405e657dd148b3f56e4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a1b14f54bb62c5405e657dd148b3f56e4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a1b14f54bb62c5405e657dd148b3f56e4">operator+=</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;)</td></tr>
<tr class="separator:a1b14f54bb62c5405e657dd148b3f56e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b86ff1fb61ff1d1f4b4763dd86f17c7"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a1b86ff1fb61ff1d1f4b4763dd86f17c7"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a1b86ff1fb61ff1d1f4b4763dd86f17c7">operator-=</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;)</td></tr>
<tr class="separator:a1b86ff1fb61ff1d1f4b4763dd86f17c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deb61c717ad0fe04eea0b669930d00c"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a1deb61c717ad0fe04eea0b669930d00c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a1deb61c717ad0fe04eea0b669930d00c">operator*=</a> (const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a1deb61c717ad0fe04eea0b669930d00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98c50fee6f5551a7b415569a04d1466d"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a98c50fee6f5551a7b415569a04d1466d"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a98c50fee6f5551a7b415569a04d1466d">operator/=</a> (const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a98c50fee6f5551a7b415569a04d1466d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefefaeca7323eb80aad5ce0822178578"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#aefefaeca7323eb80aad5ce0822178578">operator-</a> () const</td></tr>
<tr class="separator:aefefaeca7323eb80aad5ce0822178578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508ec4561f82997a2f883163d550d312"><td class="memItemLeft" align="right" valign="top">constexpr void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a508ec4561f82997a2f883163d550d312">clear</a> ()</td></tr>
<tr class="separator:a508ec4561f82997a2f883163d550d312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0934b4edd71063f66a9c67540e79fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#afd0934b4edd71063f66a9c67540e79fc">norm</a> () const</td></tr>
<tr class="separator:afd0934b4edd71063f66a9c67540e79fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a3169a68a27cc04f2ad1fd9790b874c"><td class="memItemLeft" align="right" valign="top">constexpr <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::real_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a7a3169a68a27cc04f2ad1fd9790b874c">norm_square</a> () const</td></tr>
<tr class="separator:a7a3169a68a27cc04f2ad1fd9790b874c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5247561f23bd98ebc99dc8d54b1b19fe"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a5247561f23bd98ebc99dc8d54b1b19fe"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a5247561f23bd98ebc99dc8d54b1b19fe">unroll</a> (<a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;result) const</td></tr>
<tr class="separator:a5247561f23bd98ebc99dc8d54b1b19fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade3232e978fc18c65b746b7597868638"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:ade3232e978fc18c65b746b7597868638"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ade3232e978fc18c65b746b7597868638">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:ade3232e978fc18c65b746b7597868638"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a691feb72e96831cab4a85fbc28167abd"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a691feb72e96831cab4a85fbc28167abd">component_to_unrolled_index</a> (const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;indices)</td></tr>
<tr class="separator:a691feb72e96831cab4a85fbc28167abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2967bd64add4b290f52801a682d722d2"><td class="memItemLeft" align="right" valign="top">static constexpr <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a2967bd64add4b290f52801a682d722d2">unrolled_to_component_indices</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:a2967bd64add4b290f52801a682d722d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa684a29980c5e7787414e35636b5d0dc"><td class="memItemLeft" align="right" valign="top">static constexpr std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#aa684a29980c5e7787414e35636b5d0dc">memory_consumption</a> ()</td></tr>
<tr class="separator:aa684a29980c5e7787414e35636b5d0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9a72352995b42241f9e90c697cecab85"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a9a72352995b42241f9e90c697cecab85">dimension</a> = dim</td></tr>
<tr class="separator:a9a72352995b42241f9e90c697cecab85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3b967eb1f9ba8e9237260ceb26fd5c"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a> = rank_</td></tr>
<tr class="separator:a3b3b967eb1f9ba8e9237260ceb26fd5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed199dbe319871d4d1ee68ef763cc4ac"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#aed199dbe319871d4d1ee68ef763cc4ac">n_independent_components</a></td></tr>
<tr class="separator:aed199dbe319871d4d1ee68ef763cc4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac28d5dc5dbe7ac90f03b79b5a5131556"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ac28d5dc5dbe7ac90f03b79b5a5131556"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ac28d5dc5dbe7ac90f03b79b5a5131556">unroll_recursion</a> (<a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;result, unsigned <a class="el" href="classint.html">int</a> &amp;start_index) const</td></tr>
<tr class="separator:ac28d5dc5dbe7ac90f03b79b5a5131556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2b5f7538f024325c2a7dc33ff932240"><td class="memTemplParams" colspan="2">template&lt;typename ArrayLike , std::size_t... Indices&gt; </td></tr>
<tr class="memitem:ad2b5f7538f024325c2a7dc33ff932240"><td class="memTemplItemLeft" align="right" valign="top">constexpr&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ad2b5f7538f024325c2a7dc33ff932240">Tensor</a> (const ArrayLike &amp;initializer, std::index_sequence&lt; Indices... &gt;)</td></tr>
<tr class="separator:ad2b5f7538f024325c2a7dc33ff932240"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:af47d364c3c106ce504e0f41bfe740cf8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; rank_ - 1, dim, Number &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#af47d364c3c106ce504e0f41bfe740cf8">values</a> [(dim !=0) ? dim :1]</td></tr>
<tr class="separator:af47d364c3c106ce504e0f41bfe740cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a837dcd9e4e283888ec9f3d11478d0f21"><td class="memTemplParams" colspan="2">template&lt;int , int , typename &gt; </td></tr>
<tr class="memitem:a837dcd9e4e283888ec9f3d11478d0f21"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a837dcd9e4e283888ec9f3d11478d0f21">Tensor</a></td></tr>
<tr class="separator:a837dcd9e4e283888ec9f3d11478d0f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa03297e722be020f98fc14aafcab34a7"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTensor.html#aa03297e722be020f98fc14aafcab34a7">Point&lt; dim, Number &gt;</a></td></tr>
<tr class="separator:aa03297e722be020f98fc14aafcab34a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:af47eaebd03e0a183fd38a09d8863659f"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number &gt; </td></tr>
<tr class="memitem:af47eaebd03e0a183fd38a09d8863659f"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#af47eaebd03e0a183fd38a09d8863659f">sum</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;local, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator)</td></tr>
<tr class="separator:af47eaebd03e0a183fd38a09d8863659f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Output functions for Tensor objects</div></td></tr>
<tr class="memitem:a26060566f66f799dab8bbe04289ed81b"><td class="memTemplParams" colspan="2">template&lt;int rank_, int dim, typename Number &gt; </td></tr>
<tr class="memitem:a26060566f66f799dab8bbe04289ed81b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a26060566f66f799dab8bbe04289ed81b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:a26060566f66f799dab8bbe04289ed81b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c3b3312173253961fda78ac2b7bf4b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a92c3b3312173253961fda78ac2b7bf4b"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a92c3b3312173253961fda78ac2b7bf4b">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;p)</td></tr>
<tr class="separator:a92c3b3312173253961fda78ac2b7bf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vector space operations on Tensor objects:</div></td></tr>
<tr class="memitem:a866270925a280330ae3e2bd05e648dc4"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename Other &gt; </td></tr>
<tr class="memitem:a866270925a280330ae3e2bd05e648dc4"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Other, Number &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a866270925a280330ae3e2bd05e648dc4">operator*</a> (const Other &amp;object, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a866270925a280330ae3e2bd05e648dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad27223b3f4809138f070ca30369b7f26"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename Other &gt; </td></tr>
<tr class="memitem:ad27223b3f4809138f070ca30369b7f26"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, Other &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ad27223b3f4809138f070ca30369b7f26">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;t, const Other &amp;object)</td></tr>
<tr class="separator:ad27223b3f4809138f070ca30369b7f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6af378a072e8881e65058bd937de898a"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a6af378a072e8881e65058bd937de898a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a6af378a072e8881e65058bd937de898a">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a6af378a072e8881e65058bd937de898a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361b2cfdd860d356ad80c91147c76327"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a361b2cfdd860d356ad80c91147c76327"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a361b2cfdd860d356ad80c91147c76327">operator/</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a361b2cfdd860d356ad80c91147c76327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab976c32648a69f93416e35b2c6c82800"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ab976c32648a69f93416e35b2c6c82800"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ab976c32648a69f93416e35b2c6c82800">operator+</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:ab976c32648a69f93416e35b2c6c82800"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ed2c7983fc5c58b67291507d41c20d0"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a2ed2c7983fc5c58b67291507d41c20d0"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a2ed2c7983fc5c58b67291507d41c20d0">operator-</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:a2ed2c7983fc5c58b67291507d41c20d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94c55da76e6d429a04c325ec2db311a"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ad94c55da76e6d429a04c325ec2db311a"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ad94c55da76e6d429a04c325ec2db311a">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:ad94c55da76e6d429a04c325ec2db311a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4635b4d8f14ce045aeec05eaed74ba8"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:aa4635b4d8f14ce045aeec05eaed74ba8"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#aa4635b4d8f14ce045aeec05eaed74ba8">operator*</a> (const Number &amp;factor, const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;t)</td></tr>
<tr class="separator:aa4635b4d8f14ce045aeec05eaed74ba8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a071fce7ab1078d6407cb42ff790ef0ce"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a071fce7ab1078d6407cb42ff790ef0ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a071fce7ab1078d6407cb42ff790ef0ce">operator/</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;t, const OtherNumber &amp;factor)</td></tr>
<tr class="separator:a071fce7ab1078d6407cb42ff790ef0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8406ed86acf24dbf6e3fa6e2c531cf5f"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a8406ed86acf24dbf6e3fa6e2c531cf5f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a8406ed86acf24dbf6e3fa6e2c531cf5f">operator+</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:a8406ed86acf24dbf6e3fa6e2c531cf5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acca33b30cb806b4240462114190ff5f1"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:acca33b30cb806b4240462114190ff5f1"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#acca33b30cb806b4240462114190ff5f1">operator-</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;p, const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;q)</td></tr>
<tr class="separator:acca33b30cb806b4240462114190ff5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7435d412395211da77bfd33a98d86c8e"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a7435d412395211da77bfd33a98d86c8e"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a7435d412395211da77bfd33a98d86c8e">schur_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a7435d412395211da77bfd33a98d86c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8b8b98a183ecfdb74d685655f1a7edd"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:ac8b8b98a183ecfdb74d685655f1a7edd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ac8b8b98a183ecfdb74d685655f1a7edd">schur_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:ac8b8b98a183ecfdb74d685655f1a7edd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Contraction operations and the outer product for tensor objects</div></td></tr>
<tr class="memitem:ab497e11d02a539db2e4b4676d5119e2b"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber , typename  = typename std::enable_if&lt;rank_1 &gt;= 1 &amp;&amp; rank_2&gt; </td></tr>
<tr class="memitem:ab497e11d02a539db2e4b4676d5119e2b"><td class="memTemplItemLeft" align="right" valign="top">OtherNumber::type::tensor_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ab497e11d02a539db2e4b4676d5119e2b">operator*</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:ab497e11d02a539db2e4b4676d5119e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9711379deb6b31d5ef98c5aa194e7057"><td class="memTemplParams" colspan="2">template&lt;int index_1, int index_2, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a9711379deb6b31d5ef98c5aa194e7057"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a9711379deb6b31d5ef98c5aa194e7057">contract</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a9711379deb6b31d5ef98c5aa194e7057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ef2ce44eebfa45884c747b286128555"><td class="memTemplParams" colspan="2">template&lt;int index_1, int index_2, int index_3, int index_4, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a3ef2ce44eebfa45884c747b286128555"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 4, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a3ef2ce44eebfa45884c747b286128555">double_contract</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a3ef2ce44eebfa45884c747b286128555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71d0baf87e7b3d210ee9c0922a4b7f9f"><td class="memTemplParams" colspan="2">template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a71d0baf87e7b3d210ee9c0922a4b7f9f"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a71d0baf87e7b3d210ee9c0922a4b7f9f">scalar_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;left, const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;right)</td></tr>
<tr class="separator:a71d0baf87e7b3d210ee9c0922a4b7f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeff476b88727f4418ec899ec85471063"><td class="memTemplParams" colspan="2">template&lt;template&lt; int, int, typename &gt; class TensorT1, template&lt; int, int, typename &gt; class TensorT2, template&lt; int, int, typename &gt; class TensorT3, int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 &gt; </td></tr>
<tr class="memitem:aeff476b88727f4418ec899ec85471063"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; T1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T2, T3 &gt;::type &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#aeff476b88727f4418ec899ec85471063">contract3</a> (const TensorT1&lt; rank_1, dim, T1 &gt; &amp;left, const TensorT2&lt; rank_1+rank_2, dim, T2 &gt; &amp;middle, const TensorT3&lt; rank_2, dim, T3 &gt; &amp;right)</td></tr>
<tr class="separator:aeff476b88727f4418ec899ec85471063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b76d52ead3fafce2f9c8e06cd1762ba"><td class="memTemplParams" colspan="2">template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </td></tr>
<tr class="memitem:a0b76d52ead3fafce2f9c8e06cd1762ba"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a0b76d52ead3fafce2f9c8e06cd1762ba">outer_product</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;src2)</td></tr>
<tr class="separator:a0b76d52ead3fafce2f9c8e06cd1762ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Special operations on tensors of rank 1</div></td></tr>
<tr class="memitem:a9b0ea33c5eb6c2986072c80d4916599b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a9b0ea33c5eb6c2986072c80d4916599b"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a9b0ea33c5eb6c2986072c80d4916599b">cross_product_2d</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;src)</td></tr>
<tr class="separator:a9b0ea33c5eb6c2986072c80d4916599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8718a0f27d7cfaa0b91464bb81e2c28"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number1 , typename Number2 &gt; </td></tr>
<tr class="memitem:af8718a0f27d7cfaa0b91464bb81e2c28"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number1, Number2 &gt;::type &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#af8718a0f27d7cfaa0b91464bb81e2c28">cross_product_3d</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number1 &gt; &amp;src1, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number2 &gt; &amp;src2)</td></tr>
<tr class="separator:af8718a0f27d7cfaa0b91464bb81e2c28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Special operations on tensors of rank 2</div></td></tr>
<tr class="memitem:a3e191fd2cb0ed2b86e5ca58aaedcdd13"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a3e191fd2cb0ed2b86e5ca58aaedcdd13"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a3e191fd2cb0ed2b86e5ca58aaedcdd13">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a3e191fd2cb0ed2b86e5ca58aaedcdd13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6a5bcd00c2a33b1af85f2ffc2976243"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ab6a5bcd00c2a33b1af85f2ffc2976243"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ab6a5bcd00c2a33b1af85f2ffc2976243">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 1, Number &gt; &amp;t)</td></tr>
<tr class="separator:ab6a5bcd00c2a33b1af85f2ffc2976243"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad34b6b774c5a94e2d75219bc1de767f5"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ad34b6b774c5a94e2d75219bc1de767f5"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ad34b6b774c5a94e2d75219bc1de767f5">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 2, Number &gt; &amp;t)</td></tr>
<tr class="separator:ad34b6b774c5a94e2d75219bc1de767f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fff6c2d9823b88726460d9bd373a5b"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae9fff6c2d9823b88726460d9bd373a5b"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#ae9fff6c2d9823b88726460d9bd373a5b">determinant</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 3, Number &gt; &amp;t)</td></tr>
<tr class="separator:ae9fff6c2d9823b88726460d9bd373a5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947dac48d007097defaf2736e4586e1d"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a947dac48d007097defaf2736e4586e1d"><td class="memTemplItemLeft" align="right" valign="top">constexpr Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a947dac48d007097defaf2736e4586e1d">trace</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;d)</td></tr>
<tr class="separator:a947dac48d007097defaf2736e4586e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addae444929c0f639ff2a684d87616220"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:addae444929c0f639ff2a684d87616220"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#addae444929c0f639ff2a684d87616220">invert</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;)</td></tr>
<tr class="separator:addae444929c0f639ff2a684d87616220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2991e0d54a5ae64c50fe9573570c5fcd"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a2991e0d54a5ae64c50fe9573570c5fcd"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a2991e0d54a5ae64c50fe9573570c5fcd">transpose</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a2991e0d54a5ae64c50fe9573570c5fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403b17edbfb509662833ac8f5213f20"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a1403b17edbfb509662833ac8f5213f20"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a1403b17edbfb509662833ac8f5213f20">adjugate</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a1403b17edbfb509662833ac8f5213f20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05378f1d72d70a9f08c4f6edab2cbe2c"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a05378f1d72d70a9f08c4f6edab2cbe2c"><td class="memTemplItemLeft" align="right" valign="top">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a05378f1d72d70a9f08c4f6edab2cbe2c">cofactor</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a05378f1d72d70a9f08c4f6edab2cbe2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92a1fd2ad72ff18b882744a2413bca73"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a92a1fd2ad72ff18b882744a2413bca73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a92a1fd2ad72ff18b882744a2413bca73">project_onto_orthogonal_tensors</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;A)</td></tr>
<tr class="separator:a92a1fd2ad72ff18b882744a2413bca73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93ba01d979880b278cd4b573dd9c653b"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a93ba01d979880b278cd4b573dd9c653b"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a93ba01d979880b278cd4b573dd9c653b">l1_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a93ba01d979880b278cd4b573dd9c653b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858195ddbd94c49d6a2cdd447fc5ee63"><td class="memTemplParams" colspan="2">template&lt;int dim, typename Number &gt; </td></tr>
<tr class="memitem:a858195ddbd94c49d6a2cdd447fc5ee63"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTensor.html#a858195ddbd94c49d6a2cdd447fc5ee63">linfty_norm</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;t)</td></tr>
<tr class="separator:a858195ddbd94c49d6a2cdd447fc5ee63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int rank_, int dim, typename Number&gt;<br />
class Tensor&lt; rank_, dim, Number &gt;</h3>

<p>A general tensor class with an arbitrary rank, i.e. with an arbitrary number of indices. The <a class="el" href="classTensor.html">Tensor</a> class provides an indexing operator and a bit of infrastructure, but most functionality is recursively handed down to tensors of rank 1 or put into external templated functions, e.g. the <code>contract</code> family.</p>
<p>The rank of a tensor specifies which types of physical quantities it can represent: </p><ul>
<li>
A rank-0 tensor is a scalar that can store quantities such as temperature or pressure. These scalar quantities are shown in this documentation as simple lower-case Latin letters e.g. \(a, b, c, \dots\).  </li>
<li>
A rank-1 tensor is a vector with <code>dim</code> components and it can represent vector quantities such as velocity, displacement, electric field, etc. They can also describe the gradient of a scalar field. The notation used for rank-1 tensors is bold-faced lower-case Latin letters e.g. \(\mathbf a, \mathbf b, \mathbf c, \dots\). The components of a rank-1 tensor such as \(\mathbf a\) are represented as \(a_i\) where \(i\) is an index between 0 and <code>dim-1</code>.  </li>
<li>
A rank-2 tensor is a linear operator that can transform a vector into another vector. These tensors are similar to matrices with \(\text{dim} \times \text{dim}\) components. There is a related class <a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt;2,dim&gt;</a> for tensors of rank 2 whose elements are symmetric. Rank-2 tensors are usually denoted by bold-faced upper-case Latin letters such as \(\mathbf A, \mathbf B, \dots\) or bold-faced Greek letters for example \(\boldsymbol{\varepsilon}, \boldsymbol{\sigma}\). The components of a rank 2 tensor such as \(\mathbf A\) are shown with two indices \((i,j)\) as \(A_{ij}\). These tensors usually describe the gradients of vector fields (deformation gradient, velocity gradient, etc.) or Hessians of scalar fields. Additionally, mechanical stress tensors are rank-2 tensors that map the unit normal vectors of internal surfaces into local traction (force per unit area) vectors.  </li>
<li>
Tensors with ranks higher than 2 are similarly defined in a consistent manner. They have \(\text{dim}^{\text{rank}}\) components and the number of indices required to identify a component equals <code>rank</code>. For rank-4 tensors, a symmetric variant called <a class="el" href="classSymmetricTensor.html">SymmetricTensor&lt;4,dim&gt;</a> exists.  </li>
</ul>
<p>Using this tensor class for objects of rank 2 has advantages over matrices in many cases since the dimension is known to the compiler as well as the location of the data. It is therefore possible to produce far more efficient code than for matrices with runtime-dependent dimension. It also makes the code easier to read because of the semantic difference between a tensor (an object that relates to a coordinate system and has transformation properties with regard to coordinate rotations and transforms) and matrices (which we consider as operators on arbitrary vector spaces related to linear algebra things).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank_</td><td>An integer that denotes the rank of this tensor. A specialization of this class exists for rank-0 tensors.</td></tr>
    <tr><td class="paramname">dim</td><td>An integer that denotes the dimension of the space in which this tensor operates. This of course equals the number of coordinates that identify a point and rank-1 tensor.</td></tr>
    <tr><td class="paramname">Number</td><td>The data type in which the tensor elements are to be stored. This will, in almost all cases, simply be the default <code>double</code>, but there are cases where one may want to store elements in a different (and always scalar) type. It can be used to base tensors on <code>float</code> or <code>complex</code> numbers or any other data type that implements basic arithmetic operations. Another example would be a type that allows for Automatic <a class="el" href="namespaceDifferentiation.html">Differentiation</a> (see, for example, the Sacado type used in step-33) and thereby can generate analytic (spatial) derivatives of a function that takes a tensor as argument. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00471">471</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a81d20aa0cc1fc1510b3a10d28842e516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81d20aa0cc1fc1510b3a10d28842e516">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html#a81d20aa0cc1fc1510b3a10d28842e516">value_type</a> =  typename <a class="el" href="classTensor.html">Tensor</a>&lt;rank_ - 1, dim, Number&gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of objects encapsulated by this container and returned by <a class="el" href="classTensor.html#ad194bd5ea5dfb608aa6870d528bbd5a5">operator[]()</a>. This is a tensor of lower rank for a general tensor, and a scalar number type for <a class="el" href="classTensor.html">Tensor&lt;1,dim,Number&gt;</a>. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00505">505</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a1452bf1234bc23a62d9f5fd801535d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1452bf1234bc23a62d9f5fd801535d6a">&#9670;&nbsp;</a></span>array_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html#a1452bf1234bc23a62d9f5fd801535d6a">array_type</a> =  typename <a class="el" href="classTensor.html">Tensor</a>&lt;rank_ - 1, dim, Number&gt;::<a class="el" href="classTensor.html#a1452bf1234bc23a62d9f5fd801535d6a">array_type</a>[(dim != 0) ? dim : 1]</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an array type which can be used to initialize an object of this type statically. For <code>dim == 0</code>, its size is 1. Otherwise, it is <code>dim</code>. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00512">512</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="acff8ee52ec395c87107aee5be1b7be3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff8ee52ec395c87107aee5be1b7be3a">&#9670;&nbsp;</a></span>tensor_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a> =  <a class="el" href="classTensor.html">Tensor</a>&lt;rank_, dim, Number&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal type declaration that is used to specialize the return type of <a class="el" href="classTensor.html#ad194bd5ea5dfb608aa6870d528bbd5a5">operator[]()</a> for <a class="el" href="classTensor.html">Tensor&lt;1,dim,Number&gt;</a> </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00808">808</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a72139803a5d9c82790b533ad2d966982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72139803a5d9c82790b533ad2d966982">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Initialize all entries to zero.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="aeb8a775428e8c476cb85894c5839356e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8a775428e8c476cb85894c5839356e">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html#a1452bf1234bc23a62d9f5fd801535d6a">array_type</a> &amp;&#160;</td>
          <td class="paramname"><em>initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A constructor where the data is copied from a C-style array.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a0463d8b406ed60b7db0763a508102e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0463d8b406ed60b7db0763a508102e8a">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename ElementType , typename MemorySpace &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; ElementType, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A constructor where the data is copied from an <a class="el" href="classArrayView.html">ArrayView</a> object. Obviously, the <a class="el" href="classArrayView.html">ArrayView</a> object must represent a stretch of data of size <code>dim</code><sup><code>rank</code></sup>. The sequentially ordered elements of the argument <code>initializer</code> are interpreted as described by unrolled_to_component_index().</p>
<p>This constructor obviously requires that the <code>ElementType</code> type is either equal to <code>Number</code>, or is convertible to <code>Number</code>. Number.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a4b581ed73ff2383aa74419b3345ccb24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b581ed73ff2383aa74419b3345ccb24">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor from tensors with different underlying scalar type. This obviously requires that the <code>OtherNumber</code> type is convertible to <code>Number</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a66b5d1fd14a1fb52acd273a91dc04d3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66b5d1fd14a1fb52acd273a91dc04d3b">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classTensor.html">Tensor</a>&lt; rank_ - 1, dim, OtherNumber &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>initializer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor that converts from a "tensor of tensors". </p>

</div>
</div>
<a id="ad2b5f7538f024325c2a7dc33ff932240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2b5f7538f024325c2a7dc33ff932240">&#9670;&nbsp;</a></span>Tensor() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename ArrayLike , std::size_t... Indices&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::<a class="el" href="classTensor.html">Tensor</a> </td>
          <td>(</td>
          <td class="paramtype">const ArrayLike &amp;&#160;</td>
          <td class="paramname"><em>initializer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Indices... &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This constructor is for internal use. It provides a way to create constexpr constructors for <a class="el" href="classTensor.html">Tensor&lt;rank, dim, Number&gt;</a></p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1f2dbe01a5c3f92a469c446d54c40abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2dbe01a5c3f92a469c446d54c40abb">&#9670;&nbsp;</a></span>operator Tensor< 1, dim, Tensor< rank_ - 1, dim, OtherNumber >>()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, <a class="el" href="classTensor.html">Tensor</a>&lt; rank_ - 1, dim, OtherNumber &gt;&gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion operator to tensor of tensors. </p>

</div>
</div>
<a id="ad194bd5ea5dfb608aa6870d528bbd5a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad194bd5ea5dfb608aa6870d528bbd5a5">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html#a81d20aa0cc1fc1510b3a10d28842e516">value_type</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-Write access operator.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a4e175587b3c7ec3e69dc2389d2e12d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e175587b3c7ec3e69dc2389d2e12d1f">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const <a class="el" href="classTensor.html#a81d20aa0cc1fc1510b3a10d28842e516">value_type</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read-only access operator.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a4ad45d5ef39bb19c1781104cfa7f2719"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ad45d5ef39bb19c1781104cfa7f2719">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr const Number&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access using <a class="el" href="classTableIndices.html">TableIndices</a> <code>indices</code> </p>

</div>
</div>
<a id="a551bc8879285f6fa0c1af8edfe1e97ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551bc8879285f6fa0c1af8edfe1e97ba">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access using <a class="el" href="classTableIndices.html">TableIndices</a> <code>indices</code> </p>

</div>
</div>
<a id="aaf51824501b35657c109b15b24845ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf51824501b35657c109b15b24845ade">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the first element of the underlying storage. </p>

</div>
</div>
<a id="a7aad90204dd22941d557dd847bd991a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aad90204dd22941d557dd847bd991a9">&#9670;&nbsp;</a></span>begin_raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::begin_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a const pointer to the first element of the underlying storage. </p>

</div>
</div>
<a id="a71e9c49f0f76fa957bff112e5cf6973e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e9c49f0f76fa957bff112e5cf6973e">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::end_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the element past the end of the underlying storage. </p>

</div>
</div>
<a id="ad4e1c9b494f6133582a0520f7c6246e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e1c9b494f6133582a0520f7c6246e1">&#9670;&nbsp;</a></span>end_raw() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const Number* <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::end_raw </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a pointer to the element past the end of the underlying storage. </p>

</div>
</div>
<a id="a640a9cfc2c7d0e23e5394bce43521ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a640a9cfc2c7d0e23e5394bce43521ade">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator from tensors with different underlying scalar type. This obviously requires that the <code>OtherNumber</code> type is convertible to <code>Number</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="acd585d3cdadbd9bf0fce6ca4a0b25e86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd585d3cdadbd9bf0fce6ca4a0b25e86">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a tensor. To avoid confusion with what exactly it means to assign a scalar value to a tensor, zero is the only value allowed for <code>d</code>, allowing the intuitive notation <code>t=0</code> to reset all elements of the tensor to zero. </p>

</div>
</div>
<a id="a064a6aafb0388efbb736370aad64e3c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a064a6aafb0388efbb736370aad64e3c5">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for equality of two tensors. </p>

</div>
</div>
<a id="a6f25fcb07d6ce69fe6ca3bf4912d6a84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f25fcb07d6ce69fe6ca3bf4912d6a84">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classbool.html">bool</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Test for inequality of two tensors. </p>

</div>
</div>
<a id="a1b14f54bb62c5405e657dd148b3f56e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b14f54bb62c5405e657dd148b3f56e4">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another tensor.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a1b86ff1fb61ff1d1f4b4763dd86f17c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b86ff1fb61ff1d1f4b4763dd86f17c7">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtract another tensor.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a1deb61c717ad0fe04eea0b669930d00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deb61c717ad0fe04eea0b669930d00c">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the tensor by <code>factor</code>, i.e. multiply all components by <code>factor</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a98c50fee6f5551a7b415569a04d1466d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98c50fee6f5551a7b415569a04d1466d">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&amp; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the vector by <code>1/factor</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="aefefaeca7323eb80aad5ce0822178578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefefaeca7323eb80aad5ce0822178578">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unary minus operator. Negate all entries of a tensor.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a508ec4561f82997a2f883163d550d312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508ec4561f82997a2f883163d550d312">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr void <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reset all values to zero.</p>
<p>Note that this is partly inconsistent with the semantics of the <code><a class="el" href="classTensor.html#a508ec4561f82997a2f883163d550d312">clear()</a></code> member functions of the standard library containers and of several other classes within deal.II, which not only reset the values of stored elements to zero, but release all memory and return the object into a virginial state. However, since the size of objects of the present type is determined by its template parameters, resizing is not an option, and indeed the state where all elements have a zero value is the state right after construction of such an object. </p>

</div>
</div>
<a id="afd0934b4edd71063f66a9c67540e79fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0934b4edd71063f66a9c67540e79fc">&#9670;&nbsp;</a></span>norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::real_type <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the Frobenius-norm of a tensor, i.e. the square root of the sum of the absolute squares of all entries. For the present case of rank-1 tensors, this equals the usual <code>l<sub>2</sub></code> norm of the vector.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a7a3169a68a27cc04f2ad1fd9790b874c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a3169a68a27cc04f2ad1fd9790b874c">&#9670;&nbsp;</a></span>norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::real_type <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::norm_square </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the Frobenius-norm of a tensor, i.e. the sum of the absolute squares of all entries.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

</div>
</div>
<a id="a5247561f23bd98ebc99dc8d54b1b19fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5247561f23bd98ebc99dc8d54b1b19fe">&#9670;&nbsp;</a></span>unroll()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::unroll </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill a vector with all tensor elements.</p>
<p>This function unrolls all tensor entries into a single, linearly numbered vector. As usual in C++, the rightmost index of the tensor marches fastest. </p>

</div>
</div>
<a id="a691feb72e96831cab4a85fbc28167abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691feb72e96831cab4a85fbc28167abd">&#9670;&nbsp;</a></span>component_to_unrolled_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::component_to_unrolled_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTableIndices.html">TableIndices</a>&lt; rank_ &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an unrolled index in the range \([0,\text{dim}^{\text{rank}}-1]\) for the element of the tensor indexed by the argument to the function. </p>

</div>
</div>
<a id="a2967bd64add4b290f52801a682d722d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2967bd64add4b290f52801a682d722d2">&#9670;&nbsp;</a></span>unrolled_to_component_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr <a class="el" href="classTableIndices.html">TableIndices</a>&lt;rank_&gt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::unrolled_to_component_indices </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Opposite of component_to_unrolled_index: For an index in the range \([0, \text{dim}^{\text{rank}}-1]\), return which set of indices it would correspond to. </p>

</div>
</div>
<a id="aa684a29980c5e7787414e35636b5d0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa684a29980c5e7787414e35636b5d0dc">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static constexpr std::size_t <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="ade3232e978fc18c65b746b7597868638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade3232e978fc18c65b746b7597868638">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>. </p>

</div>
</div>
<a id="ac28d5dc5dbe7ac90f03b79b5a5131556"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28d5dc5dbe7ac90f03b79b5a5131556">&#9670;&nbsp;</a></span>unroll_recursion()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::unroll_recursion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned <a class="el" href="classint.html">int</a> &amp;&#160;</td>
          <td class="paramname"><em>start_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper function for unroll. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a837dcd9e4e283888ec9f3d11478d0f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a837dcd9e4e283888ec9f3d11478d0f21">&#9670;&nbsp;</a></span>Tensor</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<div class="memtemplate">
template&lt;int , int , typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classTensor.html">Tensor</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00838">838</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aa03297e722be020f98fc14aafcab34a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa03297e722be020f98fc14aafcab34a7">&#9670;&nbsp;</a></span>Point< dim, Number ></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classPoint.html">Point</a>&lt; dim, Number &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00842">842</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af47eaebd03e0a183fd38a09d8863659f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47eaebd03e0a183fd38a09d8863659f">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; sum </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform an MPI sum of the entries of a tensor. </p>

</div>
</div>
<a id="a26060566f66f799dab8bbe04289ed81b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26060566f66f799dab8bbe04289ed81b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for tensors. Print the elements consecutively, with a space in between, two spaces between rank 1 subtensors, three between rank 2 and so on. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01824">1824</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a92c3b3312173253961fda78ac2b7bf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c3b3312173253961fda78ac2b7bf4b">&#9670;&nbsp;</a></span>operator<<() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Output operator for tensors of rank 0. Since such tensors are scalars, we simply print this one value. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01845">1845</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a866270925a280330ae3e2bd05e648dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866270925a280330ae3e2bd05e648dc4">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Other, Number &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a tensor of rank 0 with an object from the left.</p>
<p>This function unwraps the underlying <code>Number</code> stored in the <a class="el" href="classTensor.html">Tensor</a> and multiplies <code>object</code> with it.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01872">1872</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad27223b3f4809138f070ca30369b7f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad27223b3f4809138f070ca30369b7f26">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename Other &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, Other &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Other &amp;&#160;</td>
          <td class="paramname"><em>object</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of a tensor of rank 0 with an object from the right.</p>
<p>This function unwraps the underlying <code>Number</code> stored in the <a class="el" href="classTensor.html">Tensor</a> and multiplies <code>object</code> with it.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01892">1892</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a6af378a072e8881e65058bd937de898a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6af378a072e8881e65058bd937de898a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scalar multiplication of two tensors of rank 0.</p>
<p>This function unwraps the underlying objects of type <code>Number</code> and <code>OtherNumber</code> that are stored within the <a class="el" href="classTensor.html">Tensor</a> and multiplies them. It returns an unwrapped number of product type.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01912">1912</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a361b2cfdd860d356ad80c91147c76327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361b2cfdd860d356ad80c91147c76327">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a tensor of rank 0 by a scalar number.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01933">1933</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab976c32648a69f93416e35b2c6c82800"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab976c32648a69f93416e35b2c6c82800">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add two tensors of rank 0.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01949">1949</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a2ed2c7983fc5c58b67291507d41c20d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ed2c7983fc5c58b67291507d41c20d0">&#9670;&nbsp;</a></span>operator-() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract two tensors of rank 0.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01966">1966</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad94c55da76e6d429a04c325ec2db311a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94c55da76e6d429a04c325ec2db311a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a tensor of general rank with a scalar number from the right.</p>
<p>Only multiplication with a scalar number type (i.e., a floating point number, a complex floating point number, etc.) is allowed, see the documentation of <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> for details.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l01991">1991</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aa4635b4d8f14ce045aeec05eaed74ba8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4635b4d8f14ce045aeec05eaed74ba8">&#9670;&nbsp;</a></span>operator*() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; Number &gt;::type, OtherNumber &gt;::type &gt; operator* </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiplication of a tensor of general rank with a scalar number from the left.</p>
<p>Only multiplication with a scalar number type (i.e., a floating point number, a complex floating point number, etc.) is allowed, see the documentation of <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a> for details.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02019">2019</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a071fce7ab1078d6407cb42ff790ef0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071fce7ab1078d6407cb42ff790ef0ce">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, typename <a class="el" href="structEnableIfScalar.html">EnableIfScalar</a>&lt; OtherNumber &gt;::type &gt;::type &gt; operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber &amp;&#160;</td>
          <td class="paramname"><em>factor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Division of a tensor of general rank with a scalar number. See the discussion on <a class="el" href="classTensor.html#a866270925a280330ae3e2bd05e648dc4">operator*()</a> above for more information about template arguments and the return type.</p>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02090">2090</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a8406ed86acf24dbf6e3fa6e2c531cf5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8406ed86acf24dbf6e3fa6e2c531cf5f">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition of two tensors of general rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of both tensors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02108">2108</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="acca33b30cb806b4240462114190ff5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acca33b30cb806b4240462114190ff5f1">&#9670;&nbsp;</a></span>operator-() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; operator- </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>q</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction of two tensors of general rank.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of both tensors.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function can also be used in CUDA device code. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02132">2132</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a7435d412395211da77bfd33a98d86c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7435d412395211da77bfd33a98d86c8e">&#9670;&nbsp;</a></span>schur_product() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; schur_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 0, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Entrywise multiplication of two tensor objects of rank 0 (i.e. the multiplication of two scalar values). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02152">2152</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ac8b8b98a183ecfdb74d685655f1a7edd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8b8b98a183ecfdb74d685655f1a7edd">&#9670;&nbsp;</a></span>schur_product() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; schur_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Entrywise multiplication of two tensor objects of general rank.</p>
<p>This multiplication is also called "Hadamard-product" (c.f. <a href="https://en.wikipedia.org/wiki/Hadamard_product_(matrices)">https://en.wikipedia.org/wiki/Hadamard_product_(matrices)</a>), and generates a new tensor of size &lt;rank, dim&gt;: </p><p class="formulaDsp">
\[ \text{result}_{i, j} = \text{left}_{i, j}\circ \text{right}_{i, j} \]
</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">rank</td><td>The rank of both tensors. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02181">2181</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab497e11d02a539db2e4b4676d5119e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab497e11d02a539db2e4b4676d5119e2b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber , typename  = typename std::enable_if&lt;rank_1 &gt;= 1 &amp;&amp; rank_2&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">OtherNumber::type::tensor_type operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02232">2232</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9711379deb6b31d5ef98c5aa194e7057"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9711379deb6b31d5ef98c5aa194e7057">&#9670;&nbsp;</a></span>contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index_1, int index_2, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a> contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic contraction of a pair of indices of two tensors of arbitrary rank: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 2)\) that is the contraction of index <code>index_1</code> of a tensor <code>src1</code> of rank <code>rank_1</code> with the index <code>index_2</code> of a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k} \text{left}_{i_1,\ldots,k,\ldots,i_{r1}} \text{right}_{j_1,\ldots,k,\ldots,j_{r2}} \]
</p>
<p>If for example the first index (<code>index_1==0</code>) of a tensor <code>t1</code> shall be contracted with the third index (<code>index_2==2</code>) of a tensor <code>t2</code>, this function should be invoked as </p><div class="fragment"><div class="line">contract&lt;0, 2&gt;(t1, t2);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The position of the index is counted from 0, i.e., \(0\le\text{index}_i&lt;\text{range}_i\).</dd>
<dd>
In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02288">2288</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3ef2ce44eebfa45884c747b286128555"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ef2ce44eebfa45884c747b286128555">&#9670;&nbsp;</a></span>double_contract()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int index_1, int index_2, int index_3, int index_4, int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2 - 4, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt;::<a class="el" href="classTensor.html#acff8ee52ec395c87107aee5be1b7be3a">tensor_type</a> double_contract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generic contraction of two pairs of indices of two tensors of arbitrary rank: Return a tensor of rank \((\text{rank}_1 + \text{rank}_2 - 4)\) that is the contraction of index <code>index_1</code> with index <code>index_2</code>, and index <code>index_3</code> with index <code>index_4</code> of a tensor <code>src1</code> of rank <code>rank_1</code> and a tensor <code>src2</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \sum_{k, l} \text{left}_{i_1,\ldots,k,\ldots,l,\ldots,i_{r1}} \text{right}_{j_1,\ldots,k,\ldots,l\ldots,j_{r2}} \]
</p>
<p>If for example the first index (<code>index_1==0</code>) shall be contracted with the third index (<code>index_2==2</code>), and the second index (<code>index_3==1</code>) with the first index (<code>index_4==0</code>) of a tensor <code>t2</code>, this function should be invoked as </p><div class="fragment"><div class="line">double_contract&lt;0, 2, 1, 0&gt;(t1, t2);</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The position of the index is counted from 0, i.e., \(0\le\text{index}_i&lt;\text{range}_i\).</dd>
<dd>
In case the contraction yields a tensor of rank 0 the scalar number is returned as an unwrapped number type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02363">2363</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a71d0baf87e7b3d210ee9c0922a4b7f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71d0baf87e7b3d210ee9c0922a4b7f9f">&#9670;&nbsp;</a></span>scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; <a class="el" href="classTensor.html#a3b3b967eb1f9ba8e9237260ceb26fd5c">rank</a>, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The scalar product, or (generalized) Frobenius inner product of two tensors of equal rank: Return a scalar number that is the result of a full contraction of a tensor <code>left</code> and <code>right:</code> </p><p class="formulaDsp">
\[ \sum_{i_1,\ldots,i_r} \text{left}_{i_1,\ldots,i_r} \text{right}_{i_1,\ldots,i_r} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02442">2442</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aeff476b88727f4418ec899ec85471063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeff476b88727f4418ec899ec85471063">&#9670;&nbsp;</a></span>contract3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; int, int, typename &gt; class TensorT1, template&lt; int, int, typename &gt; class TensorT2, template&lt; int, int, typename &gt; class TensorT3, int rank_1, int rank_2, int dim, typename T1 , typename T2 , typename T3 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="structProductType.html">ProductType</a>&lt; T1, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T2, T3 &gt;::type &gt;::type contract3 </td>
          <td>(</td>
          <td class="paramtype">const TensorT1&lt; rank_1, dim, T1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorT2&lt; rank_1+rank_2, dim, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>middle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const TensorT3&lt; rank_2, dim, T3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Full contraction of three tensors: Return a scalar number that is the result of a full contraction of a tensor <code>left</code> of rank <code>rank_1</code>, a tensor <code>middle</code> of rank \((\text{rank}_1+\text{rank}_2)\) and a tensor <code>right</code> of rank <code>rank_2:</code> </p><p class="formulaDsp">
\[ \sum_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} \text{left}_{i_1,\ldots,i_{r1}} \text{middle}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} \text{right}_{j_1,\ldots,j_{r2}} \]
</p>
<dl class="section note"><dt>Note</dt><dd>Each of the three input tensors can be either a <a class="el" href="classTensor.html">Tensor</a> or <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02479">2479</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a0b76d52ead3fafce2f9c8e06cd1762ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b76d52ead3fafce2f9c8e06cd1762ba">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_1, int rank_2, int dim, typename Number , typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1+rank_2, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number, OtherNumber &gt;::type &gt; outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; rank_2, dim, OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The outer product of two tensors of <code>rank_1</code> and <code>rank_2:</code> Returns a tensor of rank \((\text{rank}_1 + \text{rank}_2)\): </p><p class="formulaDsp">
\[ \text{result}_{i_1,\ldots,i_{r1},j_1,\ldots,j_{r2}} = \text{left}_{i_1,\ldots,i_{r1}}\,\text{right}_{j_1,\ldots,j_{r2}.} \]
</p>
 
<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02508">2508</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a9b0ea33c5eb6c2986072c80d4916599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b0ea33c5eb6c2986072c80d4916599b">&#9670;&nbsp;</a></span>cross_product_2d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; cross_product_2d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the cross product in 2d. This is just a rotation by 90 degrees clockwise to compute the outer normal from a tangential vector. This function is defined for all space dimensions to allow for dimension independent programming (e.g. within switches over the space dimension), but may only be called if the actual dimension of the arguments is two (e.g. from the <code>dim==2</code> case in the switch). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02539">2539</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af8718a0f27d7cfaa0b91464bb81e2c28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8718a0f27d7cfaa0b91464bb81e2c28">&#9670;&nbsp;</a></span>cross_product_3d()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number1 , typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, typename <a class="el" href="structProductType.html">ProductType</a>&lt; Number1, Number2 &gt;::type &gt; cross_product_3d </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim, Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the cross product of 2 vectors in 3d. This function is defined for all space dimensions to allow for dimension independent programming (e.g. within switches over the space dimension), but may only be called if the actual dimension of the arguments is three (e.g. from the <code>dim==3</code> case in the switch). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02564">2564</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3e191fd2cb0ed2b86e5ca58aaedcdd13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e191fd2cb0ed2b86e5ca58aaedcdd13">&#9670;&nbsp;</a></span>determinant() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the determinant of a tensor or rank 2. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02598">2598</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ab6a5bcd00c2a33b1af85f2ffc2976243"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a5bcd00c2a33b1af85f2ffc2976243">&#9670;&nbsp;</a></span>determinant() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 1, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization for dim==1. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02626">2626</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ad34b6b774c5a94e2d75219bc1de767f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad34b6b774c5a94e2d75219bc1de767f5">&#9670;&nbsp;</a></span>determinant() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 2, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization for dim==2. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02638">2638</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="ae9fff6c2d9823b88726460d9bd373a5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fff6c2d9823b88726460d9bd373a5b">&#9670;&nbsp;</a></span>determinant() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number determinant </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, 3, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Specialization for dim==3. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02651">2651</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a947dac48d007097defaf2736e4586e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947dac48d007097defaf2736e4586e1d">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr Number trace </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the trace of a tensor of rank 2, i.e. the sum of its diagonal entries. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02672">2672</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="addae444929c0f639ff2a684d87616220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addae444929c0f639ff2a684d87616220">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute and return the inverse of the given tensor. Since the compiler can perform the return value optimization, and since the size of the return object is known, it is acceptable to return the result by value, rather than by reference as a parameter. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02691">2691</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a2991e0d54a5ae64c50fe9573570c5fcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2991e0d54a5ae64c50fe9573570c5fcd">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; transpose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the transpose of the given tensor. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02778">2778</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a1403b17edbfb509662833ac8f5213f20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1403b17edbfb509662833ac8f5213f20">&#9670;&nbsp;</a></span>adjugate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; adjugate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the adjugate of the given tensor of rank 2. The adjugate of a tensor \(\mathbf A\) is defined as </p><p class="formulaDsp">
\[ \textrm{adj}\mathbf A \dealcoloneq \textrm{det}\mathbf A \; \mathbf{A}^{-1} \; . \]
</p>
<dl class="section note"><dt>Note</dt><dd>This requires that the tensor is invertible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02809">2809</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a05378f1d72d70a9f08c4f6edab2cbe2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05378f1d72d70a9f08c4f6edab2cbe2c">&#9670;&nbsp;</a></span>cofactor()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; cofactor </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the cofactor of the given tensor of rank 2. The cofactor of a tensor \(\mathbf A\) is defined as </p><p class="formulaDsp">
\[ \textrm{cof}\mathbf A \dealcoloneq \textrm{det}\mathbf A \; \mathbf{A}^{-T} = \left[ \textrm{adj}\mathbf A \right]^{T} \; . \]
</p>
<dl class="section note"><dt>Note</dt><dd>This requires that the tensor is invertible. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02830">2830</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a92a1fd2ad72ff18b882744a2413bca73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92a1fd2ad72ff18b882744a2413bca73">&#9670;&nbsp;</a></span>project_onto_orthogonal_tensors()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; project_onto_orthogonal_tensors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the nearest orthogonal matrix \(\hat {\mathbf A}=\mathbf U \mathbf{V}^T\) by combining the products of the singular value decomposition (SVD) \({\mathbf A}=\mathbf U \mathbf S \mathbf V^T\) for a given input \({\mathbf A}\), effectively replacing \(\mathbf S\) with the identity matrix.</p>
<p>This is a (nonlinear) <a href="https://en.wikipedia.org/wiki/Projection_(mathematics)">projection operation</a> since when applied twice, we have \(\hat{\hat{\mathbf A}}=\hat{\mathbf A}\) as is easy to see. (That is because the SVD of \(\hat {\mathbf A}\) is simply \(\mathbf U \mathbf I \mathbf{V}^T\).) Furthermore, \(\hat {\mathbf A}\) is really an orthogonal matrix because orthogonal matrices have to satisfy \({\hat {\mathbf A}}^T \hat {\mathbf A}={\mathbf I}\), which here implies that </p><p class="formulaDsp">
\begin{align*} {\hat {\mathbf A}}^T \hat {\mathbf A} &amp;= \left(\mathbf U \mathbf{V}^T\right)^T\left(\mathbf U \mathbf{V}^T\right) \\ &amp;= \mathbf V \mathbf{U}^T \mathbf U \mathbf{V}^T \\ &amp;= \mathbf V \left(\mathbf{U}^T \mathbf U\right) \mathbf{V}^T \\ &amp;= \mathbf V \mathbf I \mathbf{V}^T \\ &amp;= \mathbf V \mathbf{V}^T \\ &amp;= \mathbf I \end{align*}
</p>
<p> due to the fact that the \(\mathbf U\) and \(\mathbf V\) factors that come out of the SVD are themselves orthogonal matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">A</td><td>The tensor for which to find the closest orthogonal tensor. </td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Number</td><td>The type used to store the entries of the tensor. Must be either <code>float</code> or <code>double</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>In order to use this function, this program must be linked with the LAPACK library. </dd>
<dd>
<code>A</code> must not be singular. This is because, conceptually, the problem to be solved here is trying to find a matrix \(\hat{\mathbf A}\) that minimizes some kind of distance from \(\mathbf A\) while satisfying the quadratic constraint \({\hat {\mathbf A}}^T \hat {\mathbf A}={\mathbf I}\). This is not so dissimilar to the kind of problem where one wants to find a vector \(\hat{\mathbf x}\in{\mathbb R}^n\) that minimizes the quadratic objective function \(\|\hat {\mathbf x} - \mathbf x\|^2\) for a given \(\mathbf x\) subject to the constraint \(\|\mathbf x\|^2=1\) &ndash; in other words, we are seeking the point \(\hat{\mathbf x}\) on the unit sphere that is closest to \(\mathbf x\). This problem has a solution for all \(\mathbf x\) except if \(\mathbf x=0\). The corresponding condition for the problem we are considering here is that \(\mathbf A\) must not have a zero eigenvalue. </dd></dl>

</div>
</div>
<a id="a93ba01d979880b278cd4b573dd9c653b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93ba01d979880b278cd4b573dd9c653b">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number l1_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_1\) norm of the given rank-2 tensor, where \(\|\mathbf T\|_1 = \max_j \sum_i |T_{ij}|\) (maximum of the sums over columns). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02913">2913</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a858195ddbd94c49d6a2cdd447fc5ee63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858195ddbd94c49d6a2cdd447fc5ee63">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, typename Number &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number linfty_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim, Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>t</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_\infty\) norm of the given rank-2 tensor, where \(\|\mathbf T\|_\infty = \max_i \sum_j |T_{ij}|\) (maximum of the sums over rows). </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l02939">2939</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a9a72352995b42241f9e90c697cecab85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a72352995b42241f9e90c697cecab85">&#9670;&nbsp;</a></span>dimension</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::dimension = dim</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide a way to get the dimension of an object without explicit knowledge of it's data type. Implementation is this way instead of providing a function <code><a class="el" href="classTensor.html#a9a72352995b42241f9e90c697cecab85">dimension()</a></code> because now it is possible to get the dimension at compile time without the expansion and preevaluation of an inlined function; the compiler may therefore produce more efficient code and you may use this value to declare other data types. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00486">486</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="a3b3b967eb1f9ba8e9237260ceb26fd5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3b967eb1f9ba8e9237260ceb26fd5c">&#9670;&nbsp;</a></span>rank</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::rank = rank_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Publish the rank of this tensor to the outside world. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00491">491</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="aed199dbe319871d4d1ee68ef763cc4ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed199dbe319871d4d1ee68ef763cc4ac">&#9670;&nbsp;</a></span>n_independent_components</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::n_independent_components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line">    <a class="code" href="classTensor.html">Tensor</a>&lt;rank_ - 1, dim&gt;<a class="code" href="classTensor.html#aed199dbe319871d4d1ee68ef763cc4ac">::n_independent_components</a> * dim</div></div><!-- fragment --><p>Number of independent components of a tensor of current rank. This is dim times the number of independent components of each sub-tensor. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00497">497</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<a id="af47d364c3c106ce504e0f41bfe740cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47d364c3c106ce504e0f41bfe740cf8">&#9670;&nbsp;</a></span>values</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int rank_, int dim, typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classTensor.html">Tensor</a>&lt;rank_ - 1, dim, Number&gt; <a class="el" href="classTensor.html">Tensor</a>&lt; rank_, dim, Number &gt;::values[(dim !=0) ? dim :1]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Array of tensors holding the subelements. </p>

<p class="definition">Definition at line <a class="el" href="tensor_8h_source.html#l00814">814</a> of file <a class="el" href="tensor_8h_source.html">tensor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="tensor_8h_source.html">tensor.h</a></li>
<li>include/deal.II/base/<a class="el" href="mpi_8h_source.html">mpi.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
