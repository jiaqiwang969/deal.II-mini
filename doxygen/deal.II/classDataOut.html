<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDataOut.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: DataOut&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDataOut-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">DataOut&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__IO.html">Input/Output</a> &raquo; <a class="el" href="group__output.html">Graphical output</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="numerics_2data__out_8h_source.html">deal.II/numerics/data_out.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for DataOut&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classDataOut__inherit__graph.svg" width="1687" height="100"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1303b5d99f10f3fae984e7d406cfeb37"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> { <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a948624b3d3973a7a7ae04f42b6e58bde">no_curved_cells</a>, 
<a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a383cfae47ea3a9416cf51c5b1725f1d0">curved_boundary</a>, 
<a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37ad8379a354d5bd6484471f6bf755cd111">curved_inner_cells</a>
 }</td></tr>
<tr class="separator:a1303b5d99f10f3fae984e7d406cfeb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a994bb1dbfacf7c835f33efd0e75b079b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> = typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, dim, spacedim, spacedim &gt;::<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a></td></tr>
<tr class="separator:a994bb1dbfacf7c835f33efd0e75b079b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19a12e8cf308de29f9d0861368bab16b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a19a12e8cf308de29f9d0861368bab16b">FirstCellFunctionType</a> = typename std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)&gt;</td></tr>
<tr class="separator:a19a12e8cf308de29f9d0861368bab16b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e5c138baa9693a9c792dd1d67925b1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a27e5c138baa9693a9c792dd1d67925b1">NextCellFunctionType</a> = typename std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &amp;)&gt;</td></tr>
<tr class="separator:a27e5c138baa9693a9c792dd1d67925b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> </td></tr>
<tr class="separator:a062005bfe37e877e1f44e1c3e8e6cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a045bd55f737005924de7f0b116f6f961"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a045bd55f737005924de7f0b116f6f961">DataOut</a> ()</td></tr>
<tr class="separator:a045bd55f737005924de7f0b116f6f961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087f63e22f0614bca326dbdca288c646"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">build_patches</a> (const unsigned <a class="el" href="classint.html">int</a> n_subdivisions=0)</td></tr>
<tr class="separator:a087f63e22f0614bca326dbdca288c646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab70929c9b791ac174b80716430f1672a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#ab70929c9b791ac174b80716430f1672a">build_patches</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions=0, const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> curved_region=<a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a383cfae47ea3a9416cf51c5b1725f1d0">curved_boundary</a>)</td></tr>
<tr class="separator:ab70929c9b791ac174b80716430f1672a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13fa1f2751f032ae4f2deae2c8e5cd9f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a13fa1f2751f032ae4f2deae2c8e5cd9f">build_patches</a> (const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;mapping, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions=0, const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> curved_region=<a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a383cfae47ea3a9416cf51c5b1725f1d0">curved_boundary</a>)</td></tr>
<tr class="separator:a13fa1f2751f032ae4f2deae2c8e5cd9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1a02b27339ad2342b6862d21954eab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a9a1a02b27339ad2342b6862d21954eab">set_cell_selection</a> (const std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)&gt; &amp;first_cell, const std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &amp;)&gt; &amp;next_cell)</td></tr>
<tr class="separator:a9a1a02b27339ad2342b6862d21954eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61411dd0618518e5dd458679e9a39534"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a61411dd0618518e5dd458679e9a39534">set_cell_selection</a> (const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &gt; &amp;filtered_iterator)</td></tr>
<tr class="separator:a61411dd0618518e5dd458679e9a39534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8223cedacc6a91e9d8df7687d042fd2c"><td class="memItemLeft" align="right" valign="top">const std::pair&lt; <a class="el" href="classDataOut.html#a19a12e8cf308de29f9d0861368bab16b">FirstCellFunctionType</a>, <a class="el" href="classDataOut.html#a27e5c138baa9693a9c792dd1d67925b1">NextCellFunctionType</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a8223cedacc6a91e9d8df7687d042fd2c">get_cell_selection</a> () const</td></tr>
<tr class="separator:a8223cedacc6a91e9d8df7687d042fd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ed7c846331069f406b8c9933c37fda4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6ed7c846331069f406b8c9933c37fda4">attach_dof_handler</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:a6ed7c846331069f406b8c9933c37fda4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3e0283e8014c775f0f7673b7a6e89b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab3e0283e8014c775f0f7673b7a6e89b8">attach_triangulation</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)</td></tr>
<tr class="separator:ab3e0283e8014c775f0f7673b7a6e89b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a79cbe2f02f8dfb85026c71d783dbb703">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a79cbe2f02f8dfb85026c71d783dbb703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6cdf62daf18912e080ff012891ade0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ae6cdf62daf18912e080ff012891ade0f">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::string &amp;name, const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a> type=<a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a>, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:ae6cdf62daf18912e080ff012891ade0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a9291a532df3e94ef08ebe750638e70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a0a9291a532df3e94ef08ebe750638e70">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a0a9291a532df3e94ef08ebe750638e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a33f3f6c09920c20d36c984c9123ff1e1">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const std::string &amp;name, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a33f3f6c09920c20d36c984c9123ff1e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4983e86e29af6cbaf4a1b3bd6e9d8621">add_data_vector</a> (const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a4983e86e29af6cbaf4a1b3bd6e9d8621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3c309b6a0db9808eee76ab1b6ba39239">add_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;data, const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;data_postprocessor)</td></tr>
<tr class="separator:a3c309b6a0db9808eee76ab1b6ba39239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8cf39310f98aeaee50c2143ee2f68ab5">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;data, const std::vector&lt; std::string &gt; &amp;names, const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;data_component_interpretation=std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt;())</td></tr>
<tr class="separator:a8cf39310f98aeaee50c2143ee2f68ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a99f8b5f94d56b40bfb67a4cdea74f764">add_mg_data_vector</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;data, const std::string &amp;name)</td></tr>
<tr class="separator:a99f8b5f94d56b40bfb67a4cdea74f764"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28da5487f291a1724cb4697c59c3f3d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a28da5487f291a1724cb4697c59c3f3d2">clear_data_vectors</a> ()</td></tr>
<tr class="separator:a28da5487f291a1724cb4697c59c3f3d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d635fcfdbd6ebe7ccc1895524b8e615"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8d635fcfdbd6ebe7ccc1895524b8e615">clear_input_data_references</a> ()</td></tr>
<tr class="separator:a8d635fcfdbd6ebe7ccc1895524b8e615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c7605d51f91376a851ec77b0a7003aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3c7605d51f91376a851ec77b0a7003aa">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim2, patch_dim, spacedim2, patch_spacedim &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt;())</td></tr>
<tr class="separator:a3c7605d51f91376a851ec77b0a7003aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#aa8ae001a1d3f270ae0d4a2b77f0d9696">merge_patches</a> (const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2::dimension, patch_dim, DoFHandlerType2::space_dimension, patch_spacedim &gt; &amp;source, const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;shift=<a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt;())</td></tr>
<tr class="separator:aa8ae001a1d3f270ae0d4a2b77f0d9696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3b3a19e7c1ed70079f8682a06b021a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a5c3b3a19e7c1ed70079f8682a06b021a">clear</a> ()</td></tr>
<tr class="separator:a5c3b3a19e7c1ed70079f8682a06b021a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88bac22217cd4bf591eb5ac77d49b8fd"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a88bac22217cd4bf591eb5ac77d49b8fd">memory_consumption</a> () const</td></tr>
<tr class="separator:a88bac22217cd4bf591eb5ac77d49b8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc05be5cd920b234e68548735852446e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#afc05be5cd920b234e68548735852446e">write_dx</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:afc05be5cd920b234e68548735852446e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#aea2031a2a6fe56c9b7d3f9f338f20882">write_eps</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aea2031a2a6fe56c9b7d3f9f338f20882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7f2c3305058c94333d8aa699286b807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ae7f2c3305058c94333d8aa699286b807">write_gmv</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ae7f2c3305058c94333d8aa699286b807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85407e870a68179ebe62410d9efc153f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a85407e870a68179ebe62410d9efc153f">write_gnuplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a85407e870a68179ebe62410d9efc153f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a15f01cb0171da2956be68ad496cd0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a33a15f01cb0171da2956be68ad496cd0">write_povray</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a33a15f01cb0171da2956be68ad496cd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a980b995a6f5944a75721097de39069c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a980b995a6f5944a75721097de39069c1">write_tecplot</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a980b995a6f5944a75721097de39069c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf06b8647892769140884b3ab44a08e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a2bf06b8647892769140884b3ab44a08e">write_ucd</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a2bf06b8647892769140884b3ab44a08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad99726038e4fca7f605fdffb3317e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">write_vtk</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:acad99726038e4fca7f605fdffb3317e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93c780f93105e0daaa76c6c43694b4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">write_vtu</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a93c780f93105e0daaa76c6c43694b4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">write_vtu_in_parallel</a> (const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a5df488dad82b811ceb08cb1adf9eafcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eff778443cd0431cd807c45b6ae16d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">write_pvtu_record</a> (std::ostream &amp;out, const std::vector&lt; std::string &gt; &amp;piece_names) const</td></tr>
<tr class="separator:a1eff778443cd0431cd807c45b6ae16d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0864e51eb173c87e2a3edc9391ea8009"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0864e51eb173c87e2a3edc9391ea8009">write_vtu_with_pvtu_record</a> (const std::string &amp;directory, const std::string &amp;filename_without_extension, const unsigned <a class="el" href="classint.html">int</a> counter, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;mpi_communicator, const unsigned <a class="el" href="classint.html">int</a> n_digits_for_counter=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const unsigned <a class="el" href="classint.html">int</a> n_groups=0) const</td></tr>
<tr class="separator:a0864e51eb173c87e2a3edc9391ea8009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ab56595d7d5aebfb2b3abfdaad51df20d">write_svg</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:ab56595d7d5aebfb2b3abfdaad51df20d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affac60e1e3799ae884642113a8e2e723"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#affac60e1e3799ae884642113a8e2e723">write_deal_II_intermediate</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:affac60e1e3799ae884642113a8e2e723"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45ef5cf2b6515c10ff080729a9901155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a45ef5cf2b6515c10ff080729a9901155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classXDMFEntry.html">XDMFEntry</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0f0b3eec5ee65bd7915c4e46272287eb">create_xdmf_entry</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;h5_mesh_filename, const std::string &amp;h5_solution_filename, const <a class="el" href="classdouble.html">double</a> cur_time, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a0f0b3eec5ee65bd7915c4e46272287eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a> (const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;entries, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:abfab5d02f11dcede67bb61ff3ae105d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29468f4e8eca1367d44b1a2431d39e91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const std::string &amp;filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a29468f4e8eca1367d44b1a2431d39e91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78fdf1cc5071d85ecb2d707d798bf063">write_hdf5_parallel</a> (const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;data_filter, const <a class="el" href="classbool.html">bool</a> write_mesh_file, const std::string &amp;mesh_filename, const std::string &amp;solution_filename, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm) const</td></tr>
<tr class="separator:a78fdf1cc5071d85ecb2d707d798bf063"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a154d8192688eef96f052f50c2f669aa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a> (<a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;filtered_data) const</td></tr>
<tr class="separator:a154d8192688eef96f052f50c2f669aa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e73ad285a8792ff0f9f227b82eb108"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a78e73ad285a8792ff0f9f227b82eb108">write</a> (std::ostream &amp;out, const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a78e73ad285a8792ff0f9f227b82eb108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a6dab6e0fed8d4ad90d658f71a68eb32c">set_default_format</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> default_format)</td></tr>
<tr class="separator:a6dab6e0fed8d4ad90d658f71a68eb32c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7280a24690b117454acfb0fa058299c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac7280a24690b117454acfb0fa058299c">set_flags</a> (const FlagType &amp;flags)</td></tr>
<tr class="separator:ac7280a24690b117454acfb0fa058299c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36120ca3f536c90709e135161030f16c"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a36120ca3f536c90709e135161030f16c">default_suffix</a> (const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a> output_format=<a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a>) const</td></tr>
<tr class="separator:a36120ca3f536c90709e135161030f16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a0a975649e4516ee7c7a67ae2f8dddd97">parse_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a0a975649e4516ee7c7a67ae2f8dddd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters</a> (<a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;prm)</td></tr>
<tr class="separator:a1f2f1d644d9cb1c4d1714d5173d159f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:af09d3320cfb06d2092ee8be96c632b8b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> = ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt; patch_dim, patch_spacedim &gt;</td></tr>
<tr class="separator:af09d3320cfb06d2092ee8be96c632b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a8abd127577fe43595d9b169953b5f593"><td class="memItemLeft" align="right" valign="top">virtual const std::vector&lt; <a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a8abd127577fe43595d9b169953b5f593">get_patches</a> () const override</td></tr>
<tr class="separator:a8abd127577fe43595d9b169953b5f593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9ebc2f6ef4666df85bb686c7e95a90"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a6e9ebc2f6ef4666df85bb686c7e95a90">get_dataset_names</a> () const override</td></tr>
<tr class="separator:a6e9ebc2f6ef4666df85bb686c7e95a90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2626aebbd6852ae06f7f407f85b615a5"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a2626aebbd6852ae06f7f407f85b615a5">get_fes</a> () const</td></tr>
<tr class="separator:a2626aebbd6852ae06f7f407f85b615a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a490249234021ec9de79b356a1f7fa42e"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a490249234021ec9de79b356a1f7fa42e">get_nonscalar_data_ranges</a> () const override</td></tr>
<tr class="separator:a490249234021ec9de79b356a1f7fa42e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3292ed269dfb832d20ae35db4177473"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#ac3292ed269dfb832d20ae35db4177473">validate_dataset_names</a> () const</td></tr>
<tr class="separator:ac3292ed269dfb832d20ae35db4177473"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab87e6a1ac30aee2b4a134aeca8b38253"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#ab87e6a1ac30aee2b4a134aeca8b38253">triangulation</a></td></tr>
<tr class="separator:ab87e6a1ac30aee2b4a134aeca8b38253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a512dc7e149e9d83b712e1707780b9afc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a512dc7e149e9d83b712e1707780b9afc">dofs</a></td></tr>
<tr class="separator:a512dc7e149e9d83b712e1707780b9afc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a6762a26e4dc93f133c175e271936e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a4a6762a26e4dc93f133c175e271936e1">dof_data</a></td></tr>
<tr class="separator:a4a6762a26e4dc93f133c175e271936e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31bbb02ee5dcd6752232e76bdecaecd4"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt; dim, spacedim &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a31bbb02ee5dcd6752232e76bdecaecd4">cell_data</a></td></tr>
<tr class="separator:a31bbb02ee5dcd6752232e76bdecaecd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3adac4a7d4453f2fe8e35a89add8590c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut__DoFData.html#a3adac4a7d4453f2fe8e35a89add8590c">patches</a></td></tr>
<tr class="separator:a3adac4a7d4453f2fe8e35a89add8590c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a072edd6d53d1c5a1e4c71af22a123228"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOutInterface.html#a072edd6d53d1c5a1e4c71af22a123228">default_subdivisions</a></td></tr>
<tr class="separator:a072edd6d53d1c5a1e4c71af22a123228"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a45d49c92b38606ebe2bfb4e6e85488b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#a45d49c92b38606ebe2bfb4e6e85488b7">build_one_patch</a> (const std::pair&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt; *cell_and_index, <a class="el" href="structinternal_1_1DataOutImplementation_1_1ParallelData.html">internal::DataOutImplementation::ParallelData</a>&lt; dim, spacedim &gt; &amp;scratch_data, const unsigned <a class="el" href="classint.html">int</a> n_subdivisions, const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a> curved_cell_region)</td></tr>
<tr class="separator:a45d49c92b38606ebe2bfb4e6e85488b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ac375257e903ef002986cf9b81b2eeacb"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#ac375257e903ef002986cf9b81b2eeacb">first_cell_function</a></td></tr>
<tr class="separator:ac375257e903ef002986cf9b81b2eeacb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8037e7fb25d22e232b61aaa10d2a374"><td class="memItemLeft" align="right" valign="top">std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDataOut.html#ac8037e7fb25d22e232b61aaa10d2a374">next_cell_function</a></td></tr>
<tr class="separator:ac8037e7fb25d22e232b61aaa10d2a374"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class DataOut&lt; dim, spacedim &gt;</h3>

<p>该类是提供由定义在单元格集合上的有限元场描述的数据输出的主要类。 该类是DataOut_DoFData类所提出的功能的实际实现。它提供了一个函数build_patches()来生成要以某种图形格式写入的数据。这个基类的文档中描述了大部分的接口和一个使用实例。 这个类唯一提供的是函数build_patches()，它循环处理由基类的attach_dof_handler()函数存储的三角形的所有单元（不包括不属于当前处理器的 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象的单元），并将这些上的数据转换为实际的补丁，这些补丁是后来被基类的函数输出的对象。你可以给函数一个参数，决定在每个坐标方向上进行多少次细分，也就是说，每个补丁由多少个子单元组成。默认值是1，但你可能想为高阶元素选择一个更高的数字，例如，二阶元素为2，三阶元素为3，依此类推。(见 <a class="el" href="step_11.html">step-11</a> 中的例子。)这个参数的目的是由于大多数图形程序不允许在文件格式中指定高阶多项式函数。只有顶点的数据可以被绘制出来，然后在单元格内部显示为双线性插值。如果你有更高阶的有限元，这可能是不够的，获得更好的输出的唯一方法是将网格的每个单元细分为几个单元进行图形输出。当然，由于输出格式的限制，你所看到的仍然是输出中每个单元的双线性插值（其中这些单元不是使用中的三角形单元的细分），但至少是更细的网格上的高阶多项式的双线性插值。 请注意，在调用了一次build_patches()之后，你可以调用DataOutInterface的一个或多个write()函数。因此，你可以以一种以上的格式输出相同的数据，而不需要重建补丁。</p>
<h3>User interface information</h3>
<p>这个类的基类，DataOutBase、DataOutInterface和DataOut_DoFData提供了它们自己的几个接口。请参考DataOutBase类的文档，以了解目前支持的不同的输出格式，DataOutInterface是在运行时选择输出时使用哪种格式的方法，当新的格式可用时，不需要调整你的程序，以及决定输出方面的标志。DataOut_DoFData()类的文档中有一个使用节点数据来生成输出的例子。</p>
<h3>Extensions</h3>
<p>默认情况下，这个类为所有活动单元产生补丁。有时候，这并不是你想要的，也许是因为数量太多（而且太小，无法单独看到），或者是因为你只想看到域的某个区域（例如在 <a class="el" href="step_46.html">step-46</a> 中只看到域的流体部分），或者其他一些原因。 为此，在内部build_patches()不会自己生成要转换为补丁的单元格序列，而是依赖于两个私有的 std::function 对象first_cell_function()和next_cell_function()。默认情况下，它们分别返回第一个活动单元，和下一个活动单元。但这可以通过set_cell_selection()函数来改变，该函数允许你替换这一行为。set_cell_selection()想知道的是，你想如何挑选出应该产生输出的第一个单元，以及给定一个产生输出的单元，你想如何挑选下一个单元。 例如，这可能只包括位于域的一部分的单元格（例如。如果你不关心其他地方的解决方案，例如在完美匹配层方法中衰减出射波的缓冲区），或者如果你不希望在自适应细化网格的所有层次上产生输出，因为这会产生太多的数据（在这种情况下，由你实现set_cell_selection()的<code>first_cell</code>和<code>next_cell</code>参数返回的单元集将包括非活动单元，而 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> ] 将简单地采取解决方案的内插值，而不是这些单元格上的精确值来输出）。) </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00092">92</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a994bb1dbfacf7c835f33efd0e75b079b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a994bb1dbfacf7c835f33efd0e75b079b">&#9670;&nbsp;</a></span>cell_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> =  typename <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt;dim, dim, spacedim, spacedim&gt;::<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对所考虑的dof处理程序类的迭代器类型的类型定义。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00100">100</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a19a12e8cf308de29f9d0861368bab16b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19a12e8cf308de29f9d0861368bab16b">&#9670;&nbsp;</a></span>FirstCellFunctionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut.html#a19a12e8cf308de29f9d0861368bab16b">FirstCellFunctionType</a> =  typename std::function&lt;<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classDataOut.html#a9a1a02b27339ad2342b6862d21954eab">set_cell_selection()</a>中使用的返回第一个单元格的函数对象的类型。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00107">107</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a27e5c138baa9693a9c792dd1d67925b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e5c138baa9693a9c792dd1d67925b1">&#9670;&nbsp;</a></span>NextCellFunctionType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut.html#a27e5c138baa9693a9c792dd1d67925b1">NextCellFunctionType</a> =  typename std::function&lt;<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &amp;, const <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在set_cell_selection()中使用的返回下一个单元格的函数对象的类型。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00115">115</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="af09d3320cfb06d2092ee8be96c632b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af09d3320cfb06d2092ee8be96c632b8b">&#9670;&nbsp;</a></span>Patch</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a> =  ::<a class="el" href="structDataOutBase_1_1Patch.html">DataOutBase::Patch</a>&lt;patch_dim, patch_spacedim&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩写有点冗长的Patch类的名字。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00781">781</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1303b5d99f10f3fae984e7d406cfeb37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1303b5d99f10f3fae984e7d406cfeb37">&#9670;&nbsp;</a></span>CurvedCellRegion</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">DataOut::CurvedCellRegion</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>枚举，描述域中应写入弯曲边界的单元的部分。在现实中，我们知道没有任何文件格式真正支持弯曲的边界，但是如果调用 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> 时细分的数量大于1，就可以通过将边缘绘制成一连串的直线（在三维中将面绘制成双线性补丁的集合）来模拟这一点。 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1303b5d99f10f3fae984e7d406cfeb37a948624b3d3973a7a7ae04f42b6e58bde"></a>no_curved_cells&#160;</td><td class="fielddoc"><p>几何体或边界描述将永远不会被查询到弯曲的几何体。这意味着，即使你每个单元有一个以上的细分（具体含义见 <a class="el" href="classDataOut.html#a087f63e22f0614bca326dbdca288c646">DataOut::build_patches()</a> ），即使几何体真的是弯曲的，每个单元仍然会被细分，好像它只是一个双线或三线单元。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a1303b5d99f10f3fae984e7d406cfeb37a383cfae47ea3a9416cf51c5b1725f1d0"></a>curved_boundary&#160;</td><td class="fielddoc"><p>对于位于边界的单元，即至少有一个面位于边界的单元，几何体或边界描述将被查询到弯曲的几何体。如果您没有为单元格内部附加流形描述，而只为边界处的面附加流形描述，这就足够了。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a1303b5d99f10f3fae984e7d406cfeb37ad8379a354d5bd6484471f6bf755cd111"></a>curved_inner_cells&#160;</td><td class="fielddoc"><p>将对所有单元和所有面进行几何体描述的查询，无论它们是否在边界上。如果你将流形对象附加到单元格（而不是只附加到边界面），这个选项是合适的。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00123">123</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="a062005bfe37e877e1f44e1c3e8e6cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a062005bfe37e877e1f44e1c3e8e6cb27">&#9670;&nbsp;</a></span>DataVectorType</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataOut_DoFData::DataVectorType</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>描述给add_data_vector()的向量是什么的类型：在DoFHandler对象中每个自由度有一个条目的向量（如解决方案向量），或者在DoFHandler对象基础的三角形中每个单元有一个条目（如每个单元的误差数据）。值::type_automatic告诉add_data_vector()自己找出来（关于使用的方法，见add_data_vector()的文档）。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00509">509</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a045bd55f737005924de7f0b116f6f961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a045bd55f737005924de7f0b116f6f961">&#9670;&nbsp;</a></span>DataOut()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut.html">DataOut</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l00069">69</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a087f63e22f0614bca326dbdca288c646"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087f63e22f0614bca326dbdca288c646">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是该类的核心功能，因为它建立了基类的低级函数所要写入的补丁列表。从本质上讲，补丁是三角形和DoFHandler对象的每个单元上的数据的一些中间表示，然后可以用来以某种可视化程序可读的格式编写文件。 你可以在这个类的一般文档中找到关于这个函数的使用概述。在这个类的基类DataOut_DoFData的文档中也提供了一个例子。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">n_subdivisions</td><td>一个参数，决定了这个函数将在每个单元中建立多少个 "补丁"。如果你在调用时没有指定这个值，或者提供默认值为0，那么这个值将被解释为 <a class="el" href="classDataOutInterface.html#a072edd6d53d1c5a1e4c71af22a123228">DataOutInterface::default_subdivisions</a> ，在大多数情况下它将等于1（除非你把它设置为其他值）。这个参数的目的是将网格的每个单元细分为2d的 \(2\times 2, 3\times 3, \ldots\) "补丁"，以及 \(2\times 2\times 2, 3\times 3\times 3, \ldots\) （如果传递值为2，3，等等），其中每个补丁代表单元的常规细分的数据，分成相等的部分。大多数时候，这是没有必要的，每个单元格输出一个补丁正是你想要绘制的解决方案。也就是说，我们写进文件用于可视化的数据只能代表每个细胞上的（双、三）线性数据，而大多数可视化程序事实上只能可视化这种数据。如果你用（双、三）线性有限元工作，这已经很好了，在这种情况下，你能看到的正是已经计算出来的数据。另一方面，如果你使用(双、三)二次元，那么写入输出文件的只是一个(双、三)线性插值到当前网格上，也就是说，只有顶点上的数值。如果这还不够好，你可以，例如，指定 <code>n_subdivisions</code> 等于2，在一次精炼的网格上绘制解决方案，或者如果设置为3，在一个每个单元由3乘3补丁代表的网格上。在这些较小的斑块上，考虑到输出格式的限制，数据仍然是线性内插的，但是在更细的网格上对二次元数据进行线性内插，仍然比在原始网格上更好地表示实际的二次元曲面。 换句话说，使用这个参数不能帮助你准确地绘制出解决方案，但如果你使用更高多项式程度的有限元，它可以让你更接近。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>当使用高阶有限元时，指定<code>n_subdivisions&gt;1</code>是有用的，但一般来说，它实际上不会导致可视化显示高阶多项式曲面</dd></dl>
<p>相反，你只是得到一个更细的网格上的高阶曲面的（双，三）线性插值。然而，当通过 <a class="el" href="classDataOutInterface.html#acad99726038e4fca7f605fdffb3317e4">DataOutInterface::write_vtk()</a> 或 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> （其中DataOutInterface是当前类的基类）以VTK和VTU文件格式输出解决方案时，正如我们在教程中经常做的，你可以通过 <a class="el" href="structDataOutBase_1_1VtkFlags.html">DataOutBase::VtkFlags</a> 结构提供一组标志，其中包括 <a class="el" href="structDataOutBase_1_1VtkFlags.html#aa9dd1830c0ff35a2431704c4d45453eb">DataOutBase::VtkFlags::write_higher_order_cells</a> 标志。当设置时，这个函数产生的细分将被解释为高阶多项式的支持点，然后将实际被可视化。例如，这在 <a class="el" href="step_11.html">step-11</a> 中显示。然而，值得注意的是，这需要一个足够新的基于VTK的可视化程序的版本。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01071">1071</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="ab70929c9b791ac174b80716430f1672a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab70929c9b791ac174b80716430f1672a">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a>&#160;</td>
          <td class="paramname"><em>curved_region</em> = <code><a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a383cfae47ea3a9416cf51c5b1725f1d0">curved_boundary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述相同，只是额外的第一个参数定义了一个映射，该映射将用于输出的生成。如果<code>n_subdivisions&gt;1</code>，则可以使用该映射来计算源于域的边界单元的细分斑块内部的点，即高阶映射导致通过使用更多的细分来表示一个弯曲的边界。一些像MappingQEulerian这样的映射会导致域内部的单元出现弯曲。 如果你将流形描述附加到三角化的单元上，情况也是如此（详见 <a class="el" href="group__manifold.html">流形</a> ）。然而，没有简单的方法来查询映射或流形是否真的导致了弯曲的单元。 因此，最后一个参数 <code>curved_region</code> 取三个值之一，导致完全没有弯曲的单元，边界上有弯曲的单元（默认）或整个域中有弯曲的单元。关于这三个选项的更多信息，请参阅CurvedCellRegion枚举的描述。 即使对于非曲线单元，映射参数也可以用于欧拉映射（见类MappingQ1Eulerian），其中映射不仅用于确定单元内部的点的位置，而且还用于确定顶点的位置。 它提供了一个机会，可以在实际进行计算的变形三角形上观察解决方案，即使网格在内部是以未变形的配置存储的，而变形只是通过一个额外的向量来跟踪每个顶点的变形情况。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01085">1085</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a13fa1f2751f032ae4f2deae2c8e5cd9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13fa1f2751f032ae4f2deae2c8e5cd9f">&#9670;&nbsp;</a></span>build_patches() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::build_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a>&#160;</td>
          <td class="paramname"><em>curved_region</em> = <code><a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37a383cfae47ea3a9416cf51c5b1725f1d0">curved_boundary</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述相同，但对于 <a class="el" href="classhp_1_1MappingCollection.html">hp::MappingCollection</a>. 而言。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01098">1098</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a9a1a02b27339ad2342b6862d21954eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1a02b27339ad2342b6862d21954eab">&#9670;&nbsp;</a></span>set_cell_selection() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::set_cell_selection </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>first_cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;, const <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>next_cell</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>一个允许选择应该为哪些单元格生成输出的函数。这个函数需要两个参数，都是 <code>std::function</code> 对象，可用于生成输出的第一个单元格是什么，以及给定一个单元格的下一个函数是什么。通过这些函数对象，可以选择一个应该产生输出的单元格子集（例如，只选择那些属于域的一部分的单元格</p>
<p>例如，在诸如 <a class="el" href="step_46.html">step-46</a> 这样的代码中，只选择属于域的一部分的单元），或者完全改变输出的位置*（例如，在多网格层次结构的非活动单元上产生输出，或者如果网格的最细层次非常细，产生图形输出会导致数据量过大）。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">first_cell</td><td>一个函数对象，以该类工作的三角形为参数，应该返回应该产生输出的第一个单元。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">next_cell</td><td>一个函数对象，以三角形以及生成输出的最后一个单元为参数，并应返回应生成输出的下一个单元。如果没有下一个单元，即如果<code>next_cell</code>函数对象的输入参数是要生成输出的最后一个单元，那么<code>next_cell</code>必须返回<code><a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">triangulation.end()</a></code>。 这些函数对象并不难写，但也不是一目了然。因此，这个函数还有一个变体，它接受一个IteratorFilter参数并自己生成相应的函数。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>如果你有单元数据（与节点或dof数据相反），如错误指示器，那么你必须确保<code>first_cell</code>和<code>next_cell</code>函数对象只在活动单元上行走，因为单元数据不能被内插到更粗的单元。如果你确实有单元格数据并使用这对函数，而它们返回的是一个非活动单元格，那么将抛出一个异常。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01282">1282</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a61411dd0618518e5dd458679e9a39534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61411dd0618518e5dd458679e9a39534">&#9670;&nbsp;</a></span>set_cell_selection() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::set_cell_selection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFilteredIterator.html">FilteredIterator</a>&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>filtered_iterator</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>前一个函数的变体，根据作为参数的FilteredIterator对象中编码的过滤器，选择所有单元格的一个子集进行输出。产生该参数的典型方法是通过make_filtered_iterator()函数。 另外，由于FilteredIterator对象可以从一个谓词（即一个返回 "bool
"的函数对象）中创建，所以可以只用一个lambda函数来调用这个函数，然后它将自动转换为FilteredIterator对象。例如，下面这段代码就可以工作。 </p><div class="fragment"><div class="line"><a class="code" href="classDataOut.html">DataOut&lt;dim&gt;</a> data_out;</div><div class="line">data_out.<a class="code" href="classDataOut.html#a9a1a02b27339ad2342b6862d21954eab">set_cell_selection</a>(</div><div class="line">       [](<span class="keyword">const</span> <span class="keyword">typename</span> <a class="code" href="classTriangulation.html">Triangulation&lt;dim&gt;::cell_iterator</a> &amp;cell) {</div><div class="line">           <span class="keywordflow">return</span> (cell-&gt;is_active() &amp;&amp; cell-&gt;subdomain_id() == 0);</div><div class="line">       });</div></div><!-- fragment --><p> 在这种情况下，lambda函数选择了所有那些 活动  的、子域id为0的单元格。然后，这些将是唯一产生输出的单元。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01296">1296</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a8223cedacc6a91e9d8df7687d042fd2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8223cedacc6a91e9d8df7687d042fd2c">&#9670;&nbsp;</a></span>get_cell_selection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::pair&lt; typename <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut.html#a19a12e8cf308de29f9d0861368bab16b">FirstCellFunctionType</a>, typename <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::<a class="el" href="classDataOut.html#a27e5c138baa9693a9c792dd1d67925b1">NextCellFunctionType</a> &gt; <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::get_cell_selection </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回由set_cell_selection()设置的用于确定第一个和下一个单元格的两个函数对象。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l01338">1338</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a45d49c92b38606ebe2bfb4e6e85488b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45d49c92b38606ebe2bfb4e6e85488b7">&#9670;&nbsp;</a></span>build_one_patch()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::build_one_patch </td>
          <td>(</td>
          <td class="paramtype">const std::pair&lt; <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>, unsigned <a class="el" href="classint.html">int</a> &gt; *&#160;</td>
          <td class="paramname"><em>cell_and_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structinternal_1_1DataOutImplementation_1_1ParallelData.html">internal::DataOutImplementation::ParallelData</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_subdivisions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut.html#a1303b5d99f10f3fae984e7d406cfeb37">CurvedCellRegion</a>&#160;</td>
          <td class="paramname"><em>curved_cell_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>建立一个补丁。这个函数在WorkStream上下文中被调用。 这里的第一个参数是迭代器，第二个是抓取数据对象。在调用 <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a>. 时，所有下面的参数都与特定的值联系在一起。该函数不接受CopyData对象，而是在自己的堆栈中分配一个，以提高内存访问效率。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8cc_source.html#l00097">97</a> of file <a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a>.</p>

</div>
</div>
<a id="a6ed7c846331069f406b8c9933c37fda4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ed7c846331069f406b8c9933c37fda4">&#9670;&nbsp;</a></span>attach_dof_handler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::attach_dof_handler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定一个dof处理程序，用来提取几何数据以及节点和节点值之间的映射。如果所有添加的数据向量都补充了DoFHandler参数，那么这个调用就没有必要。 这个调用是可选的：如果你用指定的DoFHandler对象添加数据向量，那么这就包含了生成输出所需的所有信息。 </p>

</div>
</div>
<a id="ab3e0283e8014c775f0f7673b7a6e89b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e0283e8014c775f0f7673b7a6e89b8">&#9670;&nbsp;</a></span>attach_triangulation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::attach_triangulation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指定一个用于提取几何数据和节点与节点值之间的映射的三角测量。 这个调用是可选的：如果你用指定的DoFHandler对象添加数据向量，那么这就包含了生成输出所需的所有信息。 当你只输出单元格向量而完全没有DoFHandler时，这个调用很有用，在这种情况下，它提供了几何图形。 </p>

</div>
</div>
<a id="a79cbe2f02f8dfb85026c71d783dbb703"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cbe2f02f8dfb85026c71d783dbb703">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加一个数据向量和它的名字。 一个指向该向量的指针被存储，所以你必须确保该向量至少在你调用<code>write_*</code>函数时存在于该地址。 假设该向量的分量与自由度处理程序中的自由度数量相同，在这种情况下，它被认为是一个存储节点数据的向量；或者大小可能是目前网格上活动单元的数量，在这种情况下，它被认为是一个单元数据向量。由于自由度和单元的数量通常不相等，函数可以自行决定给定哪种类型的向量。然而，在一些角落里，这种自动判断并不奏效。 一个例子是如果你用片状常数元素计算，并且有一个标量解决方案，那么有多少个单元就有多少个自由度（尽管它们的编号可能不同）。 另一种可能是，如果你有一个嵌入2D空间的1D网格，并且该网格由单元的封闭曲线组成；在这种情况下，有多少节点就有多少单元，当使用Q1元素时，你会有多少自由度就有多少单元。 在这种情况下，你可以将函数的最后一个参数从默认值::type_automatic改为::type_dof_data或::type_cell_data，这取决于矢量代表什么。除了这种角落里的情况，你可以把参数留在默认值上，让函数决定向量本身的类型。 如果它是一个持有DoF数据的向量，给出的名称应是底层有限元的每个分量。 如果它是一个仅由一个子元素组成的有限元，那么下面还有一个函数，它接受一个单一的名字而不是一个名字的向量。 data_component_interpretation参数包含关于如何解释由多个数据集组成的输出文件的各个组成部分的信息。 例如，如果一个人有一个2D的斯托克斯方程的有限元，代表组件（u,v,p），我们希望表明前两个，u和v，代表一个逻辑矢量，这样以后当我们生成图形输出时，我们可以把它们交给一个可视化程序，该程序将自动知道把它们作为一个矢量场来渲染，而不是作为两个独立的标量场。 这个参数的默认值（即一个空的矢量）对应于一个值的矢量 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>, ，表示所有的输出组件都是独立的标量场。然而，如果给定的数据向量代表逻辑向量，你可以传入一个包含数值 <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>. 的向量。 在上面的例子中，人们会传入一个包含(u,v,p)的组件 (<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0aa783915dbc182d5a49e111815fd23fe0">DataComponentInterpretation::component_is_part_of_vector</a>, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0a1f3cd50135818a6458f1d3ff7ea4bb51">DataComponentInterpretation::component_is_scalar</a>) 的向量。 数据向量的名称只能包含字母、下划线和其他一些字符。请参考本类中声明的ExcInvalidCharacter异常，看看哪些字符是有效的，哪些是无效的。 </p><dl class="section note"><dt>Note</dt><dd>矢量参数的实际类型可以是任何矢量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数从单元格上提取数值。 </dd>
<dd>
当并行工作时，要写入的向量需要对本地拥有的单元上的所有自由度进行读取访问的幽灵化，详见 <a class="el" href="step_40.html">step-40</a> 或 <a class="el" href="step_37.html">step-37</a> 教程程序，即可能需要调用data.update_ghost_values（）。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00902">902</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="ae6cdf62daf18912e080ff012891ade0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6cdf62daf18912e080ff012891ade0f">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27">DataVectorType</a>&#160;</td>
          <td class="paramname"><em>type</em> = <code><a class="el" href="classDataOut__DoFData.html#a062005bfe37e877e1f44e1c3e8e6cb27a06a7819d088394bfea7a51fbba00f962">type_automatic</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的缩写（关于各种参数的讨论见那里），旨在用于不是由子元素组成的有限元。在这种情况下，每个数据向量只需要给出一个名称，这就是这个函数的作用。它只是在将 <code>name</code> 转换为字符串矢量后，将其参数转发给上面的另一个add_data_vector()函数。 如果 <code>data</code> 是一个有多个成分的向量，这个函数将通过在 <code>name</code> 中附加下划线和每个成分的编号来为所有成分生成不同的名称。 模板参数的实际类型可以是任何向量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数在单元格中提取值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00883">883</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a0a9291a532df3e94ef08ebe750638e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a9291a532df3e94ef08ebe750638e70">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上面那个函数的扩展（除了第一个参数，其他参数的讨论见那里），允许用自己的DoFHandler对象设置一个向量。这个DoFHandler需要与调用 <code>add_data_vector或</code> <code>attach_dof_handler</code>, 分配的其他DoFHandler对象兼容，即所有的DoFHandler对象都需要基于相同的三角测量。这个函数允许你从描述不同解决方案组件的多个DoFHandler对象导出数据。在 <a class="el" href="step_61.html">step-61</a> 中给出了一个使用此函数的例子。 由于这个函数接受一个DoFHandler对象，因此自然地代表了dof数据，上面其他方法中出现的数据矢量类型参数就没有必要了。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00941">941</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a33f3f6c09920c20d36c984c9123ff1e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f3f6c09920c20d36c984c9123ff1e1">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上述函数的缩写，只给出一个标量 <code>dof_handler</code> 和一个数据名称。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00920">920</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4983e86e29af6cbaf4a1b3bd6e9d8621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4983e86e29af6cbaf4a1b3bd6e9d8621">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数是上述函数的一个替代品，允许输出派生量而不是给定的数据。这种转换必须在一个派生自DataPostprocessor的类中完成。这个函数在 <a class="el" href="step_29.html">step-29</a> 中使用。其他用途见 <a class="el" href="step_32.html">step-32</a> 和 <a class="el" href="step_33.html">step-33</a> 。 这些派生量的名称由 <code>data_postprocessor参数提供。同样，其他add_data_vector()函数的data_component_interpretation参数也是由data_postprocessor参数提供的。由于只有类型为</code> <code>type_dof_data</code> 的数据可以被转换，这个类型也是隐含地知道的，不需要给出。 </p><dl class="section note"><dt>Note</dt><dd>矢量参数的实际类型可以是任何矢量类型，FEValues可以使用 <a class="el" href="classFEValuesBase.html#a357b422e374f2f2207af3512093f3907">FEValuesBase::get_function_values()</a> 函数从单元格上提取数值。 </dd>
<dd>
数据后处理器对象（即实际上是你的派生类的对象）必须活到DataOut对象被销毁为止，因为后者保持着一个指向前者的指针，如果指向的对象被销毁，而后者仍有一个指向它的指针，就会抱怨。如果数据后处理器和DataOut对象都是一个函数的局部变量（例如，在 <a class="el" href="step_29.html">step-29</a> 中就是如此），那么你可以通过在DataOut变量之前声明数据后处理器变量来避免这个错误，因为对象的销毁顺序与声明顺序相反。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00961">961</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a3c309b6a0db9808eee76ab1b6ba39239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c309b6a0db9808eee76ab1b6ba39239">&#9670;&nbsp;</a></span>add_data_vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDataPostprocessor.html">DataPostprocessor</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_postprocessor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上面的函数相同，但有一个DoFHandler对象，不需要与最初设置的DoFHandler重合。注意，后处理器只能从给定的DoFHandler和求解向量中读取数据，而不是其他求解向量或DoFHandler。 </p>

</div>
</div>
<a id="a8cf39310f98aeaee50c2143ee2f68ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf39310f98aeaee50c2143ee2f68ab5">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data_component_interpretation</em> = <code>std::vector&lt;&#160;<a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>添加一个多级数据向量。 这个函数将属于DoFHandler <code>dof_handler的每一级的向量形式的向量值多级向量</code> <code>data</code> 添加到图形输出中。这个函数通常与调用set_cell_selection()一起使用，该函数选择的是特定层次上的单元，而不是活动单元（默认）。 矢量 <code>data</code> 可以通过几种方式获得，例如在多网格循环期间或之后使用 <a class="el" href="classMultigrid.html#a2614db3c885e19f89b2df14422634c22">Multigrid::solution</a> 或 <a class="el" href="classMultigrid.html#adecf4e39189911da5096d1112c91680b">Multigrid::defect</a> ，或者通过 <a class="el" href="classMGTransferMatrixFree.html#a90aef560cc3d832589ca13a5f18e1414">MGTransferMatrixFree::interpolate_to_mg()</a>. 对解进行插值处理 <code>names</code> 和 <code>data_component_interpretation</code> 与add_data_vector（）函数相同。 </p>

</div>
</div>
<a id="a99f8b5f94d56b40bfb67a4cdea74f764"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99f8b5f94d56b40bfb67a4cdea74f764">&#9670;&nbsp;</a></span>add_mg_data_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::add_mg_data_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMGLevelObject.html">MGLevelObject</a>&lt; <a class="el" href="classVectorType.html">VectorType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>上述函数的标量版本。 </p>

</div>
</div>
<a id="a28da5487f291a1724cb4697c59c3f3d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28da5487f291a1724cb4697c59c3f3d2">&#9670;&nbsp;</a></span>clear_data_vectors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::clear_data_vectors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向数据向量的指针。这允许输出一组新的向量，而无需再次提供DoF处理程序。因此，DataOut对象可以在代数背景下使用。注意，除了数据向量，已经计算的补丁也会被删除。 </p>

</div>
</div>
<a id="a8d635fcfdbd6ebe7ccc1895524b8e615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d635fcfdbd6ebe7ccc1895524b8e615">&#9670;&nbsp;</a></span>clear_input_data_references()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::clear_input_data_references </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向所有输入数据元素的指针，即指向数据向量和DoF处理器对象的指针。当你调用了派生类的 <code>build_patches</code> 函数时，这个函数可能很有用，因为此时补丁已经建立，不再需要输入数据，也不需要引用它。然后你就可以从主线程中分离出来输出补丁，而不需要再确保在输出线程结束之前，DoF处理程序对象和向量不能被删除。 </p>

</div>
</div>
<a id="a3c7605d51f91376a851ec77b0a7003aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c7605d51f91376a851ec77b0a7003aa">&#9670;&nbsp;</a></span>merge_patches() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim2, patch_dim, spacedim2, patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_spacedim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数可以用来将使用作为参数的对象的 <code>build_patches</code> 函数创建的补丁合并到这个对象创建的补丁列表中。例如，如果有一个领域分解算法，其中每个块都由它自己的DoFHandler表示，但人们想同时输出所有块上的解决方案，这有时是很方便的。 要做到这一点，给定的参数和这个对象需要有相同数量的输出向量，并且它们需要使用相同数量的每个补丁的细分。如果两个对象中的补丁在空间上有重叠，那么输出结果可能会看起来相当有趣。 如果你在合并补丁后为这个对象调用build_patches()，之前的状态会被覆盖，而合并的补丁会丢失。 第二个参数允许将第一个参数中传递的对象中的补丁的每个节点移动一定量。这对于生成一个区块集合的 "爆炸 "视图有时是有用的。 如果这个对象或另一个对象还没有设置任何补丁，这个函数将会失败。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00975">975</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="aa8ae001a1d3f270ae0d4a2b77f0d9696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8ae001a1d3f270ae0d4a2b77f0d9696">&#9670;&nbsp;</a></span>merge_patches() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::merge_patches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; DoFHandlerType2::dimension, patch_dim, DoFHandlerType2::space_dimension, patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; patch_spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>shift</em> = <code><a class="el" href="classPoint.html">Point</a>&lt;patch_spacedim&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000084">Deprecated:</a></b></dt><dd>用merge_patches()代替DoFHandlerType2模板。</dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l01066">1066</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a5c3b3a19e7c1ed70079f8682a06b021a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3b3a19e7c1ed70079f8682a06b021a">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放指向数据向量和DoF处理程序的指针。你必须使用add_data_vector()函数重新设置所有的数据条目。Dof处理程序的指针也被清空，连同所有其他数据一起。 实际上，这个函数把所有的东西都重设为一个处女状态。 </p>

</div>
</div>
<a id="a88bac22217cd4bf591eb5ac77d49b8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88bac22217cd4bf591eb5ac77d49b8fd">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="a8abd127577fe43595d9b169953b5f593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8abd127577fe43595d9b169953b5f593">&#9670;&nbsp;</a></span>get_patches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const std::vector&lt;<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a>&gt;&amp; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_patches </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>函数，基类的函数通过这个函数知道他们应该把哪些补丁写到文件中。 </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a7c3eeef4bc56cdb85c31e05dc09dae72">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a6e9ebc2f6ef4666df85bb686c7e95a90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9ebc2f6ef4666df85bb686c7e95a90">&#9670;&nbsp;</a></span>get_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;std::string&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>虚拟函数，基类的输出函数通过它获得数据集的名称。 </p>

<p>Implements <a class="el" href="classDataOutInterface.html#a128e5dec286cc1a429b94e29dd55ab81">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="a2626aebbd6852ae06f7f407f85b615a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2626aebbd6852ae06f7f407f85b615a5">&#9670;&nbsp;</a></span>get_fes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt;::<a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_fes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>提取存储在dof_data对象中的有限元，包括一个FE_DGQ&lt;dim&gt;(0)的假对象，以防只使用三角法。 </p>

</div>
</div>
<a id="a490249234021ec9de79b356a1f7fa42e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a490249234021ec9de79b356a1f7fa42e">&#9670;&nbsp;</a></span>get_nonscalar_data_ranges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; std::tuple&lt;unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, std::string, <a class="el" href="namespaceDataComponentInterpretation.html#a0cd2da3afe902f9004c23a73dbcc8ab0">DataComponentInterpretation::DataComponentInterpretation</a>&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::get_nonscalar_data_ranges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">protected</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>相关的 <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface::get_nonscalar_data_ranges()</a> 函数的重载。参见那里有更多的文档。 </p>

<p>Reimplemented from <a class="el" href="classDataOutInterface.html#a05d5d72abcf81f4174e15fd984f1267c">DataOutInterface&lt; patch_dim, patch_spacedim &gt;</a>.</p>

</div>
</div>
<a id="afc05be5cd920b234e68548735852446e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc05be5cd920b234e68548735852446e">&#9670;&nbsp;</a></span>write_dx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_dx </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以OpenDX格式写入<code>out</code>。见 <a class="el" href="namespaceDataOutBase.html#a75750d50e3d27159f8a1e4de7f0a8f32">DataOutBase::write_dx</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07130">7130</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="aea2031a2a6fe56c9b7d3f9f338f20882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea2031a2a6fe56c9b7d3f9f338f20882">&#9670;&nbsp;</a></span>write_eps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_eps </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以EPS格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a98914588b1516419a572a1718b1bf3d5">DataOutBase::write_eps</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07182">7182</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ae7f2c3305058c94333d8aa699286b807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7f2c3305058c94333d8aa699286b807">&#9670;&nbsp;</a></span>write_gmv()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gmv </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据并以GMV格式写入<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#afa4389cfc36770d2881867f6889bc348">DataOutBase::write_gmv</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07195">7195</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a85407e870a68179ebe62410d9efc153f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85407e870a68179ebe62410d9efc153f">&#9670;&nbsp;</a></span>write_gnuplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_gnuplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获得数据并以GNUPLOT格式写入<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a3cfd561a7b5262f83e3cdc4020b377f4">DataOutBase::write_gnuplot</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07156">7156</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a33a15f01cb0171da2956be68ad496cd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a15f01cb0171da2956be68ad496cd0">&#9670;&nbsp;</a></span>write_povray()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_povray </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以POVRAY格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#ae661c9d7979da0c39b5f08fd715ed947">DataOutBase::write_povray</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07169">7169</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a980b995a6f5944a75721097de39069c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a980b995a6f5944a75721097de39069c1">&#9670;&nbsp;</a></span>write_tecplot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_tecplot </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Tecplot格式写到<code>out</code>。见 <a class="el" href="namespaceDataOutBase.html#ab9f9f33c200120450b6844d986a83604">DataOutBase::write_tecplot</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07208">7208</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a2bf06b8647892769140884b3ab44a08e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf06b8647892769140884b3ab44a08e">&#9670;&nbsp;</a></span>write_ucd()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_ucd </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以UCD格式写入<code>out</code>，用于AVS。参见 <a class="el" href="namespaceDataOutBase.html#a5ec32be3e3379b7c83dc339f52cf2ad6">DataOutBase::write_ucd</a>. </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07143">7143</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="acad99726038e4fca7f605fdffb3317e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad99726038e4fca7f605fdffb3317e4">&#9670;&nbsp;</a></span>write_vtk()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtk </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Vtk格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a336d97147011f5f8f3746cac0a3ca4ab">DataOutBase::write_vtk</a>. </p><dl class="section note"><dt>Note</dt><dd>VTK是一种遗留格式，在很大程度上已经被VTU格式（VTK的XML结构版本）所取代了。特别是，VTU允许对数据进行压缩，因此导致大文件的文件大小要比VTK文件小得多。由于所有支持VTK的可视化程序也支持VTU，你应该考虑使用后者的文件格式，通过使用write_vtu()函数来代替。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07221">7221</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a93c780f93105e0daaa76c6c43694b4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93c780f93105e0daaa76c6c43694b4ae">&#9670;&nbsp;</a></span>write_vtu()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以Vtu（VTK的XML）格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu</a>. 一些可视化程序，如ParaView，可以读取几个独立的VTU文件以实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件构成一个组。 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a> 函数可以生成这样一个集中的记录。同样， <a class="el" href="namespaceDataOutBase.html#a482d9621dcc87d6a43cf8a9651e16cd8">DataOutInterface::write_visit_record()</a> 对旧版本的VisIt也有同样的作用（尽管VisIt从2.5.1版本开始也可以读取 <code>pvtu</code> 记录）。最后， <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutInterface::write_pvd_record()</a> 可以用来将共同构成时间相关模拟的文件分组。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07232">7232</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a5df488dad82b811ceb08cb1adf9eafcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5df488dad82b811ceb08cb1adf9eafcd">&#9670;&nbsp;</a></span>write_vtu_in_parallel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_in_parallel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>集体MPI调用，将所有参与节点（给定通信器中的节点）的解决方案写入共享文件系统上的一个压缩的.vtu文件。 该通信器可以是计算所使用的通信器的一个子通信器。 这个程序使用MPI I/O来实现并行文件系统上的高性能。也可参见 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07254">7254</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1eff778443cd0431cd807c45b6ae16d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eff778443cd0431cd807c45b6ae16d9">&#9670;&nbsp;</a></span>write_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>piece_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些可视化程序，如ParaView，可以读取几个独立的VTU文件，这些文件都是同一模拟的一部分，以实现可视化的并行化。在这种情况下，你需要一个 <code>.pvtu</code> 文件来描述哪些VTU文件（例如，通过 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 函数写入）构成一个组。 当前的函数可以生成这样一个集中记录。 该函数生成的中央记录文件包含一个（标量或矢量）字段列表，描述哪些字段实际上可以在构成平行VTU文件组的各个文件中找到，以及这些文件的名称。这个函数通过本类的get_dataset_names()和get_nonscalar_data_ranges()函数获得字段的名称和类型。这个函数的第二个参数指定了构成平行集的文件名。 </p><dl class="section note"><dt>Note</dt><dd>使用 <a class="el" href="namespaceDataOutBase.html#a3aec479936b78bd0ec2ecc3674e24584">DataOutBase::write_vtu()</a> 和 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 来写每一块。还要注意，只有一个并行进程需要调用当前函数，列出所有并行进程写入的文件名。 </dd>
<dd>
这个函数的使用在 <a class="el" href="step_40.html">step-40</a> 中解释。 </dd>
<dd>
为了告诉Paraview将多个 <code>pvtu</code> 文件组合在一起，每个文件描述一个与时间有关的仿真的一个时间步骤，请参见 <a class="el" href="namespaceDataOutBase.html#a6f1c052ba49fd44cd8e3f35ba871aebd">DataOutBase::write_pvd_record()</a> 函数。 </dd>
<dd>
旧版本的VisIt（2.5.1之前），不能读取 <code>pvtu</code> 记录。然而，它可以读取由write_visit_record()函数写入的访问记录。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07357">7357</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0864e51eb173c87e2a3edc9391ea8009"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0864e51eb173c87e2a3edc9391ea8009">&#9670;&nbsp;</a></span>write_vtu_with_pvtu_record()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_vtu_with_pvtu_record </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>directory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename_without_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>counter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>mpi_communicator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_digits_for_counter</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_groups</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数并行地写入几个.vtu文件和一个.pvtu记录，并自动构建文件名。它是 <a class="el" href="classDataOutInterface.html#a93c780f93105e0daaa76c6c43694b4ae">DataOutInterface::write_vtu()</a> 或 <a class="el" href="classDataOutInterface.html#a5df488dad82b811ceb08cb1adf9eafcd">DataOutInterface::write_vtu_in_parallel()</a>, 和 <a class="el" href="classDataOutInterface.html#a1eff778443cd0431cd807c45b6ae16d9">DataOutInterface::write_pvtu_record()</a>. 的组合。例如，在10个进程中运行<code> write_vtu_with_pvtu_record("output/", "solution", 3, comm, 4, 2) </code>会生成这些文件 </p><div class="fragment"><div class="line">output/solution_0003.0.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.1.<a class="code" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1acff6079f78795530409873a79263ad7e">vtu</a></div><div class="line">output/solution_0003.pvtu</div></div><!-- fragment --><p> 其中<code>.0.vtu</code>文件包含前一半进程的输出分组，而<code>.1.vtu</code>是其余一半进程的数据。 一个指定的 <code>directory</code> 和一个 <code>filename_without_extension</code> 构成文件名的第一部分。然后用 <code>counter</code> 扩展文件名，标明当前的时间步数/迭代次数/等等，处理器ID，最后是.vtu/.pvtu结尾。由于要写入的时间步数取决于应用，在文件名中保留的数字可以作为参数 <code>n_digits_for_counter</code>, 来指定，如果该参数保持默认值，则数字不加前导零 <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>. 如果需要一个以上的文件标识符（例如时间步数和求解器的迭代计数器），最后一个标识符作为 <code>counter</code>, 使用，而所有其他标识符必须在调用该函数时加入 <code>filename_without_extension</code> 。 在并行设置中，每个时间步长通常要写几个文件。并行写入的文件数量取决于MPI进程的数量（见参数 <code>mpi_communicator</code>), 和默认值为0的指定数量 <code>n_groups</code> 。其背景是VTU文件输出支持在并行文件系统上写入时，使用MPI I/O将几个CPU的文件分组为给定数量的文件。 <code>n_groups</code> 的默认值是0，意味着每个MPI等级将写入一个文件。1的值将生成一个包含整个域的解决方案的大文件，而更大的值将创建 <code>n_groups</code> 个文件（但不会超过MPI等级的数量）。 请注意，只有一个处理器需要生成.pvtu文件，其中零号处理器被选择来承担这项工作。 返回值是pvtu记录的集中文件的文件名。 </p><dl class="section note"><dt>Note</dt><dd>代码简单地结合了字符串 <code>directory</code> 和 <code>filename_without_extension</code>, ，即用户必须确保 <code>directory</code> 包含一个尾部字符，例如"/"，将目录和文件名分开。 </dd>
<dd>
如果要将输出写入当前工作目录，则使用空字符串""作为第一个参数。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07370">7370</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ab56595d7d5aebfb2b3abfdaad51df20d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56595d7d5aebfb2b3abfdaad51df20d">&#9670;&nbsp;</a></span>write_svg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_svg </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以SVG格式写到<code>out</code>。参见 <a class="el" href="namespaceDataOutBase.html#ad20ab1f2f5ec29122aefe1f016ff6eac">DataOutBase::write_svg</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07243">7243</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="affac60e1e3799ae884642113a8e2e723"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affac60e1e3799ae884642113a8e2e723">&#9670;&nbsp;</a></span>write_deal_II_intermediate()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_deal_II_intermediate </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过get_patches()获取数据，并以deal.II中间格式写到&lt;tt&gt;out中。参见 <a class="el" href="namespaceDataOutBase.html#a70b0a895fd8b48c1555fa1c34f2cd176">DataOutBase::write_deal_II_intermediate</a>. 注意，中间格式就像它的名字一样：内部数据的直接表示。它不是标准化的，每当我们改变内部表示时，它就会改变。你只能期望使用用于编写的相同版本的deal.II来处理以这种格式编写的文件。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07452">7452</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a45ef5cf2b6515c10ff080729a9901155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45ef5cf2b6515c10ff080729a9901155">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于data_filter中的数据创建一个XDMFEntry。这假设网格和求解数据被写到一个文件中。参见write_xdmf_file()中的使用实例。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07465">7465</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0f0b3eec5ee65bd7915c4e46272287eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f0b3eec5ee65bd7915c4e46272287eb">&#9670;&nbsp;</a></span>create_xdmf_entry() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classXDMFEntry.html">XDMFEntry</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::create_xdmf_entry </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>h5_solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>cur_time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基于data_filter中的数据，创建一个XDMFEntry。这假设网格和解的数据被写入不同的文件。参见write_xdmf_file()中的使用实例。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07479">7479</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="abfab5d02f11dcede67bb61ff3ae105d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfab5d02f11dcede67bb61ff3ae105d2">&#9670;&nbsp;</a></span>write_xdmf_file()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_xdmf_file </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classXDMFEntry.html">XDMFEntry</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>entries</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据提供的XDMFEntry对象的向量，写一个XDMF文件。 下面是一个如何用HDF5和DataOutFilter使用这个函数的例子。 </p><div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line">std::vector&lt;XDMFEntry&gt; xdmf_entries;</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Create an XDMF entry detailing the HDF5 file</span></div><div class="line"><span class="keyword">auto</span> new_xdmf_entry = data_out.<a class="code" href="classDataOutInterface.html#a45ef5cf2b6515c10ff080729a9901155">create_xdmf_entry</a>(data_filter,</div><div class="line">                                               <span class="stringliteral">&quot;solution.h5&quot;</span>,</div><div class="line">                                               simulation_time,</div><div class="line">                                               MPI_COMM_WORLD);</div><div class="line"><span class="comment">// Add the XDMF entry to the list</span></div><div class="line">xdmf_entries.push_back(new_xdmf_entry);</div><div class="line"><span class="comment">// Create an XDMF file from all stored entries</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#abfab5d02f11dcede67bb61ff3ae105d2">write_xdmf_file</a>(xdmf_entries, <span class="stringliteral">&quot;solution.xdmf&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07552">7552</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a29468f4e8eca1367d44b1a2431d39e91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29468f4e8eca1367d44b1a2431d39e91">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>data_filter</code> 中的数据写入一个单一的HDF5文件，包含网格和解的数值。下面是一个如何使用这个函数与DataOutFilter的例子。 </p><div class="fragment"><div class="line"><a class="code" href="structDataOutBase_1_1DataOutFilterFlags.html">DataOutBase::DataOutFilterFlags</a> flags(<span class="keyword">true</span>, <span class="keyword">true</span>);</div><div class="line"><a class="code" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> data_filter(flags);</div><div class="line"><span class="comment">// Filter the data and store it in data_filter</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a154d8192688eef96f052f50c2f669aa8">write_filtered_data</a>(data_filter);</div><div class="line"><span class="comment">// Write the filtered data to HDF5</span></div><div class="line">data_out.<a class="code" href="classDataOutInterface.html#a29468f4e8eca1367d44b1a2431d39e91">write_hdf5_parallel</a>(data_filter, <span class="stringliteral">&quot;solution.h5&quot;</span>, MPI_COMM_WORLD);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07730">7730</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78fdf1cc5071d85ecb2d707d798bf063"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78fdf1cc5071d85ecb2d707d798bf063">&#9670;&nbsp;</a></span>write_hdf5_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_hdf5_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>data_filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>write_mesh_file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mesh_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>solution_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将data_filter中的数据写到HDF5文件中。如果write_mesh_file为false，网格数据将不会被写入，而解文件将只包含解的数值。如果write_mesh_file为true，且文件名相同，则生成的文件将同时包含网格数据和求解值。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07742">7742</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a154d8192688eef96f052f50c2f669aa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a154d8192688eef96f052f50c2f669aa8">&#9670;&nbsp;</a></span>write_filtered_data()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write_filtered_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDataOutBase_1_1DataOutFilter.html">DataOutBase::DataOutFilter</a> &amp;&#160;</td>
          <td class="paramname"><em>filtered_data</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>DataOutFilter是一种中间数据格式，可以减少将被写入文件的数据量。这个函数所填充的对象随后可以再次用于写入具体文件格式的数据；例如，见 <a class="el" href="namespaceDataOutBase.html#af5a956cffba0fa383f85a82bb2a4ca63">DataOutBase::write_hdf5_parallel()</a>. 。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l07602">7602</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a78e73ad285a8792ff0f9f227b82eb108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e73ad285a8792ff0f9f227b82eb108">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>根据给定的数据格式向<code>out</code>写入数据和网格。 这个函数只是调用相应的<code>write_*</code>函数。如果没有要求输出格式，将写入<code>default_format</code>。 如果没有提供格式，而默认格式是<code>default_format</code>，则会发生错误。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08134">8134</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a6dab6e0fed8d4ad90d658f71a68eb32c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dab6e0fed8d4ad90d658f71a68eb32c">&#9670;&nbsp;</a></span>set_default_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_default_format </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>default_format</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置默认格式。这里设置的值在任何时候都会被使用，要求输出格式为<code>default_format</code>。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08200">8200</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac7280a24690b117454acfb0fa058299c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7280a24690b117454acfb0fa058299c">&#9670;&nbsp;</a></span>set_flags()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::set_flags </td>
          <td>(</td>
          <td class="paramtype">const FlagType &amp;&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置用于输出的标志。这个方法希望<code>flags</code>是<code>OutputFlagsBase</code>的一个子类中的成员。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08210">8210</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a36120ca3f536c90709e135161030f16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36120ca3f536c90709e135161030f16c">&#9670;&nbsp;</a></span>default_suffix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_suffix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1">DataOutBase::OutputFormat</a>&#160;</td>
          <td class="paramname"><em>output_format</em> = <code><a class="el" href="namespaceDataOutBase.html#aa3cbced9f1d4ae661f13018f4c980aa1aaca645a9a5b8782ed6dff8ef6b809e07">DataOutBase::default_format</a></code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个函数，返回与基类中相应函数相同的字符串；唯一的例外是，如果省略了参数，则返回当前默认格式的值，即在调用此函数之前通过set_default_format()或parse_parameters()设置的格式的正确后缀。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08245">8245</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a1f2f1d644d9cb1c4d1714d5173d159f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f2f1d644d9cb1c4d1714d5173d159f2">&#9670;&nbsp;</a></span>declare_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::declare_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过在每个输出格式的参数文件中声明子段来声明所有输出格式的参数，并调用每个输出格式的标志类的相应<code>declare_parameters</code>函数。 如果相应的格式不输出任何标志，那么某些声明的子段可能不包含条目。 请注意，表示每个补丁的分区数量和输出格式的顶层参数没有被声明，因为它们只被传递给虚拟函数，而不被存储在这种类型的对象中。你必须自己声明它们。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08258">8258</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="a0a975649e4516ee7c7a67ae2f8dddd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a975649e4516ee7c7a67ae2f8dddd97">&#9670;&nbsp;</a></span>parse_parameters()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::parse_parameters </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classParameterHandler.html">ParameterHandler</a> &amp;&#160;</td>
          <td class="paramname"><em>prm</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>读取 <a class="el" href="classDataOutInterface.html#a1f2f1d644d9cb1c4d1714d5173d159f2">declare_parameters()</a> 中声明的参数，并为输出格式设置相应的标志。 这样得到的标志会覆盖之前所有默认构建的或由set_flags()函数设置的标志对象的内容。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08311">8311</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<a id="ac3292ed269dfb832d20ae35db4177473"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3292ed269dfb832d20ae35db4177473">&#9670;&nbsp;</a></span>validate_dataset_names()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::validate_dataset_names </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>验证get_dataset_names()和get_nonscalar_data_ranges()返回的数据集的名称是否有效。目前这包括检查名称是否被多次使用。如果遇到一个无效的状态，将在调试模式下触发一个Assert()。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8cc_source.html#l08393">8393</a> of file <a class="el" href="data__out__base_8cc_source.html">data_out_base.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ac375257e903ef002986cf9b81b2eeacb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac375257e903ef002986cf9b81b2eeacb">&#9670;&nbsp;</a></span>first_cell_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &amp;)&gt; <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::first_cell_function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个函数对象，用于选择第一个单元格是什么，以生成图形输出。参见set_cell_selection()函数以了解更多信息。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00260">260</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="ac8037e7fb25d22e232b61aaa10d2a374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8037e7fb25d22e232b61aaa10d2a374">&#9670;&nbsp;</a></span>next_cell_function</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;<a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a>(const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &amp;, const <a class="el" href="classDataOut.html#a994bb1dbfacf7c835f33efd0e75b079b">cell_iterator</a> &amp;)&gt; <a class="el" href="classDataOut.html">DataOut</a>&lt; dim, spacedim &gt;::next_cell_function</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个函数对象，用于选择下一个单元格，并在其上生成图形输出，给定一个前一个单元格。参见set_cell_selection()函数以了解更多信息。 </p>

<p class="definition">Definition at line <a class="el" href="numerics_2data__out_8h_source.html#l00268">268</a> of file <a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a>.</p>

</div>
</div>
<a id="ab87e6a1ac30aee2b4a134aeca8b38253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab87e6a1ac30aee2b4a134aeca8b38253">&#9670;&nbsp;</a></span>triangulation</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classTriangulation.html">Triangulation</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::triangulation</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向三角测量对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00787">787</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a512dc7e149e9d83b712e1707780b9afc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a512dc7e149e9d83b712e1707780b9afc">&#9670;&nbsp;</a></span>dofs</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::dofs</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>指向可选的处理程序对象的指针。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00793">793</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a4a6762a26e4dc93f133c175e271936e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a6762a26e4dc93f133c175e271936e1">&#9670;&nbsp;</a></span>dof_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::dof_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>带有每个自由度数值向量的数据元素的列表。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00801">801</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a31bbb02ee5dcd6752232e76bdecaecd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31bbb02ee5dcd6752232e76bdecaecd4">&#9670;&nbsp;</a></span>cell_data</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::shared_ptr&lt; <a class="el" href="classinternal_1_1DataOutImplementation_1_1DataEntryBase.html">internal::DataOutImplementation::DataEntryBase</a>&lt;dim, spacedim&gt; &gt; &gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::cell_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>带有每个单元值向量的数据元素的列表。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00809">809</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a3adac4a7d4453f2fe8e35a89add8590c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3adac4a7d4453f2fe8e35a89add8590c">&#9670;&nbsp;</a></span>patches</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classDataOut__DoFData.html#af09d3320cfb06d2092ee8be96c632b8b">Patch</a>&gt; <a class="el" href="classDataOut__DoFData.html">DataOut_DoFData</a>&lt; dim, patch_dim, spacedim, patch_spacedim &gt;::patches</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这是一个补丁列表，每次调用build_patches()时都会创建一个补丁。这些补丁在基类的输出例程中使用。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__dof__data_8h_source.html#l00815">815</a> of file <a class="el" href="data__out__dof__data_8h_source.html">data_out_dof_data.h</a>.</p>

</div>
</div>
<a id="a072edd6d53d1c5a1e4c71af22a123228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a072edd6d53d1c5a1e4c71af22a123228">&#9670;&nbsp;</a></span>default_subdivisions</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classDataOutInterface.html">DataOutInterface</a>&lt; dim, spacedim &gt;::default_subdivisions</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>补丁的默认分区数。这是由parse_parameters()填充的，并且应该被派生类中的build_patches()遵守。 </p>

<p class="definition">Definition at line <a class="el" href="data__out__base_8h_source.html#l02440">2440</a> of file <a class="el" href="data__out__base_8h_source.html">data_out_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="numerics_2data__out_8h_source.html">data_out.h</a></li>
<li>source/numerics/<a class="el" href="numerics_2data__out_8cc_source.html">data_out.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
