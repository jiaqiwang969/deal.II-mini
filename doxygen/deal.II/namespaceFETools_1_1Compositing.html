<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceFETools_1_1Compositing.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FETools::Compositing Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceFETools.html">FETools</a></li><li class="navelem"><a class="el" href="namespaceFETools_1_1Compositing.html">Compositing</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">FETools::Compositing Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3845103dc7e5f8bba804fa3aa27b3292"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3845103dc7e5f8bba804fa3aa27b3292"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a3845103dc7e5f8bba804fa3aa27b3292">multiply_dof_numbers</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:a3845103dc7e5f8bba804fa3aa27b3292"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50eb7e3a393279dfb2ed7d8fe40b03ab"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a50eb7e3a393279dfb2ed7d8fe40b03ab"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a50eb7e3a393279dfb2ed7d8fe40b03ab">multiply_dof_numbers</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:a50eb7e3a393279dfb2ed7d8fe40b03ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4ac49c8856da17afc02cae938642f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3d4ac49c8856da17afc02cae938642f3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a3d4ac49c8856da17afc02cae938642f3">multiply_dof_numbers</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned <a class="el" href="classint.html">int</a> N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned <a class="el" href="classint.html">int</a> N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned <a class="el" href="classint.html">int</a> N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned <a class="el" href="classint.html">int</a> N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned <a class="el" href="classint.html">int</a> N5=0)</td></tr>
<tr class="separator:a3d4ac49c8856da17afc02cae938642f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad3aa394f4f4f3b1c0f6e58dff2037d"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:abad3aa394f4f4f3b1c0f6e58dff2037d"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#abad3aa394f4f4f3b1c0f6e58dff2037d">compute_restriction_is_additive_flags</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities)</td></tr>
<tr class="separator:abad3aa394f4f4f3b1c0f6e58dff2037d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a84e7e5e0ef8dcf107eb56f09b8f4f0"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3a84e7e5e0ef8dcf107eb56f09b8f4f0"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a3a84e7e5e0ef8dcf107eb56f09b8f4f0">compute_restriction_is_additive_flags</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:a3a84e7e5e0ef8dcf107eb56f09b8f4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f3bfba7f3e5aa020a01155fcf590910"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a2f3bfba7f3e5aa020a01155fcf590910"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classbool.html">bool</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#a2f3bfba7f3e5aa020a01155fcf590910">compute_restriction_is_additive_flags</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned <a class="el" href="classint.html">int</a> N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned <a class="el" href="classint.html">int</a> N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned <a class="el" href="classint.html">int</a> N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned <a class="el" href="classint.html">int</a> N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned <a class="el" href="classint.html">int</a> N5=0)</td></tr>
<tr class="separator:a2f3bfba7f3e5aa020a01155fcf590910"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ebe5ad61b55ad6f50796a54ed941b4"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ad9ebe5ad61b55ad6f50796a54ed941b4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ad9ebe5ad61b55ad6f50796a54ed941b4">compute_nonzero_components</a> (const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;fes, const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;multiplicities, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:ad9ebe5ad61b55ad6f50796a54ed941b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1e55e33cc82c47f89fea01dbfbadf4a"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ac1e55e33cc82c47f89fea01dbfbadf4a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ac1e55e33cc82c47f89fea01dbfbadf4a">compute_nonzero_components</a> (const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;fe_systems)</td></tr>
<tr class="separator:ac1e55e33cc82c47f89fea01dbfbadf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace11dcf8e781d4bd523e1a71b2f5c724"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ace11dcf8e781d4bd523e1a71b2f5c724"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classComponentMask.html">ComponentMask</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ace11dcf8e781d4bd523e1a71b2f5c724">compute_nonzero_components</a> (const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe1, const unsigned <a class="el" href="classint.html">int</a> N1, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe2=nullptr, const unsigned <a class="el" href="classint.html">int</a> N2=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe3=nullptr, const unsigned <a class="el" href="classint.html">int</a> N3=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe4=nullptr, const unsigned <a class="el" href="classint.html">int</a> N4=0, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *fe5=nullptr, const unsigned <a class="el" href="classint.html">int</a> N5=0, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:ace11dcf8e781d4bd523e1a71b2f5c724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd957d101116d4a8b4c17c0ee16ad202"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:abd957d101116d4a8b4c17c0ee16ad202"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#abd957d101116d4a8b4c17c0ee16ad202">build_cell_tables</a> (std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;system_to_base_table, std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;system_to_component_table, std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;component_to_base_table, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true)</td></tr>
<tr class="separator:abd957d101116d4a8b4c17c0ee16ad202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9bbed0346e30935279bc5289c7c9269"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:ae9bbed0346e30935279bc5289c7c9269"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceFETools_1_1Compositing.html#ae9bbed0346e30935279bc5289c7c9269">build_face_tables</a> (std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;face_system_to_base_table, std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;face_system_to_component_table, const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;finite_element, const <a class="el" href="classbool.html">bool</a> do_tensor_product=true, const unsigned <a class="el" href="classint.html">int</a> face_no=0)</td></tr>
<tr class="separator:ae9bbed0346e30935279bc5289c7c9269"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>一个命名空间，包含了在实现FiniteElement时帮助设置内部数据结构的函数，FiniteElement是由更简单的（"基"）元素构建的，例如FESystem。这些函数计算出来的东西通常作为被构造的派生有限元对象的FiniteElement基类的构造器参数。 一般来说，有两种方法可以构建更复杂的元素，这反映在这个命名空间的几个函数的参数被称为 <code>do_tensor_product</code> ： </p><ol>
<li>
张量积构造（ <code>do_tensor_product=true</code> ）。 张量积构造，在最简单的情况下，从标量元素中建立一个矢量值元素（更多信息见 <a class="el" href="group__vector__valued.html">本文档模块 </a>和 <a class="el" href="DEALGlossary.html#GlossComponent">本词汇条</a>）。 举个例子，考虑创建一个有两个矢量分量的矢量值元素，其中第一个应该有线性形状函数，第二个有二次形状函数。在1d中，基础元素的形状函数（在参考单元上）则是 <p class="formulaDsp">
\begin{align*} Q_1 &amp;= \{ 1-x, x \}, \\ Q_2 &amp;= \{ 2(\frac 12 - x)(1-x), 2(x - \frac 12)x, 4x(1-x) \}, \end{align*}
</p>
 其中形状函数以通常的方式排序（首先在第一个顶点上，然后在第二个顶点上，然后在单元的内部）。张量乘积结构将创建一个具有以下形状函数的元素。 <p class="formulaDsp">
\begin{align*} Q_1 \times Q_2 &amp;= \left\{ \begin{pmatrix} 1-x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(\frac 12 - x)(1-x) \end{pmatrix}, \begin{pmatrix} x \\ 0 \end{pmatrix}, \begin{pmatrix} 0 \\ 2(x - \frac 12)x \end{pmatrix}, \begin{pmatrix} 0 \\ 4x(1-x) \end{pmatrix} \right\}. \end{align*}
</p>
 这里的列表又是按标准顺序排列的。 当然，如果基数元素本身已经是矢量值，这个过程也是有效的：在这种情况下，组成的元素只是具有与基数元素加起来一样多的矢量成分。 </li>
<li>
组合形状函数（ <code>do_tensor_product=false</code> ）。与之前的策略相反，组合形状函数只是将<em>all</em>的形状函数合在一起。在上面的例子中，这将产生以下元素。 <p class="formulaDsp">
\begin{align*} Q_1 + Q_2 &amp;= \{ 1-x, 2(\frac 12 - x)(1-x), x, 2(x - \frac 12)x, 4x(1-x) \}. \end{align*}
</p>
 换句话说，如果基础元素是标量的，产生的元素也将是标量的。一般来说，基本元素都必须有相同数量的矢量成分。 当然，上面构建的元素不再有一组线性独立的形状函数。因此，通过以同样的方式处理组成元素的所有形状函数而创建的任何矩阵将是奇异的。因此，在实践中，这种策略通常用于明确确保某些形状函数被区别对待的情况（例如，通过与权重函数相乘），或者用于所组合的形状函数不是线性独立的情况。 </li>
</ol>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3845103dc7e5f8bba804fa3aa27b3292"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3845103dc7e5f8bba804fa3aa27b3292">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt;dim&gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取有限元和乘数的向量，乘出组成的元素在每个顶点、线条等方面有多少自由度。 如果 <code>do_tensor_product</code> 为真，在FiniteElementData对象中返回的构件数是每个有限元中的构件数乘以相应的倍数的乘积之和。 否则，组件数取自第一个具有非零倍数的有限元素，所有其他具有非零倍数的元素需要具有相同数量的矢量组件。 关于 <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> 参数的更多信息，请参见命名空间 <code>do_tensor_product</code> 的文档。 </p>

</div>
</div>
<a id="a50eb7e3a393279dfb2ed7d8fe40b03ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50eb7e3a393279dfb2ed7d8fe40b03ab">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt;dim&gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于任意数量的 <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,  spacedim&gt;&gt;, unsigned int&gt;</code>和 <code>do_tensor_product = true</code> 类型的参数，与上述相同。 </p>

</div>
</div>
<a id="a3d4ac49c8856da17afc02cae938642f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4ac49c8856da17afc02cae938642f3">&#9670;&nbsp;</a></span>multiply_dof_numbers() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFiniteElementData.html">FiniteElementData</a>&lt;dim&gt; FETools::Compositing::multiply_dof_numbers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但对特定数量的子元素。 </p>

</div>
</div>
<a id="abad3aa394f4f4f3b1c0f6e58dff2037d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad3aa394f4f4f3b1c0f6e58dff2037d">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算 "限制是加法的
"标志（见FiniteElement类的文档），用于第二个参数中给出的乘数的有限元列表。 限制是相加的 "标志是单个形状函数的属性，不取决于组成元素是否使用 FETools::Composition 命名空间的文档中概述的张量乘积或组合策略。因此，这个函数没有 <code>do_tensor_product</code> 参数。 </p>

</div>
</div>
<a id="a3a84e7e5e0ef8dcf107eb56f09b8f4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a84e7e5e0ef8dcf107eb56f09b8f4f0">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，用于任意数量的 <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,  spacedim&gt;&gt;, unsigned int&gt;</code>类型的参数。 </p>

</div>
</div>
<a id="a2f3bfba7f3e5aa020a01155fcf590910"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f3bfba7f3e5aa020a01155fcf590910">&#9670;&nbsp;</a></span>compute_restriction_is_additive_flags() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classbool.html">bool</a>&gt; FETools::Compositing::compute_restriction_is_additive_flags </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取一个 <code><a class="el" href="classFiniteElement.html">FiniteElement</a></code> 对象并返回一个布尔向量，描述由 <code>N1</code>, <code>N2</code>, ...子元素 <code>fe1</code>, <code>fe2</code>, 的副本组成的混合元素的每个形状函数的 <code>restriction_is_additive_flags</code> （见FiniteElement类的文档）。 "限制是加法的
"标志是单个形状函数的属性，不取决于组成元素是否使用 FETools::Composition 命名空间的文档中概述的张量积或组合策略。因此，这个函数没有 <code>do_tensor_product</code> 参数。 </p>

</div>
</div>
<a id="ad9ebe5ad61b55ad6f50796a54ed941b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ebe5ad61b55ad6f50796a54ed941b4">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>fes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; unsigned <a class="el" href="classint.html">int</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>multiplicities</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算由有限元列表描述的组成有限元的每个形状函数的非零分量，其乘数在第二个参数中给出。 如果 <code>do_tensor_product</code> 为真，则分量的数量（以及ComponentMask对象的大小）是每个有限元中的分量数量乘以相应倍数的乘积之和。 否则，组件数从第一个具有非零倍数的有限元中提取，所有其他具有非零倍数的元素都需要有相同数量的向量组件。 关于 <code>do_tensor_product</code> 参数的更多信息，请参见命名空间 <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> 的文档。 </p>

</div>
</div>
<a id="ac1e55e33cc82c47f89fea01dbfbadf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1e55e33cc82c47f89fea01dbfbadf4a">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const std::initializer_list&lt; std::pair&lt; std::unique_ptr&lt; <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt;&gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_systems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于任意数量的 <code>std::pair&lt;std::unique_ptr&lt;FiniteElement&lt;dim,  spacedim&gt;&gt;, unsigned int&gt;</code>和 <code>do_tensor_product = true</code> 类型的参数，与上述相同。 </p>

</div>
</div>
<a id="ace11dcf8e781d4bd523e1a71b2f5c724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace11dcf8e781d4bd523e1a71b2f5c724">&#9670;&nbsp;</a></span>compute_nonzero_components() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classComponentMask.html">ComponentMask</a>&gt; FETools::Compositing::compute_nonzero_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe2</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N2</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe3</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N3</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe4</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N4</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; *&#160;</td>
          <td class="paramname"><em>fe5</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>N5</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算组成有限元的非零向量分量。这个函数与前一个函数类似，只是指针表示要组成的元素，而参数 <code>N1</code>, <code>N2</code>, ......是乘数。空指针表示一个参数将被跳过。 如果 <code>do_tensor_product</code> 为真，组件的数量（以及ComponentMask对象的大小）是每个有限元素中的组件数量乘以相应的倍数的乘积之和。 否则，组件数从第一个具有非零倍数的有限元中提取，所有其他具有非零倍数的元素都需要有相同数量的向量组件。 关于 <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> 参数的更多信息，请参见命名空间 <code>do_tensor_product</code> 的文档。 </p>

</div>
</div>
<a id="abd957d101116d4a8b4c17c0ee16ad202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd957d101116d4a8b4c17c0ee16ad202">&#9670;&nbsp;</a></span>build_cell_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::Compositing::build_cell_tables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>system_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>system_to_component_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于一个给定的（复合） <code>finite_element</code> 构建 <code>系统_to_component_table，</code> <code>system_to_base_table</code> 和 <code>component_to_base_table。</code> 如果 <code>do_tensor_product</code> 为真，用于复合元素的组件数是每个有限元素中的组件数乘以相应的倍数的乘积之和。 否则，组件数取自第一个具有非零倍数的有限元，所有其他具有非零倍数的元素需要有相同数量的矢量组件。 关于 <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> 参数的更多信息，请参见命名空间 <code>do_tensor_product</code> 的文档。 </p>

</div>
</div>
<a id="ae9bbed0346e30935279bc5289c7c9269"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9bbed0346e30935279bc5289c7c9269">&#9670;&nbsp;</a></span>build_face_tables()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void FETools::Compositing::build_face_tables </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_system_to_base_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_system_to_component_table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFiniteElement.html">FiniteElement</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>finite_element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>do_tensor_product</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>face_no</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于给定的（复合） <code>finite_element</code> 建立 <code>face_system_to_base_table</code>, 和 <code>face_system_to_component_table</code>. 如果 <code>do_tensor_product</code> 为真，用于复合元素的组件数是每个有限元素中的组件数乘以相应倍数的乘积之和。 否则，组件数取自第一个具有非零倍数的有限元，所有其他具有非零倍数的元素需要有相同数量的矢量组件。 关于 <code>do_tensor_product</code> 参数的更多信息，请参见命名空间 <a class="el" href="namespaceFETools_1_1Compositing.html">FETools::Compositing</a> 的文档。 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
