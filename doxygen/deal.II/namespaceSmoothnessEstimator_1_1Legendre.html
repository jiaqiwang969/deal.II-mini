<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceSmoothnessEstimator_1_1Legendre.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SmoothnessEstimator::Legendre Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceSmoothnessEstimator.html">SmoothnessEstimator</a></li><li class="navelem"><a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">SmoothnessEstimator::Legendre Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af6d025a69f8a4d1e9fc5914e5d648463"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:af6d025a69f8a4d1e9fc5914e5d648463"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html#af6d025a69f8a4d1e9fc5914e5d648463">coefficient_decay</a> (<a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a>&lt; dim, spacedim &gt; &amp;fe_legendre, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;smoothness_indicators, const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a> regression_strategy=<a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a>, const <a class="el" href="classdouble.html">double</a> smallest_abs_coefficient=1e-10, const bool only_flagged_cells=false)</td></tr>
<tr class="separator:af6d025a69f8a4d1e9fc5914e5d648463"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eea95238b34ae80bafcc82bd1e7c64f"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, typename VectorType &gt; </td></tr>
<tr class="memitem:a6eea95238b34ae80bafcc82bd1e7c64f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html#a6eea95238b34ae80bafcc82bd1e7c64f">coefficient_decay_per_direction</a> (<a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a>&lt; dim, spacedim &gt; &amp;fe_legendre, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof_handler, const <a class="el" href="classVectorType.html">VectorType</a> &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;smoothness_indicators, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;coefficients_predicate=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classdouble.html">double</a> smallest_abs_coefficient=1e-10, const bool only_flagged_cells=false)</td></tr>
<tr class="separator:a6eea95238b34ae80bafcc82bd1e7c64f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e07cd38b0325d2786ca31a1c50f0c01"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim&gt; </td></tr>
<tr class="memitem:a3e07cd38b0325d2786ca31a1c50f0c01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a>&lt; dim, spacedim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html#a3e07cd38b0325d2786ca31a1c50f0c01">default_fe_series</a> (const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;fe_collection, const unsigned <a class="el" href="classint.html">int</a> component=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>)</td></tr>
<tr class="separator:a3e07cd38b0325d2786ca31a1c50f0c01"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Smoothness estimation strategy based on the decay of <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> expansion coefficients.</p>
<p>In one dimension, the finite element solution on cell \(K\) with polynomial degree \(p\) can be written as </p><p class="formulaDsp">
\begin{eqnarray*} u_h(x) &amp;=&amp; \sum_j u_j \varphi_j (x) \\ u_{h, k}(x) &amp;=&amp; \sum_{k=0}^{p} a_k \widetilde P_k (x), \quad a_k = \sum_j {\cal L}_{k,j} u_j \end{eqnarray*}
</p>
<p> where \(u_j\) are degrees of freedom and \(\varphi_j\) are the corresponding shape functions. \(\{\widetilde P_k(x)\}\) are <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> polynomials on cell \(K\). \(a_k\) and \({\cal L}_{k,j}\) are coefficients and transformation matrices from the <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> expansion of each shape function. For practical reasons, we will perform the calculation of these matrices and coefficients only on the reference cell \(\hat K\). We only have to calculate the transformation matrices once this way. However, results are only applicable if the mapping from the reference cell to the actual cell is affine. We use the class <a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a> to determine all coefficients \(a_k\).</p>
<p>A function is analytic, i.e., representable by a power series, if and only if their <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> expansion coefficients decay as (see <b>[eibner2007hp]</b>) </p><p class="formulaDsp">
\[ |a_k| \sim c \, \exp(-\sigma k) \]
</p>
<p> We determine their decay rate \(\sigma\) by performing the linear regression fit of </p><p class="formulaDsp">
\[ \ln |a_k| \sim C - \sigma k \]
</p>
<p> for \(k=0,\ldots,p\), with \(p\) the polynomial degree of the finite element. The rate of the decay \(\sigma\) can be used to estimate the smoothness. For example, one strategy to implement hp-refinement criteria is to perform p-refinement if \(\sigma&gt;1\) (see <b>[mavriplis1994hp]</b>). </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="af6d025a69f8a4d1e9fc5914e5d648463"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6d025a69f8a4d1e9fc5914e5d648463">&#9670;&nbsp;</a></span>coefficient_decay()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SmoothnessEstimator::Legendre::coefficient_decay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_legendre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>smoothness_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1">VectorTools::NormType</a>&#160;</td>
          <td class="paramname"><em>regression_strategy</em> = <code><a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>smallest_abs_coefficient</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_flagged_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this variant of the estimation strategy for higher dimensions, we will consider all mode vectors \(\bf k\) describing <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> polynomials \(\widetilde P_{\bf k}\) and perform one least-squares fit over all coefficients at once. If there are multiple coefficients corresponding to the same absolute value of modes \(\|{\bf k}\|_1\), we take the maximum among those. Thus, the least-squares fit is performed on </p><p class="formulaDsp">
\begin{eqnarray*} \widetilde P_{\bf k}({\bf x}) &amp;=&amp; \widetilde P_{k_1} (x_1) \ldots \widetilde P_{k_d} (x_d) \\ \ln \left( \max\limits_{\|{\bf k}\|_1} |a_{\bf k}| \right) &amp;\sim&amp; C - \sigma \|{\bf k}\|_1 \end{eqnarray*}
</p>
<p> for \({\bf k}=(k_1,\ldots,k_d)\) and \(k_i=0,\ldots,p\), with \(p\) the polynomial degree of the finite element.</p>
<p>For a finite element approximation <code>solution</code>, this function writes the decay rate for every cell into the output vector <code>smoothness_indicators</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_legendre</td><td><a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a> object to calculate coefficients. This object needs to be initialized to have at least \(p+1\) coefficients in each direction for every finite element in the collection, where \(p\) is its polynomial degree. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>A <a class="el" href="classDoFHandler.html">DoFHandler</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>A solution vector. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">smoothness_indicators</td><td>A vector for smoothness indicators. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">regression_strategy</td><td>Determines which norm will be used on the subset of coefficients \(\mathbf{k}\) with the same absolute value \(\|{\bf k}\|_1\). Default is <a class="el" href="namespaceVectorTools.html#a69967cb7a148a7169963126249213db1a0532fa97d3218aed4fa2e7fb0a2017e4">VectorTools::Linfty_norm</a> for a maximum approximation. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallest_abs_coefficient</td><td>The smallest absolute value of the coefficient to be used in linear regression. Note that <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> coefficients of some functions may have a repeating pattern of zero coefficients (i.e. for functions that are locally symmetric or antisymmetric about the midpoint of the element in any coordinate direction). Thus this parameters allows to ignore small (in absolute value) coefficients within the linear regression fit. In case there are less than two nonzero coefficients, the returned value for this cell will be \(\sigma=\infty\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">only_flagged_cells</td><td>Smoothness indicators are usually used to decide whether to perform h- or p-adaptation. So in most cases, we only need to calculate those indicators on cells flagged for refinement or coarsening. This parameter controls whether this particular subset or all cells will be considered. By default, all cells will be considered. When only flagged cells are supposed to be considered, smoothness indicators will only be set on those vector entries of flagged cells; the others will be set to a signaling NaN.</td></tr>
  </table>
  </dd>
</dl>
<p>For more theoretical details see <b>[mavriplis1994hp]</b> <b>[houston2005hp]</b> <b>[eibner2007hp]</b>. </p>

</div>
</div>
<a id="a6eea95238b34ae80bafcc82bd1e7c64f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eea95238b34ae80bafcc82bd1e7c64f">&#9670;&nbsp;</a></span>coefficient_decay_per_direction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, typename VectorType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void SmoothnessEstimator::Legendre::coefficient_decay_per_direction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_legendre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_handler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVectorType.html">VectorType</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>smoothness_indicators</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>coefficients_predicate</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>smallest_abs_coefficient</em> = <code>1e-10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>only_flagged_cells</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>In this variant of the estimation strategy for higher dimensions, we only consider modes in each coordinate direction, i.e., only mode vectors \(\bf k\) with one nonzero entry. We perform the least-squares fit in each coordinate direction separately and take the lowest decay rate \(\sigma\) among them.</p>
<p>For a finite element approximation <code>solution</code>, this function writes the decay rate for every cell into the output vector <code>smoothness_indicators</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fe_legendre</td><td><a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a> object to calculate coefficients. This object needs to be initialized to have at least \(p+1\) coefficients in each direction, where \(p\) is the maximum polynomial degree to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dof_handler</td><td>A <a class="el" href="classDoFHandler.html">DoFHandler</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">solution</td><td>A solution vector </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">smoothness_indicators</td><td>A vector for smoothness indicators </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">coefficients_predicate</td><td>A predicate to select <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> coefficients \(a_j\), \(j=0,\ldots,p\) for linear regression in each coordinate direction. The user is responsible for updating the vector of <code>flags</code> provided to this function. Note that its size is \(p+1\), where \(p\) is the polynomial degree of the FE basis on a given element. The default implementation will use all <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> coefficients in each coordinate direction, i.e. set all elements of the vector to <code>true</code>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">smallest_abs_coefficient</td><td>The smallest absolute value of the coefficient to be used in linear regression in each coordinate direction. Note that <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> coefficients of some functions may have a repeating pattern of zero coefficients (i.e. for functions that are locally symmetric or antisymmetric about the midpoint of the element in any coordinate direction). Thus this parameters allows to ignore small (in absolute value) coefficients within the linear regression fit. In case there are less than two nonzero coefficients for a coordinate direction, this direction will be skipped. If all coefficients are zero, the returned value for this cell will be \(\sigma=\infty\). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">only_flagged_cells</td><td>Smoothness indicators are usually used to decide whether to perform h- or p-adaptation. So in most cases, we only need to calculate those indicators on cells flagged for refinement or coarsening. This parameter controls whether this particular subset or all cells will be considered. By default, all cells will be considered. When only flagged cells are supposed to be considered, smoothness indicators will only be set on those vector entries of flagged cells; the others will be set to NaN.</td></tr>
  </table>
  </dd>
</dl>
<p>For more theoretical details and the application within the deal.II library see <b>[davydov2017hp]</b>. </p>

</div>
</div>
<a id="a3e07cd38b0325d2786ca31a1c50f0c01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e07cd38b0325d2786ca31a1c50f0c01">&#9670;&nbsp;</a></span>default_fe_series()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a>&lt;dim, spacedim&gt; SmoothnessEstimator::Legendre::default_fe_series </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhp_1_1FECollection.html">hp::FECollection</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>fe_collection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>component</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a <a class="el" href="classFESeries_1_1Legendre.html">FESeries::Legendre</a> object for <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> series expansions with the default configuration for smoothness estimation purposes.</p>
<p>For each finite element of the provided <code>fe_collection</code>, we use as many modes as its polynomial degree plus two. This includes the first <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> polynomial which is just a constant. Further for each element, we use a Gaussian quadrature designed to yield exact results for the highest order <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> polynomial used.</p>
<p>As the <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> expansion can only be performed on scalar fields, this class does not operate on vector-valued finite elements and will therefore throw an assertion. However, each component of a finite element field can be treated as a scalar field, respectively, on which <a class="el" href="namespaceSmoothnessEstimator_1_1Legendre.html">Legendre</a> expansions are again possible. For this purpose, the optional parameter <code>component</code> defines which component of each <a class="el" href="classFiniteElement.html">FiniteElement</a> will be used. The default value of <code>component</code> only applies to scalar FEs, in which case it indicates that the sole component is to be decomposed. For vector-valued FEs, a non-default value must be explicitly provided. </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
