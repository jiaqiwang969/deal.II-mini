<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceMatrixTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceMatrixTools_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ad0eb7a8662628534586716748d62fb"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a9ad0eb7a8662628534586716748d62fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a9ad0eb7a8662628534586716748d62fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9059560fbdad8186d7b22117fbb3d62d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a9059560fbdad8186d7b22117fbb3d62d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a9059560fbdad8186d7b22117fbb3d62d">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;solution, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a9059560fbdad8186d7b22117fbb3d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d63cb21abc6c954557c603478ba5f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a6d63cb21abc6c954557c603478ba5f7d">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a6d63cb21abc6c954557c603478ba5f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7726d60a7932a8681fa24b292063891e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a7726d60a7932a8681fa24b292063891e">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">PETScWrappers::MPI::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a7726d60a7932a8681fa24b292063891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967ecdb0d0efe1549be8e3f6b9bbf123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a967ecdb0d0efe1549be8e3f6b9bbf123">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a967ecdb0d0efe1549be8e3f6b9bbf123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1220276dc006f61cca2f166861b40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a61c1220276dc006f61cca2f166861b40">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a61c1220276dc006f61cca2f166861b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe66f38c3a4f4e46dd8389b62209b891"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:afe66f38c3a4f4e46dd8389b62209b891"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">local_apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;local_dof_indices, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_rhs, const <a class="el" href="classbool.html">bool</a> eliminate_columns)</td></tr>
<tr class="separator:afe66f38c3a4f4e46dd8389b62209b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734f7b4fce41d8f4d0bfc5805460651b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a734f7b4fce41d8f4d0bfc5805460651b">DeclExceptionMsg</a> (ExcBlocksDontMatch, &quot;You are providing a matrix whose subdivision into &quot; &quot;blocks in either row or column direction does not use &quot; &quot;the same blocks sizes as the solution vector or &quot; &quot;right hand side vectors, respectively.&quot;)</td></tr>
<tr class="separator:a734f7b4fce41d8f4d0bfc5805460651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>提供一个对矩阵进行操作的函数集合。这些包括对线性方程组的边界条件的应用和其他。</p>
<h3>Boundary conditions</h3>
<p><a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">apply_boundary_values()</a>函数修改了一个线性系统，以纳入由Dirichlet型边界条件（或者，更具体地说："强
"边界条件）所产生的约束。为了真正做到这一点，当前命名空间中的这个名字的函数需要一个自由度指数的列表，以及这些自由度应该具有的值。要了解如何获得这样一个列表，请看 <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> 函数的讨论，作为一个例子。 有两种方法可以将固定自由度（如边界节点）纳入线性系统，如下文所述。这两种方法都是在局部对全局线性系统的贡献层面上操作，或者是全局系统本身。第三种方法，使用 AffineConstraints::copy_local_to_global(), 执行相同的过程，作为将一个单元的局部贡献加入全局线性系统的一部分（"装配
"步骤），是目前教程程序中最主要的方法。 </p><dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<h3>Global elimination</h3>
<p>在第一种方法中，我们首先在不尊重固定自由度的情况下装配全局线性系统，并在第二步中再次从线性系统中消除它们。纳入组装过程如下：当矩阵和向量被设置好后，要列出受Dirichlet边界条件约束的节点，并对矩阵和向量进行相应修改。这是通过删除矩阵中该自由度行的所有条目，将主对角线条目设置为一个合适的正值，并将右手边的元素设置为一个值，这样线性系统的解将在该节点有边界值。为了使剩余的线性方程组解耦并使系统再次对称（至少以前是这样的），要对这条线进行一个高斯消除步骤，将这条线（现在几乎是空的）加入到所有与给定自由度相耦合的其他线中，从而消除这个自由度与其他自由度之间的所有耦合。现在，除了主要的对角线条目之外，各自的列也只由零组成。另外，这个命名空间的函数有一个布尔参数，允许省略这最后一步，如果所产生的线性系统的对称性不需要的话。请注意，通常情况下，即使是CG也能应对具有这种特殊结构的非对称线性系统。 寻找哪些行包含我们目前正在执行的高斯消除步骤的列中的条目是困难的，或者是非常简单的，取决于情况。如果稀疏模式是对称的（矩阵是否对称在这里无关紧要），那么我们可以通过查看当前行中哪些列是不空的来推断出在当前列中有一个非零条目的行。在这种情况下，我们只需要查看固定数量的行，不需要搜索所有的行。另一方面，如果稀疏模式是非对称的，那么我们需要使用一个迭代求解器，它在任何情况下都可以处理非对称矩阵，所以可能无论如何都不需要做高斯消除。事实上，这个函数就是这样工作的：它接受一个参数（ <code>eliminate_columns</code>) ，指定稀疏模式是否是对称的；如果是，那么列就会被消除，右手边也会相应修改。如果不是，则只删除该行，完全不涉及该列，而且除了与当前行对应的值之外，所有右手边的值保持不变。 如果你的矩阵的稀疏模式是非对称的，你必须把这个参数的值设置为 <code>false</code> ，因为这样我们就不能在不搜索所有行的情况下消除这一列，这样就太昂贵了（如果 <code>N</code> ]为行数， <code>m</code> 为每行的非零元素数，那么消除一列就是<code>O(N*log(m))</code>操作，因为在每行搜索需要<code>log(m)</code>操作）。) 如果你的稀疏性模式是对称的，但你的矩阵不是，那么你也可以指定 <code>false</code> 。如果你的稀疏模式和矩阵都是对称的，你可能想指定 <code>true</code> （那么消除一行的复杂性是<code>O(m*log(m))</code>，因为我们只需要搜索 <code>m</code> 行的列的相应元素）。鉴于 <code>m</code> 大致是恒定的，不管离散化如何，边界节点的数量在2d中是<code>sqrt(N)</code>，对称稀疏模式的算法是<code>O(sqrt(N)*m*log(m))</code>，而对于一般情况，它将是<code>O(N*sqrt(N)*log(m))</code>；后者太昂贵，无法执行。 似乎我们必须明确，在做高斯消除步骤时不要覆盖其他边界节点的线。然而，由于我们在通过这样的节点时重置了右手边，所以改变其他尚未处理的边界节点的右手边的值并不是问题。改变已经处理过的节点的那些条目将是一个问题，但是由于已经处理过的节点的行上的本列矩阵条目是零，高斯步骤不会改变右手边。因此，我们不需要对其他边界节点进行特别的处理。 为了使解题速度更快，我们用正确的边界值预设了解向量（至于为什么要这样做，请看下面关于局部消除的描述）。不清楚在使用迭代求解器时，删除边界自由度和其他自由度之间的耦合是否真的能迫使解向量中的相应条目具有正确的值，因为它们的搜索方向可能包含边界节点方向上的分量。出于这个原因，我们进行了一个非常简单的线平衡，不是将主对角线条目设置为一，而是设置为删除此线之前的值，如果主对角线条目由于某种原因为零，则设置为第一个非零主对角线条目。当然，我们必须适当改变右手边的内容。这不是一个很好的策略，但它至少应该给主对角线条目一个正确的维度顺序的值，这使得求解过程更稳定一些。一个精炼的算法会将该条目设置为其他对角线条目的平均值，但这似乎太昂贵了。 在某些情况下，对同一矩阵进行多次求解，但对不同的右手边或边界值进行求解，可能是有趣的。一个典型的例子是解决一个随时间变化的问题，其中边界值或右手边发生变化，但矩阵本身没有变化。这时，人们可能会想只组装一次矩阵，然后在同一个矩阵对象上重复调用 <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> 函数，在每个时间步长中新形成一个右手边向量。然而，由于对右手向量的边界值的修改取决于原始矩阵，如果不把原始矩阵存储在某个地方，并在每个时间步长中用存储在其他地方的未修改的矩阵初始化系统矩阵，这是不可能的。 <a class="el" href="step_26.html">step-26</a> 通过存储组成系统矩阵的构件，对这一过程进行了变通，但一般原理是相同的。另外，我们可以使用constrained_linear_operator()函数。在它的文档中，你还可以找到一个正式的（数学）描述，即修改矩阵和右手边向量的边界值的过程。</p>
<h3>Local elimination</h3>
<p>处理边界值的第二种方式是在将本地矩阵和向量的贡献转移到全局稀疏矩阵和向量之前，适当地修改它们。这就是local_apply_boundary_values()的作用。这样做的好处是，我们省去了对apply_boundary_values函数的调用（这个函数很昂贵，因为它必须在稀疏数据结构上工作）。另一方面，local_apply_boundary_values()函数被多次调用，即使我们只有非常少的固定边界节点，主要的缺点是，如果有悬挂的节点也需要处理，这个函数就不能像预期的那样工作。这个函数不起作用的原因是，它是要在分布到全局矩阵之前运行的，也就是在悬空节点分布之前；由于悬空节点可以被约束到一个边界节点，对悬空节点的处理会在对应于边界值的行和列上再次增加条目，而这些条目我们已经在局部消除步骤中腾出了。更糟糕的是，在3D中受约束的节点甚至可以位于边界上。因此，当务之急是边界节点的消除发生在悬空节点消除之后 <em>，但这无法通过边界节点的局部消除来实现，除非根本就没有悬空节点约束。</em> 局部消除有一个额外的缺点：我们无法获得解向量，只能获得对矩阵和右侧的局部贡献。这方面的问题很微妙，但会导致非常难以发现的困难：当我们消除一个自由度时，我们删除这个未知数的行和列，并将对角线条目设置为某个正值。为了使问题或多或少具有良好的条件，我们将这个对角线条目设置为其先验值的绝对值（如果该值非零），或者设置为所有其他非零对角线元素的平均大小。然后，我们设置右边的值，使得到的解条目具有边界值所给的正确值。由于我们将这些贡献加到所有的局部贡献上，对角线条目和右手边的各自数值也相应地加起来，所以线性系统的解中的条目仍然有效。 然而，如果这样选择的对角线条目不适合线性系统，就会出现问题。例如，考虑一个带有矩阵<code>[[A B][C^T 0]]</code>的混合拉普拉斯问题，我们只为解的第二部分指定边界值。在混合公式中，应力应变张量只出现在矩阵 <code>B</code> 或 <code>C</code>, 中，所以其中一个可能明显大于或小于另一个。现在，如果我们消除边界值，就会删除一些行和列，但也会在右下角块的对角线上引入一些条目，这样我们就会得到系统<code>[[A' B'][C'^T X]]</code>。矩阵 <code>X</code> 中的对角线项将与 <code>A</code>. 中的对角线项具有相同的数量级。 现在，如果我们用Schur补码公式解决这个系统，我们必须反转矩阵<code>X-C'^TA'^{-1}B'</code>。删除上面的行和列可以确保边界节点在Schur补数中确实也有空行和空列，除了 <code>X</code>. 中的条目。然而， <code>X</code> 中的条目可能与<code>C'^TA'^{-1}B'</code>中的条目的数量级明显不同! 如果是这样的话，我们可能会遇到迭代求解器的麻烦。例如，假设我们从解向量的零条目开始，而 <code>X</code> 中的条目太小了几个数量级；在这种情况下，迭代求解器将在每一步计算残差向量并形成修正向量，但由于 <code>X</code> 中的条目太小，边界节点的残差贡献确实很小，尽管边界节点的值仍然接近于零，不符合规定的边界值。由于残差如此之小，迭代求解器计算的修正值也非常小，最后求解器会显示收敛到一个小的总残差，而边界值仍然有明显的错误。 在上述的全局消除过程中，我们通过给边界节点的正确值 "打底
"来避免这个问题。但是，在局部消除过程中，我们不能这样做。因此，如果你遇到类似上述的问题，你需要将 <code>X</code> 中的对角线项增加到与舒尔补数的其他部分相匹配的大小，或者更简单，在启动求解器之前给解向量打底。 总之，边界节点的局部消除只有在没有悬空节点的情况下才有效，即使如此也不一定能完全令人满意地工作。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9ad0eb7a8662628534586716748d62fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad0eb7a8662628534586716748d62fb">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对系统矩阵和向量应用Dirichlet边界条件，如该命名空间的一般文档中所述。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__tools_8cc_source.html#l00081">81</a> of file <a class="el" href="matrix__tools_8cc_source.html">matrix_tools.cc</a>.</p>

</div>
</div>
<a id="a9059560fbdad8186d7b22117fbb3d62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9059560fbdad8186d7b22117fbb3d62d">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对系统矩阵和向量应用迪里切特边界条件，如本命名空间的一般文档中所述。这个函数适用于块状稀疏矩阵和块状向量。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__tools_8cc_source.html#l00242">242</a> of file <a class="el" href="matrix__tools_8cc_source.html">matrix_tools.cc</a>.</p>

</div>
</div>
<a id="a6d63cb21abc6c954557c603478ba5f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d63cb21abc6c954557c603478ba5f7d">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对系统矩阵和向量应用Dirichlet边界条件，如本命名空间的一般文档中所述。这个函数对用于包裹PETSc对象的类起作用。 <b>Important:</b> 这个函数的效率不高：它需要交替地读和写到矩阵中，这种情况PETSc处理得不好。此外，我们只删除了与边界节点相对应的行，但删除相应的列的情况（即如果 <code>eliminate_columns</code> 是 <code>true</code>) ，目前还没有实现，而且可能永远不会实现，因为如果不直接访问PETSc数据结构，成本太高。这就导致了最后一个参数的默认值所表示的动作实际上没有实现；该参数的默认值是 <code>true</code> ，以保持与该命名空间中其他同名函数的一致性）。 这个函数在 <a class="el" href="step_17.html">step-17</a> 和 <a class="el" href="step_18.html">step-18</a> 中使用。 </p><dl class="section note"><dt>Note</dt><dd>如果矩阵是用MPI在多个处理器之间并行存储的，这个函数只触及本地存储的行，而简单地忽略所有其他行。换句话说，每个处理器负责自己的行， <code>boundary_values</code> 参数需要包含你想处理的矩阵中所有本地拥有的行。(但是它也可以包含不属于本地的自由度的条目；这些条目将被简单地忽略)。此外，在并行计算的背景下，如果你处理了某一行，而其他处理器还在等待对同一行的写入或添加，你就会陷入困境。换句话说，如果另一个处理器仍然想向某行的某个元素添加东西，而你调用这个函数将该行清零，那么你下次调用compress()时可能会将远程值添加到你刚刚创建的零值中。因此，你要在对矩阵进行最后一次修改后，在开始清空行之前调用compress()。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrix__tools__once_8cc_source.html#l00066">66</a> of file <a class="el" href="matrix__tools__once_8cc_source.html">matrix_tools_once.cc</a>.</p>

</div>
</div>
<a id="a7726d60a7932a8681fa24b292063891e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7726d60a7932a8681fa24b292063891e">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">PETScWrappers::MPI::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>和上面一样，但对于并行的BlockSparseMatrix。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__tools__once_8cc_source.html#l00159">159</a> of file <a class="el" href="matrix__tools__once_8cc_source.html">matrix_tools_once.cc</a>.</p>

</div>
</div>
<a id="a967ecdb0d0efe1549be8e3f6b9bbf123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967ecdb0d0efe1549be8e3f6b9bbf123">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对系统矩阵和向量应用Dirichlet边界条件，如本命名空间的一般文档中所述。这个函数对用于包裹特里诺斯对象的类起作用。 <b>Important:</b> 这个函数的效率不高：它需要交替地读和写到矩阵中，这种情况Trilinos处理得不好。此外，我们只删除了与边界节点相对应的行，但删除相应的列的情况（即如果 <code>eliminate_columns</code> 是 <code>true</code>) ，目前没有实现，可能永远不会实现，因为如果不直接访问Trilinos数据结构，成本太高。这导致最后一个参数的默认值所表示的动作实际上没有实现；该参数的默认值为 <code>true</code> ，以保持与本命名空间中其他同名函数的一致性）。 </p><dl class="section note"><dt>Note</dt><dd>如果矩阵是用MPI在多个处理器之间并行存储的，这个函数只触及本地存储的行，而简单地忽略所有其他行。换句话说，每个处理器负责自己的行， <code>boundary_values</code> 参数需要包含你想要处理的矩阵的所有本地拥有的行。(但是它也可以包含不属于本地的自由度的条目；这些条目将被简单地忽略)。此外，在并行计算的背景下，如果你处理了某一行，而其他处理器还在等待对同一行的写入或添加，你就会陷入困境。换句话说，如果另一个处理器仍然想向某行的某个元素添加东西，而你调用这个函数将该行清零，那么你下次调用compress()时可能会将远程值添加到你刚刚创建的零值中。因此，你要在对矩阵进行最后一次修改后，在开始清空行之前调用compress()。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrix__tools__once_8cc_source.html#l00420">420</a> of file <a class="el" href="matrix__tools__once_8cc_source.html">matrix_tools_once.cc</a>.</p>

</div>
</div>
<a id="a61c1220276dc006f61cca2f166861b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c1220276dc006f61cca2f166861b40">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数的作用与上面的函数相同，只是现在对块结构进行处理。 </p>

<p class="definition">Definition at line <a class="el" href="matrix__tools__once_8cc_source.html#l00436">436</a> of file <a class="el" href="matrix__tools__once_8cc_source.html">matrix_tools_once.cc</a>.</p>

</div>
</div>
<a id="afe66f38c3a4f4e46dd8389b62209b891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe66f38c3a4f4e46dd8389b62209b891">&#9670;&nbsp;</a></span>local_apply_boundary_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::local_apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数不是在创建全局矩阵后将边界值应用于全局矩阵和向量，而是在装配过程中通过修改局部矩阵和向量的贡献来实现。如果你在所有的局部贡献上调用这个函数，得到的矩阵将有相同的条目，最后在全局系统上调用apply_boundary_values()就没有必要。 由于这个函数不需要在稀疏矩阵的复杂数据结构上工作，所以它相对便宜。因此，如果你有很多固定的自由度（比如边界节点），或者对稀疏矩阵的访问很昂贵（比如对于块状稀疏矩阵，或者对于PETSc或Trilinos矩阵），它可能是一种胜利。然而，如果还有悬空节点需要考虑，它就不能如期工作了。更多的注意事项列在这个命名空间的一般文档中。 </p><dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) </dd></dl>

<p class="definition">Definition at line <a class="el" href="matrix__tools_8cc_source.html#l00505">505</a> of file <a class="el" href="matrix__tools_8cc_source.html">matrix_tools.cc</a>.</p>

</div>
</div>
<a id="a734f7b4fce41d8f4d0bfc5805460651b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734f7b4fce41d8f4d0bfc5805460651b">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixTools::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcBlocksDontMatch&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are providing a matrix whose subdivision into &quot; &quot;blocks in either row or column direction does not use &quot; &quot;the same blocks sizes as the solution vector or &quot; &quot;right hand side&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">respectively.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
