<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceMatrixTools.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: MatrixTools Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">MatrixTools Namespace Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a9ad0eb7a8662628534586716748d62fb"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a9ad0eb7a8662628534586716748d62fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a9ad0eb7a8662628534586716748d62fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9059560fbdad8186d7b22117fbb3d62d"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a9059560fbdad8186d7b22117fbb3d62d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a9059560fbdad8186d7b22117fbb3d62d">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;matrix, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;solution, <a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a9059560fbdad8186d7b22117fbb3d62d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d63cb21abc6c954557c603478ba5f7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a6d63cb21abc6c954557c603478ba5f7d">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a6d63cb21abc6c954557c603478ba5f7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7726d60a7932a8681fa24b292063891e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a7726d60a7932a8681fa24b292063891e">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;boundary_values, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">PETScWrappers::MPI::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;solution, <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a7726d60a7932a8681fa24b292063891e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967ecdb0d0efe1549be8e3f6b9bbf123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a967ecdb0d0efe1549be8e3f6b9bbf123">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a967ecdb0d0efe1549be8e3f6b9bbf123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61c1220276dc006f61cca2f166861b40"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a61c1220276dc006f61cca2f166861b40">apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;boundary_values, <a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;matrix, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;solution, <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;right_hand_side, const <a class="el" href="classbool.html">bool</a> eliminate_columns=true)</td></tr>
<tr class="separator:a61c1220276dc006f61cca2f166861b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe66f38c3a4f4e46dd8389b62209b891"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:afe66f38c3a4f4e46dd8389b62209b891"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">local_apply_boundary_values</a> (const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;boundary_values, const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;local_dof_indices, <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;local_matrix, <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;local_rhs, const <a class="el" href="classbool.html">bool</a> eliminate_columns)</td></tr>
<tr class="separator:afe66f38c3a4f4e46dd8389b62209b891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734f7b4fce41d8f4d0bfc5805460651b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMatrixTools.html#a734f7b4fce41d8f4d0bfc5805460651b">DeclExceptionMsg</a> (ExcBlocksDontMatch, &quot;You are providing a matrix whose subdivision into &quot; &quot;blocks in either row or column direction does not use &quot; &quot;the same blocks sizes as the solution vector or &quot; &quot;right hand side vectors, respectively.&quot;)</td></tr>
<tr class="separator:a734f7b4fce41d8f4d0bfc5805460651b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Provide a collection of functions operating on matrices. These include the application of boundary conditions to a linear system of equations and others.</p>
<h3>Boundary conditions</h3>
<p>The <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">apply_boundary_values()</a> functions modifies a linear system to incorporate the constraints that result from Dirichlet-type boundary conditions (or, more specifically: "strong" boundary conditions). To actually do this, the functions of this name in the current namespace require a list of degree of freedom indices along with the values these degrees of freedom should have. To see how to get such a list, see the discussion of the <a class="el" href="namespaceVectorTools.html#af27ac28c698a9ed0199faed50a204538">VectorTools::interpolate_boundary_values()</a> function as one example.</p>
<p>There are two ways to incorporate fixed degrees of freedom such as boundary nodes into a linear system, as discussed below. Both operate at either the level of local contributions to the global linear system, or the global system itself. A third way, using AffineConstraints::copy_local_to_global(), performs the same process as part of adding the local contributions of one cell into the global linear system (the "assembly" step) and is the method predominantly used in the tutorial programs today.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.)</dd></dl>
<h3>Global elimination</h3>
<p>In the first method, we first assemble the global linear system without respect for fixed degrees of freedom, and in a second step eliminate them again from the linear system. The inclusion into the assembly process is as follows: when the matrix and vectors are set up, a list of nodes subject to Dirichlet boundary conditions is made and matrix and vectors are modified accordingly. This is done by deleting all entries in the matrix in the line of this degree of freedom, setting the main diagonal entry to a suitable positive value and the right hand side element to a value so that the solution of the linear system will have the boundary value at this node. To decouple the remaining linear system of equations and to make the system symmetric again (at least if it was before), one Gauss elimination step is performed with this line, by adding this (now almost empty) line to all other lines which couple with the given degree of freedom and thus eliminating all coupling between this degree of freedom and others. Now the respective column also consists only of zeroes, apart from the main diagonal entry. Alternatively, the functions in this namespace take a boolean parameter that allows to omit this last step, if symmetry of the resulting linear system is not required. Note that usually even CG can cope with a non-symmetric linear system with this particular structure.</p>
<p>Finding which rows contain an entry in the column for which we are presently performing a Gauss elimination step is either difficult or very simple, depending on the circumstances. If the sparsity pattern is symmetric (whether the matrix is symmetric is irrelevant here), then we can infer the rows which have a nonzero entry in the present column by looking at which columns in the present row are nonempty. In this case, we only need to look into a fixed number of rows and need not search all rows. On the other hand, if the sparsity pattern is nonsymmetric, then we need to use an iterative solver which can handle nonsymmetric matrices in any case, so there may be no need to do the Gauss elimination anyway. In fact, this is the way the function works: it takes a parameter (<code>eliminate_columns</code>) that specifies whether the sparsity pattern is symmetric; if so, then the column is eliminated and the right hand side is also modified accordingly. If not, then only the row is deleted and the column is not touched at all, and all right hand side values apart from the one corresponding to the present row remain unchanged.</p>
<p>If the sparsity pattern for your matrix is non-symmetric, you must set the value of this parameter to <code>false</code> in any case, since then we can't eliminate the column without searching all rows, which would be too expensive (if <code>N</code> be the number of rows, and <code>m</code> the number of nonzero elements per row, then eliminating one column is an <code>O(N*log(m))</code> operation, since searching in each row takes <code>log(m)</code> operations). If your sparsity pattern is symmetric, but your matrix is not, then you might specify <code>false</code> as well. If your sparsity pattern and matrix are both symmetric, you might want to specify <code>true</code> (the complexity of eliminating one row is then <code>O(m*log(m))</code>, since we only have to search <code>m</code> rows for the respective element of the column). Given the fact that <code>m</code> is roughly constant, irrespective of the discretization, and that the number of boundary nodes is <code>sqrt(N)</code> in 2d, the algorithm for symmetric sparsity patterns is <code>O(sqrt(N)*m*log(m))</code>, while it would be <code>O(N*sqrt(N)*log(m))</code> for the general case; the latter is too expensive to be performed.</p>
<p>It seems as if we had to make clear not to overwrite the lines of other boundary nodes when doing the Gauss elimination step. However, since we reset the right hand side when passing such a node, it is not a problem to change the right hand side values of other boundary nodes not yet processed. It would be a problem to change those entries of nodes already processed, but since the matrix entry of the present column on the row of an already processed node is zero, the Gauss step does not change the right hand side. We need therefore not take special care of other boundary nodes.</p>
<p>To make solving faster, we preset the solution vector with the right boundary values (as to why this is necessary, see the discussion below in the description of local elimination). It it not clear whether the deletion of coupling between the boundary degree of freedom and other dofs really forces the corresponding entry in the solution vector to have the right value when using iterative solvers, since their search directions may contain components in the direction of the boundary node. For this reason, we perform a very simple line balancing by not setting the main diagonal entry to unity, but rather to the value it had before deleting this line, or to the first nonzero main diagonal entry if it is zero for some reason. Of course we have to change the right hand side appropriately. This is not a very good strategy, but it at least should give the main diagonal entry a value in the right order of dimension, which makes the solution process a bit more stable. A refined algorithm would set the entry to the mean of the other diagonal entries, but this seems to be too expensive.</p>
<p>In some cases, it might be interesting to solve several times with the same matrix, but for different right hand sides or boundary values. A typical case would be the solution of a time-dependent problem in which the boundary values or right hand side change, but the matrix itself does not. One may then be tempted to just assemble the matrix once and just call the <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">MatrixTools::apply_boundary_values()</a> function repeatedly on the same matrix object, with a right hand side vector newly formed in each time step. However, since the modification for boundary values of the right hand side vector depends on the original matrix, this is not possible without storing the original matrix somewhere, and in every time step initializing the system matrix with the unmodified matrix stored elsewhere. step-26 does a variation of this process by storing building blocks from which the system matrix is composed, but the general principle is the same. Alternatively, one can use the <a class="el" href="group__constraints.html#ga4787b401a7e601750d85b8b4fc84c8a5">constrained_linear_operator()</a> function. In its documentation you can also find a formal (mathematical) description of the process of modifying the matrix and right hand side vectors for boundary values.</p>
<h3>Local elimination</h3>
<p>The second way of handling boundary values is to modify the local matrix and vector contributions appropriately before transferring them into the global sparse matrix and vector. This is what <a class="el" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">local_apply_boundary_values()</a> does. The advantage is that we save the call to the apply_boundary_values function (which is expensive because it has to work on sparse data structures). On the other hand, the <a class="el" href="namespaceMatrixTools.html#afe66f38c3a4f4e46dd8389b62209b891">local_apply_boundary_values()</a> function is called many times, even if we only have a very small number of fixed boundary nodes, and the main drawback is that this function doesn't work as expected if there are hanging nodes that also need to be treated. The reason that this function doesn't work is that it is meant to be run before distribution into the global matrix, i.e. before hanging nodes are distributed; since hanging nodes can be constrained to a boundary node, the treatment of hanging nodes can add entries again to rows and columns corresponding to boundary values and that we have already vacated in the local elimination step. To make things worse, in 3d constrained nodes can even lie on the boundary. Thus, it is imperative that boundary node elimination happens <em>after</em> hanging node elimination, but this can't be achieved with local elimination of boundary nodes unless there are no hanging node constraints at all.</p>
<p>Local elimination has one additional drawback: we don't have access to the solution vector, only to the local contributions to the matrix and right hand side. The problem with this is subtle, but can lead to very hard to find difficulties: when we eliminate a degree of freedom, we delete the row and column of this unknown, and set the diagonal entry to some positive value. To make the problem more or less well-conditioned, we set this diagonal entry to the absolute value of its prior value if that was non- zero, or to the average magnitude of all other nonzero diagonal elements. Then we set the right hand side value such that the resulting solution entry has the right value as given by the boundary values. Since we add these contributions up over all local contributions, the diagonal entry and the respective value in the right hand side are added up correspondingly, so that the entry in the solution of the linear system is still valid.</p>
<p>A problem arises, however, if the diagonal entries so chosen are not appropriate for the linear system. Consider, for example, a mixed Laplace problem with matrix <code>[[A B][C^T 0]]</code>, where we only specify boundary values for the second component of the solution. In the mixed formulation, the stress-strain tensor only appears in either the matrix <code>B</code> or <code>C</code>, so one of them may be significantly larger or smaller than the other one. Now, if we eliminate boundary values, we delete some rows and columns, but we also introduce a few entries on the diagonal of the lower right block, so that we get the system <code>[[A' B'][C'^T X]]</code>. The diagonal entries in the matrix <code>X</code> will be of the same order of magnitude as those in <code>A</code>. Now, if we solve this system in the Schur complement formulation, we have to invert the matrix <code>X-C'^TA'^{-1}B'</code>. Deleting rows and columns above makes sure that boundary nodes indeed have empty rows and columns in the Schur complement as well, except for the entries in <code>X</code>. However, the entries in <code>X</code> may be of significantly different orders of magnitude than those in <code>C'^TA'^{-1}B'</code>! If this is the case, we may run into trouble with iterative solvers. For example, assume that we start with zero entries in the solution vector and that the entries in <code>X</code> are several orders of magnitude too small; in this case, iterative solvers will compute the residual vector in each step and form correction vectors, but since the entries in <code>X</code> are so small, the residual contributions for boundary nodes are really small, despite the fact that the boundary nodes are still at values close to zero and not in accordance with the prescribed boundary values. Since the residual is so small, the corrections the iterative solver computes are very small, and in the end the solver will indicate convergence to a small total residual with the boundary values still being significantly wrong.</p>
<p>We avoid this problem in the global elimination process described above by 'priming' the solution vector with the correct values for boundary nodes. However, we can't do this for the local elimination process. Therefore, if you experience a problem like the one above, you need to either increase the diagonal entries in <code>X</code> to a size that matches those in the other part of the Schur complement, or, simpler, prime the solution vector before you start the solver.</p>
<p>In conclusion, local elimination of boundary nodes only works if there are no hanging nodes and even then doesn't always work fully satisfactorily. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a9ad0eb7a8662628534586716748d62fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ad0eb7a8662628534586716748d62fb">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation of this namespace. </p>

</div>
</div>
<a id="a9059560fbdad8186d7b22117fbb3d62d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9059560fbdad8186d7b22117fbb3d62d">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classBlockVector.html">BlockVector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation of this namespace. This function works for block sparse matrices and block vectors. </p>

</div>
</div>
<a id="a6d63cb21abc6c954557c603478ba5f7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d63cb21abc6c954557c603478ba5f7d">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">PETScWrappers::MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">PETScWrappers::VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation of this namespace. This function works on the classes that are used to wrap PETSc objects.</p>
<p><b>Important:</b> This function is not very efficient: it needs to alternatingly read and write into the matrix, a situation that PETSc does not handle well. In addition, we only get rid of rows corresponding to boundary nodes, but the corresponding case of deleting the respective columns (i.e. if <code>eliminate_columns</code> is <code>true</code>) is not presently implemented, and probably will never because it is too expensive without direct access to the PETSc data structures. (This leads to the situation where the action indicated by the default value of the last argument is actually not implemented; that argument has <code>true</code> as its default value to stay consistent with the other functions of same name in this namespace.)</p>
<p>This function is used in step-17 and step-18.</p>
<dl class="section note"><dt>Note</dt><dd>If the matrix is stored in parallel across multiple processors using MPI, this function only touches rows that are locally stored and simply ignores all other rows. In other words, each processor is responsible for its own rows, and the <code>boundary_values</code> argument needs to contain all locally owned rows of the matrix that you want to have treated. (But it can also contain entries for degrees of freedom not owned locally; these will simply be ignored.) Further, in the context of parallel computations, you will get into trouble if you treat a row while other processors still have pending writes or additions into the same row. In other words, if another processor still wants to add something to an element of a row and you call this function to zero out the row, then the next time you call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> may add the remote value to the zero you just created. Consequently, you will want to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> after you made the last modifications to a matrix and before starting to clear rows. </dd></dl>

</div>
</div>
<a id="a7726d60a7932a8681fa24b292063891e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7726d60a7932a8681fa24b292063891e">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockSparseMatrix.html">PETScWrappers::MPI::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but for the parallel <a class="el" href="classBlockSparseMatrix.html">BlockSparseMatrix</a>. </p>

</div>
</div>
<a id="a967ecdb0d0efe1549be8e3f6b9bbf123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967ecdb0d0efe1549be8e3f6b9bbf123">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1Vector.html">TrilinosWrappers::MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply Dirichlet boundary conditions to the system matrix and vectors as described in the general documentation of this namespace. This function works on the classes that are used to wrap Trilinos objects.</p>
<p><b>Important:</b> This function is not very efficient: it needs to alternatingly read and write into the matrix, a situation that Trilinos does not handle well. In addition, we only get rid of rows corresponding to boundary nodes, but the corresponding case of deleting the respective columns (i.e. if <code>eliminate_columns</code> is <code>true</code>) is not presently implemented, and probably will never because it is too expensive without direct access to the Trilinos data structures. (This leads to the situation where the action indicated by the default value of the last argument is actually not implemented; that argument has <code>true</code> as its default value to stay consistent with the other functions of same name in this namespace.)</p>
<dl class="section note"><dt>Note</dt><dd>If the matrix is stored in parallel across multiple processors using MPI, this function only touches rows that are locally stored and simply ignores all other rows. In other words, each processor is responsible for its own rows, and the <code>boundary_values</code> argument needs to contain all locally owned rows of the matrix that you want to have treated. (But it can also contain entries for degrees of freedom not owned locally; these will simply be ignored.) Further, in the context of parallel computations, you will get into trouble if you treat a row while other processors still have pending writes or additions into the same row. In other words, if another processor still wants to add something to an element of a row and you call this function to zero out the row, then the next time you call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> may add the remote value to the zero you just created. Consequently, you will want to call <a class="el" href="namespaceUtilities.html#a6155277fd058eddb1504f9562cb1c04d">compress()</a> after you made the last modifications to a matrix and before starting to clear rows. </dd></dl>

</div>
</div>
<a id="a61c1220276dc006f61cca2f166861b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61c1220276dc006f61cca2f166861b40">&#9670;&nbsp;</a></span>apply_boundary_values() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, <a class="el" href="types_8h.html#a7dcbf452228a2e0b1467e0d8b722db6b">TrilinosScalar</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1BlockSparseMatrix.html">TrilinosWrappers::BlockSparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;&#160;</td>
          <td class="paramname"><em>right_hand_side</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function does the same as the one above, except now working on block structures. </p>

</div>
</div>
<a id="afe66f38c3a4f4e46dd8389b62209b891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe66f38c3a4f4e46dd8389b62209b891">&#9670;&nbsp;</a></span>local_apply_boundary_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MatrixTools::local_apply_boundary_values </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>, number &gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_dof_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>eliminate_columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rather than applying boundary values to the global matrix and vector after creating the global matrix, this function does so during assembly, by modifying the local matrix and vector contributions. If you call this function on all local contributions, the resulting matrix will have the same entries, and the final call to <a class="el" href="namespaceMatrixTools.html#a9ad0eb7a8662628534586716748d62fb">apply_boundary_values()</a> on the global system will not be necessary.</p>
<p>Since this function does not have to work on the complicated data structures of sparse matrices, it is relatively cheap. It may therefore be a win if you have many fixed degrees of freedom (e.g. boundary nodes), or if access to the sparse matrix is expensive (e.g. for block sparse matrices, or for PETSc or Trilinos matrices). However, it doesn't work as expected if there are also hanging nodes to be considered. More caveats are listed in the general documentation of this namespace.</p>
<dl class="section note"><dt>Note</dt><dd>The material presented here is also discussed in <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.6.html">video lecture 21.6</a>, <a href="http://www.math.colostate.edu/~bangerth/videos.676.21.65.html">video lecture 21.65</a>. (All video lectures are also available <a href="http://www.math.colostate.edu/~bangerth/videos.html">here</a>.) </dd></dl>

</div>
</div>
<a id="a734f7b4fce41d8f4d0bfc5805460651b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734f7b4fce41d8f4d0bfc5805460651b">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MatrixTools::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcBlocksDontMatch&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are providing a matrix whose subdivision into &quot; &quot;blocks in either row or column direction does not use &quot; &quot;the same blocks sizes as the solution vector or &quot; &quot;right hand side&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">respectively.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
