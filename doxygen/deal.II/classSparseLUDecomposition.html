<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classSparseLUDecomposition.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: SparseLUDecomposition&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classSparseLUDecomposition-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">SparseLUDecomposition&lt; number &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo;  &#124; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Preconditioners.html">Preconditioners and Relaxation Operators</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="sparse__decomposition_8h_source.html">deal.II/lac/sparse_decomposition.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for SparseLUDecomposition&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classSparseLUDecomposition__inherit__graph.svg" width="374" height="276"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition_1_1AdditionalData.html">AdditionalData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a7655ee8d8b9b781fa1e559c34b1f2230"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> = typename <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a></td></tr>
<tr class="separator:a7655ee8d8b9b781fa1e559c34b1f2230"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a85a6e464ba71f73c1a2d23c7b9a4da8d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a85a6e464ba71f73c1a2d23c7b9a4da8d">~SparseLUDecomposition</a> () override=0</td></tr>
<tr class="separator:a85a6e464ba71f73c1a2d23c7b9a4da8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab74ecba3e2568b61268ea69b9b890a9e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#ab74ecba3e2568b61268ea69b9b890a9e">clear</a> () override</td></tr>
<tr class="separator:ab74ecba3e2568b61268ea69b9b890a9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe20d0c20e2adb57d89210299254274"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:acfe20d0c20e2adb57d89210299254274"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#acfe20d0c20e2adb57d89210299254274">initialize</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix, const <a class="el" href="classSparseLUDecomposition_1_1AdditionalData.html">AdditionalData</a> parameters)</td></tr>
<tr class="separator:acfe20d0c20e2adb57d89210299254274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9e1942e50a699cf9417969df9c9aee3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#ad9e1942e50a699cf9417969df9c9aee3">empty</a> () const</td></tr>
<tr class="separator:ad9e1942e50a699cf9417969df9c9aee3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71242d5c14a00bb6aba2c5af0c9065f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a71242d5c14a00bb6aba2c5af0c9065f1">m</a> () const</td></tr>
<tr class="separator:a71242d5c14a00bb6aba2c5af0c9065f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b880c1fe466587f4199271ea2ecc316"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a6b880c1fe466587f4199271ea2ecc316">n</a> () const</td></tr>
<tr class="separator:a6b880c1fe466587f4199271ea2ecc316"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5b7ebc0f720cddcc4b2407a0f37758"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a8f5b7ebc0f720cddcc4b2407a0f37758"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a8f5b7ebc0f720cddcc4b2407a0f37758">vmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a8f5b7ebc0f720cddcc4b2407a0f37758"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ab34f131cd580d739a30eab32bba6a9"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a6ab34f131cd580d739a30eab32bba6a9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a6ab34f131cd580d739a30eab32bba6a9">Tvmult_add</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a6ab34f131cd580d739a30eab32bba6a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae34cbd15aa13aba61e33aa1e23a5729"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#aae34cbd15aa13aba61e33aa1e23a5729">memory_consumption</a> () const</td></tr>
<tr class="separator:aae34cbd15aa13aba61e33aa1e23a5729"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaef3dd92c7d1f6f008d4ad6bb2c5c9529"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaef3dd92c7d1f6f008d4ad6bb2c5c9529">DeclException1</a> (ExcInvalidStrengthening, <a class="el" href="classdouble.html">double</a>,&lt;&lt; &quot;The strengthening parameter &quot;&lt;&lt; arg1&lt;&lt; &quot; is not greater or <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> than zero!&quot;)</td></tr>
<tr class="separator:gaef3dd92c7d1f6f008d4ad6bb2c5c9529"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:ae7a9cef75f100f1d1d82f59fd95b0681"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a> = number</td></tr>
<tr class="separator:ae7a9cef75f100f1d1d82f59fd95b0681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4466250db96cbf50504bc1473ffca9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a></td></tr>
<tr class="separator:abf4466250db96cbf50504bc1473ffca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ffd7b499914cd4964c3a8d0fd8b5672"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> = <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; number, true &gt;</td></tr>
<tr class="separator:a0ffd7b499914cd4964c3a8d0fd8b5672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94776653684705604fea3dae0af35f4"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> = <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt; number, false &gt;</td></tr>
<tr class="separator:ac94776653684705604fea3dae0af35f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a03cf23744ef3cd8739e4c9d696b7bf44"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a03cf23744ef3cd8739e4c9d696b7bf44">SparseLUDecomposition</a> ()</td></tr>
<tr class="separator:a03cf23744ef3cd8739e4c9d696b7bf44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce9bc8bd5842b1e3f67397663ba84e3"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a9ce9bc8bd5842b1e3f67397663ba84e3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a9ce9bc8bd5842b1e3f67397663ba84e3">copy_from</a> (const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a9ce9bc8bd5842b1e3f67397663ba84e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb0d0d0947c76e8ada6679a1e0b34e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a5fb0d0d0947c76e8ada6679a1e0b34e7">strengthen_diagonal_impl</a> ()</td></tr>
<tr class="separator:a5fb0d0d0947c76e8ada6679a1e0b34e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56517361759a2e96a0aecc7fa5ab94e2"><td class="memItemLeft" align="right" valign="top">virtual number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a56517361759a2e96a0aecc7fa5ab94e2">get_strengthen_diagonal</a> (const number rowsum, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row) const</td></tr>
<tr class="separator:a56517361759a2e96a0aecc7fa5ab94e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb44a5bc7f9a94d85c11a1e9cd25a14"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#abeb44a5bc7f9a94d85c11a1e9cd25a14">prebuild_lower_bound</a> ()</td></tr>
<tr class="separator:abeb44a5bc7f9a94d85c11a1e9cd25a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb64bc85329109069717cfa7e68d4740"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaeb64bc85329109069717cfa7e68d4740">DeclException2</a> (ExcInvalidIndex, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You are trying to access the matrix entry with index &lt;&quot;&lt;&lt; arg1&lt;&lt; ','&lt;&lt; arg2&lt;&lt; &quot;&gt;, but this entry does not exist in the sparsity pattern &quot; &quot;of this matrix.&quot; &quot;\&quot; &quot;The most common cause for this problem is that you used &quot; &quot;a method to build the sparsity pattern that did not &quot; &quot;(completely) take into account all of the entries you &quot; &quot;will later try to write into. An example would be &quot; &quot;building a sparsity pattern that does not include &quot; &quot;the entries you will write into due to constraints &quot; &quot;on degrees of freedom such as hanging nodes or periodic &quot; &quot;boundary conditions. In such cases, building the &quot; &quot;sparsity pattern will succeed, but you will get errors &quot; &quot;such as the current one at one point or other when &quot; &quot;trying to write into the entries of the matrix.&quot;)</td></tr>
<tr class="separator:gaeb64bc85329109069717cfa7e68d4740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ab178929c14a89e3c7701b1251c4b0d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga1ab178929c14a89e3c7701b1251c4b0d">DeclException2</a> (ExcIteratorRange, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The iterators denote a range of &quot;&lt;&lt; arg1&lt;&lt; &quot; elements, but the given number of rows was &quot;&lt;&lt; arg2)</td></tr>
<tr class="separator:ga1ab178929c14a89e3c7701b1251c4b0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab349c6727159d55ec4b88754d4dd1e62"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab349c6727159d55ec4b88754d4dd1e62">DeclExceptionMsg</a> (ExcDifferentSparsityPatterns, &quot;When copying one sparse matrix into another, &quot; &quot;or when adding one sparse matrix to another, &quot; &quot;both matrices need to refer to the same &quot; &quot;sparsity pattern.&quot;)</td></tr>
<tr class="separator:gab349c6727159d55ec4b88754d4dd1e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga418f2cdecf84d79085a7c571fc30bde9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga418f2cdecf84d79085a7c571fc30bde9">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:ga418f2cdecf84d79085a7c571fc30bde9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1debf998b61291d913dfac4c8a22eaa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1debf998b61291d913dfac4c8a22eaa7">prepare_add</a> ()</td></tr>
<tr class="separator:a1debf998b61291d913dfac4c8a22eaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f68a9f93813ca167dc9f39624be2f5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9f68a9f93813ca167dc9f39624be2f5b">prepare_set</a> ()</td></tr>
<tr class="separator:a9f68a9f93813ca167dc9f39624be2f5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造函数和初始化</div></td></tr>
<tr class="memitem:afa7ae4d32bda6035661c9cccfe185597"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">reinit</a> (const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;sparsity)</td></tr>
<tr class="separator:afa7ae4d32bda6035661c9cccfe185597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵的信息</div></td></tr>
<tr class="memitem:a18c9e6f2bb89e5056fb0b7fe0efca566"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a18c9e6f2bb89e5056fb0b7fe0efca566">get_row_length</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row) const</td></tr>
<tr class="separator:a18c9e6f2bb89e5056fb0b7fe0efca566"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17ebe386bfe100a9f26404bed7d10893"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a17ebe386bfe100a9f26404bed7d10893">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:a17ebe386bfe100a9f26404bed7d10893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee6c3e34d4924f60ad89e3202c751f73"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aee6c3e34d4924f60ad89e3202c751f73">n_actually_nonzero_elements</a> (const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:aee6c3e34d4924f60ad89e3202c751f73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaf185692775468ae7364a8909af2d80"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aaaf185692775468ae7364a8909af2d80">get_sparsity_pattern</a> () const</td></tr>
<tr class="separator:aaaf185692775468ae7364a8909af2d80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231105aa86cca488901d94b1e1b55ac7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a231105aa86cca488901d94b1e1b55ac7">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:a231105aa86cca488901d94b1e1b55ac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">修改条目</div></td></tr>
<tr class="memitem:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">set</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j, const number value)</td></tr>
<tr class="separator:a3e77fcfbd1fa3ac83ef4ff2951b24ce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2fdc04dbbf9b8f0071b1f2da21d6e106">set</a> (const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a2fdc04dbbf9b8f0071b1f2da21d6e106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae96779660698dc3fdd5640f860f14bec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae96779660698dc3fdd5640f860f14bec">set</a> (const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae96779660698dc3fdd5640f860f14bec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a01efc87070a6730a10c4dc526bdb7701"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a01efc87070a6730a10c4dc526bdb7701">set</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a01efc87070a6730a10c4dc526bdb7701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:afd783c07fc8b97262201d70a71b5667d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#afd783c07fc8b97262201d70a71b5667d">set</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> n_cols, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:afd783c07fc8b97262201d70a71b5667d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acabf7629046afdd9077f77f7746a7a3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#acabf7629046afdd9077f77f7746a7a3f">add</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j, const number value)</td></tr>
<tr class="separator:acabf7629046afdd9077f77f7746a7a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:af4a987fd196ead89df045829bcc181a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#af4a987fd196ead89df045829bcc181a1">add</a> (const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:af4a987fd196ead89df045829bcc181a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a538fb6831594e3bf994c9d44af68fccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a538fb6831594e3bf994c9d44af68fccc">add</a> (const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a538fb6831594e3bf994c9d44af68fccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae745cf2afd297c8acdfe33ace4d366f4">add</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;col_indices, const std::vector&lt; number2 &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:ae745cf2afd297c8acdfe33ace4d366f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac97efa0f970b0bcf40da82584f71d39c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac97efa0f970b0bcf40da82584f71d39c">add</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> row, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> n_cols, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:ac97efa0f970b0bcf40da82584f71d39c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a157053c3502b33962ac736cc873a8dbd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a157053c3502b33962ac736cc873a8dbd">add</a> (const number factor, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:a157053c3502b33962ac736cc873a8dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aebb2ac677d0b2a212b289221ba4a43b7">operator*=</a> (const number factor)</td></tr>
<tr class="separator:aebb2ac677d0b2a212b289221ba4a43b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99829ea532c57a8de890ee70b1faa24c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a99829ea532c57a8de890ee70b1faa24c">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a99829ea532c57a8de890ee70b1faa24c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70c1643ae82c4bd45a881c91d0066776"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a70c1643ae82c4bd45a881c91d0066776">symmetrize</a> ()</td></tr>
<tr class="separator:a70c1643ae82c4bd45a881c91d0066776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:a9240d87b7695c58c41c93506a4723c08"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9240d87b7695c58c41c93506a4723c08">copy_from</a> (const ForwardIterator <a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">begin</a>, const ForwardIterator <a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">end</a>)</td></tr>
<tr class="separator:a9240d87b7695c58c41c93506a4723c08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ad182785cbf271adb6a29fa470ecde8d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad182785cbf271adb6a29fa470ecde8d7">copy_from</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;matrix)</td></tr>
<tr class="separator:ad182785cbf271adb6a29fa470ecde8d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b4b458133c76bb6b4966a5c89e2157c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a6b4b458133c76bb6b4966a5c89e2157c">copy_from</a> (const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a> &amp;matrix)</td></tr>
<tr class="separator:a6b4b458133c76bb6b4966a5c89e2157c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">条目访问</div></td></tr>
<tr class="memitem:a3871cf59e0e7c8bd18cabbcd3e02daa9"><td class="memItemLeft" align="right" valign="top">const number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3871cf59e0e7c8bd18cabbcd3e02daa9">operator()</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j) const</td></tr>
<tr class="separator:a3871cf59e0e7c8bd18cabbcd3e02daa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac96ad36bd86637f146fff43b3996536d"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ac96ad36bd86637f146fff43b3996536d">operator()</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j)</td></tr>
<tr class="separator:ac96ad36bd86637f146fff43b3996536d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25229f70f1bfccd2437d587a000001e"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa25229f70f1bfccd2437d587a000001e">el</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i, const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> j) const</td></tr>
<tr class="separator:aa25229f70f1bfccd2437d587a000001e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d9466d88f725141780a95c41e79951"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a49d9466d88f725141780a95c41e79951">diag_element</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i) const</td></tr>
<tr class="separator:a49d9466d88f725141780a95c41e79951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memItemLeft" align="right" valign="top">number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a159957553e3a4ca34cee51fdfa4cafa7">diag_element</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> i)</td></tr>
<tr class="separator:a159957553e3a4ca34cee51fdfa4cafa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">乘法运算</div></td></tr>
<tr class="memitem:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a7706b5f721efc5ea1966f5a5cdaad0e6">vmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a7706b5f721efc5ea1966f5a5cdaad0e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224a78133e7b655e3a2c26647097c2c7"><td class="memTemplParams" colspan="2">template&lt;class OutVector , class InVector &gt; </td></tr>
<tr class="memitem:a224a78133e7b655e3a2c26647097c2c7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a224a78133e7b655e3a2c26647097c2c7">Tvmult</a> (OutVector &amp;dst, const InVector &amp;src) const</td></tr>
<tr class="separator:a224a78133e7b655e3a2c26647097c2c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a56d106dfe8792db57f2d6e60bdfe63e1">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a56d106dfe8792db57f2d6e60bdfe63e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03ded9134adf275ede256b92eefae8ed"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a03ded9134adf275ede256b92eefae8ed"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a03ded9134adf275ede256b92eefae8ed">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v) const</td></tr>
<tr class="separator:a03ded9134adf275ede256b92eefae8ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memTemplItemLeft" align="right" valign="top">somenumber&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1a7074c2cc7fd4ed760d5bf06594cf12">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b) const</td></tr>
<tr class="separator:a1a7074c2cc7fd4ed760d5bf06594cf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a38676dc8cd6d6c7b8aea3a335653a25f">mmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const</td></tr>
<tr class="separator:a38676dc8cd6d6c7b8aea3a335653a25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21044730f1f38257cc0397accb4d05e5"><td class="memTemplParams" colspan="2">template&lt;typename numberB , typename numberC &gt; </td></tr>
<tr class="memitem:a21044730f1f38257cc0397accb4d05e5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a21044730f1f38257cc0397accb4d05e5">Tmmult</a> (<a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;C, const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;B, const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;V=<a class="el" href="classVector.html">Vector</a>&lt; number &gt;(), const <a class="el" href="classbool.html">bool</a> rebuild_sparsity_pattern=true) const</td></tr>
<tr class="separator:a21044730f1f38257cc0397accb4d05e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">矩阵规范</div></td></tr>
<tr class="memitem:aeb0010028e98a1e616d3ea1bed765f4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aeb0010028e98a1e616d3ea1bed765f4e">l1_norm</a> () const</td></tr>
<tr class="separator:aeb0010028e98a1e616d3ea1bed765f4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64627cdd2dc0d8c8991996c029ba9ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae64627cdd2dc0d8c8991996c029ba9ca">linfty_norm</a> () const</td></tr>
<tr class="separator:ae64627cdd2dc0d8c8991996c029ba9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae403bf35656c6b5c075186b116e7f293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ae403bf35656c6b5c075186b116e7f293">frobenius_norm</a> () const</td></tr>
<tr class="separator:ae403bf35656c6b5c075186b116e7f293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">预处理方法</div></td></tr>
<tr class="memitem:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a0b1f22866ffd7e47bfb32f62a1d3e711">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a0b1f22866ffd7e47bfb32f62a1d3e711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa6f7ebdcc75ee730592c0bf23014405f">precondition_SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1., const std::vector&lt; std::size_t &gt; &amp;pos_right_of_diagonal=std::vector&lt; std::size_t &gt;()) const</td></tr>
<tr class="separator:aa6f7ebdcc75ee730592c0bf23014405f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9ce0a2202ddc552f004523f3aef544"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:adc9ce0a2202ddc552f004523f3aef544"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#adc9ce0a2202ddc552f004523f3aef544">precondition_SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:adc9ce0a2202ddc552f004523f3aef544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967052ec6d13489bc529bb11515f89ea"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a967052ec6d13489bc529bb11515f89ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a967052ec6d13489bc529bb11515f89ea">precondition_TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number om=1.) const</td></tr>
<tr class="separator:a967052ec6d13489bc529bb11515f89ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a5439b4fc51d59a4cfa0f0829ee876763">SSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number omega=1.) const</td></tr>
<tr class="separator:a5439b4fc51d59a4cfa0f0829ee876763"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76ca15703f371cfa2b8281bb1eba0267"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a76ca15703f371cfa2b8281bb1eba0267"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a76ca15703f371cfa2b8281bb1eba0267">SOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:a76ca15703f371cfa2b8281bb1eba0267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab8aa1eba02ee6d5180fbb8173b9967eb">TSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const number om=1.) const</td></tr>
<tr class="separator:ab8aa1eba02ee6d5180fbb8173b9967eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94530f37331ed997e91d9458a1303f79"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a94530f37331ed997e91d9458a1303f79"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a94530f37331ed997e91d9458a1303f79">PSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:a94530f37331ed997e91d9458a1303f79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa3514d4a24a63ce70fe7e9486ad1688a">TPSOR</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;permutation, const std::vector&lt; <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> &gt; &amp;inverse_permutation, const number om=1.) const</td></tr>
<tr class="separator:aa3514d4a24a63ce70fe7e9486ad1688a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa039cc30461321e4f54dd54e67e8ca36"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:aa039cc30461321e4f54dd54e67e8ca36"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa039cc30461321e4f54dd54e67e8ca36">Jacobi_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:aa039cc30461321e4f54dd54e67e8ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a72eaf0aedbda317c83cd6b3fe460d995">SOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a72eaf0aedbda317c83cd6b3fe460d995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a36852dfbd7e9623dc96301d73fa2cf22">TSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a36852dfbd7e9623dc96301d73fa2cf22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a2d92814be1b12c114a2e86f7c7c9410c">SSOR_step</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;v, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;b, const number om=1.) const</td></tr>
<tr class="separator:a2d92814be1b12c114a2e86f7c7c9410c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">迭代器</div></td></tr>
<tr class="memitem:a419e25c734b10802f9c7f59d652f84ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a419e25c734b10802f9c7f59d652f84ca">begin</a> () const</td></tr>
<tr class="separator:a419e25c734b10802f9c7f59d652f84ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0872bb70a86280328309c97c78bc39f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ab0872bb70a86280328309c97c78bc39f">begin</a> ()</td></tr>
<tr class="separator:ab0872bb70a86280328309c97c78bc39f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cdd83806e88c53003d185ad639cd35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a22cdd83806e88c53003d185ad639cd35">begin</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r) const</td></tr>
<tr class="separator:a22cdd83806e88c53003d185ad639cd35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#abc32c2ee41aa5e02b5838ed9e3423919">begin</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r)</td></tr>
<tr class="separator:abc32c2ee41aa5e02b5838ed9e3423919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24c613fbc2273dd9f16c716b1d4dc29f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a24c613fbc2273dd9f16c716b1d4dc29f">end</a> () const</td></tr>
<tr class="separator:a24c613fbc2273dd9f16c716b1d4dc29f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa99041df4c848c5b46180327c1e9b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a1aa99041df4c848c5b46180327c1e9b5">end</a> ()</td></tr>
<tr class="separator:a1aa99041df4c848c5b46180327c1e9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8d50d7700dbd8560af071e146979c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aac8d50d7700dbd8560af071e146979c0">end</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r) const</td></tr>
<tr class="separator:aac8d50d7700dbd8560af071e146979c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bd553a69c0374c72195d4eb0158696"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#ad5bd553a69c0374c72195d4eb0158696">end</a> (const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> r)</td></tr>
<tr class="separator:ad5bd553a69c0374c72195d4eb0158696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">输入/输出</div></td></tr>
<tr class="memitem:aa84c2e29d3b520c53a9695b42b3941c5"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:aa84c2e29d3b520c53a9695b42b3941c5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#aa84c2e29d3b520c53a9695b42b3941c5">print</a> (StreamType &amp;out, const <a class="el" href="classbool.html">bool</a> across=false, const <a class="el" href="classbool.html">bool</a> diagonal_first=true) const</td></tr>
<tr class="separator:aa84c2e29d3b520c53a9695b42b3941c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6456ebe393c32b076eae0b5c9811e0c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a6456ebe393c32b076eae0b5c9811e0c8">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1.) const</td></tr>
<tr class="separator:a6456ebe393c32b076eae0b5c9811e0c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a737f5df58f2bf6ab275ed382ed725abb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a737f5df58f2bf6ab275ed382ed725abb">print_pattern</a> (std::ostream &amp;out, const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:a737f5df58f2bf6ab275ed382ed725abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3141075e3ad6362fce005d2f1c8da699"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a3141075e3ad6362fce005d2f1c8da699">print_as_numpy_arrays</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=9) const</td></tr>
<tr class="separator:a3141075e3ad6362fce005d2f1c8da699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b32b99a054482f06fc026248c27bb74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a8b32b99a054482f06fc026248c27bb74">block_write</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:a8b32b99a054482f06fc026248c27bb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b670368c98d6392ff8c9284db0622b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseMatrix.html#a9b670368c98d6392ff8c9284db0622b2">block_read</a> (std::istream &amp;in)</td></tr>
<tr class="separator:a9b670368c98d6392ff8c9284db0622b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a84c2deaa9405117039d3cdbfbe35943b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#a84c2deaa9405117039d3cdbfbe35943b">strengthen_diagonal</a></td></tr>
<tr class="separator:a84c2deaa9405117039d3cdbfbe35943b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafc84f4c5e650a920c1627b9d3a7be5f"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#aafc84f4c5e650a920c1627b9d3a7be5f">prebuilt_lower_bound</a></td></tr>
<tr class="separator:aafc84f4c5e650a920c1627b9d3a7be5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:adc2493b2e002e0a905a28321ab86c7a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classSparsityPattern.html">SparsityPattern</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSparseLUDecomposition.html#adc2493b2e002e0a905a28321ab86c7a3">own_sparsity</a></td></tr>
<tr class="separator:adc2493b2e002e0a905a28321ab86c7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class SparseLUDecomposition&lt; number &gt;</h3>

<p>用于将稀疏矩阵不完全分解为稀疏因子的抽象基类。这个类本身不能使用，只能作为实际实现特定分解的派生类的基类，如SparseILU或SparseMIC。 分解结果以稀疏矩阵的形式存储，这就是为什么这个类派生于SparseMatrix。因为它不是通常意义上的矩阵（存储的条目不是矩阵的条目，而是原始矩阵的两个因子），所以派生是<code>保护的</code>而不是<code>公开的</code>。</p>
<h3>Fill-in</h3>
<p>稀疏分解经常被用于额外的填充，即分解的稀疏结构比要分解的矩阵更密集。该类的initialize()函数允许通过AdditionalData对象进行填充，只要原始矩阵中的所有条目在分解中也存在，即分解的稀疏模式是原始矩阵中稀疏模式的超集。 这种填充可以通过各种方式完成，其中之一是SparsityPattern类的复制构造器，它允许在给定的稀疏结构中增加边对角线。</p>
<h3>Unified use of preconditioners</h3>
<p>虽然这个类的对象不能直接使用（这个类只是其他实现实际分解的基类），但派生类如SparseILU和SparseMIC可以以通常的形式作为预处理器使用。例如，这样就可以了。</p>
<div class="fragment"><div class="line"><a class="code" href="classSparseILU.html">SparseILU&lt;double&gt;</a> ilu;</div><div class="line">ilu.<a class="code" href="classSparseILU.html#ae4b56dfaab3fd8820faa1b21160b1acb">initialize</a>(<a class="code" href="namespaceLAPACKSupport.html#a1a9009db0d9a77923a7031b549b9b638a5bc7c54a9c20485772672825c6a73003">matrix</a>, <a class="code" href="classSparseILU.html#ae21347f3202a1186060eac36dcb45817">SparseILU&lt;double&gt;::AdditionalData</a>(...));</div><div class="line"></div><div class="line">somesolver.solve (A, x, f, ilu);</div></div><!-- fragment --><p>通过AdditionalData对象，可以指定LU分解的额外参数。 1/ 矩阵的对角线可以通过添加 <code>strengthen_diagonal</code> 倍的每一行的绝对行项之和来加强各自的对角线项。默认情况下不进行强化。 2/ 默认情况下，每个initialize()函数调用都会创建自己的稀疏度。为此，它复制了 <code>matrix</code> 的稀疏性，并增加了 <code>extra_off_diagonals</code> 所指定的特定数量的额外对角线条目。 3/ 通过设置 <code>use_previous_sparsity=true</code> ，稀疏度不会被重新创建，但之前初始化()调用的稀疏度被重新使用（回收）。当需要解决几个相同稀疏度的线性问题时，这可能是有用的，例如，在同一个三角形上的几个牛顿迭代步骤。默认值是 <code>false</code> 。 4/ 可以给用户定义的稀疏度为 <code>use_this_sparsity</code> 。然后，不创建稀疏度，但 <code>*use_this_sparsity</code> 被用来存储分解后的矩阵。关于稀疏度的限制见上面的 "填充 "部分）。)</p>
<h3>Particular implementations</h3>
<p>覆盖initialize()和vmult()方法来实现特定的LU分解就足够了，比如真正的LU，或者Cholesky分解。此外，如果该分解需要在每一行的基础上微调对角线的强度，它可以覆盖get_strengthen_diagonal()方法。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__decomposition_8h_source.html#l00072">72</a> of file <a class="el" href="sparse__decomposition_8h_source.html">sparse_decomposition.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a7655ee8d8b9b781fa1e559c34b1f2230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7655ee8d8b9b781fa1e559c34b1f2230">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::<a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> =  typename <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;::<a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明容器大小的类型。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__decomposition_8h_source.html#l00088">88</a> of file <a class="el" href="sparse__decomposition_8h_source.html">sparse_decomposition.h</a>.</p>

</div>
</div>
<a id="ae7a9cef75f100f1d1d82f59fd95b0681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7a9cef75f100f1d1d82f59fd95b0681">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ae7a9cef75f100f1d1d82f59fd95b0681">value_type</a> =  number</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵条目的类型。这个别名类似于标准库容器中的<code>value_type</code>。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00492">492</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="abf4466250db96cbf50504bc1473ffca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4466250db96cbf50504bc1473ffca9">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明一个类型，该类型持有与本类的模板参数相同精度的实值数。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。 如果模板参数是一个 std::complex 类型，那么real_type等于复数的基础类型。 这个别名被用来表示规范的返回类型。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00501">501</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="a0ffd7b499914cd4964c3a8d0fd8b5672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ffd7b499914cd4964c3a8d0fd8b5672">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> =  <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number, true&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个迭代器类的类型定义，在这个矩阵的所有非零项上行走。这个迭代器不能改变矩阵的值。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00507">507</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<a id="ac94776653684705604fea3dae0af35f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac94776653684705604fea3dae0af35f4">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> =  <a class="el" href="classSparseMatrixIterators_1_1Iterator.html">SparseMatrixIterators::Iterator</a>&lt;number, false&gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>走过该矩阵所有非零项的迭代器类的类型定义。这个迭代器 <em>可以改变矩阵的值，但当然不能改变稀疏模式，因为一旦稀疏矩阵被附加到它上面，这个模式就固定了。</em> </p>

<p class="definition">Definition at line <a class="el" href="sparse__matrix_8h_source.html#l00515">515</a> of file <a class="el" href="sparse__matrix_8h_source.html">sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a03cf23744ef3cd8739e4c9d696b7bf44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cf23744ef3cd8739e4c9d696b7bf44">&#9670;&nbsp;</a></span>SparseLUDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::<a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。什么都不做。 在使用此对象作为预处理（vmult()）之前，调用初始化()函数。 </p>

</div>
</div>
<a id="a85a6e464ba71f73c1a2d23c7b9a4da8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85a6e464ba71f73c1a2d23c7b9a4da8d">&#9670;&nbsp;</a></span>~SparseLUDecomposition()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::~<a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>销毁。将析构器标记为纯的，以确保这个类不被直接使用，而只是其派生类。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab74ecba3e2568b61268ea69b9b890a9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab74ecba3e2568b61268ea69b9b890a9e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>删除所有成员变量。将类留在调用构造函数后的直接状态中。 </p>

<p>Reimplemented from <a class="el" href="classSparseMatrix.html#a45f664681373fd3a1f8dd965395d360d">SparseMatrix&lt; number &gt;</a>.</p>

<p>Reimplemented in <a class="el" href="classSparseMIC.html#ac82e3f7a7e669fbe1c2a3f9624f02586">SparseMIC&lt; number &gt;</a>.</p>

</div>
</div>
<a id="acfe20d0c20e2adb57d89210299254274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe20d0c20e2adb57d89210299254274">&#9670;&nbsp;</a></span>initialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::initialize&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseLUDecomposition_1_1AdditionalData.html">AdditionalData</a>&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数需要在这个类的对象被用作预处理器之前被调用。 关于可能的参数的更多细节，请参阅类的文档和 <a class="el" href="classSparseLUDecomposition_1_1AdditionalData.html">SparseLUDecomposition::AdditionalData</a> 类的文档。 根据 <code>parameters</code> ，这个函数创建一个新的SparsityPattern，或者保持以前的稀疏度，或者采用用户给定的稀疏度 <code>data</code> 。然后，这个函数进行LU分解。 这个函数被调用后，预处理程序就可以使用了（使用派生类的 <code>vmult</code> 函数）。 </p>

</div>
</div>
<a id="ad9e1942e50a699cf9417969df9c9aee3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9e1942e50a699cf9417969df9c9aee3">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回对象是否为空。它调用继承的 <a class="el" href="classSparseMatrix.html#af1dc916c46eb5e629f4862d4571cef4f">SparseMatrix::empty()</a> 函数。 </p>

</div>
</div>
<a id="a71242d5c14a00bb6aba2c5af0c9065f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71242d5c14a00bb6aba2c5af0c9065f1">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回共域（或范围）空间的维度。它调用继承的 <a class="el" href="classSparseMatrix.html#acff5838afad6b9d4cc0c0eb5f6c515b5">SparseMatrix::m()</a> 函数。注意，矩阵的维数是 \(m \times n\) 。 </p>

</div>
</div>
<a id="a6b880c1fe466587f4199271ea2ecc316"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b880c1fe466587f4199271ea2ecc316">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回域空间的维度。它调用继承的 <a class="el" href="classSparseMatrix.html#acbefd236587249988e5b1dc04197d3bc">SparseMatrix::n()</a> 函数。注意，矩阵的维度是 \(m \times n\) . </p>

</div>
</div>
<a id="a8f5b7ebc0f720cddcc4b2407a0f37758"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5b7ebc0f720cddcc4b2407a0f37758">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>为该矩阵。 源和目的不能是同一个向量。 </p>

</div>
</div>
<a id="a6ab34f131cd580d739a30eab32bba6a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ab34f131cd580d739a30eab32bba6a9">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩阵-向量乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数的作用与vmult_add()相同，但取的是转置的矩阵。 来源和目的地不能是同一个向量。 </p>

</div>
</div>
<a id="aae34cbd15aa13aba61e33aa1e23a5729"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae34cbd15aa13aba61e33aa1e23a5729">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

<p>Reimplemented in <a class="el" href="classSparseMIC.html#a5feb4b9d38d4a2cb13a2738bceeb1903">SparseMIC&lt; number &gt;</a>, and <a class="el" href="classSparseILU.html#acae03317cb1ef19e319d0196f8c2bf69">SparseILU&lt; number &gt;</a>.</p>

</div>
</div>
<a id="a9ce9bc8bd5842b1e3f67397663ba84e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce9bc8bd5842b1e3f67397663ba84e3">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::copy_from&lt; float &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将传递的SparseMatrix复制到这个对象上。这个对象的稀疏度模式保持不变。 </p>

</div>
</div>
<a id="a5fb0d0d0947c76e8ada6679a1e0b34e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb0d0d0947c76e8ada6679a1e0b34e7">&#9670;&nbsp;</a></span>strengthen_diagonal_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::strengthen_diagonal_impl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行强化循环。对于每一行计算其元素的绝对值之和，确定加强因子（通过get_strengthen_diagonal()），并将对角线条目乘以 <code>sf+1</code> 。 </p>

</div>
</div>
<a id="a56517361759a2e96a0aecc7fa5ab94e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56517361759a2e96a0aecc7fa5ab94e2">&#9670;&nbsp;</a></span>get_strengthen_diagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual number <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::get_strengthen_diagonal </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>rowsum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在分解阶段，为第 <code>row</code> 行的对角线条目计算一个加强系数，其元素的绝对值之和为 <code>rowsum</code> 。 </p><dl class="section note"><dt>Note</dt><dd>SparseLUDecomposition中的默认实现返回 <code>strengthen_diagonal</code> 的值。这个变量在几个派生类中被设置为非零值。 </dd></dl>

</div>
</div>
<a id="abeb44a5bc7f9a94d85c11a1e9cd25a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb44a5bc7f9a94d85c11a1e9cd25a14">&#9670;&nbsp;</a></span>prebuild_lower_bound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::prebuild_lower_bound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>填充::prebuilt_lower_bound数组。 </p>

</div>
</div>
<a id="afa7ae4d32bda6035661c9cccfe185597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7ae4d32bda6035661c9cccfe185597">&#9670;&nbsp;</a></span>reinit()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;&#160;</td>
          <td class="paramname"><em>sparsity</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用给定的稀疏模式重新初始化稀疏矩阵。后者告诉矩阵需要保留多少个非零元素。 关于内存分配，和上面说的一样。 你必须确保稀疏结构的寿命至少与该矩阵的寿命一样长，或者只要reinit(const <a class="el" href="classSparsityPattern.html">SparsityPattern</a> &amp;)没有被调用，就不会有新的稀疏结构。 矩阵的元素被这个函数设置为零。 </p>

</div>
</div>
<a id="a18c9e6f2bb89e5056fb0b7fe0efca566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18c9e6f2bb89e5056fb0b7fe0efca566">&#9670;&nbsp;</a></span>get_row_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回特定行中的条目数。 </p>

</div>
</div>
<a id="a17ebe386bfe100a9f26404bed7d10893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17ebe386bfe100a9f26404bed7d10893">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目恰好是零，无论如何都会被计算在内。 </p>

</div>
</div>
<a id="aee6c3e34d4924f60ad89e3202c751f73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee6c3e34d4924f60ad89e3202c751f73">&#9670;&nbsp;</a></span>n_actually_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n_actually_nonzero_elements </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个矩阵中实际非零元素的数量。可以指定参数<code>threshold</code>，以便只计算绝对值大于阈值的元素。 注意，这个函数（与n_nonzero_elements()相反）不计算稀疏模式的所有条目，而只计算非零的（或绝对值大于阈值的）。 </p>

</div>
</div>
<a id="aaaf185692775468ae7364a8909af2d80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaf185692775468ae7364a8909af2d80">&#9670;&nbsp;</a></span>get_sparsity_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classSparsityPattern.html">SparsityPattern</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_sparsity_pattern </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对该矩阵底层稀疏性模式的（常量）引用。 尽管返回值被声明为<code>const</code>，但你应该注意，如果你调用任何对其进行操作的对象的非常量函数，它可能会改变。 </p>

</div>
</div>
<a id="a231105aa86cca488901d94b1e1b55ac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231105aa86cca488901d94b1e1b55ac7">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>虚函数，与分布式并行矩阵兼容。 </p>

</div>
</div>
<a id="a3e77fcfbd1fa3ac83ef4ff2951b24ce3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e77fcfbd1fa3ac83ef4ff2951b24ce3">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>设置元素（<em>i,j</em>）为<code>value</code>。如果条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="a2fdc04dbbf9b8f0071b1f2da21d6e106"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fdc04dbbf9b8f0071b1f2da21d6e106">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix中给出的所有元素设置到<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球的索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="ae96779660698dc3fdd5640f860f14bec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96779660698dc3fdd5640f860f14bec">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a01efc87070a6730a10c4dc526bdb7701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01efc87070a6730a10c4dc526bdb7701">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要设置零值，还是要过滤掉零值（如果存在的话，不改变相应元素中的先前内容）。默认值是<code>false</code>，也就是说，即使是零值也要处理。 </p>

</div>
</div>
<a id="afd783c07fc8b97262201d70a71b5667d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd783c07fc8b97262201d70a71b5667d">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给出的值，在给定的行和col_indices给出的列中设置为稀疏矩阵。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要插入零值还是要过滤掉它们。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="acabf7629046afdd9077f77f7746a7a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabf7629046afdd9077f77f7746a7a3f">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向元素添加<code>value</code>（<em>i,j</em>）。 如果该条目不存在或者<code>value</code>不是一个有限的数字，则抛出一个错误。尽管如此，它仍然允许在不存在的字段中存储零值。 </p>

</div>
</div>
<a id="af4a987fd196ead89df045829bcc181a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4a987fd196ead89df045829bcc181a1">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假定一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中通常的情况。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a538fb6831594e3bf994c9d44af68fccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a538fb6831594e3bf994c9d44af68fccc">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="ae745cf2afd297c8acdfe33ace4d366f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae745cf2afd297c8acdfe33ace4d366f4">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="ac97efa0f970b0bcf40da82584f71d39c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac97efa0f970b0bcf40da82584f71d39c">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 可选的参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些数据，只添加非零值。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a157053c3502b33962ac736cc873a8dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a157053c3502b33962ac736cc873a8dbd">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将<code>matrix</code>按<code>factor</code>的比例添加到这个矩阵中，也就是说，将<code>factor*matrix</code>的矩阵添加到<code>this</code>。如果所涉及的两个矩阵的稀疏性模式不指向同一个对象，这个函数会抛出一个错误，因为在这种情况下，操作会比较便宜。 源矩阵可以是一个任意底层标量类型的稀疏矩阵，只要其数据类型可以转换为这个矩阵的数据类型。 </p>

</div>
</div>
<a id="aebb2ac677d0b2a212b289221ba4a43b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb2ac677d0b2a212b289221ba4a43b7">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

</div>
</div>
<a id="a99829ea532c57a8de890ee70b1faa24c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99829ea532c57a8de890ee70b1faa24c">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

</div>
</div>
<a id="a70c1643ae82c4bd45a881c91d0066776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c1643ae82c4bd45a881c91d0066776">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过形成现有矩阵和其转置之间的平均值来对称矩阵， \(A = \frac 12(A+A^T)\) 。 这个操作假设底层的稀疏模式代表一个对称的对象。如果不是这样，那么这个操作的结果将不是一个对称矩阵，因为出于效率的考虑，它只通过在左下角的三角形部分进行循环来明确地进行对称；如果右上角的三角形有条目，那么这些元素在对称过程中会被遗漏。稀疏模式的对称化可以通过 <a class="el" href="classSparsityPatternBase.html#a16c1ebb8fbefcdce0a313e7be27ad34d">SparsityPattern::symmetrize()</a>. 得到。 </p>

</div>
</div>
<a id="a9240d87b7695c58c41c93506a4723c08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9240d87b7695c58c41c93506a4723c08">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数完全类似于 <a class="el" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">SparsityPattern::copy_from()</a> 函数，它允许在一个步骤中初始化整个矩阵。关于参数类型及其含义的更多信息请见那里。你还可以在那里找到一个关于如何使用这个函数的小例子。 与引用的函数唯一不同的是，内部迭代器指向的对象需要是 <code>std::pair&lt;unsigned int, value</code>类型，其中<code>value</code>需要可转换为该类的元素类型，由<code>number</code>模板参数指定。 矩阵以前的内容被覆盖。注意，由输入参数指定的条目不一定要覆盖矩阵的所有元素。未覆盖的元素保持不动。 </p>

</div>
</div>
<a id="ad182785cbf271adb6a29fa470ecde8d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad182785cbf271adb6a29fa470ecde8d7">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将一个完整矩阵的非零条目复制到此对象中。之前的内容被删除。 请注意，底层的稀疏模式必须适合容纳全矩阵的非零条目。这可以使用 <a class="el" href="classSparsityPattern.html#a96248eff3fbfa4270dfe21b0a4ea077b">SparsityPattern::copy_from()</a> 的那个版本来实现，该版本以FullMatrix作为参数。 </p>

</div>
</div>
<a id="a6b4b458133c76bb6b4966a5c89e2157c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b4b458133c76bb6b4966a5c89e2157c">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt;number&gt;&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1SparseMatrix.html">TrilinosWrappers::SparseMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将给定的特里诺斯矩阵复制到这个矩阵中。如果当前对象的稀疏模式不包含给定参数的非零条目的位置，该操作会触发一个断言。 这个函数假设两个矩阵有相同的大小。 该函数返回一个对<code>*this</code>的引用。 </p>

</div>
</div>
<a id="a3871cf59e0e7c8bd18cabbcd3e02daa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3871cf59e0e7c8bd18cabbcd3e02daa9">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。为了避免滥用，如果所需元素在矩阵中不存在，该函数会抛出一个异常。 如果你想要一个返回零的函数（对于不在矩阵的稀疏模式中的条目），请使用el()函数。 如果你要在所有元素上循环，可以考虑使用一个迭代器类来代替，因为它们更适合稀疏的矩阵结构。 </p>

</div>
</div>
<a id="ac96ad36bd86637f146fff43b3996536d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac96ad36bd86637f146fff43b3996536d">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上面那个相反，这个函数允许修改对象。 </p>

</div>
</div>
<a id="aa25229f70f1bfccd2437d587a000001e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25229f70f1bfccd2437d587a000001e">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数主要像operator()()，它返回矩阵条目的值（<em>i,j</em>）。唯一的区别是，如果这个条目不存在于稀疏模式中，那么就不会引发异常，而是返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，所以很容易写出与最优解相比很慢的算法。 如果你要在所有元素上循环，可以考虑使用一个迭代器类来代替，因为它们更适合稀疏的矩阵结构。 </p>

</div>
</div>
<a id="a49d9466d88f725141780a95c41e79951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d9466d88f725141780a95c41e79951">&#9670;&nbsp;</a></span>diag_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次方的，这个函数会抛出一个错误。 这个函数比operator()()快得多，因为对于二次矩阵来说，对角线条目可能是每行中第一个被存储的，因此访问时不需要搜索正确的列号。 </p>

</div>
</div>
<a id="a159957553e3a4ca34cee51fdfa4cafa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a159957553e3a4ca34cee51fdfa4cafa7">&#9670;&nbsp;</a></span>diag_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">number&amp; <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>和上面一样，但返回一个可写的引用。你确定你知道你在做什么吗？ </p>

</div>
</div>
<a id="a7706b5f721efc5ea1966f5a5cdaad0e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7706b5f721efc5ea1966f5a5cdaad0e6">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M*src</em>与<em>M</em>是这个矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockSparseMatrix。 源和目的不能是同一个向量。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a224a78133e7b655e3a2c26647097c2c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224a78133e7b655e3a2c26647097c2c7">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class OutVector , class InVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype">OutVector &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InVector &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>是这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 注意，虽然这个函数可以对所有提供迭代器类的向量进行操作，但它只对类型为 <a class="el" href="classVector.html">Vector</a> 的对象真正有效。 对于所有迭代元素或随机成员访问昂贵的类来说，这个函数并不高效。特别是，如果你想与BlockVector对象相乘，你应该考虑同时使用BlockSparseMatrix。 源和目的不能是同一个向量。 </p>

</div>
</div>
<a id="a56d106dfe8792db57f2d6e60bdfe63e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d106dfe8792db57f2d6e60bdfe63e1">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的法线的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 显然，对于这个操作来说，矩阵需要是二次的，而且为了使结果真正成为一个规范，它还需要是实数对称的或复数隐式的。 该矩阵和给定向量的底层模板类型应该都是实值或复值，但不是混合的，这样这个函数才有意义。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a03ded9134adf275ede256b92eefae8ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03ded9134adf275ede256b92eefae8ed">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a1a7074c2cc7fd4ed760d5bf06594cf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7074c2cc7fd4ed760d5bf06594cf12">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">somenumber <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入<code>dst</code>。残差向量的<em>l<sub>2</sub></em>准则被返回。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a38676dc8cd6d6c7b8aea3a335653a25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38676dc8cd6d6c7b8aea3a335653a25f">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法<code>C = A B</code>，或者，如果给出一个可选的矢量参数，则<code>C = A diag(V) B</code>，其中<code>diag(V)</code>定义了一个带有矢量项的对角矩阵。 这个函数假定调用矩阵 <code>A</code> 和参数 <code>B</code> 的大小兼容。默认情况下，输出矩阵 <code>C</code> 将被适当调整大小。 默认情况下，即如果可选的参数 <code>rebuild_sparsity_pattern</code> 是 <code>true</code>, ，矩阵C的稀疏模式将被改变，以确保由乘积 \(AB\) 产生的所有条目可以被存储在 \(C\) 中。这是一个昂贵的操作，如果有办法预先预测稀疏模式，你可能应该在以 <code>false</code> 为最后一个参数调用这个函数之前自己建立它。在这种情况下，疏密模式的重建被绕过了。 当把 <code>rebuild_sparsity_pattern</code> 设置为 <code>true</code> 时（即把它留在默认值），必须意识到作为第一个参数传递的矩阵 <code>C</code> 仍然需要用稀疏模式进行初始化（可以在创建稀疏矩阵对象时，或者通过 <a class="el" href="classSparseMatrix.html#afa7ae4d32bda6035661c9cccfe185597">SparseMatrix::reinit()</a> 函数）。这是因为我们可以在当前函数中创建一个稀疏模式，然后将 <code>C</code> 与之关联，但一旦当前函数结束，就没有办法将这个稀疏模式的所有权转移给任何人。因此，该函数要求 <code>C</code> 已经与一个稀疏模式对象相关联，然后该对象被重置为适合 <code>A</code> 和 <code>B</code>. 的乘积。 然而，作为其结果，还必须认识到 <code>C</code> 的稀疏模式被修改，这将使碰巧<em>also</em>使用该稀疏模式对象的<em>all other <a class="el" href="classSparseMatrix.html">SparseMatrix</a> objects</em>无效。 </p>

</div>
</div>
<a id="a21044730f1f38257cc0397accb4d05e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21044730f1f38257cc0397accb4d05e5">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename numberB , typename numberC &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberC &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; numberB &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classVector.html">Vector</a>&lt;&#160;number&#160;&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>rebuild_sparsity_pattern</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用<code>this</code>的转置执行矩阵-矩阵乘法，即<code>C = A<sup>T</sup> B</code>，或者，如果给出了可选的矢量参数，<code>C = A<sup>T</sup> diag(V) B</code>，其中<code>diag(V)</code>定义了一个带有矢量项的对角矩阵。 这个函数假定调用矩阵<code>A</code>和<code>B</code>的大小兼容。<code>C</code>的大小将在本函数中设置。 矩阵C的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在你使用这个函数之前要三思而后行。 有一个可选的标志<code>rebuild_sparsity_pattern</code>，可以用来绕过创建一个新的稀疏度模式，而使用存储在<code>C</code>中的稀疏度模式。在这种情况下，要确保它真的适合。默认情况下是重建稀疏度模式。 </p><dl class="section note"><dt>Note</dt><dd>重建稀疏度模式需要改变它。这意味着所有与该稀疏性模式相关的其他矩阵将有无效的条目。 </dd></dl>

</div>
</div>
<a id="aeb0010028e98a1e616d3ea1bed765f4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0010028e98a1e616d3ea1bed765f4e">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的 \(l_1\) 规范，即 \(|M|_1=\max_{\mathrm{all\ columns\ }j}\sum_{\mathrm{all\ rows\ } i} |M_{ij}|\) ，（最大列数之和）。 这是自然的矩阵准则，与向量的 \(l_1\) 准则兼容，即 \(|Mv|_1\leq |M|_1 |v|_1\) 。(参见Haemmerlin- Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a id="ae64627cdd2dc0d8c8991996c029ba9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64627cdd2dc0d8c8991996c029ba9ca">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的 \(l_\infty\) 准则，即 \(|M|_\infty=\max_{\mathrm{all\ rows\ }i}\sum_{\mathrm{all\ columns\ }j} |M_{ij}|\) , (行的最大和)。 这是自然的矩阵准则，与向量的 \(l_\infty\) 准则兼容，即 \(|Mv|_\infty \leq |M|_\infty |v|_\infty\) 。 (参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

</div>
</div>
<a id="ae403bf35656c6b5c075186b116e7f293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae403bf35656c6b5c075186b116e7f293">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#abf4466250db96cbf50504bc1473ffca9">real_type</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

</div>
</div>
<a id="a0b1f22866ffd7e47bfb32f62a1d3e711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b1f22866ffd7e47bfb32f62a1d3e711">&#9670;&nbsp;</a></span>precondition_Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>应用雅可比预处理，将<code>src</code>向量的每个元素乘以各自对角线元素的逆值，并将结果乘以松弛因子<code>omega</code>。 </p>

</div>
</div>
<a id="aa6f7ebdcc75ee730592c0bf23014405f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6f7ebdcc75ee730592c0bf23014405f">&#9670;&nbsp;</a></span>precondition_SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>pos_right_of_diagonal</em> = <code>std::vector&lt;&#160;std::size_t&#160;&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对<code>src</code>应用SSOR预处理，阻尼<code>omega</code>。 可选的参数<code>pos_right_of_diagonal</code>应该提供一个数组，其中每个条目指定全局非零点阵列中对角线的右边位置。 </p>

</div>
</div>
<a id="adc9ce0a2202ddc552f004523f3aef544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9ce0a2202ddc552f004523f3aef544">&#9670;&nbsp;</a></span>precondition_SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将SOR预处理矩阵应用于<code>src</code>。 </p>

</div>
</div>
<a id="a967052ec6d13489bc529bb11515f89ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967052ec6d13489bc529bb11515f89ea">&#9670;&nbsp;</a></span>precondition_TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::precondition_TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对<code>src</code>应用转置的SOR预处理矩阵。 </p>

</div>
</div>
<a id="a5439b4fc51d59a4cfa0f0829ee876763"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5439b4fc51d59a4cfa0f0829ee876763">&#9670;&nbsp;</a></span>SSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就地执行SSOR预处理。 应用预处理矩阵而不复制到第二个向量。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="a76ca15703f371cfa2b8281bb1eba0267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76ca15703f371cfa2b8281bb1eba0267">&#9670;&nbsp;</a></span>SOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就地执行SOR预处理。 <code>omega</code>是松弛参数。 </p>

</div>
</div>
<a id="ab8aa1eba02ee6d5180fbb8173b9967eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8aa1eba02ee6d5180fbb8173b9967eb">&#9670;&nbsp;</a></span>TSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就地进行转置SOR预处理。 <code>omega</code>是松弛参数。 </p>

</div>
</div>
<a id="a94530f37331ed997e91d9458a1303f79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94530f37331ed997e91d9458a1303f79">&#9670;&nbsp;</a></span>PSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::PSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就地进行移置的SOR预处理。 标准的SOR方法是按照<code>permutation</code>规定的顺序应用的，即首先是行<code>permutation[0]</code>，然后是<code>permutation[1]</code>，依此类推。出于效率的考虑，需要排列组合以及它的逆向排列。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="aa3514d4a24a63ce70fe7e9486ad1688a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3514d4a24a63ce70fe7e9486ad1688a">&#9670;&nbsp;</a></span>TPSOR()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TPSOR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>inverse_permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>就地进行转置的包络SOR预处理。 转置的SOR方法按照<code>permutation</code>规定的顺序应用，即首先是行<code>permutation[<a class="el" href="classSparseLUDecomposition.html#a71242d5c14a00bb6aba2c5af0c9065f1">m()</a>-1]</code>，然后是<code>permutation[<a class="el" href="classSparseLUDecomposition.html#a71242d5c14a00bb6aba2c5af0c9065f1">m()</a>-2]</code>，依此类推。出于效率的考虑，需要用到permutation以及它的逆向。 <code>omega</code>是放松参数。 </p>

</div>
</div>
<a id="aa039cc30461321e4f54dd54e67e8ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa039cc30461321e4f54dd54e67e8ca36">&#9670;&nbsp;</a></span>Jacobi_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Jacobi_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对<code>v</code>做一个雅可比步骤。 对<code>b</code>做一个直接的雅可比步骤，右手边<code>b</code>。这个函数需要一个辅助向量，它从GrowingVectorMemory中获取。 </p>

</div>
</div>
<a id="a72eaf0aedbda317c83cd6b3fe460d995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72eaf0aedbda317c83cd6b3fe460d995">&#9670;&nbsp;</a></span>SOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对<code>v</code>做一个SOR步骤。 对右手边的<code>b</code>直接执行SOR步骤。 </p>

</div>
</div>
<a id="a36852dfbd7e9623dc96301d73fa2cf22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36852dfbd7e9623dc96301d73fa2cf22">&#9670;&nbsp;</a></span>TSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::TSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对<code>v</code>做一个邻接的SOR步骤。 对<code>b</code>做一个直接的TSOR步骤，右手边<code>b</code>。 </p>

</div>
</div>
<a id="a2d92814be1b12c114a2e86f7c7c9410c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d92814be1b12c114a2e86f7c7c9410c">&#9670;&nbsp;</a></span>SSOR_step()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::SSOR_step </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>om</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对<code>v</code>做一个SSOR步骤。 通过在SOR之后执行TSOR，对右手边的<code>b</code>直接执行SSOR步骤。 </p>

</div>
</div>
<a id="a419e25c734b10802f9c7f59d652f84ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a419e25c734b10802f9c7f59d652f84ca">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向矩阵的第一个元素的迭代器。 注意这个类的一般文档中关于元素访问顺序的讨论。 </p>

</div>
</div>
<a id="ab0872bb70a86280328309c97c78bc39f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0872bb70a86280328309c97c78bc39f">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像上面的函数一样，但是对于非恒定矩阵。 </p>

</div>
</div>
<a id="a22cdd83806e88c53003d185ad639cd35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cdd83806e88c53003d185ad639cd35">&#9670;&nbsp;</a></span>begin() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向行 <code>r</code>. 第一个元素的迭代器 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器等于<code>end(r)</code>。在这种情况下，如果行 <code>r</code> 和以下任何一行都不包含任何非零条目，则返回的迭代器可能无法被解除引用。 </p>

</div>
</div>
<a id="abc32c2ee41aa5e02b5838ed9e3423919"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc32c2ee41aa5e02b5838ed9e3423919">&#9670;&nbsp;</a></span>begin() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像上面的函数一样，但对于非恒定矩阵。 </p>

</div>
</div>
<a id="a24c613fbc2273dd9f16c716b1d4dc29f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24c613fbc2273dd9f16c716b1d4dc29f">&#9670;&nbsp;</a></span>end() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个迭代器，指向这个矩阵的最后一个以上的元素。 </p>

</div>
</div>
<a id="a1aa99041df4c848c5b46180327c1e9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa99041df4c848c5b46180327c1e9b5">&#9670;&nbsp;</a></span>end() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像上面的函数一样，但对于非静态矩阵。 </p>

</div>
</div>
<a id="aac8d50d7700dbd8560af071e146979c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8d50d7700dbd8560af071e146979c0">&#9670;&nbsp;</a></span>end() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#a0ffd7b499914cd4964c3a8d0fd8b5672">const_iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个指向第 <code>r</code> 行最后一个元素的迭代器，如果 <code>r</code> 之后的行根本不包含任何条目，则指向整个稀疏模式的末端。 请注意，结束迭代器不一定是可被解读的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 </p>

</div>
</div>
<a id="ad5bd553a69c0374c72195d4eb0158696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bd553a69c0374c72195d4eb0158696">&#9670;&nbsp;</a></span>end() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparseMatrix.html#ac94776653684705604fea3dae0af35f4">iterator</a> <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classSparseMatrix.html#ac55a5d3fa1fbe7e280a0e3ce4c722d83">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>像上面的函数一样，但是对于非恒定矩阵。 </p>

</div>
</div>
<a id="aa84c2e29d3b520c53a9695b42b3941c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84c2e29d3b520c53a9695b42b3941c5">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>diagonal_first</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印矩阵到给定的流，使用格式&lt;tt&gt;(row,column) value，即每行打印矩阵的一个非零条目。如果<code>across</code>为真，则在单行上打印所有条目，使用格式row,column:value。 如果参数<code>diagonal_first</code>为真，则二次方矩阵的对角线元素在其行中首先打印，对应于内部存储方案。如果它是假的，一行中的元素将按升列顺序写入。 </p>

</div>
</div>
<a id="a6456ebe393c32b076eae0b5c9811e0c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6456ebe393c32b076eae0b5c9811e0c8">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>以通常的格式打印矩阵，即作为矩阵，而不是作为非零元素的列表。为了提高可读性，不在矩阵中的元素显示为空白，而明确设置为零的矩阵元素则显示为空白。 参数允许对输出格式进行灵活设置。 <code>precision</code>和<code>scientific</code>用于确定数字格式，其中<code>scientific = false</code>表示固定点符号。 <code>width</code>的一个零条目使函数计算出一个宽度，但如果输出粗略的话，可以将其改为一个正值。 此外，还可以指定一个空值的字符。 最后，整个矩阵可以与一个共同的分母相乘，以产生更可读的输出，甚至是整数。 </p><dl class="section attention"><dt>Attention</dt><dd>如果应用于一个大的矩阵，这个函数可能会产生<b>large</b>量的输出! </dd></dl>

</div>
</div>
<a id="a737f5df58f2bf6ab275ed382ed725abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a737f5df58f2bf6ab275ed382ed725abb">&#9670;&nbsp;</a></span>print_pattern()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_pattern </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印矩阵的实际模式。对于每个绝对值大于阈值的条目，打印一个'*'，对于每个较小的数值打印一个':'，对于每个未分配的条目打印一个'.'。 </p>

</div>
</div>
<a id="a3141075e3ad6362fce005d2f1c8da699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3141075e3ad6362fce005d2f1c8da699">&#9670;&nbsp;</a></span>print_as_numpy_arrays()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::print_as_numpy_arrays </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>9</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵打印到输出流 <code>out</code> 中，其格式可以被 numpy::readtxt(). 读取 要在python中加载矩阵，只需做<code> [data, row, column] = numpy.loadtxt('my_matrix.txt') sparse_matrix = scipy.sparse.csr_matrix((data, (row, column)) </code> </p>

</div>
</div>
<a id="a8b32b99a054482f06fc026248c27bb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b32b99a054482f06fc026248c27bb74">&#9670;&nbsp;</a></span>block_write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::block_write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>把这个对象的数据全部写到一个文件中。这是以二进制模式进行的，所以输出的数据既不能被人类阅读，也不能（可能）被其他使用不同操作系统的数字格式的计算机阅读。 这个函数的目的是，如果你的内存不足，想在不同的程序之间进行交流，或者允许对象在程序的不同运行中持续存在，你可以把矩阵和稀疏模式换出来。 </p>

</div>
</div>
<a id="a9b670368c98d6392ff8c9284db0622b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b670368c98d6392ff8c9284db0622b2">&#9670;&nbsp;</a></span>block_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::block_read </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从文件中读取先前由block_write()写入的数据。 这是用上述函数的逆运算来完成的，所以它的速度相当快，因为除了前面的几个数字，比特流是不被解释的。 在这个操作中，对象被调整了大小，所有以前的内容都会丢失。然而，请注意，没有对新数据和底层的SparsityPattern对象是否适合在一起进行检查。你有责任确保稀疏度模式和要读取的数据是匹配的。 一个原始形式的错误检查会被执行，它将识别最直白的尝试，即把一些数据解释为一个矩阵，以比特方式存储到一个实际上不是这样创建的文件中，但不是更多。 </p>

</div>
</div>
<a id="a1debf998b61291d913dfac4c8a22eaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1debf998b61291d913dfac4c8a22eaa7">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于某些矩阵存储格式，特别是PETSc分布式块矩阵，对单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。 BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。 这个函数确保矩阵处于一个允许添加元素的状态；如果它之前已经处于这个状态，那么这个函数就不会做任何事情。 </p>

</div>
</div>
<a id="a9f68a9f93813ca167dc9f39624be2f5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f68a9f93813ca167dc9f39624be2f5b">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classSparseMatrix.html">SparseMatrix</a>&lt; number &gt;::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。 </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a84c2deaa9405117039d3cdbfbe35943b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c2deaa9405117039d3cdbfbe35943b">&#9670;&nbsp;</a></span>strengthen_diagonal</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::strengthen_diagonal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>默认的强化值，由get_strengthen_diagonal()返回。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__decomposition_8h_source.html#l00273">273</a> of file <a class="el" href="sparse__decomposition_8h_source.html">sparse_decomposition.h</a>.</p>

</div>
</div>
<a id="aafc84f4c5e650a920c1627b9d3a7be5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafc84f4c5e650a920c1627b9d3a7be5f">&#9670;&nbsp;</a></span>prebuilt_lower_bound</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;const <a class="el" href="classSparseLUDecomposition.html#a7655ee8d8b9b781fa1e559c34b1f2230">size_type</a> *&gt; <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::prebuilt_lower_bound</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于底层SparsityPattern中的每一行，这个数组包含一个指向该行的第一个对角线条目的指针。在调用prebuild_lower_bound()后变得可用。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__decomposition_8h_source.html#l00279">279</a> of file <a class="el" href="sparse__decomposition_8h_source.html">sparse_decomposition.h</a>.</p>

</div>
</div>
<a id="adc2493b2e002e0a905a28321ab86c7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2493b2e002e0a905a28321ab86c7a3">&#9670;&nbsp;</a></span>own_sparsity</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classSparsityPattern.html">SparsityPattern</a>* <a class="el" href="classSparseLUDecomposition.html">SparseLUDecomposition</a>&lt; number &gt;::own_sparsity</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一般来说，这个指针是零，除了没有给这个类提供SparsityPattern的情况。然后，一个SparsityPattern被创建，并被传递给SparseMatrix基类。 尽管如此，SparseLUDecomposition需要保留这个稀疏度的所有权。它保留这个指针，以便在销毁时删除这个稀疏度。 </p>

<p class="definition">Definition at line <a class="el" href="sparse__decomposition_8h_source.html#l00294">294</a> of file <a class="el" href="sparse__decomposition_8h_source.html">sparse_decomposition.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="sparse__decomposition_8h_source.html">sparse_decomposition.h</a></li>
<li>source/lac/<a class="el" href="sparse__decomposition_8cc_source.html">sparse_decomposition.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
