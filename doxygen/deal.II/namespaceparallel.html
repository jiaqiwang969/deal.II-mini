<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceparallel.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: parallel Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">parallel Namespace Reference<div class="ingroups"><a class="el" href="group__Parallel.html">Parallel computing</a> &raquo; <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a> &#124; <a class="el" href="group__Quadrature.html">Quadrature formulas</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceparallel_1_1distributed"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceparallel_1_1distributed.html">distributed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceparallel_1_1fullydistributed"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceparallel_1_1fullydistributed.html">fullydistributed</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceparallel_1_1internal"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceparallel_1_1internal.html">internal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceparallel_1_1shared"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceparallel_1_1shared.html">shared</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1CellWeights.html">CellWeights</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1DistributedTriangulationBase.html">DistributedTriangulationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structparallel_1_1ParallelForInteger.html">ParallelForInteger</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classparallel_1_1TriangulationBase.html">TriangulationBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acff5a80eecf505943d8abbec0658ae93"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:acff5a80eecf505943d8abbec0658ae93"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel.html#acff5a80eecf505943d8abbec0658ae93">transform</a> (const InputIterator &amp;begin_in, const InputIterator &amp;end_in, OutputIterator out, const Predicate &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> grainsize)</td></tr>
<tr class="separator:acff5a80eecf505943d8abbec0658ae93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9695a01ce1bb5fcd169df92eb8b5e7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:a6e9695a01ce1bb5fcd169df92eb8b5e7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel.html#a6e9695a01ce1bb5fcd169df92eb8b5e7">transform</a> (const InputIterator1 &amp;begin_in1, const InputIterator1 &amp;end_in1, InputIterator2 in2, OutputIterator out, const Predicate &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> grainsize)</td></tr>
<tr class="separator:a6e9695a01ce1bb5fcd169df92eb8b5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4af40f92a2f96a799632e3500e768f9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:aa4af40f92a2f96a799632e3500e768f9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel.html#aa4af40f92a2f96a799632e3500e768f9">transform</a> (const InputIterator1 &amp;begin_in1, const InputIterator1 &amp;end_in1, InputIterator2 in2, InputIterator3 in3, OutputIterator out, const Predicate &amp;predicate, const unsigned <a class="el" href="classint.html">int</a> grainsize)</td></tr>
<tr class="separator:aa4af40f92a2f96a799632e3500e768f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa860d510323b29ede22a7f69f5dc41ad"><td class="memTemplParams" colspan="2">template&lt;typename RangeType , typename Function &gt; </td></tr>
<tr class="memitem:aa860d510323b29ede22a7f69f5dc41ad"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel.html#aa860d510323b29ede22a7f69f5dc41ad">apply_to_subranges</a> (const RangeType &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; RangeType &gt;::type &amp;end, const <a class="el" href="classFunction.html">Function</a> &amp;f, const unsigned <a class="el" href="classint.html">int</a> grainsize)</td></tr>
<tr class="separator:aa860d510323b29ede22a7f69f5dc41ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ffe536c55823d2dd1f60d12d2ca6afe"><td class="memTemplParams" colspan="2">template&lt;typename ResultType , typename RangeType , typename Function &gt; </td></tr>
<tr class="memitem:a7ffe536c55823d2dd1f60d12d2ca6afe"><td class="memTemplItemLeft" align="right" valign="top">ResultType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceparallel.html#a7ffe536c55823d2dd1f60d12d2ca6afe">accumulate_from_subranges</a> (const <a class="el" href="classFunction.html">Function</a> &amp;f, const RangeType &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; RangeType &gt;::type &amp;end, const unsigned <a class="el" href="classint.html">int</a> grainsize)</td></tr>
<tr class="separator:a7ffe536c55823d2dd1f60d12d2ca6afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A namespace in which we define classes and algorithms that deal with running in parallel on shared memory machines when deal.II is configured to use multiple threads (see <a class="el" href="group__threads.html">Parallel computing with multiple processors accessing shared memory</a>), as well as running things in parallel on distributed memory machines (see <a class="el" href="group__distributed.html">Parallel computing with multiple processors using distributed memory</a>).</p>
<dl class="section author"><dt>Author</dt><dd>Wolfgang Bangerth, 2008, 2009 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acff5a80eecf505943d8abbec0658ae93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff5a80eecf505943d8abbec0658ae93">&#9670;&nbsp;</a></span>transform() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void parallel::transform </td>
          <td>(</td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>begin_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator &amp;&#160;</td>
          <td class="paramname"><em>end_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>grainsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An algorithm that performs the action <code>*out++ = predicate(*in++)</code> where the <code>in</code> iterator ranges over the given input range.</p>
<p>This algorithm does pretty much what std::transform does. The difference is that the function can run in parallel when deal.II is configured to use multiple threads.</p>
<p>If running in parallel, the iterator range is split into several chunks that are each packaged up as a task and given to the Threading Building Blocks scheduler to work on as compute resources are available. The function returns once all chunks have been worked on. The last argument denotes the minimum number of elements of the iterator range per task; the number must be large enough to amortize the startup cost of new tasks, and small enough to ensure that tasks can be reasonably load balanced.</p>
<p>For a discussion of the kind of problems to which this function is applicable, see the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html#l00213">213</a> of file <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html">parallel.h</a>.</p>

</div>
</div>
<a id="a6e9695a01ce1bb5fcd169df92eb8b5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9695a01ce1bb5fcd169df92eb8b5e7">&#9670;&nbsp;</a></span>transform() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void parallel::transform </td>
          <td>(</td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin_in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>end_in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>grainsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An algorithm that performs the action <code>*out++ = predicate(*in1++, *in2++)</code> where the <code>in1</code> iterator ranges over the given input range, using the parallel for operator of tbb.</p>
<p>This algorithm does pretty much what std::transform does. The difference is that the function can run in parallel when deal.II is configured to use multiple threads.</p>
<p>If running in parallel, the iterator range is split into several chunks that are each packaged up as a task and given to the Threading Building Blocks scheduler to work on as compute resources are available. The function returns once all chunks have been worked on. The last argument denotes the minimum number of elements of the iterator range per task; the number must be large enough to amortize the startup cost of new tasks, and small enough to ensure that tasks can be reasonably load balanced.</p>
<p>For a discussion of the kind of problems to which this function is applicable, see the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html#l00268">268</a> of file <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html">parallel.h</a>.</p>

</div>
</div>
<a id="aa4af40f92a2f96a799632e3500e768f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4af40f92a2f96a799632e3500e768f9">&#9670;&nbsp;</a></span>transform() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InputIterator1 , typename InputIterator2 , typename InputIterator3 , typename OutputIterator , typename Predicate &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void parallel::transform </td>
          <td>(</td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>begin_in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputIterator1 &amp;&#160;</td>
          <td class="paramname"><em>end_in1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator2&#160;</td>
          <td class="paramname"><em>in2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">InputIterator3&#160;</td>
          <td class="paramname"><em>in3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Predicate &amp;&#160;</td>
          <td class="paramname"><em>predicate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>grainsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An algorithm that performs the action <code>*out++ = predicate(*in1++, *in2++, *in3++)</code> where the <code>in1</code> iterator ranges over the given input range.</p>
<p>This algorithm does pretty much what std::transform does. The difference is that the function can run in parallel when deal.II is configured to use multiple threads.</p>
<p>If running in parallel, the iterator range is split into several chunks that are each packaged up as a task and given to the Threading Building Blocks scheduler to work on as compute resources are available. The function returns once all chunks have been worked on. The last argument denotes the minimum number of elements of the iterator range per task; the number must be large enough to amortize the startup cost of new tasks, and small enough to ensure that tasks can be reasonably load balanced.</p>
<p>For a discussion of the kind of problems to which this function is applicable, see the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html#l00326">326</a> of file <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html">parallel.h</a>.</p>

</div>
</div>
<a id="aa860d510323b29ede22a7f69f5dc41ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa860d510323b29ede22a7f69f5dc41ad">&#9670;&nbsp;</a></span>apply_to_subranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RangeType , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void parallel::apply_to_subranges </td>
          <td>(</td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; RangeType &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>grainsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function applies the given function argument <code>f</code> to all elements in the range <code>[begin,end)</code> and may do so in parallel. An example of its use is given in step-69.</p>
<p>However, in many cases it is not efficient to call a function on each element, so this function calls the given function object on sub-ranges. In other words: if the given range <code>[begin,end)</code> is smaller than grainsize or if multithreading is not enabled, then we call <code>f(begin,end)</code>; otherwise, we may execute, possibly in parallel, a sequence of calls <code>f(b,e)</code> where <code>[b,e)</code> are subintervals of <code>[begin,end)</code> and the collection of calls we do to <code>f(.,.)</code> will happen on disjoint subintervals that collectively cover the original interval <code>[begin,end)</code>.</p>
<p>Oftentimes, the called function will of course have to get additional information, such as the object to work on for a given value of the iterator argument. This can be achieved by <em>binding</em> certain arguments. For example, here is an implementation of a matrix-vector multiplication \(y=Ax\) for a full matrix \(A\) and vectors \(x,y\): </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> matrix_vector_product (<span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix</a> &amp;<a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>,</div><div class="line">                            <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a>     &amp;x,</div><div class="line">                            <a class="code" href="classVector.html">Vector</a>           &amp;y)</div><div class="line">{</div><div class="line">  <a class="code" href="namespaceparallel.html#aa860d510323b29ede22a7f69f5dc41ad">parallel::apply_to_subranges</a></div><div class="line">     (0, A.n_rows(),</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> begin_row,</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end_row)</div><div class="line">      {</div><div class="line">        mat_vec_on_subranges(begin_row, end_row, A, x, y);</div><div class="line">      },</div><div class="line">      50);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> mat_vec_on_subranges (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> begin_row,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end_row,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix</a> &amp;A,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a>     &amp;x,</div><div class="line">                           <a class="code" href="classVector.html">Vector</a>           &amp;y)</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row=begin_row; row!=end_row; ++row)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col=0; col&lt;x.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++col)</div><div class="line">      y(row) += <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(row,col) * x(col);</div><div class="line">}</div></div><!-- fragment --><p>Note how we use the lambda function to convert <code>mat_vec_on_subranges</code> from a function that takes 5 arguments to one taking 2 by binding the remaining arguments. The resulting function object requires only two arguments, <code>begin_row</code> and <code>end_row</code>, with all other arguments fixed.</p>
<p>The code, if in single-thread mode, will call <code>mat_vec_on_subranges</code> on the entire range <code>[0,n_rows)</code> exactly once. In multi-threaded mode, however, it may be called multiple times on subranges of this interval, possibly allowing more than one CPU core to take care of part of the work.</p>
<p>The <code>grainsize</code> argument (50 in the example above) makes sure that subranges do not become too small, to avoid spending more time on scheduling subranges to CPU resources than on doing actual work.</p>
<p>For a discussion of the kind of problems to which this function is applicable, see also the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html#l00447">447</a> of file <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html">parallel.h</a>.</p>

</div>
</div>
<a id="a7ffe536c55823d2dd1f60d12d2ca6afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ffe536c55823d2dd1f60d12d2ca6afe">&#9670;&nbsp;</a></span>accumulate_from_subranges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType , typename RangeType , typename Function &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ResultType parallel::accumulate_from_subranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const RangeType &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; RangeType &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>grainsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function works a lot like the <a class="el" href="namespaceparallel.html#aa860d510323b29ede22a7f69f5dc41ad">apply_to_subranges()</a>, but it allows to accumulate numerical results computed on each subrange into one number. The type of this number is given by the ResultType template argument that needs to be explicitly specified.</p>
<p>An example of use of this function is to compute the value of the expression \(x^T A x\) for a square matrix \(A\) and a vector \(x\). The sum over rows can be parallelized and the whole code might look like this: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> matrix_norm (<span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix</a> &amp;A,</div><div class="line">                  <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a>     &amp;x)</div><div class="line">{</div><div class="line">  <span class="keywordflow">return</span></div><div class="line">   <a class="code" href="vectorization_8h.html#a303f564e3c189251976da401ee2e44fa">std::sqrt</a></div><div class="line">    (parallel::accumulate_from_subranges&lt;double&gt;</div><div class="line">     (0, A.n_rows(),</div><div class="line">      [&amp;](<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> begin_row,</div><div class="line">          <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end_row)</div><div class="line">      {</div><div class="line">        mat_vec_on_subranges(begin_row, end_row, A, x, y);</div><div class="line">      },</div><div class="line">      50);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">double</span></div><div class="line">mat_norm_sqr_on_subranges (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> begin_row,</div><div class="line">                           <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> end_row,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classFullMatrix.html">FullMatrix</a> &amp;A,</div><div class="line">                           <span class="keyword">const</span> <a class="code" href="classVector.html">Vector</a>     &amp;x)</div><div class="line">{</div><div class="line">  <span class="keywordtype">double</span> norm_sqr = 0;</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> row=begin_row; row!=end_row; ++row)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> col=0; col&lt;x.<a class="code" href="classVector.html#a81dcfa5c77bdd426603386c0844149ae">size</a>(); ++col)</div><div class="line">      norm_sqr += x(row) * <a class="code" href="namespaceLAPACKSupport.html#a40707d49114d54318c823f3b750e89a4">A</a>(row,col) * x(col);</div><div class="line">  <span class="keywordflow">return</span> norm_sqr;</div><div class="line">}</div></div><!-- fragment --><p>Here, <code>mat_norm_sqr_on_subranges</code> is called on the entire range <code>[0,A.n_rows())</code> if this range is less than the minimum grainsize (above chosen as 50) or if deal.II is configured to not use multithreading. Otherwise, it may be called on subsets of the given range, with results from the individual subranges accumulated internally.</p>
<dl class="section warning"><dt>Warning</dt><dd>If ResultType is a floating point type, then accumulation is not an associative operation. In other words, if the given function object is called three times on three subranges, returning values \(a,b,c\), then the returned result of this function is \((a+b)+c\). However, depending on how the three sub-tasks are distributed on available CPU resources, the result may also be \((a+c)+b\) or any other permutation; because floating point addition is not associative (as opposed, of course, to addition of real numbers), the result of invoking this function several times may differ on the order of round-off.</dd></dl>
<p>For a discussion of the kind of problems to which this function is applicable, see also the <a class="el" href="group__threads.html">Parallel computing with multiple processors</a> module. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html#l00682">682</a> of file <a class="el" href="include_2deal_8II_2base_2parallel_8h_source.html">parallel.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
