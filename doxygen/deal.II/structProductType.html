<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/structProductType.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: ProductType&lt; T, U &gt; Struct Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#related">Related Functions</a> &#124;
<a href="structProductType-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ProductType&lt; T, U &gt; Struct Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="template__constraints_8h_source.html">deal.II/base/template_constraints.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abc22b687b441f59f167958c9e6d45acc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> = typename <a class="el" href="structinternal_1_1ProductTypeImpl.html">internal::ProductTypeImpl</a>&lt; typename std::decay&lt; T &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>, typename std::decay&lt; U &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a></td></tr>
<tr class="separator:abc22b687b441f59f167958c9e6d45acc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="related"></a>
Related Functions</h2></td></tr>
<tr><td class="ititle" colspan="2"><p>(Note that these are not member functions.) </p>
</td></tr>
<tr class="memitem:a285c79b547d28de482e34d02cee71bb2"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a285c79b547d28de482e34d02cee71bb2"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#a285c79b547d28de482e34d02cee71bb2">operator*</a> (const std::complex&lt; T &gt; &amp;left, const std::complex&lt; U &gt; &amp;right)</td></tr>
<tr class="separator:a285c79b547d28de482e34d02cee71bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f70eb5194c9ccd5d61863e8f5210891"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7f70eb5194c9ccd5d61863e8f5210891"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#a7f70eb5194c9ccd5d61863e8f5210891">operator/</a> (const std::complex&lt; T &gt; &amp;left, const std::complex&lt; U &gt; &amp;right)</td></tr>
<tr class="separator:a7f70eb5194c9ccd5d61863e8f5210891"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa329eeb64bffa1dce8cbbe4f320c14cc"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:aa329eeb64bffa1dce8cbbe4f320c14cc"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, U &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#aa329eeb64bffa1dce8cbbe4f320c14cc">operator*</a> (const std::complex&lt; T &gt; &amp;left, const U &amp;right)</td></tr>
<tr class="separator:aa329eeb64bffa1dce8cbbe4f320c14cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05126e195996c09abcdd8e869b2c586d"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a05126e195996c09abcdd8e869b2c586d"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, U &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#a05126e195996c09abcdd8e869b2c586d">operator/</a> (const std::complex&lt; T &gt; &amp;left, const U &amp;right)</td></tr>
<tr class="separator:a05126e195996c09abcdd8e869b2c586d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c2a2f60c936423f25eaba4c916ea630"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:a7c2a2f60c936423f25eaba4c916ea630"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#a7c2a2f60c936423f25eaba4c916ea630">operator*</a> (const T &amp;left, const std::complex&lt; U &gt; &amp;right)</td></tr>
<tr class="separator:a7c2a2f60c936423f25eaba4c916ea630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc8f5c9788bd0057843ff8b532fe645a"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U &gt; </td></tr>
<tr class="memitem:acc8f5c9788bd0057843ff8b532fe645a"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structProductType.html#acc8f5c9788bd0057843ff8b532fe645a">operator/</a> (const T &amp;left, const std::complex&lt; U &gt; &amp;right)</td></tr>
<tr class="separator:acc8f5c9788bd0057843ff8b532fe645a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T, typename U&gt;<br />
struct ProductType&lt; T, U &gt;</h3>

<p>A class with a local alias that represents the type that results from the product of two variables of type <code>T</code> and <code>U</code>. In other words, we would like to infer the type of the <code>product</code> variable in code like this: </p><div class="fragment"><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a8cac1e477eff052db622c8a9a9426ea3">T</a> t;</div><div class="line"><a class="code" href="namespaceLAPACKSupport.html#a3e681d2d74dcf90f6556706d66f81a0d">U</a> u;</div><div class="line"><span class="keyword">auto</span> product = t*u;</div></div><!-- fragment --><p> The local alias of this structure represents the type the variable <code>product</code> would have.</p>
<h3>Where is this useful</h3>
<p>The purpose of this class is principally to represent the type one needs to use to represent the values or gradients of finite element fields at quadrature points. For example, assume you are storing the values \(U_j\) of unknowns in a Vector&lt;float&gt;, then evaluating \(u_h(x_q) = \sum_j U_j \varphi_j(x_q)\) at quadrature points results in values \(u_h(x_q)\) that need to be stored as <code>double</code> variables because the \(U_j\) are <code>float</code> values and the \(\varphi_j(x_q)\) are computed as <code>double</code> values, and the product are then <code>double</code> values. On the other hand, if you store your unknowns \(U_j\) as <code>std::complex&lt;double&gt;</code> values and you try to evaluate \(\nabla u_h(x_q) = \sum_j U_j \nabla\varphi_j(x_q)\) at quadrature points, then the gradients \(\nabla u_h(x_q)\) need to be stored as objects of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim,std::complex&lt;double&gt;&gt;</code> because that's what you get when you multiply a complex number by a <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> (the type used to represent the gradient of shape functions of scalar finite elements).</p>
<p>Likewise, if you are using a vector valued element (with dim components) and the \(U_j\) are stored as <code>double</code> variables, then \(u_h(x_q) = \sum_j U_j \varphi_j(x_q)\) needs to have type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code> (because the shape functions have type <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,dim&gt;</code>). Finally, if you store the \(U_j\) as objects of type <code>std::complex&lt;double&gt;</code> and you have a vector valued element, then the gradients \(\nabla u_h(x_q) = \sum_j U_j \nabla\varphi_j(x_q)\) will result in objects of type <code><a class="el" href="classTensor.html">Tensor</a>&lt;2,dim,std::complex&lt;double&gt; &gt;</code>.</p>
<p>In all of these cases, this type is used to identify which type needs to be used for the result of computing the product of unknowns and the values, gradients, or other properties of shape functions. </p>

<p class="definition">Definition at line <a class="el" href="template__constraints_8h_source.html#l00319">319</a> of file <a class="el" href="template__constraints_8h_source.html">template_constraints.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="abc22b687b441f59f167958c9e6d45acc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc22b687b441f59f167958c9e6d45acc">&#9670;&nbsp;</a></span>type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T, typename U&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structProductType.html">ProductType</a>&lt; T, U &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> =  typename <a class="el" href="structinternal_1_1ProductTypeImpl.html">internal::ProductTypeImpl</a>&lt;typename std::decay&lt;T&gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>, typename std::decay&lt;U&gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a>&gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="template__constraints_8h_source.html#l00323">323</a> of file <a class="el" href="template__constraints_8h_source.html">template_constraints.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a285c79b547d28de482e34d02cee71bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285c79b547d28de482e34d02cee71bb2">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator*</code> that operates on mixed complex floating point types. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00043">43</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="a7f70eb5194c9ccd5d61863e8f5210891"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f70eb5194c9ccd5d61863e8f5210891">&#9670;&nbsp;</a></span>operator/() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator/</code> that operates on mixed complex floating point types. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00061">61</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="aa329eeb64bffa1dce8cbbe4f320c14cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa329eeb64bffa1dce8cbbe4f320c14cc">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, U &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator*</code> for a scalar multiplication of a complex floating point type with a different real floating point type. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00080">80</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="a05126e195996c09abcdd8e869b2c586d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05126e195996c09abcdd8e869b2c586d">&#9670;&nbsp;</a></span>operator/() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; std::complex&lt; T &gt;, U &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator/</code> for a scalar division of a complex floating point type with a different real floating point type. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00098">98</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="a7c2a2f60c936423f25eaba4c916ea630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2a2f60c936423f25eaba4c916ea630">&#9670;&nbsp;</a></span>operator*() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> operator* </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator*</code> for a scalar multiplication of a real floating point type with a different complex floating point type. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00117">117</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<a id="acc8f5c9788bd0057843ff8b532fe645a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc8f5c9788bd0057843ff8b532fe645a">&#9670;&nbsp;</a></span>operator/() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if&lt; std::is_floating_point&lt; T &gt;::value &amp;&amp;std::is_floating_point&lt; U &gt;::value, typename <a class="el" href="structProductType.html">ProductType</a>&lt; T, std::complex&lt; U &gt; &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> &gt;::<a class="el" href="structProductType.html#abc22b687b441f59f167958c9e6d45acc">type</a> operator/ </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::complex&lt; U &gt; &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provide an <code>operator/</code> for a scalar division of a real floating point type with a different complex floating point type. Annoyingly, the standard library does not provide such an operator... </p>

<p class="definition">Definition at line <a class="el" href="complex__overloads_8h_source.html#l00135">135</a> of file <a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following files:<ul>
<li>include/deal.II/base/<a class="el" href="template__constraints_8h_source.html">template_constraints.h</a></li>
<li>include/deal.II/base/<a class="el" href="complex__overloads_8h_source.html">complex_overloads.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
