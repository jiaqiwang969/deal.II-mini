<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/group__MeshWorker.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: The MeshWorker interface</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">The MeshWorker interface<div class="ingroups"><a class="el" href="group__Integrators.html">Integrators</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<div class="dynheader">
Collaboration diagram for The MeshWorker interface:</div>
<div class="dyncontent">
<center><table><tr><td><div class="center"><iframe scrolling="no" frameborder="0" src="group__MeshWorker.svg" width="394" height="39"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
</td></tr></table></center>
</div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceMeshWorker"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker.html">MeshWorker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespaceMeshWorker_1_1Assembler"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceMeshWorker_1_1Assembler.html">MeshWorker::Assembler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1ResidualLocalBlocksToGlobalBlocks.html">MeshWorker::Assembler::ResidualLocalBlocksToGlobalBlocks&lt; VectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1MatrixLocalBlocksToGlobalBlocks.html">MeshWorker::Assembler::MatrixLocalBlocksToGlobalBlocks&lt; MatrixType, number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1MGMatrixLocalBlocksToGlobalBlocks.html">MeshWorker::Assembler::MGMatrixLocalBlocksToGlobalBlocks&lt; MatrixType, number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1DoFInfo.html">MeshWorker::DoFInfo&lt; dim, spacedim, number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1DoFInfoBox.html">MeshWorker::DoFInfoBox&lt; dim, DOFINFO &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1Functional.html">MeshWorker::Assembler::Functional&lt; number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1CellsAndFaces.html">MeshWorker::Assembler::CellsAndFaces&lt; number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1IntegrationInfo.html">MeshWorker::IntegrationInfo&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">MeshWorker::IntegrationInfoBox&lt; dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LocalIntegrator.html">MeshWorker::LocalIntegrator&lt; dim, spacedim, number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1LocalResults.html">MeshWorker::LocalResults&lt; number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1ResidualSimple.html">MeshWorker::Assembler::ResidualSimple&lt; VectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1MatrixSimple.html">MeshWorker::Assembler::MatrixSimple&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1MGMatrixSimple.html">MeshWorker::Assembler::MGMatrixSimple&lt; MatrixType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1Assembler_1_1SystemSimple.html">MeshWorker::Assembler::SystemSimple&lt; MatrixType, VectorType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorSelector.html">MeshWorker::VectorSelector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorDataBase.html">MeshWorker::VectorDataBase&lt; dim, spacedim, Number &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1VectorData.html">MeshWorker::VectorData&lt; VectorType, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classMeshWorker_1_1MGVectorData.html">MeshWorker::MGVectorData&lt; VectorType, dim, spacedim &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memTemplParams" colspan="2">template&lt;class INFOBOX , class DOFINFO , int dim, int spacedim, class ITERATOR &gt; </td></tr>
<tr class="memitem:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">MeshWorker::cell_action</a> (ITERATOR cell, <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a>&lt; dim, DOFINFO &gt; &amp;dof_info, INFOBOX &amp;info, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;loop_control)</td></tr>
<tr class="separator:gaf5a59dde8686a651b12d040cc5afdf9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class DOFINFO , class INFOBOX , class ASSEMBLER , class ITERATOR &gt; </td></tr>
<tr class="memitem:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">MeshWorker::loop</a> (ITERATOR begin, typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::type end, DOFINFO &amp;dinfo, INFOBOX &amp;info, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;cell_worker, const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;boundary_worker, const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;face_worker, ASSEMBLER &amp;assembler, const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;lctrl=<a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>())</td></tr>
<tr class="separator:gad10f528ab87f39fbb0531d24f238b2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memTemplParams" colspan="2">template&lt;int dim, int spacedim, class ITERATOR , class ASSEMBLER &gt; </td></tr>
<tr class="memitem:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga93cfb35f7969ce8f0be7628255dfe7fb">MeshWorker::integration_loop</a> (ITERATOR begin, typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::type end, <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a>&lt; dim, spacedim &gt; &amp;dof_info, <a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a>&lt; dim, spacedim &gt; &amp;box, const <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a>&lt; dim, spacedim &gt; &amp;integrator, ASSEMBLER &amp;assembler, const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;lctrl=<a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>())</td></tr>
<tr class="separator:ga93cfb35f7969ce8f0be7628255dfe7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a> (const CellIteratorType &amp;begin, const CellIteratorType &amp;end, const <a class="el" href="namespaceMeshWorker.html#aac43ce31dc7c260ded0754ed6c87645d">CellWorkerFunctionType</a> &amp;cell_worker, const CopierType &amp;copier, const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, const <a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a> &amp;boundary_worker=<a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a>(), const <a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a> &amp;face_worker=<a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a>(), const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ga76ec61fbd188fb320fe8ca166a79b322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gae1cf14f6f8ff8f5e1f168c19ad4979b9">MeshWorker::mesh_loop</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt; iterator_range, const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;cell_worker, const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;copier, const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;boundary_worker=std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;(), const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;face_worker=std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;(), const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:gae1cf14f6f8ff8f5e1f168c19ad4979b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass &gt; </td></tr>
<tr class="memitem:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#gab233c65f7c758c094edbf9a0b5687d5e">MeshWorker::mesh_loop</a> (const CellIteratorType &amp;begin, const typename <a class="el" href="structidentity.html">identity</a>&lt; CellIteratorType &gt;::type &amp;end, MainClass &amp;main_class, void(MainClass::*cell_worker)(const CellIteratorType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), void(MainClass::*copier)(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, void(MainClass::*boundary_worker)(const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, void(MainClass::*face_worker)(const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:gab233c65f7c758c094edbf9a0b5687d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memTemplParams" colspan="2">template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </td></tr>
<tr class="memitem:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__MeshWorker.html#ga47cf9870f0e4e1952e77d7c77a560998">MeshWorker::mesh_loop</a> (<a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt; iterator_range, MainClass &amp;main_class, void(MainClass::*cell_worker)(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), void(MainClass::*copier)(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;), const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;sample_scratch_data, const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;sample_copy_data, const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a> flags=<a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>, void(MainClass::*boundary_worker)(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, void(MainClass::*face_worker)(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)=nullptr, const unsigned <a class="el" href="classint.html">int</a> queue_length=2 *<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>(), const unsigned <a class="el" href="classint.html">int</a> chunk_size=8)</td></tr>
<tr class="separator:ga47cf9870f0e4e1952e77d7c77a560998"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>A collection of classes and functions simplifying the coding of loops over all cells and faces. All classes and functions of this module are in the <a class="el" href="namespaceMeshWorker.html">MeshWorker</a> namespace, which also contains documentation on the usage. </p>
<h2 class="groupheader">Function Documentation</h2>
<a id="gaf5a59dde8686a651b12d040cc5afdf9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf5a59dde8686a651b12d040cc5afdf9a">&#9670;&nbsp;</a></span>cell_action()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class INFOBOX , class DOFINFO , int dim, int spacedim, class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::cell_action </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>cell</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a>&lt; dim, DOFINFO &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INFOBOX &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;&#160;</td>
          <td class="paramname"><em>loop_control</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function called by <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> to perform the required actions on a cell and its faces. The three functions <code>cell_worker</code>, <code>boundary_worker</code> and <code>face_worker</code> are the same ones handed to <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a>. While there we only run the loop over all cells, here, we do a single cell and, if necessary, its faces, interior and boundary.</p>
<p>Upon return, the <a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a> objects in the <a class="el" href="classMeshWorker_1_1DoFInfoBox.html">DoFInfoBox</a> are filled with the data computed on the cell and each of the faces. Thus, after the execution of this function, we are ready to call <a class="el" href="classMeshWorker_1_1DoFInfoBox.html#a91374da63609baa05d9532a4c0cb7e3a">DoFInfoBox::assemble()</a> to distribute the local data into global data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">cell</td><td>is the cell we work on </td></tr>
    <tr><td class="paramname">dof_info</td><td>is the object into which local results are entered. It is expected to have been set up for the right types of data. </td></tr>
    <tr><td class="paramname">info</td><td>is the object containing additional data only needed for internal processing. </td></tr>
    <tr><td class="paramname">cell_worker</td><td>defines the local action on each cell. </td></tr>
    <tr><td class="paramname">boundary_worker</td><td>defines the local action on boundary faces </td></tr>
    <tr><td class="paramname">face_worker</td><td>defines the local action on interior faces. </td></tr>
    <tr><td class="paramname">loop_control</td><td>control structure to specify what actions should be performed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00191">191</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="gad10f528ab87f39fbb0531d24f238b2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad10f528ab87f39fbb0531d24f238b2f3">&#9670;&nbsp;</a></span>loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class DOFINFO , class INFOBOX , class ASSEMBLER , class ITERATOR &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::loop </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DOFINFO &amp;&#160;</td>
          <td class="paramname"><em>dinfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">INFOBOX &amp;&#160;</td>
          <td class="paramname"><em>info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>cell_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(DOFINFO &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>boundary_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(DOFINFO &amp;, DOFINFO &amp;, typename INFOBOX::CellInfo &amp;, typename INFOBOX::CellInfo &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>face_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASSEMBLER &amp;&#160;</td>
          <td class="paramname"><em>assembler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;&#160;</td>
          <td class="paramname"><em>lctrl</em> = <code><a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The main work function of this namespace. It is a loop over all cells in an iterator range, in which <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a> is called for each cell. Unilaterally refined interior faces are handled automatically by the loop. Most of the work in this loop is done in <a class="el" href="group__MeshWorker.html#gaf5a59dde8686a651b12d040cc5afdf9a">cell_action()</a>, which also receives most of the parameters of this function. See the documentation there for more details.</p>
<p>If you don't want anything to be done on cells, interior or boundary faces to happen, simply pass the Null pointer to one of the function arguments. </p>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00439">439</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="ga93cfb35f7969ce8f0be7628255dfe7fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga93cfb35f7969ce8f0be7628255dfe7fb">&#9670;&nbsp;</a></span>integration_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim, class ITERATOR , class ASSEMBLER &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::integration_loop </td>
          <td>(</td>
          <td class="paramtype">ITERATOR&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename <a class="el" href="structidentity.html">identity</a>&lt; ITERATOR &gt;::type&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeshWorker_1_1DoFInfo.html">DoFInfo</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof_info</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classMeshWorker_1_1IntegrationInfoBox.html">IntegrationInfoBox</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>box</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>integrator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ASSEMBLER &amp;&#160;</td>
          <td class="paramname"><em>assembler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a> &amp;&#160;</td>
          <td class="paramname"><em>lctrl</em> = <code><a class="el" href="classMeshWorker_1_1LoopControl.html">LoopControl</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplified interface for <a class="el" href="group__MeshWorker.html#gad10f528ab87f39fbb0531d24f238b2f3">loop()</a> if specialized for integration, using the virtual functions in <a class="el" href="classMeshWorker_1_1LocalIntegrator.html">LocalIntegrator</a>. </p>

<p class="definition">Definition at line <a class="el" href="loop_8h_source.html#l00493">493</a> of file <a class="el" href="loop_8h_source.html">loop.h</a>.</p>

</div>
</div>
<a id="ga76ec61fbd188fb320fe8ca166a79b322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga76ec61fbd188fb320fe8ca166a79b322">&#9670;&nbsp;</a></span>mesh_loop() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::mesh_loop </td>
          <td>(</td>
          <td class="paramtype">const CellIteratorType &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CellIteratorType &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#aac43ce31dc7c260ded0754ed6c87645d">CellWorkerFunctionType</a> &amp;&#160;</td>
          <td class="paramname"><em>cell_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CopierType &amp;&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a> &amp;&#160;</td>
          <td class="paramname"><em>boundary_worker</em> = <code><a class="el" href="namespaceMeshWorker.html#a6e4b155e980747e8f5842cebcdded8fe">BoundaryWorkerFunctionType</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a> &amp;&#160;</td>
          <td class="paramname"><em>face_worker</em> = <code><a class="el" href="namespaceMeshWorker.html#a8ce2abe92fbd932da793eb7d33ab793d">FaceWorkerFunctionType</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function extends the <a class="el" href="namespaceWorkStream.html">WorkStream</a> concept to work on meshes (cells and/or faces) and handles the complicated logic for work on adaptively refined faces and parallel computation (work on faces to ghost neighbors for example). The <code>mesh_loop</code> can be used to simplify operations on cells (for example assembly), on boundaries (Neumann type boundary conditions), or on interior faces (for example in discontinuous Galerkin methods). The function is used in a number of tutorials, including step-12, step-16, and step-47, to name just a few.</p>
<p>For uniformly refined meshes, it would be relatively easy to use <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a> with a <code>cell_worker</code> that also loops over faces, and takes care of assembling face terms depending on the current and neighbor cell. All user codes that do these loops would then need to insert manually the logic that identifies, for every face of the current cell, the neighboring cell, and the face index on the neighboring cell that corresponds to the current face.</p>
<p>This is more complicated if local refinement is enabled and the current or neighbor cells have hanging nodes. In this case it is also necessary to identify the corresponding subface on either the current or the neighbor faces.</p>
<p>This method externalizes that logic (which is independent from user codes) and separates the assembly of face terms (internal faces, boundary faces, or faces between different subdomain ids on parallel computations) from the assembling on cells, allowing the user to specify two additional workers (a <code>cell_worker</code>, a <code>boundary_worker</code>, and a <code>face_worker</code>) that are called automatically in each <code>cell</code>, according to the specific AssembleFlags <code>flags</code> that are passed. The <code>cell_worker</code> is passed the cell identifier, a <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> object, and a <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> object, following the same principles of <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a>. Internally the function passes to <code>boundary_worker</code>, in addition to the above, also a <code>face_no</code> parameter that identifies the face on which the integration should be performed. The <code>face_worker</code> instead needs to identify the current face unambiguously both on the cell and on the neighboring cell, and it is therefore called with six arguments (three for each cell: the actual cell, the face index, and the subface_index. If no subface integration is needed, then the subface_index is <a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>) in addition to the usual <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> and <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> objects.</p>
<p>If the flag AssembleFlags::assemble_own_cells is passed, then the default behavior is to first loop over faces and do the work there, and then compute the actual work on the cell. It is possible to perform the integration on the cells after working on faces, by adding the flag AssembleFlags::cells_after_faces.</p>
<p>If the flag AssembleFlags::assemble_own_interior_faces_once is specified, then each interior face is visited only once, and the <code>face_worker</code> is assumed to integrate all face terms at once (and add contributions to both sides of the face in a discontinuous Galerkin setting).</p>
<p>This method is equivalent to the <a class="el" href="namespaceWorkStream.html#ab8ceb010811941c351803b671a19fb73">WorkStream::run()</a> method when AssembleFlags contains only <code>assemble_own_cells</code>, and can be used as a drop-in replacement for that method.</p>
<p>The two data types <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> and <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> need to have a working copy constructor. <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> is only used in the worker function, while <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> is the object passed from the worker to the copier. The <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> object is reset to the value provided to this function every time this function visits a new cell (where it then calls the cell and face workers). In other words, no state carries over between calling the <code>copier</code> on one cell and the <code>cell_worker</code>/<code>face_worker</code>/<code>boundary_worker</code> functions on the next cell, and user code needs not reset the copy object either at the beginning of the cell integration or end of the copy operation. Resetting the state of the <code>copier</code> inside of a <code>face_worker</code> or <code>boundary_worker</code> constitutes a bug, and may lead to some unexpected results. The following example shows what is not permissible, as the copier is potentially shared among numerous faces on a cell: </p><div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim, spacedim&gt;</a>;</div><div class="line"><span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.begin_active());</div><div class="line"></div><div class="line">ScratchData            scratch(...);</div><div class="line">CopyData               <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>(...);</div><div class="line"></div><div class="line">std::function&lt;void(const CellIteratorType &amp;, ScratchData &amp;, CopyData &amp;)&gt;</div><div class="line">  empty_cell_worker;</div><div class="line"></div><div class="line"><span class="keyword">auto</span> boundary_worker = [...] (</div><div class="line">  <span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">  <span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>      face,</div><div class="line">  ScratchData            &amp;scratch_data,</div><div class="line">  CopyData               &amp;copy_data)</div><div class="line">{</div><div class="line"> <span class="keyword">const</span> <span class="keyword">auto</span> &amp;fe_face_values = scratch_data.reinit(cell, face);</div><div class="line"> copy_data = CopyData(...); <span class="comment">// This is an error, as we lose the</span></div><div class="line">                            <span class="comment">// accumulation that has been performed on</span></div><div class="line">                            <span class="comment">// other boundary faces of the same cell.</span></div><div class="line"></div><div class="line"> <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> q_point = 0;</div><div class="line">      q_point &lt; fe_face_values.n_quadrature_points;</div><div class="line">      ++q_point)</div><div class="line">   {</div><div class="line">     copy_data.vectors[0][0] += 1.0 * fe_face_values.JxW(q_point);</div><div class="line">   }</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keywordtype">double</span> <a class="code" href="namespaceinternal.html#aa5bef221c94bc6b9c5441c306a72cdbaa2063c1608d6e0baf80249c42e2be5804">value</a> = 0;</div><div class="line"><span class="keyword">auto</span> copier = [...](<span class="keyword">const</span> CopyData &amp;copy_data)</div><div class="line">{</div><div class="line">  value += copy_data.vectors[0][0]; <span class="comment">// Contributions from some faces may</span></div><div class="line">                                    <span class="comment">// be missing.</span></div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.active_cell_iterators(),</div><div class="line">                      empty_cell_worker, copier,</div><div class="line">                      scratch, <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>,</div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa35f26e2d96f28fb49e5b0865adc3ba9d">MeshWorker::assemble_boundary_faces</a>,</div><div class="line">                      boundary_worker);</div></div><!-- fragment --><p>The queue_length argument indicates the number of items that can be live at any given time. Each item consists of chunk_size elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<p>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that queue_length copies of the <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> object and <code>queue_length*chunk_size</code> copies of the <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> object are generated.</p>
<dl class="section note"><dt>Note</dt><dd>The types of the function arguments and the default values (empty worker functions) displayed in the Doxygen documentation here are slightly simplified compared to the real types.</dd>
<dd>
More information about requirements on template types and meaning of <code>queue_length</code> and <code>chunk_size</code> can be found in the documentation of the <a class="el" href="namespaceWorkStream.html">WorkStream</a> namespace and its members. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00282">282</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="gae1cf14f6f8ff8f5e1f168c19ad4979b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1cf14f6f8ff8f5e1f168c19ad4979b9">&#9670;&nbsp;</a></span>mesh_loop() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CellIteratorType , class ScratchData , class CopyData , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::mesh_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt;&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;&#160;</td>
          <td class="paramname"><em>cell_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;&#160;</td>
          <td class="paramname"><em>boundary_worker</em> = <code>std::function&lt;void(const&#160;CellIteratorBaseType&#160;&amp;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const&#160;unsigned&#160;<a class="el" href="classint.html">int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a>&#160;&amp;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a>&#160;&amp;)&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; std::function&lt; void(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&gt;&gt;::type &amp;&#160;</td>
          <td class="paramname"><em>face_worker</em> = <code>std::function&lt;void(const&#160;CellIteratorBaseType&#160;&amp;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const&#160;unsigned&#160;<a class="el" href="classint.html">int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const&#160;unsigned&#160;<a class="el" href="classint.html">int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const&#160;CellIteratorBaseType&#160;&amp;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const&#160;unsigned&#160;<a class="el" href="classint.html">int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;const&#160;unsigned&#160;<a class="el" href="classint.html">int</a>,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a>&#160;&amp;,&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;<a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a>&#160;&amp;)&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, but for iterator ranges (and, therefore, filtered iterators).</p>
<p>An example usage of the function for the serial case is given by </p><div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim, spacedim&gt;</a>;</div><div class="line"><span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.begin_active());</div><div class="line"></div><div class="line">ScratchData            scratch(...);</div><div class="line">CopyData               <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>(...);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> cell_worker = [...] (</div><div class="line">  <span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">  ScratchData            &amp;scratch_data,</div><div class="line">  CopyData               &amp;copy_data)</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> copier = [...](<span class="keyword">const</span> CopyData &amp;copy_data)</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(dof_handler.active_cell_iterators(),</div><div class="line">                      cell_worker, copier,</div><div class="line">                      scratch, <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>,</div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --><p>and an example usage of the function for the parallel distributed case, where the copier is only to be called on locally owned cells, is given by </p><div class="fragment"><div class="line"><span class="keyword">using</span> ScratchData      = <a class="code" href="classMeshWorker_1_1ScratchData.html">MeshWorker::ScratchData&lt;dim, spacedim&gt;</a>;</div><div class="line"><span class="keyword">using</span> CopyData         = <a class="code" href="structMeshWorker_1_1CopyData.html">MeshWorker::CopyData&lt;1, 1, 1&gt;</a>;</div><div class="line"><span class="keyword">using</span> CellIteratorType = decltype(dof_handler.begin_active());</div><div class="line"></div><div class="line">ScratchData            scratch(...);</div><div class="line">CopyData               <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>(...);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> cell_worker = [...] (</div><div class="line">  <span class="keyword">const</span> CellIteratorType &amp;cell,</div><div class="line">  ScratchData            &amp;scratch_data,</div><div class="line">  CopyData               &amp;copy_data)</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">auto</span> copier = [...](<span class="keyword">const</span> CopyData &amp;copy_data)</div><div class="line">{</div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> filtered_iterator_range =</div><div class="line">  <a class="code" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a>(dof_handler.active_cell_iterators(),</div><div class="line">                   <a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>());</div><div class="line"></div><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">MeshWorker::mesh_loop</a>(filtered_iterator_range,</div><div class="line">                      cell_worker, copier,</div><div class="line">                      scratch, copy,</div><div class="line">                      <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">MeshWorker::assemble_own_cells</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00711">711</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="gab233c65f7c758c094edbf9a0b5687d5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab233c65f7c758c094edbf9a0b5687d5e">&#9670;&nbsp;</a></span>mesh_loop() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::mesh_loop </td>
          <td>(</td>
          <td class="paramtype">const CellIteratorType &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structidentity.html">identity</a>&lt; CellIteratorType &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CellIteratorType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>cell_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>boundary_worker</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>face_worker</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a variant of the <a class="el" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop()</a> function that can be used for worker and copier functions that are member functions of a class.</p>
<p>The argument passed as <code>end</code> must be convertible to the same type as <code>begin</code>, but doesn't have to be of the same type itself. This allows to write code like <code>mesh_loop(dof_handler.begin_active(), <a class="el" href="namespaceTrilinosWrappers_1_1internal.html#aee42c8e3004e2e81eac3c3356d3ec46b">dof_handler.end()</a>, ...)</code> where the first is of type <a class="el" href="group__Iterators.html#ga6b8bbcafed8847f3030ea30c6990eb2d">DoFHandler::active_cell_iterator</a> whereas the second is of type DoFHandler::raw_cell_iterator.</p>
<p>The <code>queue_length</code> argument indicates the number of items that can be live at any given time. Each item consists of <code>chunk_size</code> elements of the input stream that will be worked on by the worker and copier functions one after the other on the same thread.</p>
<dl class="section note"><dt>Note</dt><dd>If your data objects are large, or their constructors are expensive, it is helpful to keep in mind that <code>queue_length</code> copies of the <code><a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a></code> object and <code>queue_length*chunk_size</code> copies of the <code><a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a></code> object are generated.</dd></dl>
<p>An example usage of the function is given by </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ScratchData;</div><div class="line"><span class="keyword">struct </span>CopyData;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  cell_worker(<span class="keyword">const</span> CellIteratorType &amp;cell, ScratchData &amp;, CopyData &amp;);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  copier(<span class="keyword">const</span> CopyData &amp;);</div><div class="line"></div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">MyClass&lt;dim, spacedim&gt; my_class;</div><div class="line">ScratchData            scratch;</div><div class="line">CopyData               <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>;</div><div class="line"></div><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>(tria.<a class="code" href="classTriangulation.html#afe6c58805fe436a94b141c1585606c7f">begin_active</a>(),</div><div class="line">          tria.<a class="code" href="classTriangulation.html#a92c41c89a9cf1e020050985822196dff">end</a>(),</div><div class="line">          my_class,</div><div class="line">          &amp;MyClass&lt;dim, spacedim&gt;::cell_worker,</div><div class="line">          &amp;MyClass&lt;dim, spacedim&gt;::copier,</div><div class="line">          scratch,</div><div class="line">          <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>,</div><div class="line">          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l00834">834</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
<a id="ga47cf9870f0e4e1952e77d7c77a560998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga47cf9870f0e4e1952e77d7c77a560998">&#9670;&nbsp;</a></span>mesh_loop() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class CellIteratorType , class ScratchData , class CopyData , class MainClass , class CellIteratorBaseType  = typename internal::CellIteratorBaseType&lt;CellIteratorType&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void MeshWorker::mesh_loop </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classIteratorRange.html">IteratorRange</a>&lt; CellIteratorType &gt;&#160;</td>
          <td class="paramname"><em>iterator_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MainClass &amp;&#160;</td>
          <td class="paramname"><em>main_class</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CellIteratorBaseType &amp;, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>cell_worker</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>copier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_scratch_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;&#160;</td>
          <td class="paramname"><em>sample_copy_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aa">AssembleFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>boundary_worker</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(MainClass::*)(const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, const CellIteratorBaseType &amp;, const unsigned <a class="el" href="classint.html">int</a>, const unsigned <a class="el" href="classint.html">int</a>, <a class="el" href="classMeshWorker_1_1ScratchData.html">ScratchData</a> &amp;, <a class="el" href="structMeshWorker_1_1CopyData.html">CopyData</a> &amp;)&#160;</td>
          <td class="paramname"><em>face_worker</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>queue_length</em> = <code>2&#160;*&#160;<a class="el" href="classMultithreadInfo.html#ad0b84ae105b385b88bdd4bfc0c530995">MultithreadInfo::n_threads</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>8</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the function above, but for iterator ranges (and, therefore, filtered iterators).</p>
<p>An example usage of the function for the serial case is given by </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ScratchData;</div><div class="line"><span class="keyword">struct </span>CopyData;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  cell_worker(<span class="keyword">const</span> CellIteratorType &amp;cell, ScratchData &amp;, CopyData &amp;);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  copier(<span class="keyword">const</span> CopyData &amp;);</div><div class="line"></div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">MyClass&lt;dim, spacedim&gt; my_class;</div><div class="line">ScratchData            scratch;</div><div class="line">CopyData               <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>;</div><div class="line"></div><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>(tria.<a class="code" href="group__CPP11.html#ga23e860c5192f6501650dda8bb3e2b497">active_cell_iterators</a>(),</div><div class="line">          my_class,</div><div class="line">          &amp;MyClass&lt;dim, spacedim&gt;::cell_worker,</div><div class="line">          &amp;MyClass&lt;dim, spacedim&gt;::copier,</div><div class="line">          scratch,</div><div class="line">          <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>,</div><div class="line">          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>);</div></div><!-- fragment --><p>and an example usage of the function for the parallel distributed case, where the copier is only to be called on locally owned cells, is given by </p><div class="fragment"><div class="line"><span class="keyword">struct </span>ScratchData;</div><div class="line"><span class="keyword">struct </span>CopyData;</div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> spacedim&gt;</div><div class="line"><span class="keyword">class </span>MyClass</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  cell_worker(<span class="keyword">const</span> CellIteratorType &amp;cell, ScratchData &amp;, CopyData &amp;);</div><div class="line"></div><div class="line">  <span class="keywordtype">void</span></div><div class="line">  copier(<span class="keyword">const</span> CopyData &amp;);</div><div class="line"></div><div class="line">  ...</div><div class="line">};</div><div class="line"></div><div class="line">...</div><div class="line"></div><div class="line">MyClass&lt;dim, spacedim&gt; my_class;</div><div class="line">ScratchData            scratch;</div><div class="line">CopyData               <a class="code" href="namespaceinternal_1_1VectorOperations.html#a40c8daa0881cff0123fbaeb08929f5cb">copy</a>;</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> filtered_iterator_range =</div><div class="line">  <a class="code" href="group__CPP11.html#ga3948dd66d9e66ac55d89dc8f75fa4855">filter_iterators</a>(distributed_tria.active_cell_iterators(),</div><div class="line">                   <a class="code" href="classIteratorFilters_1_1LocallyOwnedCell.html">IteratorFilters::LocallyOwnedCell</a>());</div><div class="line"></div><div class="line"><a class="code" href="group__MeshWorker.html#ga76ec61fbd188fb320fe8ca166a79b322">mesh_loop</a>(filtered_iterator_range,</div><div class="line">          my_class,</div><div class="line">          &amp;MyClass&lt;dim, spacedim&gt;::cell_worker,</div><div class="line">          &amp;MyClass&lt;dim, spacedim&gt;::copier,</div><div class="line">          scratch,</div><div class="line">          copy,</div><div class="line">          <a class="code" href="namespaceMeshWorker.html#ac7a9db8b34d398d7d398d1e8809874aaa44a76e905b1d4cd80af387b5fac4d8aa">assemble_own_cells</a>);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="mesh__loop_8h_source.html#l01015">1015</a> of file <a class="el" href="mesh__loop_8h_source.html">mesh_loop.h</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
