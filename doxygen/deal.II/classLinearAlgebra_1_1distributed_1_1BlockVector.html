<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classLinearAlgebra_1_1distributed_1_1BlockVector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LinearAlgebra::distributed::BlockVector&lt; Number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLinearAlgebra.html">LinearAlgebra</a></li><li class="navelem"><a class="el" href="namespaceLinearAlgebra_1_1distributed.html">distributed</a></li><li class="navelem"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classLinearAlgebra_1_1distributed_1_1BlockVector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearAlgebra::distributed::BlockVector&lt; Number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="la__parallel__block__vector_8h_source.html">deal.II/lac/la_parallel_block_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LinearAlgebra::distributed::BlockVector&lt; Number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classLinearAlgebra_1_1distributed_1_1BlockVector__inherit__graph.svg" width="392" height="308"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a2f13f25da5172afa079df9d2804cef98"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a2f13f25da5172afa079df9d2804cef98">BaseClass</a> = <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &gt;</td></tr>
<tr class="separator:a2f13f25da5172afa079df9d2804cef98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a976be8dace145bc740fc4b5eaa08ecfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a976be8dace145bc740fc4b5eaa08ecfc">BlockType</a> = typename <a class="el" href="classBlockVectorBase.html#aeb971802cf05add5cf1c26338ce77a9b">BaseClass::BlockType</a></td></tr>
<tr class="separator:a976be8dace145bc740fc4b5eaa08ecfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a43b405989a623b76a92efe2dfa5e39"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> = typename <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">BaseClass::value_type</a></td></tr>
<tr class="separator:a0a43b405989a623b76a92efe2dfa5e39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab99352244c902251dcd351118e7c468a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> = typename <a class="el" href="classBlockVectorBase.html#ab62c4ac95c3782bb2236bf67038adc20">BaseClass::real_type</a></td></tr>
<tr class="separator:ab99352244c902251dcd351118e7c468a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc2cd36158818c25e48e79bc9f27827e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#afc2cd36158818c25e48e79bc9f27827e">pointer</a> = typename <a class="el" href="classBlockVectorBase.html#aebed52638e6b26f5f18adec8a2437852">BaseClass::pointer</a></td></tr>
<tr class="separator:afc2cd36158818c25e48e79bc9f27827e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae230c8ce0c95764c28d22176b8bd396a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae230c8ce0c95764c28d22176b8bd396a">const_pointer</a> = typename <a class="el" href="classBlockVectorBase.html#a46a99911c512a1a08d5c5e237986d765">BaseClass::const_pointer</a></td></tr>
<tr class="separator:ae230c8ce0c95764c28d22176b8bd396a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae30d22265b642d73ed2ced13942ebb52"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae30d22265b642d73ed2ced13942ebb52">reference</a> = typename <a class="el" href="classBlockVectorBase.html#a9a15d476a8495a66f32508943c91294f">BaseClass::reference</a></td></tr>
<tr class="separator:ae30d22265b642d73ed2ced13942ebb52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4bf062593cccb0f3f8c3daca8d77f6f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab4bf062593cccb0f3f8c3daca8d77f6f">const_reference</a> = typename <a class="el" href="classBlockVectorBase.html#a490c8bf68dceb08dc60c2a3e0c6bf2a2">BaseClass::const_reference</a></td></tr>
<tr class="separator:ab4bf062593cccb0f3f8c3daca8d77f6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa000c54aa3fc182e5f05422233af7257"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> = typename <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">BaseClass::size_type</a></td></tr>
<tr class="separator:aa000c54aa3fc182e5f05422233af7257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9a7abde54c56cd458765868a4a6da3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6f9a7abde54c56cd458765868a4a6da3">iterator</a> = typename <a class="el" href="classBlockVectorBase.html#a38316f0d1b9b1e4fa4dc3e0b4e15655e">BaseClass::iterator</a></td></tr>
<tr class="separator:a6f9a7abde54c56cd458765868a4a6da3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae404965061ae3d6eb991582f3c492e36"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae404965061ae3d6eb991582f3c492e36">const_iterator</a> = typename <a class="el" href="classBlockVectorBase.html#a84ecd5753f1f75fbe1fa76e7ec72b3d8">BaseClass::const_iterator</a></td></tr>
<tr class="separator:ae404965061ae3d6eb991582f3c492e36"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gab88080c3e5c9fed396be4efefd981cf1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab88080c3e5c9fed396be4efefd981cf1">DeclException0</a> (ExcVectorTypeNotCompatible)</td></tr>
<tr class="separator:gab88080c3e5c9fed396be4efefd981cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8055b978b5e9a9912eb0d3189ac8eae4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga8055b978b5e9a9912eb0d3189ac8eae4">DeclException0</a> (ExcIteratorRangeDoesNotMatchVectorSize)</td></tr>
<tr class="separator:ga8055b978b5e9a9912eb0d3189ac8eae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a27b2a48e5b5780cd0a6640b928d794"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes</a> ()</td></tr>
<tr class="separator:a6a27b2a48e5b5780cd0a6640b928d794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae05a0e26814f032473ed2ef66da018bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a976be8dace145bc740fc4b5eaa08ecfc">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ae05a0e26814f032473ed2ef66da018bd">block</a> (const unsigned <a class="el" href="classint.html">int</a> i)</td></tr>
<tr class="separator:ae05a0e26814f032473ed2ef66da018bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e309364bfcb70d14e5a57eea6d9cb19"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a976be8dace145bc740fc4b5eaa08ecfc">BlockType</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a1e309364bfcb70d14e5a57eea6d9cb19">block</a> (const unsigned <a class="el" href="classint.html">int</a> i) const</td></tr>
<tr class="separator:a1e309364bfcb70d14e5a57eea6d9cb19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a231e1f385289359e66cadca8d9da5602"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classBlockIndices.html">BlockIndices</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a231e1f385289359e66cadca8d9da5602">get_block_indices</a> () const</td></tr>
<tr class="separator:a231e1f385289359e66cadca8d9da5602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a0d11493903975ee387841aa3cb5fc4"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a3a0d11493903975ee387841aa3cb5fc4">n_blocks</a> () const</td></tr>
<tr class="separator:a3a0d11493903975ee387841aa3cb5fc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae554df8459a4a08c3cd34c3655b1edba"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ae554df8459a4a08c3cd34c3655b1edba">locally_owned_size</a> () const</td></tr>
<tr class="separator:ae554df8459a4a08c3cd34c3655b1edba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7911affb07bbfc4a98704a98fafa2f72"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6f9a7abde54c56cd458765868a4a6da3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a7911affb07bbfc4a98704a98fafa2f72">begin</a> ()</td></tr>
<tr class="separator:a7911affb07bbfc4a98704a98fafa2f72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9a0800fc9df78b7914a7a4935472fa4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae404965061ae3d6eb991582f3c492e36">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#af9a0800fc9df78b7914a7a4935472fa4">begin</a> () const</td></tr>
<tr class="separator:af9a0800fc9df78b7914a7a4935472fa4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2e328fa354198c4e77e9a81de88a726"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6f9a7abde54c56cd458765868a4a6da3">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#aa2e328fa354198c4e77e9a81de88a726">end</a> ()</td></tr>
<tr class="separator:aa2e328fa354198c4e77e9a81de88a726"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6637f902ba0fe293b449d5ffdb6605"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae404965061ae3d6eb991582f3c492e36">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#abe6637f902ba0fe293b449d5ffdb6605">end</a> () const</td></tr>
<tr class="separator:abe6637f902ba0fe293b449d5ffdb6605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc43ed460b3575788288e9843a0873f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#acc43ed460b3575788288e9843a0873f0">operator()</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> i) const</td></tr>
<tr class="separator:acc43ed460b3575788288e9843a0873f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a568bb2c256eca3a79e0535101fe39"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae30d22265b642d73ed2ced13942ebb52">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ae6a568bb2c256eca3a79e0535101fe39">operator()</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> i)</td></tr>
<tr class="separator:ae6a568bb2c256eca3a79e0535101fe39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64efc5a4048af8ead33432578e20153"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#aa64efc5a4048af8ead33432578e20153">operator[]</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> i) const</td></tr>
<tr class="separator:aa64efc5a4048af8ead33432578e20153"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace443bdac1400b0760cef2a0e17b5bdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae30d22265b642d73ed2ced13942ebb52">reference</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ace443bdac1400b0760cef2a0e17b5bdc">operator[]</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> i)</td></tr>
<tr class="separator:ace443bdac1400b0760cef2a0e17b5bdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1972b4fd734c64bf54b45cd2fed11341"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a1972b4fd734c64bf54b45cd2fed11341">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;values) const</td></tr>
<tr class="separator:a1972b4fd734c64bf54b45cd2fed11341"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebcfeb0925594a2013981d0c36f9a41d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#aebcfeb0925594a2013981d0c36f9a41d">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:aebcfeb0925594a2013981d0c36f9a41d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3c7de4e771c97f5525ab54b3b3c25ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ae3c7de4e771c97f5525ab54b3b3c25ce">operator==</a> (const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; VectorType2 &gt; &amp;v) const</td></tr>
<tr class="separator:ae3c7de4e771c97f5525ab54b3b3c25ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6117670ad088adf41d33fb31870dfbee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a6117670ad088adf41d33fb31870dfbee">operator*</a> (const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V) const</td></tr>
<tr class="separator:a6117670ad088adf41d33fb31870dfbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6030680c6b6490b40619c0b86bcf3893"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a6030680c6b6490b40619c0b86bcf3893">add_and_dot</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;W)</td></tr>
<tr class="separator:a6030680c6b6490b40619c0b86bcf3893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8368f93764fdfbe650335472be132b1a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a8368f93764fdfbe650335472be132b1a">in_local_range</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> global_index) const</td></tr>
<tr class="separator:a8368f93764fdfbe650335472be132b1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad98b1e8ad77cb42c0f4fc572fd73c553"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ad98b1e8ad77cb42c0f4fc572fd73c553">is_non_negative</a> () const</td></tr>
<tr class="separator:ad98b1e8ad77cb42c0f4fc572fd73c553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3403ef2bfabddf775f62f5ca69d1409e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a3403ef2bfabddf775f62f5ca69d1409e">operator+=</a> (const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V)</td></tr>
<tr class="separator:a3403ef2bfabddf775f62f5ca69d1409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac025c211c9866715e396122d037074fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ac025c211c9866715e396122d037074fe">operator-=</a> (const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V)</td></tr>
<tr class="separator:ac025c211c9866715e396122d037074fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f580d55ed6577e89a86edc3b8d7e75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a30f580d55ed6577e89a86edc3b8d7e75">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, const std::vector&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:a30f580d55ed6577e89a86edc3b8d7e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a419b4fc3c617910588872e562c9318"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a0a419b4fc3c617910588872e562c9318">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:a0a419b4fc3c617910588872e562c9318"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd0d690c8f24cc6352d741f0961bd248"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#afd0d690c8f24cc6352d741f0961bd248">add</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> n_elements, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> *indices, const Number *values)</td></tr>
<tr class="separator:afd0d690c8f24cc6352d741f0961bd248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab91dc0cc56bb74713d3fa4b98c63bcd7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ab91dc0cc56bb74713d3fa4b98c63bcd7">add</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> s)</td></tr>
<tr class="separator:ab91dc0cc56bb74713d3fa4b98c63bcd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae697bc329049cdb045d11b8b1d9a01b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#aae697bc329049cdb045d11b8b1d9a01b">add</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V)</td></tr>
<tr class="separator:aae697bc329049cdb045d11b8b1d9a01b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d5c9c612d47ba6becd4200856fac480"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a2d5c9c612d47ba6becd4200856fac480">add</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> b, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;W)</td></tr>
<tr class="separator:a2d5c9c612d47ba6becd4200856fac480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71b0ab8295e98caf3dfe1ef14ae6b6c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a71b0ab8295e98caf3dfe1ef14ae6b6c1">sadd</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> s, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V)</td></tr>
<tr class="separator:a71b0ab8295e98caf3dfe1ef14ae6b6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b1daec966bbe66a1c5ad01cd1c43d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a55b1daec966bbe66a1c5ad01cd1c43d2">sadd</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V)</td></tr>
<tr class="separator:a55b1daec966bbe66a1c5ad01cd1c43d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae8fd4a5640a0d1ca7d39621bdb3b61f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#aae8fd4a5640a0d1ca7d39621bdb3b61f">sadd</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> b, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;W)</td></tr>
<tr class="separator:aae8fd4a5640a0d1ca7d39621bdb3b61f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65c94c564909a8eeca18c99d19d95f9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a65c94c564909a8eeca18c99d19d95f9e">sadd</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;V, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> b, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;W, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> c, const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;X)</td></tr>
<tr class="separator:a65c94c564909a8eeca18c99d19d95f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71cf6d7d6bcbc1fe64c64cf10824f0a3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a71cf6d7d6bcbc1fe64c64cf10824f0a3">operator*=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> factor)</td></tr>
<tr class="separator:a71cf6d7d6bcbc1fe64c64cf10824f0a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13301b26e86abe6916a109165a019001"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a13301b26e86abe6916a109165a019001">operator/=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> factor)</td></tr>
<tr class="separator:a13301b26e86abe6916a109165a019001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab84665a55ce69eeb5c951c009e47500e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#ab84665a55ce69eeb5c951c009e47500e">scale</a> (const BlockVector2 &amp;v)</td></tr>
<tr class="separator:ab84665a55ce69eeb5c951c009e47500e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe94f0b17a0eaaacbfdc8c55268d6a3a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#afe94f0b17a0eaaacbfdc8c55268d6a3a">equ</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> a, const BlockVector2 &amp;V)</td></tr>
<tr class="separator:afe94f0b17a0eaaacbfdc8c55268d6a3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6207efeaeff0d0f321b35d29d58e8df2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a6207efeaeff0d0f321b35d29d58e8df2">compress</a> (<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:a6207efeaeff0d0f321b35d29d58e8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Basic operations</div></td></tr>
<tr class="memitem:a28bef4c0ba10221b1aeaf200f1bd8957"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a28bef4c0ba10221b1aeaf200f1bd8957">BlockVector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> num_blocks=0, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> block_size=0)</td></tr>
<tr class="separator:a28bef4c0ba10221b1aeaf200f1bd8957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77e77142f145f27e6de83c7769fee866"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a77e77142f145f27e6de83c7769fee866">BlockVector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a77e77142f145f27e6de83c7769fee866"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6e6e3a3ba2c1ad09c7b2e9bde1fd52fd">BlockVector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; OtherNumber &gt; &amp;v)</td></tr>
<tr class="separator:a6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a632b36dc3cfbe1858681e56f985b8a8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a632b36dc3cfbe1858681e56f985b8a8a">BlockVector</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;block_sizes)</td></tr>
<tr class="separator:a632b36dc3cfbe1858681e56f985b8a8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a3fe3d069769bfe44cfbb12bb8d9ec"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ad6a3fe3d069769bfe44cfbb12bb8d9ec">BlockVector</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;local_ranges, const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;ghost_indices, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:ad6a3fe3d069769bfe44cfbb12bb8d9ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae44f6a147f001ce40a3390356939cedb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae44f6a147f001ce40a3390356939cedb">BlockVector</a> (const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;local_ranges, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:ae44f6a147f001ce40a3390356939cedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a599e94513f88be426a73c5ad3162b27a"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a599e94513f88be426a73c5ad3162b27a">~BlockVector</a> () override=default</td></tr>
<tr class="separator:a599e94513f88be426a73c5ad3162b27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b82aa81372ebfe22ed6968ef8317417"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a2b82aa81372ebfe22ed6968ef8317417">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> s) override</td></tr>
<tr class="separator:a2b82aa81372ebfe22ed6968ef8317417"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0069a784bc60ecfc7d87075927b4b086"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0069a784bc60ecfc7d87075927b4b086">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;V)</td></tr>
<tr class="separator:a0069a784bc60ecfc7d87075927b4b086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a631ced4f5e83bbf22ece66c4ee1ea301"><td class="memTemplParams" colspan="2">template&lt;class Number2 &gt; </td></tr>
<tr class="memitem:a631ced4f5e83bbf22ece66c4ee1ea301"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a631ced4f5e83bbf22ece66c4ee1ea301">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;V)</td></tr>
<tr class="separator:a631ced4f5e83bbf22ece66c4ee1ea301"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0806d02bb7a443ef28e810d1f4fe7381"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0806d02bb7a443ef28e810d1f4fe7381">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a0806d02bb7a443ef28e810d1f4fe7381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaccfcceeeb6f47176b448d72945a112d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aaccfcceeeb6f47176b448d72945a112d">operator=</a> (const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a> &amp;petsc_vec)</td></tr>
<tr class="separator:aaccfcceeeb6f47176b448d72945a112d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f521396d68256f73799da5a1460fdf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a3f521396d68256f73799da5a1460fdf7">operator=</a> (const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a> &amp;trilinos_vec)</td></tr>
<tr class="separator:a3f521396d68256f73799da5a1460fdf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7833e60852b449291aa16fcfc5b3d600"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> num_blocks, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> block_size=0, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a7833e60852b449291aa16fcfc5b3d600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad74c8e31c81f8ef46b26d3c958125f22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ad74c8e31c81f8ef46b26d3c958125f22">reinit</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;N, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ad74c8e31c81f8ef46b26d3c958125f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9ebeba63b750246591e48b468e3e737"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab9ebeba63b750246591e48b468e3e737"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab9ebeba63b750246591e48b468e3e737">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ab9ebeba63b750246591e48b468e3e737"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852d132f4827ec54f9583013a536761b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a852d132f4827ec54f9583013a536761b">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation) override</td></tr>
<tr class="separator:a852d132f4827ec54f9583013a536761b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec81b97d7e38d836457bfbc7b2f20226"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aec81b97d7e38d836457bfbc7b2f20226">update_ghost_values</a> () const</td></tr>
<tr class="separator:aec81b97d7e38d836457bfbc7b2f20226"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e0cf1c878130c12b0c16cad8da0610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae9e0cf1c878130c12b0c16cad8da0610">zero_out_ghosts</a> () const</td></tr>
<tr class="separator:ae9e0cf1c878130c12b0c16cad8da0610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa205bf18350c2095d459c75edfa622db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa205bf18350c2095d459c75edfa622db">zero_out_ghost_values</a> () const</td></tr>
<tr class="separator:aa205bf18350c2095d459c75edfa622db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ac470622adef2b2aec45be681112de3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0ac470622adef2b2aec45be681112de3">has_ghost_elements</a> () const</td></tr>
<tr class="separator:a0ac470622adef2b2aec45be681112de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a872d9c74afd697767a824cdd69135ba4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a872d9c74afd697767a824cdd69135ba4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a872d9c74afd697767a824cdd69135ba4">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:a872d9c74afd697767a824cdd69135ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f222571d59cc48f9d505fc7ba4d8dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ac1f222571d59cc48f9d505fc7ba4d8dd">sadd</a> (const Number s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ac1f222571d59cc48f9d505fc7ba4d8dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a809ec1490fd39c130932290aae65355c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a809ec1490fd39c130932290aae65355c">all_zero</a> () const override</td></tr>
<tr class="separator:a809ec1490fd39c130932290aae65355c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7df34df7e744cbfdb5cec39176821cf1"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7df34df7e744cbfdb5cec39176821cf1">mean_value</a> () const override</td></tr>
<tr class="separator:a7df34df7e744cbfdb5cec39176821cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab588b3e1883730aff30b5408fcf22298"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab588b3e1883730aff30b5408fcf22298">lp_norm</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> p) const</td></tr>
<tr class="separator:ab588b3e1883730aff30b5408fcf22298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2072c8a6af39eb4ef8aa61e18b5864c1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a2072c8a6af39eb4ef8aa61e18b5864c1">swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;v)</td></tr>
<tr class="separator:a2072c8a6af39eb4ef8aa61e18b5864c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Implementation of VectorSpaceVector</div></td></tr>
<tr class="memitem:a456e59ce23e0da8010f74d80875f6aa5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a456e59ce23e0da8010f74d80875f6aa5">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:a456e59ce23e0da8010f74d80875f6aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be26d6eb72dcefdec2e2305d0e1c2e6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a5be26d6eb72dcefdec2e2305d0e1c2e6">operator*=</a> (const Number factor) override</td></tr>
<tr class="separator:a5be26d6eb72dcefdec2e2305d0e1c2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4daee550e5e52be51395ca7afe42896d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a4daee550e5e52be51395ca7afe42896d">operator/=</a> (const Number factor) override</td></tr>
<tr class="separator:a4daee550e5e52be51395ca7afe42896d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a97828f252550978a7525b82d1e1f92"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a4a97828f252550978a7525b82d1e1f92">operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a4a97828f252550978a7525b82d1e1f92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fb6dc78db248d8b4749632ef52d36f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a52fb6dc78db248d8b4749632ef52d36f">operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a52fb6dc78db248d8b4749632ef52d36f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8143655154d18b0c5753b00158b2e2f1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a8143655154d18b0c5753b00158b2e2f1">import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={}) override</td></tr>
<tr class="separator:a8143655154d18b0c5753b00158b2e2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f5bd0dc1f676eaf0747b580b6ca468"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a93f5bd0dc1f676eaf0747b580b6ca468">operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const override</td></tr>
<tr class="separator:a93f5bd0dc1f676eaf0747b580b6ca468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae860233e47e643eb93892aa873da9889"><td class="memTemplParams" colspan="2">template&lt;typename FullMatrixType &gt; </td></tr>
<tr class="memitem:ae860233e47e643eb93892aa873da9889"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae860233e47e643eb93892aa873da9889">multivector_inner_product</a> (FullMatrixType &amp;matrix, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> symmetric=false) const</td></tr>
<tr class="separator:ae860233e47e643eb93892aa873da9889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a5a9811aff25c8dd2a242d1e309547"><td class="memTemplParams" colspan="2">template&lt;typename FullMatrixType &gt; </td></tr>
<tr class="memitem:aa0a5a9811aff25c8dd2a242d1e309547"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa0a5a9811aff25c8dd2a242d1e309547">multivector_inner_product_with_metric</a> (const FullMatrixType &amp;matrix, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> symmetric=false) const</td></tr>
<tr class="separator:aa0a5a9811aff25c8dd2a242d1e309547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda5640c41b09bae50c6c3c6a863e289"><td class="memTemplParams" colspan="2">template&lt;typename FullMatrixType &gt; </td></tr>
<tr class="memitem:aeda5640c41b09bae50c6c3c6a863e289"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aeda5640c41b09bae50c6c3c6a863e289">mmult</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;V, const FullMatrixType &amp;matrix, const Number s=Number(0.), const Number b=Number(1.)) const</td></tr>
<tr class="separator:aeda5640c41b09bae50c6c3c6a863e289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accecdd88bcfc805d1554fc99e8f05e38"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#accecdd88bcfc805d1554fc99e8f05e38">add</a> (const Number a) override</td></tr>
<tr class="separator:accecdd88bcfc805d1554fc99e8f05e38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0b1677974de1a51cade3dea2e268dd0"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab0b1677974de1a51cade3dea2e268dd0">add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ab0b1677974de1a51cade3dea2e268dd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32a59caf6a091dc576366547bb71dc86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a32a59caf6a091dc576366547bb71dc86">add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:a32a59caf6a091dc576366547bb71dc86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3515ad42ca76e04aed377d32d266daa6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a3515ad42ca76e04aed377d32d266daa6">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;indices, const std::vector&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:a3515ad42ca76e04aed377d32d266daa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a306d119c19bffc19f7d99800e5de79"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a5a306d119c19bffc19f7d99800e5de79">sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a5a306d119c19bffc19f7d99800e5de79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b50074b32093b5471d1c7e033c0f2d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6b50074b32093b5471d1c7e033c0f2d6">scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors) override</td></tr>
<tr class="separator:a6b50074b32093b5471d1c7e033c0f2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8bc1dd4072504da9cbea82e6ba01180"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ad8bc1dd4072504da9cbea82e6ba01180">equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ad8bc1dd4072504da9cbea82e6ba01180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cdf84bbe46a886cdde6bad3a4246163"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a2cdf84bbe46a886cdde6bad3a4246163">l1_norm</a> () const override</td></tr>
<tr class="separator:a2cdf84bbe46a886cdde6bad3a4246163"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fceaca158b4b7b17d280c618c469228"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a8fceaca158b4b7b17d280c618c469228">l2_norm</a> () const override</td></tr>
<tr class="separator:a8fceaca158b4b7b17d280c618c469228"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52b4564def3f222e3c54266a61c75810"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a52b4564def3f222e3c54266a61c75810">norm_sqr</a> () const</td></tr>
<tr class="separator:a52b4564def3f222e3c54266a61c75810"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1403274bfe2ad51433f205ae1a10b6ae"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a1403274bfe2ad51433f205ae1a10b6ae">linfty_norm</a> () const override</td></tr>
<tr class="separator:a1403274bfe2ad51433f205ae1a10b6ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c44bfad65af75c21d0d23af1125414"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#af1c44bfad65af75c21d0d23af1125414">add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:af1c44bfad65af75c21d0d23af1125414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8d5be159fec545106c67bc940589fcb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#af8d5be159fec545106c67bc940589fcb">size</a> () const override</td></tr>
<tr class="separator:af8d5be159fec545106c67bc940589fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a468dfbd79a0d0d614327f292ee66f76a"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a468dfbd79a0d0d614327f292ee66f76a">locally_owned_elements</a> () const override</td></tr>
<tr class="separator:a468dfbd79a0d0d614327f292ee66f76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb764f033c38e246091f50d0ee3f8b90"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#abb764f033c38e246091f50d0ee3f8b90">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const override</td></tr>
<tr class="separator:abb764f033c38e246091f50d0ee3f8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9c15a88fd2789219e70fd950d211e6"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7d9c15a88fd2789219e70fd950d211e6">memory_consumption</a> () const override</td></tr>
<tr class="separator:a7d9c15a88fd2789219e70fd950d211e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a4b58ae27edeb2cbb96a5a2496109154b"><td class="memItemLeft" align="right" valign="top">static constexpr unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a4b58ae27edeb2cbb96a5a2496109154b">communication_block_size</a> = 20</td></tr>
<tr class="separator:a4b58ae27edeb2cbb96a5a2496109154b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a732363be4cddc7dbb3ff940f95f37eac"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#a732363be4cddc7dbb3ff940f95f37eac">components</a></td></tr>
<tr class="separator:a732363be4cddc7dbb3ff940f95f37eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1e20030f38cf12a1bd73c7f2c657d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classBlockIndices.html">BlockIndices</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classBlockVectorBase.html#aad1e20030f38cf12a1bd73c7f2c657d4">block_indices</a></td></tr>
<tr class="separator:aad1e20030f38cf12a1bd73c7f2c657d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number&gt;<br />
class LinearAlgebra::distributed::BlockVector&lt; Number &gt;</h3>

<p>An implementation of block vectors based on distributed deal.II vectors. While the base class provides for most of the interface, this class handles the actual allocation of vectors and provides functions that are specific to the underlying vector type.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00084">84</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a2f13f25da5172afa079df9d2804cef98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f13f25da5172afa079df9d2804cef98">&#9670;&nbsp;</a></span>BaseClass</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a2f13f25da5172afa079df9d2804cef98">BaseClass</a> =  <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the base class for simpler access to its own alias. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00105">105</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="a976be8dace145bc740fc4b5eaa08ecfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a976be8dace145bc740fc4b5eaa08ecfc">&#9670;&nbsp;</a></span>BlockType</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a976be8dace145bc740fc4b5eaa08ecfc">BlockType</a> =  typename <a class="el" href="classBlockVectorBase.html#aeb971802cf05add5cf1c26338ce77a9b">BaseClass::BlockType</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Typedef the type of the underlying vector. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00110">110</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="a0a43b405989a623b76a92efe2dfa5e39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a43b405989a623b76a92efe2dfa5e39">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> =  typename <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">BaseClass::value_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import the alias from the base class. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00115">115</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ab99352244c902251dcd351118e7c468a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab99352244c902251dcd351118e7c468a">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> =  typename <a class="el" href="classBlockVectorBase.html#ab62c4ac95c3782bb2236bf67038adc20">BaseClass::real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00116">116</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="afc2cd36158818c25e48e79bc9f27827e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc2cd36158818c25e48e79bc9f27827e">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#afc2cd36158818c25e48e79bc9f27827e">pointer</a> =  typename <a class="el" href="classBlockVectorBase.html#aebed52638e6b26f5f18adec8a2437852">BaseClass::pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00117">117</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ae230c8ce0c95764c28d22176b8bd396a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae230c8ce0c95764c28d22176b8bd396a">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae230c8ce0c95764c28d22176b8bd396a">const_pointer</a> =  typename <a class="el" href="classBlockVectorBase.html#a46a99911c512a1a08d5c5e237986d765">BaseClass::const_pointer</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00118">118</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ae30d22265b642d73ed2ced13942ebb52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae30d22265b642d73ed2ced13942ebb52">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae30d22265b642d73ed2ced13942ebb52">reference</a> =  typename <a class="el" href="classBlockVectorBase.html#a9a15d476a8495a66f32508943c91294f">BaseClass::reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00119">119</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ab4bf062593cccb0f3f8c3daca8d77f6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bf062593cccb0f3f8c3daca8d77f6f">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab4bf062593cccb0f3f8c3daca8d77f6f">const_reference</a> =  typename <a class="el" href="classBlockVectorBase.html#a490c8bf68dceb08dc60c2a3e0c6bf2a2">BaseClass::const_reference</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00120">120</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="aa000c54aa3fc182e5f05422233af7257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa000c54aa3fc182e5f05422233af7257">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> =  typename <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">BaseClass::size_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00121">121</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="a6f9a7abde54c56cd458765868a4a6da3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9a7abde54c56cd458765868a4a6da3">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6f9a7abde54c56cd458765868a4a6da3">iterator</a> =  typename <a class="el" href="classBlockVectorBase.html#a38316f0d1b9b1e4fa4dc3e0b4e15655e">BaseClass::iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00122">122</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="ae404965061ae3d6eb991582f3c492e36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae404965061ae3d6eb991582f3c492e36">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae404965061ae3d6eb991582f3c492e36">const_iterator</a> =  typename <a class="el" href="classBlockVectorBase.html#a84ecd5753f1f75fbe1fa76e7ec72b3d8">BaseClass::const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00123">123</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a28bef4c0ba10221b1aeaf200f1bd8957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28bef4c0ba10221b1aeaf200f1bd8957">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. There are three ways to use this constructor. First, without any arguments, it generates an object with no blocks. Given one argument, it initializes <code>num_blocks</code> blocks, but these blocks have size zero. The third variant finally initializes all blocks to the same size <code>block_size</code>.</p>
<p>Confer the other constructor further down if you intend to use blocks of different sizes. </p>

</div>
</div>
<a id="a77e77142f145f27e6de83c7769fee866"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77e77142f145f27e6de83c7769fee866">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy-Constructor. Dimension set to that of V, all components are copied from V </p>

</div>
</div>
<a id="a6e6e3a3ba2c1ad09c7b2e9bde1fd52fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e6e3a3ba2c1ad09c7b2e9bde1fd52fd">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor taking a <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> of another data type. This will fail if there is no conversion path from <code>OtherNumber</code> to <code>Number</code>. Note that you may lose accuracy when copying to a <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> with data elements with less accuracy.</p>
<p>Older versions of gcc did not honor the <code>explicit</code> keyword on template constructors. In such cases, it is easy to accidentally write code that can be very inefficient, since the compiler starts performing hidden conversions. To avoid this, this function is disabled if we have detected a broken compiler during configuration. </p>

</div>
</div>
<a id="a632b36dc3cfbe1858681e56f985b8a8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a632b36dc3cfbe1858681e56f985b8a8a">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>block_sizes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Set the number of blocks to <code>block_sizes.size()</code> and initialize each block with <code>block_sizes[i]</code> zero elements. </p>

</div>
</div>
<a id="ad6a3fe3d069769bfe44cfbb12bb8d9ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a3fe3d069769bfe44cfbb12bb8d9ec">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a block vector with an <a class="el" href="classIndexSet.html">IndexSet</a> for the local range and ghost entries for each block. </p>

</div>
</div>
<a id="ae44f6a147f001ce40a3390356939cedb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae44f6a147f001ce40a3390356939cedb">&#9670;&nbsp;</a></span>BlockVector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classIndexSet.html">IndexSet</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>local_ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above but the ghost indices are assumed to be empty. </p>

</div>
</div>
<a id="a599e94513f88be426a73c5ad3162b27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a599e94513f88be426a73c5ad3162b27a">&#9670;&nbsp;</a></span>~BlockVector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::~<a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor.</p>
<dl class="section note"><dt>Note</dt><dd>We need to explicitly provide a destructor, otherwise the linker may think it is unused and discards it, although required in a different section. The Intel compiler is prone to this behavior. </dd></dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2b82aa81372ebfe22ed6968ef8317417"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b82aa81372ebfe22ed6968ef8317417">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy operator: fill all components of the vector with the given scalar value. </p>

</div>
</div>
<a id="a0069a784bc60ecfc7d87075927b4b086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0069a784bc60ecfc7d87075927b4b086">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for arguments of the same type. Resize the present vector if necessary. </p>

</div>
</div>
<a id="a631ced4f5e83bbf22ece66c4ee1ea301"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a631ced4f5e83bbf22ece66c4ee1ea301">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;class Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator for template arguments of different types. Resize the present vector if necessary. </p>

</div>
</div>
<a id="a0806d02bb7a443ef28e810d1f4fe7381"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0806d02bb7a443ef28e810d1f4fe7381">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a regular vector into a block vector. </p>

</div>
</div>
<a id="aaccfcceeeb6f47176b448d72945a112d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaccfcceeeb6f47176b448d72945a112d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1BlockVector.html">PETScWrappers::MPI::BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>petsc_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the content of a PETSc vector into the calling vector. This function assumes that the vectors layouts have already been initialized to match.</p>
<p>This operator is only available if deal.II was configured with PETSc. </p>

</div>
</div>
<a id="a3f521396d68256f73799da5a1460fdf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f521396d68256f73799da5a1460fdf7">&#9670;&nbsp;</a></span>operator=() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTrilinosWrappers_1_1MPI_1_1BlockVector.html">TrilinosWrappers::MPI::BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>trilinos_vec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the content of a Trilinos vector into the calling vector. This function assumes that the vectors layouts have already been initialized to match.</p>
<p>This operator is only available if deal.II was configured with Trilinos. </p>

</div>
</div>
<a id="a7833e60852b449291aa16fcfc5b3d600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7833e60852b449291aa16fcfc5b3d600">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>num_blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a>&#160;</td>
          <td class="paramname"><em>block_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> to contain <code>num_blocks</code> blocks of size <code>block_size</code> each.</p>
<p>If the second argument is left at its default value, then the block vector allocates the specified number of blocks but leaves them at zero size. You then need to later reinitialize the individual blocks, and call <a class="el" href="classBlockVectorBase.html#a6a27b2a48e5b5780cd0a6640b928d794">collect_sizes()</a> to update the block system's knowledge of its individual block's sizes.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros. </p>

</div>
</div>
<a id="ad74c8e31c81f8ef46b26d3c958125f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad74c8e31c81f8ef46b26d3c958125f22">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reinitialize the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a> such that it contains <code>block_sizes.size()</code> blocks. Each block is reinitialized to dimension <code>block_sizes[i]</code>.</p>
<p>If the number of blocks is the same as before this function was called, all vectors remain the same and <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> is called for each vector.</p>
<p>If <code>omit_zeroing_entries==false</code>, the vector is filled with zeros.</p>
<p>Note that you must call this (or the other <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions) function, rather than calling the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions of an individual block, to allow the block vector to update its caches of vector sizes. If you call <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> on one of the blocks, then subsequent actions on this object may yield unpredictable results since they may be routed to the wrong block. </p>

</div>
</div>
<a id="ab9ebeba63b750246591e48b468e3e737"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9ebeba63b750246591e48b468e3e737">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector <code>V</code>. The same applies as for the other <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> function.</p>
<p>The elements of <code>V</code> are not copied, i.e. this function is the same as calling <code>reinit (V.size(), omit_zeroing_entries)</code>.</p>
<p>Note that you must call this (or the other <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions) function, rather than calling the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> functions of an individual block, to allow the block vector to update its caches of vector sizes. If you call <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a7833e60852b449291aa16fcfc5b3d600">reinit()</a> of one of the blocks, then subsequent actions of this object may yield unpredictable results since they may be routed to the wrong block. </p>

</div>
</div>
<a id="a852d132f4827ec54f9583013a536761b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852d132f4827ec54f9583013a536761b">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the data that has accumulated in the data buffer for ghost indices to the owning processor. For the meaning of the argument <code>operation</code>, see the entry on <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed vectors and matrices</a> in the glossary.</p>
<p>There are two variants for this function. If called with argument <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code> adds all the data accumulated in ghost elements to the respective elements on the owning processor and clears the ghost array afterwards. If called with argument <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a></code>, a set operation is performed. Since setting elements in a vector with ghost elements is ambiguous (as one can set both the element on the ghost site as well as the owning site), this operation makes the assumption that all data is set correctly on the owning processor. Upon call of compress(VectorOperation::insert), all ghost entries are therefore simply zeroed out (using zero_ghost_values()). In debug mode, a check is performed that makes sure that the data set is actually consistent between processors, i.e., whenever a non-zero ghost element is found, it is compared to the value on the owning processor and an exception is thrown if these elements do not agree. </p>

</div>
</div>
<a id="aec81b97d7e38d836457bfbc7b2f20226"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec81b97d7e38d836457bfbc7b2f20226">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the data field for ghost indices with the values stored in the respective positions of the owning processor. This function is needed before reading from ghosts. The function is <code>const</code> even though ghost data is changed. This is needed to allow functions with a <code>const</code> vector to perform the data exchange without creating temporaries. </p>

</div>
</div>
<a id="ae9e0cf1c878130c12b0c16cad8da0610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e0cf1c878130c12b0c16cad8da0610">&#9670;&nbsp;</a></span>zero_out_ghosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::zero_out_ghosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000043">Deprecated:</a></b></dt><dd>Use <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa205bf18350c2095d459c75edfa622db">zero_out_ghost_values()</a> instead. </dd></dl>

</div>
</div>
<a id="aa205bf18350c2095d459c75edfa622db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa205bf18350c2095d459c75edfa622db">&#9670;&nbsp;</a></span>zero_out_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::zero_out_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state. </p>

</div>
</div>
<a id="a0ac470622adef2b2aec45be681112de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac470622adef2b2aec45be681112de3">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return if this <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> contains ghost elements. </p>

</div>
</div>
<a id="a872d9c74afd697767a824cdd69135ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a872d9c74afd697767a824cdd69135ba4">&#9670;&nbsp;</a></span>add() <span class="overload">[1/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a collective add operation that adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="ac1f222571d59cc48f9d505fc7ba4d8dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f222571d59cc48f9d505fc7ba4d8dd">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this)+V</code>. </p>

</div>
</div>
<a id="a809ec1490fd39c130932290aae65355c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a809ec1490fd39c130932290aae65355c">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a7df34df7e744cbfdb5cec39176821cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df34df7e744cbfdb5cec39176821cf1">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the mean value of all the entries in the vector. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#ab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ab588b3e1883730aff30b5408fcf22298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab588b3e1883730aff30b5408fcf22298">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements. </p>

</div>
</div>
<a id="a2072c8a6af39eb4ef8aa61e18b5864c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2072c8a6af39eb4ef8aa61e18b5864c1">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>Limitation: right now this function only works if both vectors have the same number of blocks. If needed, the numbers of blocks should be exchanged, too.</p>
<p>This function is analogous to the <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a2072c8a6af39eb4ef8aa61e18b5864c1">swap()</a> function of all C++ standard containers. Also, there is a global function swap(u,v) that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="a456e59ce23e0da8010f74d80875f6aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a456e59ce23e0da8010f74d80875f6aa5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector V. The elements of V are not copied. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a5be26d6eb72dcefdec2e2305d0e1c2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be26d6eb72dcefdec2e2305d0e1c2e6">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a4daee550e5e52be51395ca7afe42896d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4daee550e5e52be51395ca7afe42896d">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a4a97828f252550978a7525b82d1e1f92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a97828f252550978a7525b82d1e1f92">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the vector <code>V</code> to the present one. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a52fb6dc78db248d8b4749632ef52d36f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fb6dc78db248d8b4749632ef52d36f">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt;Number&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract the vector <code>V</code> from the present one. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a8143655154d18b0c5753b00158b2e2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8143655154d18b0c5753b00158b2e2f1">&#9670;&nbsp;</a></span>import()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>V</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a93f5bd0dc1f676eaf0747b580b6ca468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f5bd0dc1f676eaf0747b580b6ca468">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#abe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ae860233e47e643eb93892aa873da9889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae860233e47e643eb93892aa873da9889">&#9670;&nbsp;</a></span>multivector_inner_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename FullMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::multivector_inner_product </td>
          <td>(</td>
          <td class="paramtype">FullMatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the scalar product between each block of this vector and <code>V</code> and store the result in a full matrix <code>matrix</code>. This function computes the result by forming \(A_{ij}=U_i \cdot V_j\) where \(U_i\) and \(V_j\) indicate the \(i\)th block (not element!) of \(U\) and the \(j\)th block of \(V\), respectively. If <code>symmetric</code> is <code>true</code>, it is assumed that inner product results in a square symmetric matrix and almost half of the scalar products can be avoided.</p>
<p>Obviously, this function can only be used if all blocks of both vectors are of the same size.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, a single global reduction will be called to accumulate scalar product between locally owned degrees of freedom. </dd></dl>

</div>
</div>
<a id="aa0a5a9811aff25c8dd2a242d1e309547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a5a9811aff25c8dd2a242d1e309547">&#9670;&nbsp;</a></span>multivector_inner_product_with_metric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename FullMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::multivector_inner_product_with_metric </td>
          <td>(</td>
          <td class="paramtype">const FullMatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the scalar product between each block of this vector and <code>V</code> using a metric tensor <code>matrix</code>. This function computes the result of \( \sum_{ij} A^{ij} U_i \cdot V_j\) where \(U_i\) and \(V_j\) indicate the \(i\)th block (not element) of \(U\) and the \(j\)th block of \(V\), respectively. If <code>symmetric</code> is <code>true</code>, it is assumed that \(U_i \cdot V_j\) and \(A^{ij}\) are symmetric matrices and almost half of the scalar products can be avoided.</p>
<p>Obviously, this function can only be used if all blocks of both vectors are of the same size.</p>
<dl class="section note"><dt>Note</dt><dd>Internally, a single global reduction will be called to accumulate the scalar product between locally owned degrees of freedom. </dd></dl>

</div>
</div>
<a id="aeda5640c41b09bae50c6c3c6a863e289"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda5640c41b09bae50c6c3c6a863e289">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<div class="memtemplate">
template&lt;typename FullMatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const FullMatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em> = <code>Number(0.)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em> = <code>Number(1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set each block of this vector as follows: \(V^i = s V^i + b \sum_{j} U_j A^{ji}\) where \(V^i\) and \(U_j\) indicate the \(i\)th block (not element) of \(V\) and the \(j\)th block of \(U\), respectively.</p>
<p>Obviously, this function can only be used if all blocks of both vectors are of the same size. </p>

</div>
</div>
<a id="accecdd88bcfc805d1554fc99e8f05e38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accecdd88bcfc805d1554fc99e8f05e38">&#9670;&nbsp;</a></span>add() <span class="overload">[2/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>a</code> to all components. Note that <code>a</code> is a scalar not a vector. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ab0b1677974de1a51cade3dea2e268dd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0b1677974de1a51cade3dea2e268dd0">&#9670;&nbsp;</a></span>add() <span class="overload">[3/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a32a59caf6a091dc576366547bb71dc86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32a59caf6a091dc576366547bb71dc86">&#9670;&nbsp;</a></span>add() <span class="overload">[4/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#abc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a3515ad42ca76e04aed377d32d266daa6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3515ad42ca76e04aed377d32d266daa6">&#9670;&nbsp;</a></span>add() <span class="overload">[5/11]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="a5a306d119c19bffc19f7d99800e5de79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a306d119c19bffc19f7d99800e5de79">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code>*this = s*(*this)+a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a6b50074b32093b5471d1c7e033c0f2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b50074b32093b5471d1c7e033c0f2d6">&#9670;&nbsp;</a></span>scale() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ad8bc1dd4072504da9cbea82e6ba01180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8bc1dd4072504da9cbea82e6ba01180">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a2cdf84bbe46a886cdde6bad3a4246163"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdf84bbe46a886cdde6bad3a4246163">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>1</sub> norm of the vector (i.e., the sum of the absolute values of all entries among all processors). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a8fceaca158b4b7b17d280c618c469228"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fceaca158b4b7b17d280c618c469228">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_2\) norm of the vector (i.e., the square root of the sum of the square of all entries among all processors). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a52b4564def3f222e3c54266a61c75810"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52b4564def3f222e3c54266a61c75810">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\) norm of the vector. </p>

</div>
</div>
<a id="a1403274bfe2ad51433f205ae1a10b6ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1403274bfe2ad51433f205ae1a10b6ae">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ab99352244c902251dcd351118e7c468a">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum norm of the vector (i.e., the maximum absolute value among all entries and among all processors). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#af84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="af1c44bfad65af75c21d0d23af1125414"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c44bfad65af75c21d0d23af1125414">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a872d9c74afd697767a824cdd69135ba4">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value = *<span class="keyword">this</span> * W;</div></div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="af8d5be159fec545106c67bc940589fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8d5be159fec545106c67bc940589fcb">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aa000c54aa3fc182e5f05422233af7257">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global size of the vector, equal to the sum of the number of locally owned indices among all processors. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a468dfbd79a0d0d614327f292ee66f76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a468dfbd79a0d0d614327f292ee66f76a">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div></div><!-- fragment --> 
<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="abb764f033c38e246091f50d0ee3f8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb764f033c38e246091f50d0ee3f8b90">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a7d9c15a88fd2789219e70fd950d211e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9c15a88fd2789219e70fd950d211e6">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a6a27b2a48e5b5780cd0a6640b928d794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a27b2a48e5b5780cd0a6640b928d794">&#9670;&nbsp;</a></span>collect_sizes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::collect_sizes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Update internal structures after resizing vectors. Whenever you reinited a block of a block vector, the internal data structures are corrupted. Therefore, you should call this function after all blocks got their new size. </p>

</div>
</div>
<a id="ae05a0e26814f032473ed2ef66da018bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae05a0e26814f032473ed2ef66da018bd">&#9670;&nbsp;</a></span>block() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a976be8dace145bc740fc4b5eaa08ecfc">BlockType</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access to a single block. </p>

</div>
</div>
<a id="a1e309364bfcb70d14e5a57eea6d9cb19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e309364bfcb70d14e5a57eea6d9cb19">&#9670;&nbsp;</a></span>block() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a976be8dace145bc740fc4b5eaa08ecfc">BlockType</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::block </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read-only access to a single block. </p>

</div>
</div>
<a id="a231e1f385289359e66cadca8d9da5602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a231e1f385289359e66cadca8d9da5602">&#9670;&nbsp;</a></span>get_block_indices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classBlockIndices.html">BlockIndices</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::get_block_indices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a reference on the object that describes the mapping between block and global indices. The use of this function is highly deprecated and it should vanish in one of the next versions </p>

</div>
</div>
<a id="a3a0d11493903975ee387841aa3cb5fc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a0d11493903975ee387841aa3cb5fc4">&#9670;&nbsp;</a></span>n_blocks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::n_blocks </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Number of blocks. </p>

</div>
</div>
<a id="ae554df8459a4a08c3cd34c3655b1edba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae554df8459a4a08c3cd34c3655b1edba">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return local dimension of the vector. This is the sum of the local dimensions (i.e., values stored on the current processor) of all components. </p>

</div>
</div>
<a id="a7911affb07bbfc4a98704a98fafa2f72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7911affb07bbfc4a98704a98fafa2f72">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6f9a7abde54c56cd458765868a4a6da3">iterator</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element. </p>

</div>
</div>
<a id="af9a0800fc9df78b7914a7a4935472fa4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9a0800fc9df78b7914a7a4935472fa4">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae404965061ae3d6eb991582f3c492e36">const_iterator</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the first element of a constant block vector. </p>

</div>
</div>
<a id="aa2e328fa354198c4e77e9a81de88a726"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2e328fa354198c4e77e9a81de88a726">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a6f9a7abde54c56cd458765868a4a6da3">iterator</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end. </p>

</div>
</div>
<a id="abe6637f902ba0fe293b449d5ffdb6605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6637f902ba0fe293b449d5ffdb6605">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae404965061ae3d6eb991582f3c492e36">const_iterator</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of a constant block vector. </p>

</div>
</div>
<a id="acc43ed460b3575788288e9843a0873f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc43ed460b3575788288e9843a0873f0">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access components, returns U(i). </p>

</div>
</div>
<a id="ae6a568bb2c256eca3a79e0535101fe39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a568bb2c256eca3a79e0535101fe39">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae30d22265b642d73ed2ced13942ebb52">reference</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access components, returns U(i) as a writeable reference. </p>

</div>
</div>
<a id="aa64efc5a4048af8ead33432578e20153"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64efc5a4048af8ead33432578e20153">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access components, returns U(i).</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="ace443bdac1400b0760cef2a0e17b5bdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace443bdac1400b0760cef2a0e17b5bdc">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#ae30d22265b642d73ed2ced13942ebb52">reference</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Access components, returns U(i) as a writeable reference.</p>
<p>Exactly the same as operator(). </p>

</div>
</div>
<a id="a1972b4fd734c64bf54b45cd2fed11341"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1972b4fd734c64bf54b45cd2fed11341">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical. </dd></dl>

</div>
</div>
<a id="aebcfeb0925594a2013981d0c36f9a41d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebcfeb0925594a2013981d0c36f9a41d">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line">  *values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="ae3c7de4e771c97f5525ab54b3b3c25ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3c7de4e771c97f5525ab54b3b3c25ce">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; VectorType2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check for equality of two block vector types. This operation is only allowed if the two vectors already have the same block structure. </p>

</div>
</div>
<a id="a6117670ad088adf41d33fb31870dfbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6117670ad088adf41d33fb31870dfbee">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\(U = U * V\): scalar product. </p>

</div>
</div>
<a id="a6030680c6b6490b40619c0b86bcf3893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6030680c6b6490b40619c0b86bcf3893">&#9670;&nbsp;</a></span>add_and_dot() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a0a43b405989a623b76a92efe2dfa5e39">value_type</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Performs a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a872d9c74afd697767a824cdd69135ba4">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value = *<span class="keyword">this</span> * W;</div></div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately on deal.II's vector classes (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;Number&gt;</a> and LinearAlgebra::distributed::Vector&lt;double&gt;). This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

</div>
</div>
<a id="a8368f93764fdfbe650335472be132b1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8368f93764fdfbe650335472be132b1a">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given global index is in the local range of this processor. Asks the corresponding block. </p>

</div>
</div>
<a id="ad98b1e8ad77cb42c0f4fc572fd73c553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad98b1e8ad77cb42c0f4fc572fd73c553">&#9670;&nbsp;</a></span>is_non_negative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::is_non_negative </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return <code>true</code> if the vector has no negative entries, i.e. all entries are zero or positive. This function is used, for example, to check whether refinement indicators are really all positive (or zero). </p>

</div>
</div>
<a id="a3403ef2bfabddf775f62f5ca69d1409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3403ef2bfabddf775f62f5ca69d1409e">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Addition operator. Fast equivalent to <code>U.add(1, V)</code>. </p>

</div>
</div>
<a id="ac025c211c9866715e396122d037074fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac025c211c9866715e396122d037074fe">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtraction operator. Fast equivalent to <code>U.add(-1, V)</code>. </p>

</div>
</div>
<a id="a30f580d55ed6577e89a86edc3b8d7e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f580d55ed6577e89a86edc3b8d7e75">&#9670;&nbsp;</a></span>add() <span class="overload">[6/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="a0a419b4fc3c617910588872e562c9318"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a419b4fc3c617910588872e562c9318">&#9670;&nbsp;</a></span>add() <span class="overload">[7/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a second collective add operation. As a difference, this function takes a deal.II vector of values. </p>

</div>
</div>
<a id="afd0d690c8f24cc6352d741f0961bd248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd0d690c8f24cc6352d741f0961bd248">&#9670;&nbsp;</a></span>add() <span class="overload">[8/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a5c50677a9f39b52e75474f172059ed45">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Take an address where <code>n_elements</code> are stored contiguously and add them into the vector. Handles all cases which are not covered by the other two <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a872d9c74afd697767a824cdd69135ba4">add()</a></code> functions above. </p>

</div>
</div>
<a id="ab91dc0cc56bb74713d3fa4b98c63bcd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab91dc0cc56bb74713d3fa4b98c63bcd7">&#9670;&nbsp;</a></span>add() <span class="overload">[9/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>\(U(0-DIM)+=s\). Addition of <code>s</code> to all components. Note that <code>s</code> is a scalar and not a vector. </p>

</div>
</div>
<a id="aae697bc329049cdb045d11b8b1d9a01b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae697bc329049cdb045d11b8b1d9a01b">&#9670;&nbsp;</a></span>add() <span class="overload">[10/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U+=a*V. Simple addition of a scaled vector. </p>

</div>
</div>
<a id="a2d5c9c612d47ba6becd4200856fac480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d5c9c612d47ba6becd4200856fac480">&#9670;&nbsp;</a></span>add() <span class="overload">[11/11]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U+=a*V+b*W. Multiple addition of scaled vectors. </p>

</div>
</div>
<a id="a71b0ab8295e98caf3dfe1ef14ae6b6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71b0ab8295e98caf3dfe1ef14ae6b6c1">&#9670;&nbsp;</a></span>sadd() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U=s*U+V. Scaling and simple vector addition. </p>

</div>
</div>
<a id="a55b1daec966bbe66a1c5ad01cd1c43d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b1daec966bbe66a1c5ad01cd1c43d2">&#9670;&nbsp;</a></span>sadd() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U=s*U+a*V. Scaling and simple addition. </p>

</div>
</div>
<a id="aae8fd4a5640a0d1ca7d39621bdb3b61f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae8fd4a5640a0d1ca7d39621bdb3b61f">&#9670;&nbsp;</a></span>sadd() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U=s*U+a*V+b*W. Scaling and multiple addition. </p>

</div>
</div>
<a id="a65c94c564909a8eeca18c99d19d95f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65c94c564909a8eeca18c99d19d95f9e">&#9670;&nbsp;</a></span>sadd() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classVector.html">Vector</a>&lt; Number &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U=s*U+a*V+b*W+c*X. Scaling and multiple addition. </p>

</div>
</div>
<a id="a71cf6d7d6bcbc1fe64c64cf10824f0a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71cf6d7d6bcbc1fe64c64cf10824f0a3">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of the vector by a constant value. </p>

</div>
</div>
<a id="a13301b26e86abe6916a109165a019001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13301b26e86abe6916a109165a019001">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&amp; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of the vector by the inverse of the given value. </p>

</div>
</div>
<a id="ab84665a55ce69eeb5c951c009e47500e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84665a55ce69eeb5c951c009e47500e">&#9670;&nbsp;</a></span>scale() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const BlockVector2 &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply each element of this vector by the corresponding element of <code>v</code>. </p>

</div>
</div>
<a id="afe94f0b17a0eaaacbfdc8c55268d6a3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe94f0b17a0eaaacbfdc8c55268d6a3a">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classBlockVectorBase.html#a6055b029c116fd1fd580bfab2d4234ae">value_type</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const BlockVector2 &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>U=a*V. Assignment. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a6207efeaeff0d0f321b35d29d58e8df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6207efeaeff0d0f321b35d29d58e8df2">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does nothing and only exists for backward compatibility. </p>

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00225">225</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4b58ae27edeb2cbb96a5a2496109154b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b58ae27edeb2cbb96a5a2496109154b">&#9670;&nbsp;</a></span>communication_block_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>&lt; Number &gt;::communication_block_size = 20</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The chunks size to split communication in <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#aec81b97d7e38d836457bfbc7b2f20226">update_ghost_values()</a> and <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html#a852d132f4827ec54f9583013a536761b">compress()</a> calls.</p>
<p>Most common MPI implementations will get slow when too many messages/requests are outstanding. Even when messages are small, say 1 kB only, we should collect enough data with <code>communication_block_size</code> to cover typical infiniband latencies which are around a few microseconds. Sending 20 kB at a throughput of 5 GB/s takes 4 microseconds, so we should arrive at the bandwidth dominated regime then which is good enough. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__block__vector_8h_source.html#l00100">100</a> of file <a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a>.</p>

</div>
</div>
<a id="a732363be4cddc7dbb3ff940f95f37eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a732363be4cddc7dbb3ff940f95f37eac">&#9670;&nbsp;</a></span>components</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt; &gt; <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::components</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Pointer to the array of components. </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00949">949</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<a id="aad1e20030f38cf12a1bd73c7f2c657d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad1e20030f38cf12a1bd73c7f2c657d4">&#9670;&nbsp;</a></span>block_indices</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classBlockIndices.html">BlockIndices</a> <a class="el" href="classBlockVectorBase.html">BlockVectorBase</a>&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number &gt;  &gt;::block_indices</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Object managing the transformation between global indices and indices within the different blocks. </p>

<p class="definition">Definition at line <a class="el" href="block__vector__base_8h_source.html#l00955">955</a> of file <a class="el" href="block__vector__base_8h_source.html">block_vector_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="la__parallel__block__vector_8h_source.html">la_parallel_block_vector.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
