<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classTimeDependent.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: TimeDependent Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classTimeDependent-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">TimeDependent Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="time__dependent_8h_source.html">deal.II/numerics/time_dependent.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a55de3b5182ab608b2fb1f3f132d88f9e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9e">Direction</a> { <a class="el" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9ea43822403531b8faddaba4d2ed6773eef">forward</a>, 
<a class="el" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9ea62bce58174e641d7d14496ad66a68595">backward</a>
 }</td></tr>
<tr class="separator:a55de3b5182ab608b2fb1f3f132d88f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad2d9ed5517250a6703861853b377e371"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#ad2d9ed5517250a6703861853b377e371">TimeDependent</a> (const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;data_primal, const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;data_dual, const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;data_postprocess)</td></tr>
<tr class="separator:ad2d9ed5517250a6703861853b377e371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae2cf1a81fbbd208f255e25aa18abdd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a5ae2cf1a81fbbd208f255e25aa18abdd">~TimeDependent</a> ()</td></tr>
<tr class="separator:a5ae2cf1a81fbbd208f255e25aa18abdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0023778dc56fd5d8bed14e8f689c5f83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a0023778dc56fd5d8bed14e8f689c5f83">insert_timestep</a> (const <a class="el" href="classTimeStepBase.html">TimeStepBase</a> *position, <a class="el" href="classTimeStepBase.html">TimeStepBase</a> *new_timestep)</td></tr>
<tr class="separator:a0023778dc56fd5d8bed14e8f689c5f83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adceb99a948e2e1412085a56b4e787f68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#adceb99a948e2e1412085a56b4e787f68">add_timestep</a> (<a class="el" href="classTimeStepBase.html">TimeStepBase</a> *new_timestep)</td></tr>
<tr class="separator:adceb99a948e2e1412085a56b4e787f68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49ae1b02f0079ed7861688dc6ee764d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#ad49ae1b02f0079ed7861688dc6ee764d">delete_timestep</a> (const unsigned <a class="el" href="classint.html">int</a> position)</td></tr>
<tr class="separator:ad49ae1b02f0079ed7861688dc6ee764d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8d50f4e53e423097282db2d939ca62a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#aa8d50f4e53e423097282db2d939ca62a">solve_primal_problem</a> ()</td></tr>
<tr class="separator:aa8d50f4e53e423097282db2d939ca62a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56c5cf6247dea796e4eec7c3b6eec943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a56c5cf6247dea796e4eec7c3b6eec943">solve_dual_problem</a> ()</td></tr>
<tr class="separator:a56c5cf6247dea796e4eec7c3b6eec943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde6bd44420d6706ad84b55b15661aca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#afde6bd44420d6706ad84b55b15661aca">postprocess</a> ()</td></tr>
<tr class="separator:afde6bd44420d6706ad84b55b15661aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b8b2277df654ab4d9fe9809ffa374f2"><td class="memTemplParams" colspan="2">template&lt;typename InitFunctionObject , typename LoopFunctionObject &gt; </td></tr>
<tr class="memitem:a5b8b2277df654ab4d9fe9809ffa374f2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a5b8b2277df654ab4d9fe9809ffa374f2">do_loop</a> (InitFunctionObject init_function, LoopFunctionObject loop_function, const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;timestepping_data, const <a class="el" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9e">Direction</a> direction)</td></tr>
<tr class="separator:a5b8b2277df654ab4d9fe9809ffa374f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c1ff62023c2d26ba7fd2220fbe5b700"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a0c1ff62023c2d26ba7fd2220fbe5b700">start_sweep</a> (const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="classTimeDependent.html#ab8a97b3419a346419077941d082dfd73">sweep_no</a>)</td></tr>
<tr class="separator:a0c1ff62023c2d26ba7fd2220fbe5b700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397ecd00bd58479326460b6d91e0ab86"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a397ecd00bd58479326460b6d91e0ab86">end_sweep</a> ()</td></tr>
<tr class="separator:a397ecd00bd58479326460b6d91e0ab86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a145fa0199ac7c678cc3f28f84f757af6"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a145fa0199ac7c678cc3f28f84f757af6">memory_consumption</a> () const</td></tr>
<tr class="separator:a145fa0199ac7c678cc3f28f84f757af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d42edbea290d936a5318e3326f5b946"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a7d42edbea290d936a5318e3326f5b946">DeclExceptionMsg</a> (ExcInvalidPosition, &quot;You cannot insert a time step at the specified position.&quot;)</td></tr>
<tr class="separator:a7d42edbea290d936a5318e3326f5b946"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a45bc5cb4c0dc165e66030436e86bda32"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classSmartPointer.html">SmartPointer</a>&lt; <a class="el" href="classTimeStepBase.html">TimeStepBase</a>, <a class="el" href="classTimeDependent.html">TimeDependent</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a></td></tr>
<tr class="separator:a45bc5cb4c0dc165e66030436e86bda32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8a97b3419a346419077941d082dfd73"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#ab8a97b3419a346419077941d082dfd73">sweep_no</a></td></tr>
<tr class="separator:ab8a97b3419a346419077941d082dfd73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a337854b0a7c9361c65520fc57e61dc99"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a337854b0a7c9361c65520fc57e61dc99">timestepping_data_primal</a></td></tr>
<tr class="separator:a337854b0a7c9361c65520fc57e61dc99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9faffa5541ca5d3bd30961a0b7fcfaa5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#a9faffa5541ca5d3bd30961a0b7fcfaa5">timestepping_data_dual</a></td></tr>
<tr class="separator:a9faffa5541ca5d3bd30961a0b7fcfaa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7a70165a5a2e9b4bf9f360fc4160fc5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#af7a70165a5a2e9b4bf9f360fc4160fc5">timestepping_data_postprocess</a></td></tr>
<tr class="separator:af7a70165a5a2e9b4bf9f360fc4160fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad9b1d6fcafcdee7cab466ecc7917ce33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classTimeDependent.html#ad9b1d6fcafcdee7cab466ecc7917ce33">end_sweep</a> (const unsigned <a class="el" href="classint.html">int</a> begin_timestep, const unsigned <a class="el" href="classint.html">int</a> end_timestep)</td></tr>
<tr class="separator:ad9b1d6fcafcdee7cab466ecc7917ce33"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>这个类为时间相关问题提供了一个抽象接口，它解决了这一类问题中最令人讨厌的一些方面：数据管理。这些问题经常需要大量的计算机资源，最明显的是计算时间、主内存和磁盘空间。减少主内存往往是最迫切的需求，不过实现它的方法几乎总是相当混乱，很快就会导致代码在散落在程序各处的地方存储和重新加载数据，而且有时变得无法维护。本类试图提供一个更加结构化的接口，尽管很简单，这是在我搞了几个月的波浪方程模拟之后在我的脑海中出现的。 这个类的设计主要是为解决与时间有关的偏微分方程而定制的，在这些方程中，每两个时间段的计算网格可能不同，而且与这个类的开销相比，每个时间段的计算需要相当长的时间。由于本类中没有提到问题的类别，因此它并不局限于PDEs，尽管如此，大型普通矩阵微分方程的求解器似乎有可能成功地使用相同的设置，因此本类。</p>
<h3>Overview</h3>
<p>使用时间步进方案的时间相关问题求解器的一般结构大约如下：我们有一个时间步进对象的集合，我们随后在其上求解我们的问题。为了做到这一点，我们需要知道之前的零个或几个时间步长的数据（当使用单步或多步方法时，即），也许还需要一些时间步长的数据（例如，这些时间步长的计算网格）。根据有关问题，可以在所有时间步上进行第二次循环，解决一个对偶问题，循环可以向前运行（每个时间步的一个对偶问题）或向后运行（使用一个全局对偶问题）。在这些循环中的一个或使用一个单独的循环，可以计算误差估计值并完善网格。这些循环中的每一个都是由一个为下一个循环准备每个时间步对象的调用开始的，然后才实际开始循环本身。 我们将用术语 "扫频
  "来表示所有这些循环的完整集合。由于这个库主要是关于自适应方法的，所以在一个扫频中的最后一个循环可能会产生精炼的网格，我们将对这些精炼的网格进行另一次扫频。因此，一个总的运行往往是几个扫频的序列。因此，全局设置看起来像这样。</p>
<pre class="fragment">*  for sweep=0 to n_sweeps-1
*  {
*    for i=0 to n_timesteps-1
*      initialize timestep i for this sweep, e.g. for setting up
*      data structures, creating temporary files, etc.
*
*    for i=0 to n_timesteps-1
*      prepare timestep i for loop 0
*    for i=0 to n_timesteps-1
*      perform loop 0 on timestep i   (e.g. solve primal problem)
*
*    for i=0 to n_timesteps-1
*      prepare timestep i for loop 1
*    for i=0 to n_timesteps-1
*      perform loop 1 on timestep i   (e.g. solve dual problem)
*
*    for i=0 to n_timesteps-1
*      prepare timestep i for loop 2
*    for i=0 to n_timesteps-1
*      perform loop 2 on timestep i   (e.g. compute error information)
*
*    ...
*
*    for i=0 to n_timesteps-1
*      notify timestep i of the end of the sweep, e.g. for cleanups,
*      deletion of temporary files, etc.
*  }
* </pre><p> 用户可以指定一个循环应向前或向后运行（例如，后者是解决全局对偶问题所需要的）。 从全局的角度来看，我们注意到，当一个循环访问一个时间段时（例如，解决原始或对偶问题，或计算误差信息），我们需要关于这个时间段、之前的一个或多个时间段以及未来的零个或多个时间段的信息。然而，往往不需要知道这些时间步骤的所有信息，而且在不再需要数据的时候，在第一个可能的时间删除数据往往是一种计算要求。同样，数据也应该在可能的最晚时间被重新加载。 为了促进这些原则，开发了唤醒和让一个时间步长对象睡眠的概念。假设我们有一个时间步长方案，需要向前看一个时间步长，并且需要最后两个时间步长的数据，下面的伪代码描述了当我们从时间步长 <code>n-1移到时间步长</code> <code>n:</code> 时，这个类的中心循环函数将做什么</p>
<pre class="fragment">* wake up timestep n+1 with signal 1
* wake up timestep n with signal 0
* do computation on timestep n
* let timestep n sleep with signal 0
* let timestep n-1 sleep with signal 1
* let timestep n-2 sleep with signal 2
*
* move from n to n+1
* </pre><p> 这里的信号号表示被发送信号的时间段到进行计算的时间段的距离。对 <code>wake_up和</code> <code>sleep</code> 函数的信号0的调用原则上可以被吸收到进行计算的函数中；然而，我们使用这些多余的信号是为了将计算和数据管理相互分离，允许将所有围绕网格管理、数据重载和存储的东西放到一组函数中，而将计算放到另一组中。 在上面的例子中，可能的动作是：时间步数<code>n+1</code>重建计算网格（有一个专门的类可以为你做这个）；时间步数 <code>n</code> 建立矩阵并将解决方案向量设置为合适的大小，也许使用一个初始猜测；然后它进行计算；然后它删除矩阵，因为它们不被后续时间步数需要；时间步数 <code>n-1</code> ]删除那些只被前面一个时间步骤所需要的数据向量；时间步骤 <code>n-2</code> 删除剩余的向量并删除计算网格，在某处存储如何最终重建它的信息。 从上面给定的草图中可以看出，每个时间步骤对象都看到以下的事件序列。</p>
<pre class="fragment">* wake up with signal 1
* wake up with signal 0
* do computation
* sleep with signal 0
* sleep with signal 1
* sleep with signal 2
* </pre><p> 这个模式对每个扫频中的每个循环都是重复的。 对于每个扫频中的不同循环，可以分别选择向前看（即对 <code>wake_up</code> 函数的最大信号数）和向后看（即对 <code>sleep</code> 函数的最大信号数）的时间步数。例如，在计算误差估计时，通常只需要往后看一个时间步长（在某些情况下，甚至可以完全不往前看或往后看，在这种情况下，将只发送零号信号），而对于时间步长法，则需要至少往后看一个。 最后，关于前看和后看的方向的说明：前看总是指循环运行的方向，即对于向前运行的循环， <code>wake_up</code> 是为时间值大于先前计算的时间段对象而调用的，而 <code>sleep</code> 是为时间值较低的时间段调用的。如果循环运行的方向相反，例如在解决一个全局对偶问题时，这个顺序是相反的。</p>
<h3>Implementation</h3>
<p>使用这个类的程序的主循环通常会像下面这样，从一个没有作为库的一部分分发的应用程序中修改而来。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> TimeDependent_Wave&lt;dim&gt;::run_sweep (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> <a class="code" href="classTimeDependent.html#ab8a97b3419a346419077941d082dfd73">sweep_no</a>)</div><div class="line">{</div><div class="line">  <a class="code" href="classTimeDependent.html#a0c1ff62023c2d26ba7fd2220fbe5b700">start_sweep</a> (sweep_no);</div><div class="line"></div><div class="line">  <a class="code" href="classTimeDependent.html#aa8d50f4e53e423097282db2d939ca62a">solve_primal_problem</a> ();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (compute_dual_problem)</div><div class="line">    <a class="code" href="classTimeDependent.html#a56c5cf6247dea796e4eec7c3b6eec943">solve_dual_problem</a> ();</div><div class="line"></div><div class="line">  <a class="code" href="classTimeDependent.html#afde6bd44420d6706ad84b55b15661aca">postprocess</a> ();</div><div class="line"></div><div class="line">  <span class="keywordflow">if</span> (sweep_no != number_of_sweeps-1)</div><div class="line">    refine_grids ();</div><div class="line"></div><div class="line">  write_statistics ();</div><div class="line"></div><div class="line">  <a class="code" href="classTimeDependent.html#a397ecd00bd58479326460b6d91e0ab86">end_sweep</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">template</span> &lt;<span class="keywordtype">int</span> dim&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="namespaceWorkStream_1_1internal_1_1tbb__no__coloring.html#a8673698a405bf47aa24002aeb6d76d70">WaveProblem&lt;dim&gt;::run</a> ()</div><div class="line">{</div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sweep=0; sweep&lt;number_of_sweeps; ++sweep)</div><div class="line">    timestep_manager.run_sweep (sweep);</div><div class="line">}</div></div><!-- fragment --><p> 这里， <code>timestep_manager</code> 是一个类型为TimeDependent_Wave&lt;dim&gt;的对象，它是一个从TimeDependent派生的类。 <code>start_sweep</code>, <code>solve_primal_problem</code>, <code>solve_dual_problem</code>, <code>postprocess</code> 和 <code>end_sweep</code> 是继承自这个类的函数。它们都在这个对象中的所有时间段上做循环，并在每个对象上调用各自的函数。例如，这里有两个函数是由库实现的。</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> <a class="code" href="classTimeDependent.html#a0c1ff62023c2d26ba7fd2220fbe5b700">TimeDependent::start_sweep</a> (<span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> s)</div><div class="line">{</div><div class="line">  sweep_no = s;</div><div class="line"></div><div class="line"> <span class="comment">// reset the number each time step has, since some time steps might have</span></div><div class="line"> <span class="comment">// been added since the last time we visited them.</span></div><div class="line"> <span class="comment">// also set the sweep we will process in the sequel</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;<a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>.size(); ++step)</div><div class="line">    {</div><div class="line">      <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step]-&gt;set_timestep_no (step);</div><div class="line">      <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step]-&gt;set_sweep_no (sweep_no);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;<a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>.size(); ++step)</div><div class="line">    <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step]-&gt;<a class="code" href="classTimeDependent.html#a0c1ff62023c2d26ba7fd2220fbe5b700">start_sweep</a> ();</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"><span class="keywordtype">void</span></div><div class="line"><a class="code" href="classTimeDependent.html#aa8d50f4e53e423097282db2d939ca62a">TimeDependent::solve_primal_problem</a> ()</div><div class="line">{</div><div class="line">  <a class="code" href="classTimeDependent.html#a5b8b2277df654ab4d9fe9809ffa374f2">do_loop</a>([](TimeStepBaseconst time_step)</div><div class="line">            { time_step-&gt;init_for_primal_problem(); },</div><div class="line">          [](TimeStepBaseconst time_step)</div><div class="line">            { time_step-&gt;solve_primal_problem(); },</div><div class="line">          <a class="code" href="classTimeDependent.html#a337854b0a7c9361c65520fc57e61dc99">timestepping_data_primal</a>,</div><div class="line">          <a class="code" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9ea43822403531b8faddaba4d2ed6773eef">forward</a>);</div><div class="line">}</div></div><!-- fragment --><p> 后一个函数相当清楚地显示了大多数循环的调用方式（ <code>solve_primal_problem</code>, <code>solve_dual_problem</code>, <code>postprocess</code>, <code>refine_grids和</code> <code>write_statistics</code> 都有这种形式，其中后两个函数给出了派生时间段类的函数，而不是来自基类）。函数 <a class="el" href="classTimeStepBase.html#aef78d3a32f19ecbf80dd7a29382cb7c9">TimeStepBase::init_for_primal_problem</a> 和该类定义的其他操作的相应函数仅用于存储目前执行的循环将进行的操作类型。 可以看出，大部分工作是由该类的 <code>do_loop</code> 函数完成的，它接收两个函数的地址，这两个函数用于初始化循环的所有时间步长对象和实际执行一些动作。下一个参数给出了一些关于前视和后视的信息，最后一个参数表示了循环运行的方向。 使用lambda函数可以做一些巧妙的技巧，就像下面这种情况下的函数 <code>refine_grids:</code> 。</p>
<div class="fragment"><div class="line">...</div><div class="line">compute the thresholds <span class="keywordflow">for</span> refinement</div><div class="line">...</div><div class="line"></div><div class="line">do_loop([](<a class="code" href="classTimeStepBase__Tria.html">TimeStepBase_Tria&lt;dim&gt;</a><span class="keyword">const</span> time_step)</div><div class="line">          { time_step-&gt;<a class="code" href="classTimeStepBase__Tria.html#a734c4f6ab0d400f3955ac799c6d80343">init_for_refinement</a>(); },</div><div class="line">        [=](TimeStepBase_Wave&lt;dim&gt;<span class="keyword">const</span> time_step)</div><div class="line">          {</div><div class="line">            time_step-&gt;<a class="code" href="classTimeStepBase.html#ac1f547b8bebb845180be381c667f273f">solve_primal_problem</a>(</div><div class="line">              <a class="code" href="classTimeStepBase__Tria.html#aa66d0a5c91d8b3ec9b80ff60a3c8e711">TimeStepBase_Tria&lt;dim&gt;::RefinementData</a> (</div><div class="line">                top_threshold, bottom_threshold)));</div><div class="line">          },</div><div class="line">        <a class="code" href="structTimeDependent_1_1TimeSteppingData.html">TimeDependent::TimeSteppingData</a> (0,1),</div><div class="line">        <a class="code" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9ea43822403531b8faddaba4d2ed6773eef">TimeDependent::forward</a>);</div></div><!-- fragment --><p> TimeStepBase_Wave&lt;dim&gt;::refine_grid 是一个带参数的函数，与上面在循环中使用的所有其他函数不同。然而，在这种特殊情况下，参数对所有时间段都是一样的，而且在循环开始之前就已经知道了，所以我们把它固定下来，做成一个对外界来说不需要参数的函数对象。 因为它是这个类的中心函数，所以我们最后展示了一个精简版的 <code>do_loop</code> 方法，展示它的目的是为了让大家更好地了解这个类的内部结构。为了简洁起见，我们省略了处理向后运行循环的部分，以及检查唤醒和睡眠操作是否在<code>0...n_timesteps-1</code>以外的时间步长上进行。</p>
<div class="fragment"><div class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InitFunctionObject, <span class="keyword">typename</span> LoopFunctionObject&gt;</div><div class="line"><span class="keywordtype">void</span> <a class="code" href="classTimeDependent.html#a5b8b2277df654ab4d9fe9809ffa374f2">TimeDependent::do_loop</a> (InitFunctionObject      init_function,</div><div class="line">                        LoopFunctionObject      loop_function,</div><div class="line">                        <span class="keyword">const</span> TimeSteppingData &amp;timestepping_data,</div><div class="line">                        <span class="keyword">const</span> <a class="code" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9e">Direction</a>         direction)</div><div class="line">{</div><div class="line">  <span class="comment">// initialize the time steps for a round of this loop</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;n_timesteps; ++step)</div><div class="line">    init_function (static_cast&lt;typename InitFunctionObject::argument_type&gt;</div><div class="line">                     (<a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step]));</div><div class="line"></div><div class="line">  <span class="comment">// wake up the first few time levels</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> step=-timestepping_data.look_ahead; step&lt;0; ++step)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> look_ahead=0;</div><div class="line">         look_ahead&lt;=timestepping_data.look_ahead;</div><div class="line">         ++look_ahead)</div><div class="line">      <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step+look_ahead]-&gt;wake_up(look_ahead);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> step=0; step&lt;n_timesteps; ++step)</div><div class="line">    {</div><div class="line">      <span class="comment">// first thing: wake up the timesteps ahead as necessary</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> look_ahead=0;</div><div class="line">           look_ahead&lt;=timestepping_data.look_ahead;</div><div class="line">           ++look_ahead)</div><div class="line">        <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step+look_ahead]-&gt;wake_up(look_ahead);</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">      <span class="comment">// actually do the work</span></div><div class="line">      loop_function(</div><div class="line">        static_cast&lt;typename LoopFunctionObject::argument_type&gt; (</div><div class="line">          <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step]));</div><div class="line"></div><div class="line">      <span class="comment">// let the timesteps behind sleep</span></div><div class="line">      <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> look_back=0;</div><div class="line">           look_back&lt;=timestepping_data.look_back;</div><div class="line">           ++look_back)</div><div class="line">        <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step-look_back]-&gt;sleep(look_back);</div><div class="line">    }</div><div class="line"></div><div class="line">  <span class="comment">// make the last few timesteps sleep</span></div><div class="line">  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> step=n_timesteps;</div><div class="line">       step&lt;=n_timesteps+timestepping_data.look_back;</div><div class="line">       ++step)</div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> look_back=0;</div><div class="line">         look_back&lt;=timestepping_data.look_back;</div><div class="line">         ++look_back)</div><div class="line">      <a class="code" href="classTimeDependent.html#a45bc5cb4c0dc165e66030436e86bda32">timesteps</a>[step-look_back]-&gt;sleep(look_back);</div><div class="line">}</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00292">292</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a55de3b5182ab608b2fb1f3f132d88f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55de3b5182ab608b2fb1f3f132d88f9e">&#9670;&nbsp;</a></span>Direction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9e">TimeDependent::Direction</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>枚举提供了由 <code>do_loop执行的循环可能运行的不同方向。</code> </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a55de3b5182ab608b2fb1f3f132d88f9ea43822403531b8faddaba4d2ed6773eef"></a>forward&#160;</td><td class="fielddoc"><p>往前走。 </p>
</td></tr>
<tr><td class="fieldname"><a id="a55de3b5182ab608b2fb1f3f132d88f9ea62bce58174e641d7d14496ad66a68595"></a>backward&#160;</td><td class="fielddoc"><p>在后退方向上走。 </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00335">335</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad2d9ed5517250a6703861853b377e371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2d9ed5517250a6703861853b377e371">&#9670;&nbsp;</a></span>TimeDependent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimeDependent::TimeDependent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;&#160;</td>
          <td class="paramname"><em>data_primal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;&#160;</td>
          <td class="paramname"><em>data_dual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;&#160;</td>
          <td class="paramname"><em>data_postprocess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00042">42</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="a5ae2cf1a81fbbd208f255e25aa18abdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae2cf1a81fbbd208f255e25aa18abdd">&#9670;&nbsp;</a></span>~TimeDependent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">TimeDependent::~TimeDependent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>销毁器。这将删除给<code>insert_*</code>和 <code>add_timestep</code> 函数的指针所指向的对象，也就是说，它将删除在每个时间步长进行计算的对象。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00052">52</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0023778dc56fd5d8bed14e8f689c5f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0023778dc56fd5d8bed14e8f689c5f83">&#9670;&nbsp;</a></span>insert_timestep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::insert_timestep </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTimeStepBase.html">TimeStepBase</a> *&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTimeStepBase.html">TimeStepBase</a> *&#160;</td>
          <td class="paramname"><em>new_timestep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在任何位置添加一个时间步长。该位置是一个指向现有时间步长对象的指针，或者一个表示时间步长序列结束的空指针。如果 <code>position</code> 为非空，新的时间步长将被插入到相应的元素之前。 请注意，通过将一个对象交给这个函数，TimeDependent对象承担了该对象的所有权；因此它也将负责删除其管理的对象。 还有一个函数， <code>add_timestep</code>, ，在列表的末尾插入一个时间步骤。 注意，这个函数不会改变存储在其他时间步长对象中的时间步长，也不会设置这个新时间步长的时间步长。这只有在调用 <code>start_sweep</code> 函数时才会完成。在不改变时间步数的情况下，对时空三角的操作更简单，因为可以一直使用上一次扫频中使用的时间步数。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00065">65</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="adceb99a948e2e1412085a56b4e787f68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adceb99a948e2e1412085a56b4e787f68">&#9670;&nbsp;</a></span>add_timestep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::add_timestep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTimeStepBase.html">TimeStepBase</a> *&#160;</td>
          <td class="paramname"><em>new_timestep</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>就像 <code>insert_timestep</code>, 一样，但在最后插入。 这种机制通常会导致像这样的设置循环 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">int</span> i=0; i&lt;<a class="code" href="namespaceLAPACKSupport.html#a8edacd69ab93285f82b7f63c733a86b7">N</a>; ++i)</div><div class="line">manager.add_timestep(<span class="keyword">new</span> MyTimeStep());</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00127">127</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="ad49ae1b02f0079ed7861688dc6ee764d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49ae1b02f0079ed7861688dc6ee764d">&#9670;&nbsp;</a></span>delete_timestep()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::delete_timestep </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>position</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>删除一个时间段。只有当你想在两次扫描之间删除它时，才有必要调用这个功能；在这个对象的生命周期结束时，会自动注意删除时间步长对象。解构器对对象的删除也是通过这个函数完成的。 注意，这个函数不会改变存储在其他时间步数对象中的时间步数。这只有在调用 <code>start_sweep函数时才会完成。在不改变时间步数的情况下，对时空三角的操作更加简单，因为可以一直使用上一次扫频中使用的时间步数。</code> </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00134">134</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="aa8d50f4e53e423097282db2d939ca62a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8d50f4e53e423097282db2d939ca62a">&#9670;&nbsp;</a></span>solve_primal_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::solve_primal_problem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>解决原始问题；通过TimeStepBase类的 <code>init_for_primal_problem</code> 和 <code>solve_primal_problem</code> do_loop函数使用该类的函数。 向前看和向后看是由给构造函数的 <code>timestepping_data_primal对象决定的。</code> </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00169">169</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="a56c5cf6247dea796e4eec7c3b6eec943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56c5cf6247dea796e4eec7c3b6eec943">&#9670;&nbsp;</a></span>solve_dual_problem()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::solve_dual_problem </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>解决对偶问题；通过TimeStepBase类的 <code>do_loop</code> 函数使用该类的 <code>init_for_dual_problem</code> 和 <code>solve_dual_problem</code> 函数。 向前看和向后看是由给构造函数的 <code>timestepping_data_dual</code> 对象决定的。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00180">180</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="afde6bd44420d6706ad84b55b15661aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afde6bd44420d6706ad84b55b15661aca">&#9670;&nbsp;</a></span>postprocess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::postprocess </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>做一轮后处理；通过本类的 <code>do_loop</code> 函数使用TimeStepBase类的 <code>init_for_postprocessing</code> 和 <code>postprocess</code> 函数。 向前看和向后看是由给构造函数的 <code>timestepping_data_postprocess对象决定的。</code> </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00191">191</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="a5b8b2277df654ab4d9fe9809ffa374f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b8b2277df654ab4d9fe9809ffa374f2">&#9670;&nbsp;</a></span>do_loop()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename InitFunctionObject , typename LoopFunctionObject &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::do_loop </td>
          <td>(</td>
          <td class="paramtype">InitFunctionObject&#160;</td>
          <td class="paramname"><em>init_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">LoopFunctionObject&#160;</td>
          <td class="paramname"><em>loop_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> &amp;&#160;</td>
          <td class="paramname"><em>timestepping_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9e">Direction</a>&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在所有时间步长上做一个循环，在开始时调用 <code>init_function</code> ，在每个时间步长的 <code>loop_function</code> 上调用。 <code>timestepping_data</code> 决定在当前时间段前后有多少个时间段调用 <code>wake_up和</code> <code>sleep</code> 函数。 为了了解这个函数的工作原理，请注意，函数 <code>solve_primal_problem只包括以下调用。</code> </p><div class="fragment"><div class="line"><a class="code" href="classTimeDependent.html#a5b8b2277df654ab4d9fe9809ffa374f2">do_loop</a>([](TimeStepBaseconst time_step)</div><div class="line">        { time_step-&gt;init_for_primal_problem(); },</div><div class="line">      [](TimeStepBaseconst time_step)</div><div class="line">        { time_step-&gt;solve_primal_problem(); },</div><div class="line">      <a class="code" href="classTimeDependent.html#a337854b0a7c9361c65520fc57e61dc99">timestepping_data_primal</a>,</div><div class="line">      <a class="code" href="classTimeDependent.html#a55de3b5182ab608b2fb1f3f132d88f9ea43822403531b8faddaba4d2ed6773eef">forward</a>);</div></div><!-- fragment --><p> 还请注意，这两个函数所来自的给定类不一定是TimeStepBase，但也可以是一个派生类，即 <code>static_castable</code> 来自一个TimeStepBase。该函数可以是该类的一个虚函数（甚至是一个纯函数），如果实现该函数的实际类是一个通过虚基类派生的类，从而无法通过 <code>static_cast</code> 从TimeStepBase类到达，这应该会有帮助。 不使用上述形式，你同样可以使用<code>[args...](Xconst x){x-&gt;unary_function(args...);}</code>，让 <code>do_loop</code> 函数用指定参数调用给定的函数。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l01209">1209</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<a id="a0c1ff62023c2d26ba7fd2220fbe5b700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c1ff62023c2d26ba7fd2220fbe5b700">&#9670;&nbsp;</a></span>start_sweep()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::start_sweep </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>sweep_no</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为下一次扫描初始化对象。这个函数具体做了以下工作：给每个时间层分配它目前在数组中的编号（如果时间层被插入或删除，这个编号可能会改变），并将本次扫描的编号传送给这些对象。 在上述数字设定后，它还调用每个时间层对象的 <code>start_sweep</code> 函数。 这个函数是虚拟的，所以你可以重载它。然而，你不应该忘记在你的重载版本中也调用这个函数，最好是在你的函数的开头，因为这是某种 "类似构造器 "的函数，应该自下而上地调用。 这个函数的默认实现在所有时间步长对象上调用 <code>start_sweep</code> 。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00203">203</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="a397ecd00bd58479326460b6d91e0ab86"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397ecd00bd58479326460b6d91e0ab86">&#9670;&nbsp;</a></span>end_sweep() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::end_sweep </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与上述函数类似，调用每个时间步长对象的 <code>end_sweep</code> 。这个函数的 <code>virtualness</code> 与前一个函数的 <code>virtualness</code> 同样适用。 </p><dl class="section note"><dt>Note</dt><dd>这个函数并不保证 <code>end_sweep</code> 对连续的时间步长连续调用，相反，调用该函数的时间步长对象的顺序是任意的。因此，你不应该认为该函数已经为以前的时间步数调用过了。如果在多线程模式下，几个时间步骤的 <code>end_sweep</code> 函数可能会被同时调用，所以如果你的程序需要，你应该使用同步机制。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00227">227</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="a145fa0199ac7c678cc3f28f84f757af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a145fa0199ac7c678cc3f28f84f757af6">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t TimeDependent::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00250">250</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<a id="a7d42edbea290d936a5318e3326f5b946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d42edbea290d936a5318e3326f5b946">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TimeDependent::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidPosition&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You cannot insert a time step at the specified position.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况。 </p>

</div>
</div>
<a id="ad9b1d6fcafcdee7cab466ecc7917ce33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9b1d6fcafcdee7cab466ecc7917ce33">&#9670;&nbsp;</a></span>end_sweep() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void TimeDependent::end_sweep </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>begin_timestep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>end_timestep</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>只对某些时间段做<code><a class="el" href="classTimeDependent.html#a397ecd00bd58479326460b6d91e0ab86">end_sweep()</a>/tt&gt;的工作。这在多线程模式下是很有用的。 </code></p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8cc_source.html#l00241">241</a> of file <a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a45bc5cb4c0dc165e66030436e86bda32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45bc5cb4c0dc165e66030436e86bda32">&#9670;&nbsp;</a></span>timesteps</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classSmartPointer.html">SmartPointer</a>&lt;<a class="el" href="classTimeStepBase.html">TimeStepBase</a>, <a class="el" href="classTimeDependent.html">TimeDependent</a>&gt; &gt; TimeDependent::timesteps</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>持有指向时间级别对象的指针的向量。这是此对象操作的主要数据。请注意，这个对象占有这个集合中的指针所指向的对象。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00511">511</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<a id="ab8a97b3419a346419077941d082dfd73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8a97b3419a346419077941d082dfd73">&#9670;&nbsp;</a></span>sweep_no</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> TimeDependent::sweep_no</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>当前扫频的编号。这将由每次扫描开始时调用的 <code>start_sweep</code> 函数重置。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00518">518</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<a id="a337854b0a7c9361c65520fc57e61dc99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a337854b0a7c9361c65520fc57e61dc99">&#9670;&nbsp;</a></span>timestepping_data_primal</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> TimeDependent::timestepping_data_primal</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些告诉 <code>solve_primal_problem</code> 函数要做什么的标志。更多信息请参见该结构的文档。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00525">525</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<a id="a9faffa5541ca5d3bd30961a0b7fcfaa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9faffa5541ca5d3bd30961a0b7fcfaa5">&#9670;&nbsp;</a></span>timestepping_data_dual</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> TimeDependent::timestepping_data_dual</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些告诉 <code>solve_dual_problem</code> 函数要做什么的标志。更多信息请参见此结构的文档。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00532">532</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<a id="af7a70165a5a2e9b4bf9f360fc4160fc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7a70165a5a2e9b4bf9f360fc4160fc5">&#9670;&nbsp;</a></span>timestepping_data_postprocess</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structTimeDependent_1_1TimeSteppingData.html">TimeSteppingData</a> TimeDependent::timestepping_data_postprocess</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一些告诉 <code>postprocess</code> 函数要做什么的标志。更多信息请参见此结构的文档。 </p>

<p class="definition">Definition at line <a class="el" href="time__dependent_8h_source.html#l00539">539</a> of file <a class="el" href="time__dependent_8h_source.html">time_dependent.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/numerics/<a class="el" href="time__dependent_8h_source.html">time_dependent.h</a></li>
<li>source/numerics/<a class="el" href="time__dependent_8cc_source.html">time_dependent.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
