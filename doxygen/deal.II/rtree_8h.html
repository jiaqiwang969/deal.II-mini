<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/rtree_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II/numerics/rtree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ee90d91a514b839c31faec7a1d916f67.html">deal.II</a></li><li class="navelem"><a class="el" href="dir_5c2eb6d9a7a6f1e9cd32e0e8abf42ca6.html">numerics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rtree.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="base_2point_8h_source.html">deal.II/base/point.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="iota__view_8h_source.html">deal.II/base/std_cxx20/iota_view.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2bounding__box_8h_source.html">deal.II/boost_adaptors/bounding_box.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2point_8h_source.html">deal.II/boost_adaptors/point.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="segment_8h_source.html">deal.II/boost_adaptors/segment.h</a>&gt;</code><br />
<code>#include &lt;boost/geometry/index/rtree.hpp&gt;</code><br />
<code>#include &lt;boost/geometry/strategies/strategies.hpp&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
</div>
<p><a href="rtree_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices&lt; Container &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExtractLevelVisitor.html">ExtractLevelVisitor&lt; Value, Options, Translator, Box, Allocators &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4c344ba05898daa78401ef2c92580f97"><td class="memTemplParams" colspan="2">template&lt;typename LeafType , typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename IndexableGetter  = boost::geometry::index::indexable&lt;LeafType&gt;&gt; </td></tr>
<tr class="memitem:a4c344ba05898daa78401ef2c92580f97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a> = boost::geometry::index::rtree&lt; LeafType, IndexType, IndexableGetter &gt;</td></tr>
<tr class="separator:a4c344ba05898daa78401ef2c92580f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename LeafTypeIterator , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename LeafTypeIterator::value_type&gt;&gt; </td></tr>
<tr class="memitem:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename LeafTypeIterator::value_type, IndexType, IndexableGetter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a> (const LeafTypeIterator &amp;begin, const LeafTypeIterator &amp;end)</td></tr>
<tr class="separator:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e3cb848beee59152a7963c98c857dd"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename ContainerType::value_type&gt;&gt; </td></tr>
<tr class="memitem:a21e3cb848beee59152a7963c98c857dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename ContainerType::value_type, IndexType, IndexableGetter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a21e3cb848beee59152a7963c98c857dd">pack_rtree</a> (const ContainerType &amp;container)</td></tr>
<tr class="separator:a21e3cb848beee59152a7963c98c857dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType &gt; </td></tr>
<tr class="memitem:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename ContainerType::size_type, IndexType, <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a>&lt; ContainerType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a> (const ContainerType &amp;container)</td></tr>
<tr class="separator:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591e6e032b1a56920f897a2bc387d43"><td class="memTemplParams" colspan="2">template&lt;typename Rtree &gt; </td></tr>
<tr class="memitem:a3591e6e032b1a56920f897a2bc387d43"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; boost::geometry::dimension&lt; typename Rtree::indexable_type &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a> (const Rtree &amp;tree, const unsigned <a class="el" href="classint.html">int</a> <a class="el" href="grid__out_8cc.html#a9082f945c1d289684d0bcd51ee08e11e">level</a>)</td></tr>
<tr class="separator:a3591e6e032b1a56920f897a2bc387d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4c344ba05898daa78401ef2c92580f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c344ba05898daa78401ef2c92580f97">&#9670;&nbsp;</a></span>RTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeafType , typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename IndexableGetter  = boost::geometry::index::indexable&lt;LeafType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a> =  boost::geometry::index::rtree&lt;LeafType, IndexType, IndexableGetter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>boost::geometry::index::rtree 类的一个封装器，实现了一个自平衡的空间索引（R-tree），能够使用不同的平衡算法来存储各种类型的值。 来自[Wikipedia]（https://en.wikipedia.org/wiki/R-tree）。</p><blockquote class="doxtable">
<p>R树是用于空间访问方法的树形数据结构，即用于索引多维信息，如地理坐标、矩形或多边形。R树是由Antonin Guttman在1984年提出的，并在理论和应用方面都有很大的用途。R树在现实世界中的一个常见用途可能是存储空间对象，如餐厅位置或典型地图所构成的多边形：街道、建筑、湖泊轮廓、海岸线等，然后快速找到查询的答案，如 "找到我当前位置2公里内的所有博物馆"、"检索我位置2公里内的所有路段"（在导航系统中显示）或 "找到最近的加油站"（尽管没有考虑道路）。R-树还可以加速各种距离指标的近邻搜索，包括大圆距离。 该数据结构的关键思想是将附近的物体分组，并在树的下一个较高层次中用它们的最小边界矩形来表示；R-树中的 "R
"是指矩形。由于所有的对象都在这个边界矩形内，一个不与边界矩形相交的查询也不能与任何包含的对象相交。在叶子层，每个矩形描述了一个单一的对象；在更高的层次上，聚集了越来越多的对象。这也可以看作是对数据集越来越粗的近似。 R-tree的关键困难是建立一个高效的树，一方面是平衡的（所以叶子节点在同一高度）另一方面是矩形不覆盖太多空隙，不重叠太多（这样在搜索过程中，需要处理的子树就少）。例如，插入元素以获得有效的树的原始想法是，总是插入到需要最少扩大其边界盒的子树中。一旦该页满了，数据就被分成两组，每组应覆盖最小的面积。大多数对R树的研究和改进都是为了改进树的构建方式，可以分为两个目标：从头开始构建一个高效的树（称为批量加载）和对现有的树进行修改（插入和删除）。</p>
</blockquote>
<p>一个RTree可以存储任何类型的 <code>LeafType</code> ，只要可以提取一个RTree可以处理的 <code>Indexable</code> ，并进行数值比较。一个 <code>Indexable</code> 是适应于点（Point）、边界盒（BoundingBox）或段（Segment）概念的类型，对它来说，距离和相等的比较是可以实现的。deal.II的Point、Segment和BoundingBox类满足这个要求，但你可以混入任何 <a class="el" href="namespaceboost_1_1geometry.html">boost::geometry</a> 接受为可索引的几何对象。 特别是，给定一个 <code>Indexable</code> 类型（例如一个点，一个BoundingBox，或一个段）， <code>LeafType</code> 可以由 <code>Indexable</code>, <code>std::pair&lt;Indexable, T&gt;</code>， <code>boost::tuple&lt;Indexable, ...&gt;</code>或 <code>std::tuple&lt;Indexable, ...&gt;</code>中的任何一个。 可选的参数 <code>IndexType</code> 只在向树上逐一添加元素时使用。如果使用的是范围插入，那么树是使用打包算法建立的。 如果想按顺序构建树，可以使用线性算法、二次算法和rstar算法。然而，这些都不是很有效，用户应该尽可能地使用打包算法。 打包算法是一次性构建树，当你拥有所有的叶子时可以使用。 这个类通常与两个辅助函数pack_rtree()中的一个结合使用，该函数接收一个容器或一系列迭代器，使用打包算法构建RTree。 以下是一个使用实例。</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;2&gt;&gt; points = generate_some_points();</div><div class="line"><span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(points.begin(), points.end());</div><div class="line"><span class="comment">// or, equivalently:</span></div><div class="line"><span class="comment">// auto tree = pack_rtree(points);</span></div></div><!-- fragment --><p>通过使用 <a href="https://www.boost.org/doc/libs/1_68_0/libs/geometry/doc/html/geometry/spatial_indexes/queries.html"><code>boost::geometry::index</code> 查询</a>来访问该树。例如，在用上面的片段构建了树之后，人们可以用下面的方式询问离某段最近的点。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bgi = <a class="code" href="namespaceboost_1_1geometry_1_1index.html">boost::geometry::index</a>;</div><div class="line"></div><div class="line"><a class="code" href="segment_8h.html#abe8b244c98d19a51f52c0b4e9c5516bc">Segment&lt;2&gt;</a> segment(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0,0), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1,1));</div><div class="line"></div><div class="line">std::vector&lt;Point&lt;2&gt;&gt; nearest;</div><div class="line">tree.query(bgi::nearest(segment,3), std::back_inserter(intersection));</div><div class="line"><span class="comment">// Returns the 3 closest points to the Segment defined above.</span></div></div><!-- fragment --><p>一般来说，树不需要存储实际的对象，只要它知道如何访问一个可索引类型的常量引用。这可以通过传递可选的模板参数 <code>IndexableGetter</code>, 来实现，该模板参数可以提取给定类型的对象 <code>LeafType</code>. 的一个可能的可索引类型的常量引用。 作为一个例子，人们可以在一个容器中存储点，并且只在容器中创建一个索引树，使用下面定义的IndexableGetterFromIndices类，以及函数pack_rtree_of_indices()。 </p>

<p class="definition">Definition at line <a class="el" href="rtree_8h_source.html#l00102">102</a> of file <a class="el" href="rtree_8h_source.html">rtree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66a9d76ea405b07e60e74aa6159ac7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a9d76ea405b07e60e74aa6159ac7ad">&#9670;&nbsp;</a></span>pack_rtree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename LeafTypeIterator , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename LeafTypeIterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename LeafTypeIterator::value_type, IndexType, IndexableGetter&gt; pack_rtree </td>
          <td>(</td>
          <td class="paramtype">const LeafTypeIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LeafTypeIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过传递一个迭代器范围来构造正确的RTree对象。 注意，参数的顺序与RTree类相反，因为我们可以从参数中自动推断出 <code>LeafType</code> 。 </p>

</div>
</div>
<a id="a21e3cb848beee59152a7963c98c857dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e3cb848beee59152a7963c98c857dd">&#9670;&nbsp;</a></span>pack_rtree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename ContainerType::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename ContainerType::value_type, IndexType, IndexableGetter&gt; pack_rtree </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过传递一个STL容器类型来构造一个RTree对象。这个函数在 <a class="el" href="step_70.html">step-70</a> 中使用。 注意模板参数的顺序与RTree类相反，因为我们可以从参数中自动推断出 <code>LeafType</code> ，而我们只需要在默认值不够的情况下指定 <code>IndexType</code> 。 </p>

</div>
</div>
<a id="a37474f7ac23c083eaa5c89c59f37a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37474f7ac23c083eaa5c89c59f37a09e">&#9670;&nbsp;</a></span>pack_rtree_of_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename ContainerType::size_type, IndexType, <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a>&lt;ContainerType&gt; &gt; pack_rtree_of_indices </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构建一个RTree对象，存储现有可索引类型的容器的索引。对容器的唯一要求是它支持0和容器大小之间的任何索引的operator[]（即，一个 std::vector, 或一个 std::array 可以，然而一个 std::map 就不行了）。 与pack_rtree()函数创建的对象不同，在这种情况下，我们不存储实际的几何类型，而只是存储它们的索引。</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bgi = <a class="code" href="namespaceboost_1_1geometry_1_1index.html">boost::geometry::index</a>;</div><div class="line">std::vector&lt;Point&lt;dim&gt;&gt; some_points = fill();</div><div class="line"><span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(points); <span class="comment">// the tree contains a copy of the points</span></div><div class="line"><span class="keyword">auto</span> index_tree = <a class="code" href="rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a>(points); <span class="comment">// the tree contains only</span></div><div class="line">                                               <span class="comment">// the indices of the</span></div><div class="line">                                               <span class="comment">// points</span></div><div class="line"><a class="code" href="classBoundingBox.html">BoundingBox&lt;dim&gt;</a> box = build_a_box();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p: tree       | bgi::adaptors::queried(bgi::intersects(box)))</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Point p: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i: index_tree | bgi::adaptors::queried(bgi::intersects(box)))</div><div class="line">std::cout &lt;&lt; <span class="stringliteral">&quot;Point p: &quot;</span> &lt;&lt; some_points[i] &lt;&lt; std::endl;</div></div><!-- fragment --><p>存储在树中的叶子是容器中相应条目的索引。对外部容器的引用被存储在内部，但请记住，如果你改变了容器，你应该重新建立树。 </p>

</div>
</div>
<a id="a3591e6e032b1a56920f897a2bc387d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591e6e032b1a56920f897a2bc387d43">&#9670;&nbsp;</a></span>extract_rtree_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rtree &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; boost::geometry::dimension&lt;typename Rtree::indexable_type&gt;::value&gt; &gt; extract_rtree_level </td>
          <td>(</td>
          <td class="paramtype">const Rtree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>给定一个RTree对象 <code>rtree</code>, 和一个目标级别 <code>level</code>, ，返回一个BoundingBox对象的向量，其中包含使给定的 <code>level</code> 的 <code>rtree</code>. 的所有边界框。 这个函数是ExtractLevelVisitor类的一个方便的包装器。它被用于 <a class="el" href="step_70.html">step-70</a> 。 由于RTree对象是一棵平衡的树，你可以期望得到的向量的每个条目都包含大致相同数量的子对象，并最终包含相同数量的叶对象。如果你要求的级别在RTree中不存在，那么将返回最后的级别。 这个函数的一个典型用法是在 <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> 对象的背景下，人们希望构建一个活动进程的本地拥有的单元所覆盖的区域的粗略表示，并与其他进程交换这一信息。最精细的信息是由叶子提供的，在这种情况下，叶子是与三角形的本地所有单元相关的所有边界盒的集合。与所有参与的进程交换这些信息将违背并行计算的目的。然而，如果构建一个包含这些边界框的RT树（例如，通过调用 <a class="el" href="classGridTools_1_1Cache.html#aca2782d6e93b5a0033c046b57904c67f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>), ，然后提取RT树的第一层之一，那么将只返回少量的BoundingBox对象，允许用户对域的几何形状及其在进程中的分布有一个非常有效的描述。 下面的代码片断给出了一个使用实例。</p>
<div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;2&gt;</a> tria(MPI_COMM_WORLD);</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria);</div><div class="line">tria.refine_global(4);</div><div class="line"></div><div class="line">std::vector&lt;BoundingBox&lt;2&gt;&gt; all_boxes(tria.n_locally_owned_active_cells());</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : tria.active_cell_iterators())</div><div class="line"><span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">  all_boxes[i++] = cell-&gt;bounding_box();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tree  = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boxes = <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, 1);</div></div><!-- fragment --><p>当在三个进程上运行时，仅围绕本地拥有的单元格的BoundingBox对象的完整集合以及用这些盒子构建的rtree的第二层看起来就像下面的图片（每个进程一个图片）。 </p><div class="image">
<img src="rtree-process-0.png" alt="rtree-process-0.png"/>
<div class="caption">
html rtree-process-1.png  html rtree-process-2.png 。</div></div>
 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
