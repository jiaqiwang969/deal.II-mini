<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/rtree_8h.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: include/deal.II/numerics/rtree.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_ee90d91a514b839c31faec7a1d916f67.html">deal.II</a></li><li class="navelem"><a class="el" href="dir_5c2eb6d9a7a6f1e9cd32e0e8abf42ca6.html">numerics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">rtree.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;<a class="el" href="config_8h_source.html">deal.II/base/config.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="base_2point_8h_source.html">deal.II/base/point.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="iota__view_8h_source.html">deal.II/base/std_cxx20/iota_view.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2bounding__box_8h_source.html">deal.II/boost_adaptors/bounding_box.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="boost__adaptors_2point_8h_source.html">deal.II/boost_adaptors/point.h</a>&gt;</code><br />
<code>#include &lt;<a class="el" href="segment_8h_source.html">deal.II/boost_adaptors/segment.h</a>&gt;</code><br />
<code>#include &lt;boost/geometry/index/rtree.hpp&gt;</code><br />
<code>#include &lt;boost/geometry/strategies/strategies.hpp&gt;</code><br />
<code>#include &lt;memory&gt;</code><br />
</div>
<p><a href="rtree_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices&lt; Container &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structExtractLevelVisitor.html">ExtractLevelVisitor&lt; Value, Options, Translator, Box, Allocators &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4c344ba05898daa78401ef2c92580f97"><td class="memTemplParams" colspan="2">template&lt;typename LeafType , typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename IndexableGetter  = boost::geometry::index::indexable&lt;LeafType&gt;&gt; </td></tr>
<tr class="memitem:a4c344ba05898daa78401ef2c92580f97"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a> = boost::geometry::index::rtree&lt; LeafType, IndexType, IndexableGetter &gt;</td></tr>
<tr class="separator:a4c344ba05898daa78401ef2c92580f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename LeafTypeIterator , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename LeafTypeIterator::value_type&gt;&gt; </td></tr>
<tr class="memitem:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename LeafTypeIterator::value_type, IndexType, IndexableGetter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a> (const LeafTypeIterator &amp;begin, const LeafTypeIterator &amp;end)</td></tr>
<tr class="separator:a66a9d76ea405b07e60e74aa6159ac7ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21e3cb848beee59152a7963c98c857dd"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename ContainerType::value_type&gt;&gt; </td></tr>
<tr class="memitem:a21e3cb848beee59152a7963c98c857dd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename ContainerType::value_type, IndexType, IndexableGetter &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a21e3cb848beee59152a7963c98c857dd">pack_rtree</a> (const ContainerType &amp;container)</td></tr>
<tr class="separator:a21e3cb848beee59152a7963c98c857dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memTemplParams" colspan="2">template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType &gt; </td></tr>
<tr class="memitem:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt; typename ContainerType::size_type, IndexType, <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a>&lt; ContainerType &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a> (const ContainerType &amp;container)</td></tr>
<tr class="separator:a37474f7ac23c083eaa5c89c59f37a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3591e6e032b1a56920f897a2bc387d43"><td class="memTemplParams" colspan="2">template&lt;typename Rtree &gt; </td></tr>
<tr class="memitem:a3591e6e032b1a56920f897a2bc387d43"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; boost::geometry::dimension&lt; typename Rtree::indexable_type &gt;::value &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a> (const Rtree &amp;tree, const unsigned <a class="el" href="classint.html">int</a> level)</td></tr>
<tr class="separator:a3591e6e032b1a56920f897a2bc387d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4c344ba05898daa78401ef2c92580f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c344ba05898daa78401ef2c92580f97">&#9670;&nbsp;</a></span>RTree</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename LeafType , typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename IndexableGetter  = boost::geometry::index::indexable&lt;LeafType&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a> =  boost::geometry::index::rtree&lt;LeafType, IndexType, IndexableGetter&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A wrapper for the boost::geometry::index::rtree class, implementing a self-balancing spatial index (the R-tree) capable of storing various types of values, using different balancing algorithms.</p>
<p>From <a href="https://en.wikipedia.org/wiki/R-tree">Wikipedia</a>: </p><blockquote class="doxtable">
<p>R-trees are tree data structures used for spatial access methods, i.e., for indexing multi-dimensional information such as geographical coordinates, rectangles or polygons. The R-tree was proposed by Antonin Guttman in 1984 and has found significant use in both theoretical and applied contexts. A common real-world usage for an R-tree might be to store spatial objects such as restaurant locations or the polygons that typical maps are made of: streets, buildings, outlines of lakes, coastlines, etc. and then find answers quickly to queries such as "Find all museums within 2 km of my current
location", "retrieve all road segments within 2 km of my location" (to display them in a navigation system) or "find the nearest gas station" (although not taking roads into account). The R-tree can also accelerate nearest neighbor search for various distance metrics, including great-circle distance.</p>
<p>The key idea of the data structure is to group nearby objects and represent them with their minimum bounding rectangle in the next higher level of the tree; the "R" in R-tree is for rectangle. Since all objects lie within this bounding rectangle, a query that does not intersect the bounding rectangle also cannot intersect any of the contained objects. At the leaf level, each rectangle describes a single object; at higher levels the aggregation of an increasing number of objects. This can also be seen as an increasingly coarse approximation of the data set.</p>
<p>The key difficulty of R-tree is to build an efficient tree that on one hand is balanced (so the leaf nodes are at the same height) on the other hand the rectangles do not cover too much empty space and do not overlap too much (so that during search, fewer subtrees need to be processed). For example, the original idea for inserting elements to obtain an efficient tree is to always insert into the subtree that requires least enlargement of its bounding box. Once that page is full, the data is split into two sets that should cover the minimal area each. Most of the research and improvements for R-trees aims at improving the way the tree is built and can be grouped into two objectives: building an efficient tree from scratch (known as bulk-loading) and performing changes on an existing tree (insertion and deletion). </p>
</blockquote>
<p>An RTree may store any type of <code>LeafType</code> as long as it is possible to extract an <code>Indexable</code> that the RTree can handle and compare values. An <code>Indexable</code> is a type adapted to the <a class="el" href="classPoint.html">Point</a>, <a class="el" href="classBoundingBox.html">BoundingBox</a> or Segment concept, for which distance and equality comparison are implemented. The deal.II <a class="el" href="classPoint.html">Point</a>, Segment, and <a class="el" href="classBoundingBox.html">BoundingBox</a> classes satisfy this requirement, but you can mix in any geometry object that <a class="el" href="namespaceboost_1_1geometry.html">boost::geometry</a> accepts as indexable.</p>
<p>In particular, given an <code>Indexable</code> type (for example a <a class="el" href="classPoint.html">Point</a>, a <a class="el" href="classBoundingBox.html">BoundingBox</a>, or a Segment), <code>LeafType</code> can by any of <code>Indexable</code>, <code>std::pair&lt;Indexable, T&gt;</code>, <code>boost::tuple&lt;Indexable, ...&gt;</code> or <code>std::tuple&lt;Indexable, ...&gt;</code>.</p>
<p>The optional argument <code>IndexType</code> is used only when adding elements to the tree one by one. If a range insertion is used, then the tree is built using the packing algorithm.</p>
<p>Linear, quadratic, and rstar algorithms are available if one wants to construct the tree sequentially. However, none of these is very efficient, and users should use the packing algorithm when possible.</p>
<p>The packing algorithm constructs the tree all at once, and may be used when you have all the leaves at your disposal.</p>
<p>This class is usually used in combination with one of the two helper functions <a class="el" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree()</a>, that takes a container or a range of iterators to construct the RTree using the packing algorithm.</p>
<p>An example usage is the following:</p>
<div class="fragment"><div class="line">std::vector&lt;Point&lt;2&gt;&gt; points = generate_some_points();</div><div class="line"><span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(points.begin(), points.end());</div><div class="line"><span class="comment">// or, equivalently:</span></div><div class="line"><span class="comment">// auto tree = pack_rtree(points);</span></div></div><!-- fragment --><p>The tree is accessed by using <a href="https://www.boost.org/doc/libs/1_68_0/libs/geometry/doc/html/geometry/spatial_indexes/queries.html"><code>boost::geometry::index</code> queries</a>. For example, after constructing the tree with the snippet above, one can ask for the closest points to a segment in the following way:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bgi = <a class="code" href="namespaceboost_1_1geometry_1_1index.html">boost::geometry::index</a>;</div><div class="line"></div><div class="line"><a class="code" href="segment_8h.html#abe8b244c98d19a51f52c0b4e9c5516bc">Segment&lt;2&gt;</a> segment(<a class="code" href="classPoint.html">Point&lt;2&gt;</a>(0,0), <a class="code" href="classPoint.html">Point&lt;2&gt;</a>(1,1));</div><div class="line"></div><div class="line">std::vector&lt;Point&lt;2&gt;&gt; nearest;</div><div class="line">tree.query(bgi::nearest(segment,3), std::back_inserter(intersection));</div><div class="line"><span class="comment">// Returns the 3 closest points to the Segment defined above.</span></div></div><!-- fragment --><p>In general, a tree does not need to store the actual objects, as long as it knows how to access a const reference to an indexable type. This is achieved by passing the optional template argument <code>IndexableGetter</code>, that extracts a const reference to one of the possible indexable types given an object of type <code>LeafType</code>. As an example, one may store points in a container, and only create a tree of the indices within the container, using the <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a> class defined below, and the function <a class="el" href="rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices()</a>. </p>

<p class="definition">Definition at line <a class="el" href="rtree_8h_source.html#l00145">145</a> of file <a class="el" href="rtree_8h_source.html">rtree.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a66a9d76ea405b07e60e74aa6159ac7ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a9d76ea405b07e60e74aa6159ac7ad">&#9670;&nbsp;</a></span>pack_rtree() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename LeafTypeIterator , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename LeafTypeIterator::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename LeafTypeIterator::value_type, IndexType, IndexableGetter&gt; pack_rtree </td>
          <td>(</td>
          <td class="paramtype">const LeafTypeIterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const LeafTypeIterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct the correct RTree object by passing an iterator range.</p>
<p>Notice that the order of the parameters is the opposite with respect to the RTree class, since we can automatically infer the <code>LeafType</code> from the arguments. </p>

</div>
</div>
<a id="a21e3cb848beee59152a7963c98c857dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21e3cb848beee59152a7963c98c857dd">&#9670;&nbsp;</a></span>pack_rtree() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType , typename IndexableGetter  = boost::geometry::index::indexable&lt;            typename ContainerType::value_type&gt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename ContainerType::value_type, IndexType, IndexableGetter&gt; pack_rtree </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct an RTree object by passing an STL container type. This function is used in step-70.</p>
<p>Notice that the order of the template parameters is the opposite with respect to the RTree class, since we can automatically infer the <code>LeafType</code> from the arguments, and we only need to specify the <code>IndexType</code> if the default is not adequate. </p>

</div>
</div>
<a id="a37474f7ac23c083eaa5c89c59f37a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37474f7ac23c083eaa5c89c59f37a09e">&#9670;&nbsp;</a></span>pack_rtree_of_indices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IndexType  = boost::geometry::index::linear&lt;16&gt;, typename ContainerType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtree_8h.html#a4c344ba05898daa78401ef2c92580f97">RTree</a>&lt;typename ContainerType::size_type, IndexType, <a class="el" href="classIndexableGetterFromIndices.html">IndexableGetterFromIndices</a>&lt;ContainerType&gt; &gt; pack_rtree_of_indices </td>
          <td>(</td>
          <td class="paramtype">const ContainerType &amp;&#160;</td>
          <td class="paramname"><em>container</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a RTree object that stores the indices of an existing container of indexable types. The only requirement on the container is that it supports operator[] for any index between 0 and the size of the container (i.e., a std::vector, or an std::array will do, however an std::map won't).</p>
<p>Differently from the object created by the <a class="el" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree()</a> function, in this case we don't store the actual geometrical types, but just their indices:</p>
<div class="fragment"><div class="line"><span class="keyword">namespace </span>bgi = <a class="code" href="namespaceboost_1_1geometry_1_1index.html">boost::geometry::index</a>;</div><div class="line">std::vector&lt;Point&lt;dim&gt;&gt; some_points = <a class="code" href="namespacemystl.html#a43bf1ee8d2cbb81603617c68f519303b">fill</a>();</div><div class="line"><span class="keyword">auto</span> tree = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(points); <span class="comment">// the tree contains a copy of the points</span></div><div class="line"><span class="keyword">auto</span> index_tree = <a class="code" href="rtree_8h.html#a37474f7ac23c083eaa5c89c59f37a09e">pack_rtree_of_indices</a>(points); <span class="comment">// the tree contains only</span></div><div class="line">                                                 <span class="comment">// the indices of the</span></div><div class="line">                                                 <span class="comment">// points</span></div><div class="line"><a class="code" href="classBoundingBox.html">BoundingBox&lt;dim&gt;</a> box = build_a_box();</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;p: tree       | bgi::adaptors::queried(bgi::intersects(box)))</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Point p: &quot;</span> &lt;&lt; p &lt;&lt; std::endl;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;i: index_tree | bgi::adaptors::queried(bgi::intersects(box)))</div><div class="line">  std::cout &lt;&lt; <span class="stringliteral">&quot;Point p: &quot;</span> &lt;&lt; some_points[i] &lt;&lt; std::endl;</div></div><!-- fragment --><p>The leaves stored in the tree are the indices of the corresponding entry in the container. A reference to the external container is stored internally, but keep in mind that if you change the container, you should rebuild the tree. </p>

</div>
</div>
<a id="a3591e6e032b1a56920f897a2bc387d43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3591e6e032b1a56920f897a2bc387d43">&#9670;&nbsp;</a></span>extract_rtree_level()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rtree &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classBoundingBox.html">BoundingBox</a>&lt; boost::geometry::dimension&lt;typename Rtree::indexable_type&gt;::value&gt; &gt; extract_rtree_level </td>
          <td>(</td>
          <td class="paramtype">const Rtree &amp;&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a RTree object <code>rtree</code>, and a target level <code>level</code>, return a vector of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects containing all the bounding boxes that make the given <code>level</code> of the <code>rtree</code>. This function is a convenient wrapper around the <a class="el" href="structExtractLevelVisitor.html">ExtractLevelVisitor</a> class. It is used in step-70.</p>
<p>Since an RTree object is a balanced tree, you can expect each entry of the resulting vector to contain roughly the same number of children, and ultimately, the same number of leaf objects. If you request for a level that is not present in the RTree, the last level is returned.</p>
<p>A typical usage of this function is in the context of <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a> objects, where one would like to construct a rough representation of the area which is covered by the locally owned cells of the active process, and exchange this information with other processes. The finest level of information is given by the leaves, which in this context would be the collection of all the bounding boxes associated to the locally owned cells of the triangulation. Exchanging this information with all participating processes would defeat the purpuse of parallel computations. If however one constructs an RTree containing these bounding boxes (for example, by calling <a class="el" href="classGridTools_1_1Cache.html#a2350605fd3cd20b4df7eec0012974e5f">GridTools::Cache::get_cell_bounding_boxes_rtree()</a>), and then extracts one of the first levels of the RTree, only a handful of <a class="el" href="classBoundingBox.html">BoundingBox</a> objects would be returned, allowing the user to have a very efficient description of the geometry of the domain, and of its distribution among processes.</p>
<p>An example usage is given by the following snippet of code: </p><div class="fragment"><div class="line"><a class="code" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation&lt;2&gt;</a> tria(MPI_COMM_WORLD);</div><div class="line"><a class="code" href="namespaceGridGenerator.html#a533c4778cbc9bcbed365dcab42ca4418">GridGenerator::hyper_ball</a>(tria);</div><div class="line">tria.refine_global(4);</div><div class="line"></div><div class="line">std::vector&lt;BoundingBox&lt;2&gt;&gt; all_boxes(tria.n_locally_owned_active_cells());</div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span>                i = 0;</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span> &amp;cell : tria.active_cell_iterators())</div><div class="line">  <span class="keywordflow">if</span> (cell-&gt;is_locally_owned())</div><div class="line">    all_boxes[i++] = cell-&gt;bounding_box();</div><div class="line"></div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> tree  = <a class="code" href="rtree_8h.html#a66a9d76ea405b07e60e74aa6159ac7ad">pack_rtree</a>(all_boxes);</div><div class="line"><span class="keyword">const</span> <span class="keyword">auto</span> boxes = <a class="code" href="rtree_8h.html#a3591e6e032b1a56920f897a2bc387d43">extract_rtree_level</a>(tree, 1);</div></div><!-- fragment --><p>When run on three processes, the complete set of the <a class="el" href="classBoundingBox.html">BoundingBox</a> objects surrounding only the locally owned cells and the second level of the rtree constructed with those boxes would look like in the following pictures (one image per process):</p>
<div class="image">
<img src="rtree-process-0.png" alt="rtree-process-0.png"/>
</div>
 <div class="image">
<img src="rtree-process-1.png" alt="rtree-process-1.png"/>
</div>
 <div class="image">
<img src="rtree-process-2.png" alt="rtree-process-2.png"/>
</div>
 
</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
