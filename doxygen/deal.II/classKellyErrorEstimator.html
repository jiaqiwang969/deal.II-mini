<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classKellyErrorEstimator.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: KellyErrorEstimator&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classKellyErrorEstimator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">KellyErrorEstimator&lt; dim, spacedim &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__numerics.html">Numerical algorithms</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="error__estimator_8h_source.html">deal.II/numerics/error_estimator.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:adc94d710b3db4967da1ea80bd7813a1e"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> { <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a> = 0, 
<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea1a7f77da54520df51814d7a93306d6d1">face_diameter_over_twice_max_degree</a>, 
<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1eaf8f87cb31b00db990be93ff11809ea06">cell_diameter</a>
 }</td></tr>
<tr class="separator:adc94d710b3db4967da1ea80bd7813a1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a89bc380daafc0581bf95ecdc6620e68a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a89bc380daafc0581bf95ecdc6620e68a">DeclExceptionMsg</a> (ExcInvalidComponentMask, &quot;You provided a <a class="el" href="classComponentMask.html">ComponentMask</a> argument that is invalid. &quot; &quot;Component masks need to be either default constructed &quot; &quot;(in which case they indicate that every component is &quot; &quot;selected) or need to have a length <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number &quot; &quot;of vector components of the finite element in use &quot; &quot;by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. In the latter case, at &quot; &quot;least one component needs to be selected.&quot;)</td></tr>
<tr class="separator:a89bc380daafc0581bf95ecdc6620e68a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2b26006ab9a630030e4b35441045544"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#aa2b26006ab9a630030e4b35441045544">DeclExceptionMsg</a> (ExcInvalidCoefficient, &quot;If you do specify the argument for a (possibly &quot; &quot;spatially variable) coefficient function for this function, &quot; &quot;then it needs to refer to a coefficient that is either &quot; &quot;scalar (has one vector component) or has as many vector &quot; &quot;components as there are in the finite element used by &quot; &quot;the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument.&quot;)</td></tr>
<tr class="separator:aa2b26006ab9a630030e4b35441045544"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f097cebfe4ca2d502673d4b103e72f6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a9f097cebfe4ca2d502673d4b103e72f6">DeclException3</a> (ExcInvalidBoundaryFunction, <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You provided a function map that for boundary indicator &quot;&lt;&lt; arg1&lt;&lt; &quot; specifies a function with &quot;&lt;&lt; arg2&lt;&lt; &quot; vector components. However, the finite &quot; &quot;element in use has &quot;&lt;&lt; arg3&lt;&lt; &quot; components, and these two numbers need to match.&quot;)</td></tr>
<tr class="separator:a9f097cebfe4ca2d502673d4b103e72f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e54685ad5fb8d398e59e9738a1ea3dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a6e54685ad5fb8d398e59e9738a1ea3dc">DeclException2</a> (ExcIncompatibleNumberOfElements, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;The number of input vectors, &quot;&lt;&lt; arg1&lt;&lt; &quot; needs to be <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number of output vectors, &quot;&lt;&lt; arg2&lt;&lt; &quot;. This is not the case in your call of this function.&quot;)</td></tr>
<tr class="separator:a6e54685ad5fb8d398e59e9738a1ea3dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01964146b93387474ba9021acd90eb18"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a01964146b93387474ba9021acd90eb18">DeclExceptionMsg</a> (ExcNoSolutions, &quot;You need to specify at least one solution vector as &quot; &quot;input.&quot;)</td></tr>
<tr class="separator:a01964146b93387474ba9021acd90eb18"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae2269e1c9903e9d863b7abd54948af00"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:ae2269e1c9903e9d863b7abd54948af00"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:ae2269e1c9903e9d863b7abd54948af00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a2d50d84e23346f63edb23fa300af4d"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:a3a2d50d84e23346f63edb23fa300af4d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a3a2d50d84e23346f63edb23fa300af4d">estimate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a3a2d50d84e23346f63edb23fa300af4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15883245f837a46d030f21e8069a0648"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:a15883245f837a46d030f21e8069a0648"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a15883245f837a46d030f21e8069a0648">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a15883245f837a46d030f21e8069a0648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d532c1a22dfebe7ac8e278b7e467020"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:a5d532c1a22dfebe7ac8e278b7e467020"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a5d532c1a22dfebe7ac8e278b7e467020">estimate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a5d532c1a22dfebe7ac8e278b7e467020"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa201c9b6ae94601b6cbdc582ec038635"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:aa201c9b6ae94601b6cbdc582ec038635"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#aa201c9b6ae94601b6cbdc582ec038635">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:aa201c9b6ae94601b6cbdc582ec038635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26d7f4ab108ebdee6db6b15aff0184bb"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:a26d7f4ab108ebdee6db6b15aff0184bb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a26d7f4ab108ebdee6db6b15aff0184bb">estimate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const InputVector &amp;solution, <a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;error, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a26d7f4ab108ebdee6db6b15aff0184bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a201770502aceb466095aab7b327a0013"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:a201770502aceb466095aab7b327a0013"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#a201770502aceb466095aab7b327a0013">estimate</a> (const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;mapping, const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:a201770502aceb466095aab7b327a0013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45e1c0662968c4b764f178243f46eed"><td class="memTemplParams" colspan="2">template&lt;typename InputVector &gt; </td></tr>
<tr class="memitem:aa45e1c0662968c4b764f178243f46eed"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classKellyErrorEstimator.html#aa45e1c0662968c4b764f178243f46eed">estimate</a> (const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;dof, const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;quadrature, const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;neumann_bc, const std::vector&lt; const InputVector *&gt; &amp;solutions, std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;errors, const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;component_mask=<a class="el" href="classComponentMask.html">ComponentMask</a>(), const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *coefficients=nullptr, const unsigned <a class="el" href="classint.html">int</a> n_threads=<a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a>, const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a> subdomain_id=<a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a>, const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a> material_id=<a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>, const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a> strategy=<a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a>)</td></tr>
<tr class="separator:aa45e1c0662968c4b764f178243f46eed"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class KellyErrorEstimator&lt; dim, spacedim &gt;</h3>

<p>Implementation of the error indicator by Kelly, De S. R. Gago, Zienkiewicz and Babuska (see <b>[KGZB83]</b>) and its modification for the hp-FEM. This error indicator tries to approximate the error per cell by integration of the jump of the gradient of the solution along the faces of each cell. It can be understood as a gradient recovery estimator; see the survey of Ainsworth and Oden, "A Posteriori Error Estimation in Finite Element Analysis" (Wiley, 2000) for a complete discussion.</p>
<p>In the original Kelly error estimator, the contribution of each face to the cell error is scaled with the cell diagonal. In the modified version, however, we employ a scaling factor which depends on the face diagonal and polynomial degrees of the adjacent elements. The choice between the two is done by means of the enumerator, defined within the class.</p>
<dl class="section note"><dt>Note</dt><dd>In spite of the name, Kelly estimator is not truly an a posteriori error estimator, even if applied to the Poisson problem only. It gives good hints for mesh refinement, but the estimate is not to be trusted. For higher order trial spaces the integrals computed here tend to zero faster than the error itself, thus ruling out the values as error estimators. However, the modified version discussed below can be utilised to obtain the reliable error estimator by adding the residual (volume) part.</dd></dl>
<p>The error estimator really only estimates the error for the generalized Poisson equation \(-\nabla\cdot a(x) \nabla u = f\) with either Dirichlet boundary conditions or generalized Neumann boundary conditions involving the conormal derivative \(a\frac{du}{dn} = g\).</p>
<p>The error estimator returns a vector of estimated errors per cell which can be used to feed the <a class="el" href="namespaceGridRefinement.html#ae90dc87c4db158b8d01f6d564ac614e5">GridRefinement::refine_and_coarsen_fixed_fraction()</a>, <a class="el" href="namespaceGridRefinement.html#a48e5395381ed87155942a61a1edd134d">GridRefinement::refine_and_coarsen_fixed_number()</a>, and similar functions. This vector contains elements of data type <code>float</code>, rather than <code>double</code>, since accuracy is not important in the current context.</p>
<h3>Implementation</h3>
<p>In principle, the implementation of the error estimation is simple: let </p><p class="formulaDsp">
\[ \eta_K^2 = \sum_{F\in\partial K} c_F \int_{\partial K_F} \jump{a \frac{\partial u_h}{\partial n}}^2 \]
</p>
<p> be the error estimator for cell \(K\). \(\jump{\cdot}\) denotes the jump of the function in square brackets at the face, and \(c_F\) is a factor discussed below. This is the general form of the interface terms of the error estimator derived by Kelly et al. in the paper referenced above. The overall error estimate is then computed as </p><p class="formulaDsp">
\[ \eta^2 = \sum_K \eta_K^2 \]
</p>
<p> so that \(\eta \approx \|\nabla (u-u_h)\|\) for the Laplace equation. The functions of this class compute a vector of values that corresponds to \(\eta_K\) (i.e., the square root of the quantity above).</p>
<p>In the paper of Ainsworth \( c_F=\frac {h_K}{24} \), but this factor is a bit esoteric, stemming from interpolation estimates and stability constants which may hold for the Poisson problem, but may not hold for more general situations. Alternatively, we consider the case when \(c_F=\frac {h_F}{2p_F}\), where \(h_F\) is the diameter of the face and \(p_F=max(p^+,p^-)\) is the maximum polynomial degree of adjacent elements; or \(c_F=h_K\). The choice between these factors is done by means of the enumerator, provided as the last argument in all functions.</p>
<p>To perform the integration, use is made of the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and <a class="el" href="classFESubfaceValues.html">FESubfaceValues</a> classes. The integration is performed by looping over all cells and integrating over faces that are not yet treated. This way we avoid integration on faces twice, once for each time we visit one of the adjacent cells. In a second loop over all cells, we sum up the contributions of the faces (which are the integrated square of the jumps times some factor) of each cell and take the square root.</p>
<p>The integration is done using a quadrature formula on the face provided by the caller of the <a class="el" href="classKellyErrorEstimator.html#ae2269e1c9903e9d863b7abd54948af00">estimate()</a> functions declared by this class. For linear trial functions (<a class="el" href="classFE__Q.html">FE_Q(1)</a>), <a class="el" href="classQGauss.html">QGauss</a> with two points or even the <a class="el" href="classQMidpoint.html">QMidpoint</a> rule might actually suffice. For higher order elements, it is necessary to utilize higher order quadrature formulae with <code>fe.degree+1</code> Gauss points.</p>
<p>We store the contribution of each face in a <code>map</code>, as provided by the C++ standard library, with the iterator pointing to that face being the key into the map. When looping the second time over all cells, we have to sum up the contributions of the faces and take the square root. For the Kelly estimator, the multiplication with \(\frac {h_K}{24}\) is done in the second loop. By doing so we avoid problems to decide with which \(h_K\) to multiply, that of the cell on the one or that of the cell on the other side of the face. Whereas for the hp-estimator the <code>map</code> stores integrals multiplied by \(\frac {h_F}{2p_F}\), which are then summed in the second loop.</p>
<p>\(h_K\) ( \(h_F\)) is taken to be the greatest length of the diagonals of the cell (face). For more or less uniform cells (faces) without deformed angles, this coincides with the diameter of the cell (face).</p>
<h3>Vector-valued functions</h3>
<p>If the finite element field for which the error is to be estimated is vector-valued, i.e. the finite element has more than one component, then all the above can be applied to all or only some components at the same time. The main function of this class takes a list of flags denoting the components for which components the error estimator is to be applied; by default, it is a list of only <code>trues</code>, meaning that all variables shall be treated.</p>
<p>In case the different components of a field have different physical meaning (for example velocity and pressure in the Stokes equations), it would be senseless to use the same coefficient for all components. In that case, you can pass a function with as many components as there are components in the finite element field and each component of the error estimator will then be weighted by the respective component in this coefficient function. In the other case, when all components have the same meaning (for example the displacements in Lam&eacute;'s equations of elasticity), you can specify a scalar coefficient which will then be used for all components.</p>
<h3>Boundary values</h3>
<p>If the face is at the boundary, i.e. there is no neighboring cell to which the jump in the gradient could be computed, there are two possibilities: </p><ul>
<li>
<p class="startli">The face belongs to a Dirichlet boundary. Then the face is not considered, which can be justified looking at a dual problem technique and should hold exactly if the boundary can be approximated exactly by the finite element used (i.e. it is a linear boundary for linear finite elements, quadratic for isoparametric quadratic elements, etc). For boundaries which can not be exactly approximated, one should consider the difference \(z-z_h\) on the face, \(z\) being a dual problem's solution which is zero at the true boundary and \(z_h\) being an approximation, which in most cases will be zero on the numerical boundary. Since on the numerical boundary \(z\) will not be zero in general, we would get another term here, but this one is neglected for practical reasons, in the hope that the error made here will tend to zero faster than the energy error we wish to estimate.</p>
<p>Though no integration is necessary, in the list of face contributions we store a zero for this face, which makes summing up the contributions of the different faces to the cells easier.</p>
<p class="endli"></p>
</li>
<li>
<p class="startli">The face belongs to a Neumann boundary. In this case, the contribution of the face \(F\in\partial K\) looks like </p><p class="formulaDsp">
\[ n_F\int_F \left|g-a\frac{\partial u_h}{\partial n}\right|^2 ds \]
</p>
<p> where \(g\) is the Neumann boundary function, \(n_F=\frac {h_K}{24}\) and \(n_F=\frac {h_F}{p}\) for the Kelly and hp-estimator, respectively. If the finite element is vector- valued, then obviously the function denoting the Neumann boundary conditions needs to be vector-valued as well.</p>
<p class="endli"></p>
</li>
<li>
No other boundary conditions are considered. </li>
</ul>
<p>In practice, if you have Robin boundary conditions or are too lazy to accurately describe Neumann values, then this is rarely an issue: if you don't say anything in the map about a particular part of the boundary then the Kelly indicator will simply assume that the solution is correct on that part of the boundary and not touch it. Of course, if you have a have a Neumann or Robin boundary, that isn't quite true, there is going to be a difference between the normal derivative of the numerical solution and the Neumann values these normal derivatives should equal. So if we simply ignore those parts of the boundary, we'll underestimate the error. In practice, this rarely appears to be a problem &ndash; you may not refine the cell this time around but you'll probably refine it in the next refinement step and everything is good again. After all, for all problems but the Laplace equation, the Kelly indicator is only an indicator, not an estimator, and so the values it computes are not exact error representations anyway.</p>
<h3>Handling of hanging nodes</h3>
<p>The integration along faces with hanging nodes is quite tricky, since one of the elements has to be shifted one level up or down. See the documentation for the FESubFaceValues class for more information about technical issues regarding this topic.</p>
<p>In praxi, since we integrate over each face only once, we do this when we are on the coarser one of the two cells adjacent to a subface (a subface is defined to be the child of a face; seen from the coarse cell, it is a subface, while seen from the refined cell it is one of its faces). The reason is that finding neighborship information is a bit easier then, but that's all practical reasoning, nothing fundamental.</p>
<p>Since we integrate from the coarse side of the face, we have the mother face readily at hand and store the result of the integration over that mother face (being the sum of the integrals along the subfaces) in the abovementioned map of integrals as well. This consumes some memory more than needed, but makes the summing up of the face contributions to the cells easier, since then we have the information from all faces of all cells at hand and need not think about explicitly determining whether a face was refined or not. The same applies for boundary faces, see above.</p>
<h3>Multiple solution vectors</h3>
<p>In some cases, for example in time-dependent problems, one would like to compute the error estimates for several solution vectors on the same grid at once, with the same coefficients, boundary condition object, etc, e.g. for the solutions on several successive time steps. One could then call the functions of this class several times for each solution. However, the largest factor in the computation of the error estimates (in terms of computing time) is initialization of <a class="el" href="classFEFaceValues.html">FEFaceValues</a> and FESubFaceValues objects, and iterating through all faces and subfaces. If the solution vectors live on the same grid, this effort can be reduced significantly by treating all solution vectors at the same time, initializing the <a class="el" href="classFEFaceValues.html">FEFaceValues</a> objects only once per cell and for all solution vectors at once, and also only looping through the triangulation only once. For this reason, besides the <code>estimate</code> function in this class that takes a single input vector and returns a single output vector, there is also a function that accepts several in- and output vectors at the same time. </p>

<p class="definition">Definition at line <a class="el" href="error__estimator_8h_source.html#l00260">260</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="adc94d710b3db4967da1ea80bd7813a1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc94d710b3db4967da1ea80bd7813a1e">&#9670;&nbsp;</a></span>Strategy</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">KellyErrorEstimator::Strategy</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The enum type given to the class functions to decide on the scaling factors of the face integrals. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383"></a>cell_diameter_over_24&#160;</td><td class="fielddoc"><p>Kelly error estimator with the factor \(\frac {h_K}{24}\). </p>
</td></tr>
<tr><td class="fieldname"><a id="adc94d710b3db4967da1ea80bd7813a1ea1a7f77da54520df51814d7a93306d6d1"></a>face_diameter_over_twice_max_degree&#160;</td><td class="fielddoc"><p>the boundary residual estimator with the factor \(\frac {h_F}{2 //! max(p^+,p^-)}\). </p>
</td></tr>
<tr><td class="fieldname"><a id="adc94d710b3db4967da1ea80bd7813a1eaf8f87cb31b00db990be93ff11809ea06"></a>cell_diameter&#160;</td><td class="fielddoc"><p>Kelly error estimator with the factor \(h_K\). </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="error__estimator_8h_source.html#l00267">267</a> of file <a class="el" href="error__estimator_8h_source.html">error_estimator.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae2269e1c9903e9d863b7abd54948af00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2269e1c9903e9d863b7abd54948af00">&#9670;&nbsp;</a></span>estimate() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Implementation of the error estimator described above. You may give a coefficient, but there is a default value which denotes the constant coefficient with value one. The coefficient function may either be a scalar one, in which case it is used for all components of the finite element, or a vector-valued one with as many components as there are in the finite element; in the latter case, each component is weighted by the respective component in the coefficient.</p>
<p>You might give a list of components you want to evaluate, in case the finite element used by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object is vector-valued. You then have to set those entries to true in the bit-vector <code>component_mask</code> (see <a class="el" href="DEALGlossary.html#GlossComponentMask">GlossComponentMask</a> ) for which the respective component is to be used in the error estimator. The default is to use all components, which is done by either providing a bit-vector with all-set entries, or an empty bit-vector.</p>
<p>The <code>subdomain_id</code> parameter indicates whether we shall compute indicators for all cells (in case its value is the default, <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>), or only for the cells belonging to a certain subdomain with the given indicator. The latter case is used for parallel computations where all processor nodes have the global grid stored, and could well compute all the indicators for all cells themselves, but where it is more efficient to have each process compute only indicators for the cells it owns, and have them exchange the resulting information afterwards. This is in particular true for the case where meshes are very large and computing indicators for <em>every</em> cell is too expensive, while computing indicators for only local cells is acceptable. Note that if you only ask for the indicators of a certain subdomain to be computed, you must nevertheless make sure that this function has access to the correct node values of <em>all</em> degrees of freedom. This is since the function needs to access DoF values on neighboring cells as well, even if they belong to a different subdomain.</p>
<p>The <code>material_id</code> parameter has a similar meaning: if not set to its default value (which is <a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a>), it means that indicators will only be computed for cells with this particular material id.</p>
<p>The <code>n_threads</code> parameter used to indicate the number of threads to be used to compute the error estimator. This parameter is now ignored, with the number of threads determined automatically. The parameter is retained for compatibility with old versions of the library.</p>
<p>The <code>strategy</code> parameter is used to choose the scaling factor for the integral over cell's faces.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="classDoFHandler.html">DoFHandler</a> object given as an argument to this function builds on a <a class="el" href="classparallel_1_1distributed_1_1Triangulation.html">parallel::distributed::Triangulation</a>, this function skips computations on all cells that are not locally owned. In that case, the only valid value for the subdomain_id argument (besides the invalid value) is the subdomain id that is associated with the currently processor, as reported by <a class="el" href="classparallel_1_1TriangulationBase.html#a41b129156d89f37482d2095de5751d9c">parallel::distributed::Triangulation::locally_owned_subdomain()</a>. Even though nothing is computed on cells that we don't locally own, the error indicator vector must still have a length equal to the number of active cell in the mesh as reported by <a class="el" href="classparallel_1_1TriangulationBase.html#a74e904416671ca175093274144e49439">parallel::distributed::Triangulation::n_locally_owned_active_cells()</a>. </dd></dl>

</div>
</div>
<a id="a3a2d50d84e23346f63edb23fa300af4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a2d50d84e23346f63edb23fa300af4d">&#9670;&nbsp;</a></span>estimate() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the <code>estimate</code> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="a15883245f837a46d030f21e8069a0648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15883245f837a46d030f21e8069a0648">&#9670;&nbsp;</a></span>estimate() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Same function as above, but accepts more than one solution vector and returns one error vector for each solution vector. For the reason of existence of this function, see the general documentation of this class.</p>
<p>Since we do not want to force the user of this function to copy around their solution vectors, the vector of solution vectors takes pointers to the solutions, rather than being a vector of vectors. This makes it simpler to have the solution vectors somewhere in memory, rather than to have them collected somewhere special. (Note that it is not possible to construct of vector of references, so we had to use a vector of pointers.) </p>

</div>
</div>
<a id="a5d532c1a22dfebe7ac8e278b7e467020"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d532c1a22dfebe7ac8e278b7e467020">&#9670;&nbsp;</a></span>estimate() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classQuadrature.html">Quadrature</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the <code>estimate</code> function, see above, with <code>mapping=<a class="el" href="classMappingQGeneric.html">MappingQGeneric</a>&lt;dim&gt;(1)</code>. </p>

</div>
</div>
<a id="aa201c9b6ae94601b6cbdc582ec038635"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa201c9b6ae94601b6cbdc582ec038635">&#9670;&nbsp;</a></span>estimate() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp-finite element dof handlers. </p>

</div>
</div>
<a id="a26d7f4ab108ebdee6db6b15aff0184bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26d7f4ab108ebdee6db6b15aff0184bb">&#9670;&nbsp;</a></span>estimate() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const InputVector &amp;&#160;</td>
          <td class="paramname"><em>solution</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp-finite element dof handlers. </p>

</div>
</div>
<a id="a201770502aceb466095aab7b327a0013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a201770502aceb466095aab7b327a0013">&#9670;&nbsp;</a></span>estimate() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp-finite element dof handlers. </p>

</div>
</div>
<a id="aa45e1c0662968c4b764f178243f46eed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45e1c0662968c4b764f178243f46eed">&#9670;&nbsp;</a></span>estimate() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<div class="memtemplate">
template&lt;typename InputVector &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::estimate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDoFHandler.html">DoFHandler</a>&lt; dim, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>dof</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhp_1_1QCollection.html">hp::QCollection</a>&lt; dim - 1 &gt; &amp;&#160;</td>
          <td class="paramname"><em>quadrature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; <a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>, const <a class="el" href="classFunction.html">Function</a>&lt; spacedim, typename InputVector::value_type &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>neumann_bc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; const InputVector *&gt; &amp;&#160;</td>
          <td class="paramname"><em>solutions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classVector.html">Vector</a>&lt; float &gt; *&gt; &amp;&#160;</td>
          <td class="paramname"><em>errors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classComponentMask.html">ComponentMask</a> &amp;&#160;</td>
          <td class="paramname"><em>component_mask</em> = <code><a class="el" href="classComponentMask.html">ComponentMask</a>()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFunction.html">Function</a>&lt; spacedim &gt; *&#160;</td>
          <td class="paramname"><em>coefficients</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>n_threads</em> = <code><a class="el" href="namespacenumbers.html#a8ae36952c7e0cc778b47b5371b3aeff1">numbers::invalid_unsigned_int</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3d8ea8a4c6a58127f8c2fcc9ec74af6e">types::subdomain_id</a>&#160;</td>
          <td class="paramname"><em>subdomain_id</em> = <code><a class="el" href="namespacenumbers.html#a6fe5acece133d890bee8cc49ccd8ebfb">numbers::invalid_subdomain_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#ae22a1b4da339109d8dc9cc2a112b1a69">types::material_id</a>&#160;</td>
          <td class="paramname"><em>material_id</em> = <code><a class="el" href="namespacenumbers.html#a0057e26e840aa2b146bf44499754774d">numbers::invalid_material_id</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1e">Strategy</a>&#160;</td>
          <td class="paramname"><em>strategy</em> = <code><a class="el" href="classKellyErrorEstimator.html#adc94d710b3db4967da1ea80bd7813a1ea460c903b8ec8ac425e665ef3dfddb383">cell_diameter_over_24</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Equivalent to the set of functions above, except that this one takes a quadrature collection for hp-finite element dof handlers. </p>

</div>
</div>
<a id="a89bc380daafc0581bf95ecdc6620e68a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bc380daafc0581bf95ecdc6620e68a">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidComponentMask&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You provided a <a class="el" href="classComponentMask.html">ComponentMask</a> argument that is invalid. &quot; &quot;Component masks need to be either default constructed &quot; &quot;(in which case they indicate that every component is &quot; &quot;selected) or need to have a length <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number &quot; &quot;of vector components of the finite element in use &quot; &quot;by the <a class="el" href="classDoFHandler.html">DoFHandler</a> object. In the latter&#160;</td>
          <td class="paramname"><em>case</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">at &quot; &quot;least one component needs to be selected.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="aa2b26006ab9a630030e4b35441045544"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2b26006ab9a630030e4b35441045544">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidCoefficient&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;If you do specify the argument for a (possibly &quot; &quot;spatially variable) coefficient function for this&#160;</td>
          <td class="paramname"><em>function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot; &quot;then it needs to refer to a coefficient that is either &quot; &quot;scalar(has one vector component) or has as many vector &quot; &quot;components as there are in the finite element used by &quot; &quot;the <a class="el" href="classDoFHandler.html">DoFHandler</a> argument.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a9f097cebfe4ca2d502673d4b103e72f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f097cebfe4ca2d502673d4b103e72f6">&#9670;&nbsp;</a></span>DeclException3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::DeclException3 </td>
          <td>(</td>
          <td class="paramtype">ExcInvalidBoundaryFunction&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacetypes.html#aed8813fee8c8a2edcc6005e6a48c321a">types::boundary_id</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You provided a function map that for boundary indicator &quot;&lt;&lt; arg1&lt;&lt; &quot; specifies a function with &quot;&lt;&lt; arg2&lt;&lt; &quot; vector components.&#160;</td>
          <td class="paramname"><em>However</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">the finite &quot; &quot;element in use has &quot;&lt;&lt; arg3&lt;&lt; &quot;&#160;</td>
          <td class="paramname"><em>components</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and these two numbers need to match.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a6e54685ad5fb8d398e59e9738a1ea3dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e54685ad5fb8d398e59e9738a1ea3dc">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcIncompatibleNumberOfElements&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The number of input&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;&lt;&lt; arg1&lt;&lt; &quot; needs to be <a class="el" href="vectorization_8h.html#a31b02447b71a04a1ec9bdd1358751e45a465289687a70db7aa7217cc240c29f0f">equal</a> to the number of output&#160;</td>
          <td class="paramname"><em>vectors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;&lt;&lt; arg2&lt;&lt; &quot;. This is not the case in your call of this function.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a01964146b93387474ba9021acd90eb18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01964146b93387474ba9021acd90eb18">&#9670;&nbsp;</a></span>DeclExceptionMsg() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a>&lt; dim, spacedim &gt;::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcNoSolutions&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You need to specify at least one solution vector as &quot; &quot;input.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/numerics/<a class="el" href="error__estimator_8h_source.html">error_estimator.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
