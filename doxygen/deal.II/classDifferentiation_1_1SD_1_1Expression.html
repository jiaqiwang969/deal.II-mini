<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classDifferentiation_1_1SD_1_1Expression.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Differentiation::SD::Expression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceDifferentiation.html">Differentiation</a></li><li class="navelem"><a class="el" href="namespaceDifferentiation_1_1SD.html">SD</a></li><li class="navelem"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classDifferentiation_1_1SD_1_1Expression-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Differentiation::SD::Expression Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="symengine__number__types_8h_source.html">deal.II/differentiation/sd/symengine_number_types.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors</div></td></tr>
<tr class="memitem:ad1eed4afe6f1633fc848b36bb04f56d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> ()</td></tr>
<tr class="separator:ad1eed4afe6f1633fc848b36bb04f56d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a70f103bd92b275c281709d2f345ba"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a51a70f103bd92b275c281709d2f345ba">Expression</a> (const <a class="el" href="classbool.html">bool</a> value)</td></tr>
<tr class="separator:a51a70f103bd92b275c281709d2f345ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31c67bc4b867ab20e72f221847256a4e"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                  std::is_arithmetic&lt;NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a31c67bc4b867ab20e72f221847256a4e"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a31c67bc4b867ab20e72f221847256a4e">Expression</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;value)</td></tr>
<tr class="separator:a31c67bc4b867ab20e72f221847256a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c8f404412788dff491411518888471"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                  std::is_arithmetic&lt;NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:af1c8f404412788dff491411518888471"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#af1c8f404412788dff491411518888471">Expression</a> (const std::complex&lt; <a class="el" href="classNumberType.html">NumberType</a> &gt; &amp;value)</td></tr>
<tr class="separator:af1c8f404412788dff491411518888471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6309fa817e14c80ab651c62835d85a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ad6309fa817e14c80ab651c62835d85a7">Expression</a> (const SymEngine::integer_class &amp;value)</td></tr>
<tr class="separator:ad6309fa817e14c80ab651c62835d85a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a3db163da2f6f4fdd2035473b932a96"><td class="memTemplParams" colspan="2">template&lt;typename NumberType , typename  = typename std::enable_if&lt;                  std::is_integral&lt;NumberType&gt;::value&gt;::type&gt; </td></tr>
<tr class="memitem:a4a3db163da2f6f4fdd2035473b932a96"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a4a3db163da2f6f4fdd2035473b932a96">Expression</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;numerator, const <a class="el" href="classNumberType.html">NumberType</a> &amp;denominator)</td></tr>
<tr class="separator:a4a3db163da2f6f4fdd2035473b932a96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe363a93b001e3cb6b7e73441495ad9b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#afe363a93b001e3cb6b7e73441495ad9b">Expression</a> (const SymEngine::rational_class &amp;value)</td></tr>
<tr class="separator:afe363a93b001e3cb6b7e73441495ad9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8170fb1b1e6f64a1369ef7be433ea59f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a8170fb1b1e6f64a1369ef7be433ea59f">Expression</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;condition, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression_if_true, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression_if_false)</td></tr>
<tr class="separator:a8170fb1b1e6f64a1369ef7be433ea59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3d7c45543ecea57cfbaeaf167ac25b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ad3d7c45543ecea57cfbaeaf167ac25b7">Expression</a> (const std::vector&lt; std::pair&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&gt; &amp;condition_expression, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;expression_otherwise)</td></tr>
<tr class="separator:ad3d7c45543ecea57cfbaeaf167ac25b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a019301d26bfec565342119416dd497"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a7a019301d26bfec565342119416dd497">Expression</a> (const std::vector&lt; std::pair&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&gt; &amp;condition_expression)</td></tr>
<tr class="separator:a7a019301d26bfec565342119416dd497"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd213bcc0e25ec24dfdf5631985ef3c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#abd213bcc0e25ec24dfdf5631985ef3c6">Expression</a> (const char *symbol)</td></tr>
<tr class="separator:abd213bcc0e25ec24dfdf5631985ef3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b7f46103f32b947cfb74ebb61ef0cfb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a9b7f46103f32b947cfb74ebb61ef0cfb">Expression</a> (const std::string &amp;symb_expr, const <a class="el" href="classbool.html">bool</a> parse_as_expression=false)</td></tr>
<tr class="separator:a9b7f46103f32b947cfb74ebb61ef0cfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc5e17d5d7d1601fe4066f12e3dd837d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#abc5e17d5d7d1601fe4066f12e3dd837d">Expression</a> (const std::string &amp;symbol_func, const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a3851c361f9dae70bd4fa3c005ce295e0">types::symbol_vector</a> &amp;arguments)</td></tr>
<tr class="separator:abc5e17d5d7d1601fe4066f12e3dd837d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d4bcd739796b5634e5042163a2473b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aa1d4bcd739796b5634e5042163a2473b">Expression</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)=default</td></tr>
<tr class="separator:aa1d4bcd739796b5634e5042163a2473b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b3c305d3e0fe25c72ae1efb496ba33"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a32b3c305d3e0fe25c72ae1efb496ba33">Expression</a> (const SymEngine::Expression &amp;rhs)</td></tr>
<tr class="separator:a32b3c305d3e0fe25c72ae1efb496ba33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5607ac4e5dceaf5b363ea7c5adf90918"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a5607ac4e5dceaf5b363ea7c5adf90918">Expression</a> (const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;rhs)</td></tr>
<tr class="separator:a5607ac4e5dceaf5b363ea7c5adf90918"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b05046366f2f27c9dc5e150398bedcb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a4b05046366f2f27c9dc5e150398bedcb">Expression</a> (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&amp;rhs)=default</td></tr>
<tr class="separator:a4b05046366f2f27c9dc5e150398bedcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78a2a5c286692db6d79d33e21a57072"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ad78a2a5c286692db6d79d33e21a57072">Expression</a> (SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;&amp;rhs)</td></tr>
<tr class="separator:ad78a2a5c286692db6d79d33e21a57072"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e99eab977a29b8a13755842e5387ced"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a3e99eab977a29b8a13755842e5387ced">~Expression</a> ()=default</td></tr>
<tr class="separator:a3e99eab977a29b8a13755842e5387ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader"></div></td></tr>
<tr class="memitem:a0560b0e97d122ad4c122407d4708e345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a0560b0e97d122ad4c122407d4708e345">parse</a> (const std::string &amp;<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aef1df7282f8a447fd716b0b924ac0f03">expression</a>)</td></tr>
<tr class="separator:a0560b0e97d122ad4c122407d4708e345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8728f3f590d8040410a0282d4aff207b"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a8728f3f590d8040410a0282d4aff207b">print</a> (std::ostream &amp;stream) const</td></tr>
<tr class="separator:a8728f3f590d8040410a0282d4aff207b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e9ba8b8e938443b8c3737faef39dce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aa6e9ba8b8e938443b8c3737faef39dce">save</a> (std::ostream &amp;stream) const</td></tr>
<tr class="separator:aa6e9ba8b8e938443b8c3737faef39dce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7bfe3dcb00c9e21792efa5ed30b8d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a3a7bfe3dcb00c9e21792efa5ed30b8d3">load</a> (std::istream &amp;stream)</td></tr>
<tr class="separator:a3a7bfe3dcb00c9e21792efa5ed30b8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ea745682bf03ee4fe89d86ddf3a2154"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a9ea745682bf03ee4fe89d86ddf3a2154"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a9ea745682bf03ee4fe89d86ddf3a2154">save</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version) const</td></tr>
<tr class="separator:a9ea745682bf03ee4fe89d86ddf3a2154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedc7b5610282abcb3283746aba1634c2"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:aedc7b5610282abcb3283746aba1634c2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aedc7b5610282abcb3283746aba1634c2">load</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:aedc7b5610282abcb3283746aba1634c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cc109e113a95222de8d9d16d073d751"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a5cc109e113a95222de8d9d16d073d751"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a5cc109e113a95222de8d9d16d073d751">serialize</a> (Archive &amp;archive, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a5cc109e113a95222de8d9d16d073d751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Values</div></td></tr>
<tr class="memitem:ae4b27220fbccc039160ce6d268e82b39"><td class="memItemLeft" align="right" valign="top">const SymEngine::Expression &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ae4b27220fbccc039160ce6d268e82b39">get_expression</a> () const</td></tr>
<tr class="separator:ae4b27220fbccc039160ce6d268e82b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7bba68c27819fcfe2c537dfb3d5bd7"><td class="memItemLeft" align="right" valign="top">const SymEngine::Basic &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ade7bba68c27819fcfe2c537dfb3d5bd7">get_value</a> () const</td></tr>
<tr class="separator:ade7bba68c27819fcfe2c537dfb3d5bd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3467304d7d217530746de81ecfab508b"><td class="memItemLeft" align="right" valign="top">const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a3467304d7d217530746de81ecfab508b">get_RCP</a> () const</td></tr>
<tr class="separator:a3467304d7d217530746de81ecfab508b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Math and relational operators with (potentially) symbolic types</div></td></tr>
<tr class="memitem:a28d86864d3d8d14fb6f395ff4132c07c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a28d86864d3d8d14fb6f395ff4132c07c">operator=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a28d86864d3d8d14fb6f395ff4132c07c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84c798956888ef3986685b301d58233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ad84c798956888ef3986685b301d58233">operator=</a> (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&amp;rhs) noexcept</td></tr>
<tr class="separator:ad84c798956888ef3986685b301d58233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed1cef351b5eed807c4e06b7e43ff28a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aed1cef351b5eed807c4e06b7e43ff28a">operator+=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:aed1cef351b5eed807c4e06b7e43ff28a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc60c8e387c895bef15a080b46bf4e75"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#acc60c8e387c895bef15a080b46bf4e75">operator-=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:acc60c8e387c895bef15a080b46bf4e75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c769cbfc50d385bf033a83e8207166b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a4c769cbfc50d385bf033a83e8207166b">operator*=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a4c769cbfc50d385bf033a83e8207166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03666bc7a1f29e2589fba654b782505f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a03666bc7a1f29e2589fba654b782505f">operator/=</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;rhs)</td></tr>
<tr class="separator:a03666bc7a1f29e2589fba654b782505f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Math and relational operators with numeric types</div></td></tr>
<tr class="memitem:ab84ade8b9deafe48a08e3b64478893cc"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:ab84ade8b9deafe48a08e3b64478893cc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ab84ade8b9deafe48a08e3b64478893cc">operator=</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:ab84ade8b9deafe48a08e3b64478893cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f932b96763ded2a0e3e313fea9aba1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a0f932b96763ded2a0e3e313fea9aba1b">operator-</a> () const</td></tr>
<tr class="separator:a0f932b96763ded2a0e3e313fea9aba1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a750756c6393b605972f51461b368e484"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:a750756c6393b605972f51461b368e484"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a750756c6393b605972f51461b368e484">operator+=</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:a750756c6393b605972f51461b368e484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7290addc2d1dfcafc95bff0d5dcc33b7"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:a7290addc2d1dfcafc95bff0d5dcc33b7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a7290addc2d1dfcafc95bff0d5dcc33b7">operator-=</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:a7290addc2d1dfcafc95bff0d5dcc33b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0fff955edd047bbde2454edab394cee"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:aa0fff955edd047bbde2454edab394cee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aa0fff955edd047bbde2454edab394cee">operator*=</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:aa0fff955edd047bbde2454edab394cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6ffcb12abc1cc11a2a06cf13ccbafd0"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:ab6ffcb12abc1cc11a2a06cf13ccbafd0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ab6ffcb12abc1cc11a2a06cf13ccbafd0">operator/=</a> (const <a class="el" href="classNumberType.html">NumberType</a> &amp;rhs)</td></tr>
<tr class="separator:ab6ffcb12abc1cc11a2a06cf13ccbafd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Differentiation</div></td></tr>
<tr class="memitem:af1de25e7cd7f7aabe0e4563ffbfcc2d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#af1de25e7cd7f7aabe0e4563ffbfcc2d5">differentiate</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol) const</td></tr>
<tr class="separator:af1de25e7cd7f7aabe0e4563ffbfcc2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf241db3bc0903648f4aff4cd60f6365"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#acf241db3bc0903648f4aff4cd60f6365">differentiate</a> (const SymEngine::RCP&lt; const SymEngine::Symbol &gt; &amp;symbol) const</td></tr>
<tr class="separator:acf241db3bc0903648f4aff4cd60f6365"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79ffdd0c612e9ad1488e792811a494d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a79ffdd0c612e9ad1488e792811a494d1">differentiate</a> (const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;symbol) const</td></tr>
<tr class="separator:a79ffdd0c612e9ad1488e792811a494d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Dictionary-based substitution</div></td></tr>
<tr class="memitem:a878a213d98c64d599912d2fe57e4e7b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a878a213d98c64d599912d2fe57e4e7b5">substitute</a> (const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_values) const</td></tr>
<tr class="separator:a878a213d98c64d599912d2fe57e4e7b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5139ab6b522e64a4d03f290995d645f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a5139ab6b522e64a4d03f290995d645f3">substitute</a> (const SymEngine::map_basic_basic &amp;substitution_values) const</td></tr>
<tr class="separator:a5139ab6b522e64a4d03f290995d645f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab57f848ba5a62368f38adc3ccd873f8a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ab57f848ba5a62368f38adc3ccd873f8a">substitute</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol, const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;value) const</td></tr>
<tr class="separator:ab57f848ba5a62368f38adc3ccd873f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c28bf2a1124a39e905c38b1dd752bee"><td class="memTemplParams" colspan="2">template&lt;typename NumberType &gt; </td></tr>
<tr class="memitem:a1c28bf2a1124a39e905c38b1dd752bee"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a1c28bf2a1124a39e905c38b1dd752bee">substitute</a> (const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;symbol, const <a class="el" href="classNumberType.html">NumberType</a> &amp;value) const</td></tr>
<tr class="separator:a1c28bf2a1124a39e905c38b1dd752bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384aeffc01dd7d6b2c658323ef741a7d"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:a384aeffc01dd7d6b2c658323ef741a7d"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a384aeffc01dd7d6b2c658323ef741a7d">substitute_and_evaluate</a> (const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;substitution_values) const</td></tr>
<tr class="separator:a384aeffc01dd7d6b2c658323ef741a7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab21bf0b917a9fefd3e1aaaff67c6e31e"><td class="memTemplParams" colspan="2">template&lt;typename ReturnType &gt; </td></tr>
<tr class="memitem:ab21bf0b917a9fefd3e1aaaff67c6e31e"><td class="memTemplItemLeft" align="right" valign="top">ReturnType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ab21bf0b917a9fefd3e1aaaff67c6e31e">substitute_and_evaluate</a> (const SymEngine::map_basic_basic &amp;substitution_values) const</td></tr>
<tr class="separator:ab21bf0b917a9fefd3e1aaaff67c6e31e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Conversion operators</div></td></tr>
<tr class="memitem:a667cb38093dd283a0b87501e21d8fcfa"><td class="memTemplParams" colspan="2">template&lt;typename ResultType &gt; </td></tr>
<tr class="memitem:a667cb38093dd283a0b87501e21d8fcfa"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a667cb38093dd283a0b87501e21d8fcfa">operator ResultType</a> () const</td></tr>
<tr class="separator:a667cb38093dd283a0b87501e21d8fcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d8003cafbe589706900c41ff8b6def3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#a4d8003cafbe589706900c41ff8b6def3">operator const SymEngine::Expression &amp;</a> () const</td></tr>
<tr class="separator:a4d8003cafbe589706900c41ff8b6def3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade7a3d1c21d6102385e1b0737e989773"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#ade7a3d1c21d6102385e1b0737e989773">operator const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;</a> () const</td></tr>
<tr class="separator:ade7a3d1c21d6102385e1b0737e989773"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:aadcbda719f85e606b6bb5c26f593b776"><td class="memItemLeft" align="right" valign="top">SymEngine::Expression &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aadcbda719f85e606b6bb5c26f593b776">get_expression</a> ()</td></tr>
<tr class="separator:aadcbda719f85e606b6bb5c26f593b776"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aef1df7282f8a447fd716b0b924ac0f03"><td class="memItemLeft" align="right" valign="top">SymEngine::Expression&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html#aef1df7282f8a447fd716b0b924ac0f03">expression</a></td></tr>
<tr class="separator:aef1df7282f8a447fd716b0b924ac0f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class to wrap SymEngine expressions.</p>
<p>With this number type, SymEngine numbers can be used to perform scalar and tensor mathematics in deal.II. It (or the SymEngine::Expression class, of which it stores an instance) therefore forms the basis of symbolic computation via SymEngine in deal.II. With it one can perform symbolic differentiation and subsequent substitution with both scalars and deal.II's native <a class="el" href="classTensor.html">Tensor</a> and <a class="el" href="classSymmetricTensor.html">SymmetricTensor</a> types.</p>
<p>The symbolic features that this class supports includes:</p><ul>
<li>expression parsing,</li>
<li>comparison operations,</li>
<li>logical operations,</li>
<li>math operations,</li>
<li>conditional expression construction,</li>
<li>differentiation,</li>
<li>substitution (partial and complete), and</li>
<li>serialization.</li>
</ul>
<p>A simple example of how this class may be used is as follows: </p><div class="fragment"><div class="line"><span class="comment">// Constructing a symbolic expression:</span></div><div class="line"><span class="comment">// This is a symbol, which we will treat as an argument to a symbolic</span></div><div class="line"><span class="comment">// function.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> x(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line"><span class="comment">// This is a symbolic expression, which is an expression constructed</span></div><div class="line"><span class="comment">// from individual symbols.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> f = (x + y)*(x + y);</div><div class="line"></div><div class="line"><span class="comment">// Value substitution</span></div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>;</div><div class="line">substitution_map[x] = <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(1);</div><div class="line">substitution_map[y] = <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(2.5);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> evaluated_f =</div><div class="line">  f.substitute_and_evaluate&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"><span class="comment">// We could also have performed substitution of each individual</span></div><div class="line"><span class="comment">// argument, if we wanted to. This means that one can partially</span></div><div class="line"><span class="comment">// substitute an expression at any time.</span></div></div><!-- fragment --><p>A more intricate example of conditional evaluation is as follows: </p><div class="fragment"><div class="line"><span class="comment">// Construct symbolic expressions</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> x(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> f_plus = (x + y)*(x + y);</div><div class="line"><span class="comment">// Parsing expressions from a string is also possible. Its arguments</span></div><div class="line"><span class="comment">// must have been previously declared through (and in scope).</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> f_minus (<span class="stringliteral">&quot;(x-y)*(x-y)&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Constructing a conditional expression</span></div><div class="line"><span class="keyword">const</span> SD_number_t f((x &gt; <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(0.0)), f_plus, f_minus);</div><div class="line"></div><div class="line"><span class="comment">// Value substitution</span></div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>;</div><div class="line">substitution_map[x] = <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(1);</div><div class="line">substitution_map[y] = <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(2.5);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> evaluated_f =</div><div class="line">  f.substitute_and_evaluate&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"><span class="comment">// Since the substituted value for x was greater than zero, we expect</span></div><div class="line"><span class="comment">// that the returned result now in evaluated_f was evaluated from</span></div><div class="line"><span class="comment">// the function f_plus.</span></div></div><!-- fragment --><p>Lastly, here is an example using symbolic differentiation: </p><div class="fragment"><div class="line"><span class="comment">// Construct symbolic expressions</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> x(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> f(<span class="stringliteral">&quot;x**2&quot;</span>, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">// Now perform differentiation. Specifically, we differentiate the</span></div><div class="line"><span class="comment">// function &quot;f&quot; with respect to the symbolic variable &quot;x&quot;.</span></div><div class="line"><span class="comment">// The result should be the expression &quot;2*x&quot;.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> df_dx = f.differentiate(x);</div><div class="line"></div><div class="line"><span class="comment">// Value substitution</span></div><div class="line"><a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> <a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>;</div><div class="line">substitution_map[x] = <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(10.0);</div><div class="line"><span class="keyword">const</span> <span class="keywordtype">double</span> evaluated_df_dx =</div><div class="line">  evaluated_df_dx.substitute_and_evaluate&lt;<span class="keywordtype">double</span>&gt;(<a class="code" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">substitution_map</a>);</div><div class="line"><span class="comment">// We can expect the above to evaluate to &quot;2*10&quot; which is,</span></div><div class="line"><span class="comment">// of course, the numeric value 20.</span></div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l00177">177</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad1eed4afe6f1633fc848b36bb04f56d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1eed4afe6f1633fc848b36bb04f56d2">&#9670;&nbsp;</a></span>Expression() <span class="overload">[1/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Default constructor. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00048">48</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a51a70f103bd92b275c281709d2f345ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51a70f103bd92b275c281709d2f345ba">&#9670;&nbsp;</a></span>Expression() <span class="overload">[2/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor for boolean types.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is marked as explicit so that there are no potential ambiguities related to implicit conversions in either user code or math functions that are loaded into the standard namespace. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00053">53</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a31c67bc4b867ab20e72f221847256a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31c67bc4b867ab20e72f221847256a4e">&#9670;&nbsp;</a></span>Expression() <span class="overload">[3/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                  std::is_arithmetic&lt;NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor for arithmetic number types.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is marked as explicit so that there are no potential ambiguities related to implicit conversions in either user code or math functions that are loaded into the standard namespace. </dd></dl>

</div>
</div>
<a id="af1c8f404412788dff491411518888471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c8f404412788dff491411518888471">&#9670;&nbsp;</a></span>Expression() <span class="overload">[4/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                  std::is_arithmetic&lt;NumberType&gt;::value&gt;::type&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::complex&lt; <a class="el" href="classNumberType.html">NumberType</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor for complex numbers templated on arithmetic number types.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is marked as explicit so that there are no potential ambiguities related to implicit conversions in either user code or math functions that are loaded into the standard namespace. </dd></dl>

</div>
</div>
<a id="ad6309fa817e14c80ab651c62835d85a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6309fa817e14c80ab651c62835d85a7">&#9670;&nbsp;</a></span>Expression() <span class="overload">[5/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::integer_class &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for integer types. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00058">58</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a4a3db163da2f6f4fdd2035473b932a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a3db163da2f6f4fdd2035473b932a96">&#9670;&nbsp;</a></span>Expression() <span class="overload">[6/18]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType , typename  = typename std::enable_if&lt;                  std::is_integral&lt;NumberType&gt;::value&gt;::type&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>numerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>denominator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for rational types.</p>
<p>It is expected that both the <code>numerator</code> and <code>denominator</code> be integral types. </p>

</div>
</div>
<a id="afe363a93b001e3cb6b7e73441495ad9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe363a93b001e3cb6b7e73441495ad9b">&#9670;&nbsp;</a></span>Expression() <span class="overload">[7/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::rational_class &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for rational types. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00063">63</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a8170fb1b1e6f64a1369ef7be433ea59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8170fb1b1e6f64a1369ef7be433ea59f">&#9670;&nbsp;</a></span>Expression() <span class="overload">[8/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression_if_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression_if_false</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a piecewise defined function.</p>
<p>The generated expression may be interpreted as the result of the teniary operator, i.e. <code>(condition ? expression_if_true : expression_if_false)</code>.</p>
<p>The <code>condition</code> can be any expression that renders an expression that is convertible to a SymEngine::Boolean operator. This includes:</p><ul>
<li>the logical operators of the deal.II <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> class</li>
<li>SymEngine::boolean()</li>
<li>SymEngine::contains()</li>
<li>SymEngine::Eq()</li>
<li>SymEngine::Ne()</li>
<li>SymEngine::Ge()</li>
<li>SymEngine::Gt()</li>
<li>SymEngine::Le()</li>
<li>SymEngine::Lt()</li>
<li>SymEngine::logical_and()</li>
<li>SymEngine::logical_nand()</li>
<li><a class="el" href="namespaceUtilities_1_1MPI.html#a32879e6c2f20242f7fa2b4f16ebf674a">SymEngine::logical_or()</a></li>
<li>SymEngine::logical_not()</li>
<li>SymEngine::logical_nor()</li>
<li>SymEngine::logical_xor()</li>
<li>SymEngine::logical_xnor()</li>
<li>...</li>
</ul>
<p>An example of this constructor's use is as follows: </p><div class="fragment"><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> x(<span class="stringliteral">&quot;x&quot;</span>);</div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> y(<span class="stringliteral">&quot;y&quot;</span>);</div><div class="line"></div><div class="line"><span class="comment">// Construct a conditional expression using the symbolic variables.</span></div><div class="line"><span class="keyword">const</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a> f ((x &lt; <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a>(0.0)), x+y, x-y);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00068">68</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ad3d7c45543ecea57cfbaeaf167ac25b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3d7c45543ecea57cfbaeaf167ac25b7">&#9670;&nbsp;</a></span>Expression() <span class="overload">[9/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>condition_expression</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>expression_otherwise</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a piecewise defined function.</p>
<p>The generated expression may be interpreted as the result of the set of nested if-elseif-else statements, i.e. (in pseudo-code) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (condition_expression[0].<a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> == <span class="keyword">true</span>)</div><div class="line">  <span class="keywordflow">return</span> condition_expression[0].second;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (condition_expression[1].<a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> == <span class="keyword">true</span>)</div><div class="line">  <span class="keywordflow">return</span> condition_expression[1].second;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (...)</div><div class="line">  <span class="keywordflow">return</span> ...;</div><div class="line"><span class="keywordflow">else</span></div><div class="line">  <span class="keywordflow">return</span> expression_otherwise;</div></div><!-- fragment --><p> if the input vector has more than 2 elements.</p>
<p>This variant takes the piecewise evaluated conditions and its results as the first argument, and the default return value as the second argument. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00084">84</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a7a019301d26bfec565342119416dd497"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a019301d26bfec565342119416dd497">&#9670;&nbsp;</a></span>Expression() <span class="overload">[10/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>, <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>condition_expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for a piecewise defined function.</p>
<p>The generated expression may be interpreted as the result of the set of nested if-elseif statements, i.e. (in pseudo-code) </p><div class="fragment"><div class="line"><span class="keywordflow">if</span> (condition_expression[0].<a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> == <span class="keyword">true</span>)</div><div class="line">  <span class="keywordflow">return</span> condition_expression[0].second;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (condition_expression[1].<a class="code" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> == <span class="keyword">true</span>)</div><div class="line">  <span class="keywordflow">return</span> condition_expression[1].second;</div><div class="line"><span class="keywordflow">else</span> <span class="keywordflow">if</span> (...)</div><div class="line">  <span class="keywordflow">return</span> ...;</div></div><!-- fragment --><p> if the input vector has more than 2 elements.</p>
<p>This variant takes only the piecewise evaluated conditions and its results. If none of the conditions are met upon evaluation then the returned result will be NaN. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00111">111</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="abd213bcc0e25ec24dfdf5631985ef3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd213bcc0e25ec24dfdf5631985ef3c6">&#9670;&nbsp;</a></span>Expression() <span class="overload">[11/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for symbolic types.</p>
<p>This constructor initializes a symbolic type with a character array representing its symbolic value. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00122">122</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a9b7f46103f32b947cfb74ebb61ef0cfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b7f46103f32b947cfb74ebb61ef0cfb">&#9670;&nbsp;</a></span>Expression() <span class="overload">[12/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symb_expr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>parse_as_expression</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for symbolic types.</p>
<p>This constructor initializes a symbolic type with a string representing its symbolic value. If the <code>parse_as_expression</code> flag is <code>false</code>, then the <code>symb_expr</code> (potentially composed of multiple characters) will be interpreted as a single symbol. If the <code>parse_as_expression</code> flag is <code>true</code>, then the <code>symb_expr</code> will be parsed as a symbolic expression (potentially composed of multiple symbols, constants, etc.). </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00127">127</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="abc5e17d5d7d1601fe4066f12e3dd837d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc5e17d5d7d1601fe4066f12e3dd837d">&#9670;&nbsp;</a></span>Expression() <span class="overload">[13/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol_func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#a3851c361f9dae70bd4fa3c005ce295e0">types::symbol_vector</a> &amp;&#160;</td>
          <td class="paramname"><em>arguments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor for function symbol types.</p>
<p>This constructor initializes a function symbol with a string representing its symbolic name. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00145">145</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="aa1d4bcd739796b5634e5042163a2473b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d4bcd739796b5634e5042163a2473b">&#9670;&nbsp;</a></span>Expression() <span class="overload">[14/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor. </p>

</div>
</div>
<a id="a32b3c305d3e0fe25c72ae1efb496ba33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b3c305d3e0fe25c72ae1efb496ba33">&#9670;&nbsp;</a></span>Expression() <span class="overload">[15/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::Expression &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<dl class="section note"><dt>Note</dt><dd>This constructor is marked as explicit to prevent any ambiguities from implicit conversion when both the deal.II and SymEngine namespaces are imported. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00153">153</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a5607ac4e5dceaf5b363ea7c5adf90918"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5607ac4e5dceaf5b363ea7c5adf90918">&#9670;&nbsp;</a></span>Expression() <span class="overload">[16/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor.</p>
<p>This allows us to create our class straight from the results of SymEngine operations. This is especially important for operations like "diff", because the returned result is not primitive, but rather a set of compound operations. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00158">158</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a4b05046366f2f27c9dc5e150398bedcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b05046366f2f27c9dc5e150398bedcb">&#9670;&nbsp;</a></span>Expression() <span class="overload">[17/18]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move constructor. </p>

</div>
</div>
<a id="ad78a2a5c286692db6d79d33e21a57072"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78a2a5c286692db6d79d33e21a57072">&#9670;&nbsp;</a></span>Expression() <span class="overload">[18/18]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::Expression </td>
          <td>(</td>
          <td class="paramtype">SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor.</p>
<p>This allows us to create our class straight from the results of SymEngine operations. This is especially important for operations like "diff", because the returned result is not primitive, but rather a set of compound operations. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00163">163</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a3e99eab977a29b8a13755842e5387ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e99eab977a29b8a13755842e5387ced">&#9670;&nbsp;</a></span>~Expression()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Differentiation::SD::Expression::~Expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0560b0e97d122ad4c122407d4708e345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0560b0e97d122ad4c122407d4708e345">&#9670;&nbsp;</a></span>parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::parse </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>expression</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="namespaceDifferentiation_1_1SD_1_1Utilities.html">Utilities</a> Parse an expression from a string representing a symbolic <code>expression</code>. This overwrites any existing value or expression that this object represents. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00172">172</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a8728f3f590d8040410a0282d4aff207b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8728f3f590d8040410a0282d4aff207b">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; Differentiation::SD::Expression::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the value stored by this object.</p>
<p>Since the stored value could be one of a number of types, we leave SymEngine to cast and output the correct representation of the data. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00180">180</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="aa6e9ba8b8e938443b8c3737faef39dce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e9ba8b8e938443b8c3737faef39dce">&#9670;&nbsp;</a></span>save() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::Expression::save </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Save the value stored by this object to the <code>stream</code>.</p>
<p>Each expression will be saved on a new line of the <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00188">188</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a3a7bfe3dcb00c9e21792efa5ed30b8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7bfe3dcb00c9e21792efa5ed30b8d3">&#9670;&nbsp;</a></span>load() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::Expression::load </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load the value stored in the <code>stream</code> into this object using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>It is expected that each expression appears on its own on single line of <code>stream</code>.</p>
<dl class="section note"><dt>Note</dt><dd>When loading a symbolic expression, it is imperative that you first create or load all of the symbolic variables used in the saved expression. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00198">198</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a9ea745682bf03ee4fe89d86ddf3a2154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ea745682bf03ee4fe89d86ddf3a2154">&#9670;&nbsp;</a></span>save() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::Expression::save </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the data of this object to a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This effectively saves the value stored in this object to the <code>archive</code> with the given <code>version</code> number. </p>

</div>
</div>
<a id="aedc7b5610282abcb3283746aba1634c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedc7b5610282abcb3283746aba1634c2">&#9670;&nbsp;</a></span>load() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::Expression::load </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the data of this object from a stream for the purpose of serialization.</p>
<p>This effectively loads into this object the value stored in of the <code>archive</code> with the given <code>version</code> number. In doing so, the previous contents of this object are thrown away.</p>
<dl class="section note"><dt>Note</dt><dd>When deserializing a symbolic expression, it is imperative that you first create or deserialize all of the symbolic variables used in the serialized expression. </dd></dl>

</div>
</div>
<a id="a5cc109e113a95222de8d9d16d073d751"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cc109e113a95222de8d9d16d073d751">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void Differentiation::SD::Expression::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>archive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write and read the data of this object from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This effectively saves or loads the value stored into/out of the <code>archive</code> with the given <code>version</code> number into this object. If deserializing data, then the previous contents of this object are thrown away.</p>
<dl class="section note"><dt>Note</dt><dd>When deserializing a symbolic expression, it is imperative that you first create or deserialize all of the symbolic variables used in the serialized expression. </dd></dl>

</div>
</div>
<a id="ae4b27220fbccc039160ce6d268e82b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b27220fbccc039160ce6d268e82b39">&#9670;&nbsp;</a></span>get_expression() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SE::Expression &amp; Differentiation::SD::Expression::get_expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the value or expression that this class instance represents. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00213">213</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ade7bba68c27819fcfe2c537dfb3d5bd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7bba68c27819fcfe2c537dfb3d5bd7">&#9670;&nbsp;</a></span>get_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SE::Basic &amp; Differentiation::SD::Expression::get_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the primitive SymEngine data type that stores the value or expression represented by this object. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00227">227</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a3467304d7d217530746de81ecfab508b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3467304d7d217530746de81ecfab508b">&#9670;&nbsp;</a></span>get_RCP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const SE::RCP&lt; const SE::Basic &gt; &amp; Differentiation::SD::Expression::get_RCP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the pointer to the primitive SymEngine data type that stores the value or expression represented by this object. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00234">234</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a28d86864d3d8d14fb6f395ff4132c07c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d86864d3d8d14fb6f395ff4132c07c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator.</p>
<p>Sets the data of this object's <code>expression</code> equal to that of the <code>rhs</code> object. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00320">320</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ad84c798956888ef3986685b301d58233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84c798956888ef3986685b301d58233">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment operator.</p>
<p>Sets the data of this object's <code>expression</code> equal to that of the <code>rhs</code> object. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00330">330</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="aed1cef351b5eed807c4e06b7e43ff28a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed1cef351b5eed807c4e06b7e43ff28a">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition assignment.</p>
<p>The <code>rhs</code> <code>expression</code> is added in-place to that of this object's <code>expression</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00347">347</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="acc60c8e387c895bef15a080b46bf4e75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc60c8e387c895bef15a080b46bf4e75">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction assignment.</p>
<p>The <code>rhs</code> <code>expression</code> is subtracted in-place from that of this object's <code>expression</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00355">355</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a4c769cbfc50d385bf033a83e8207166b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c769cbfc50d385bf033a83e8207166b">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication assignment.</p>
<p>This object's <code>expression</code> is multiplied in-place by that of the <code>rhs</code> <code>expression</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00363">363</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a03666bc7a1f29e2589fba654b782505f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03666bc7a1f29e2589fba654b782505f">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp; Differentiation::SD::Expression::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division assignment.</p>
<p>This object's <code>expression</code> is divided in-place by that of the <code>rhs</code> <code>expression</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00371">371</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ab84ade8b9deafe48a08e3b64478893cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab84ade8b9deafe48a08e3b64478893cc">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&amp; Differentiation::SD::Expression::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator.</p>
<p>Set the data of this object's <code>expression</code> equal to the numerical value of the <code>rhs</code>. </p>

</div>
</div>
<a id="a0f932b96763ded2a0e3e313fea9aba1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f932b96763ded2a0e3e313fea9aba1b">&#9670;&nbsp;</a></span>operator-()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::operator- </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Negation operator.</p>
<p>Return a the result of pre-multipying this object's <code>expression</code> by <code>-1</code>.</p>
<dl class="section note"><dt>Note</dt><dd>This operation is not performed in-place. </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00340">340</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a750756c6393b605972f51461b368e484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a750756c6393b605972f51461b368e484">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&amp; Differentiation::SD::Expression::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Addition assignment.</p>
<p>The numerical value of the <code>rhs</code> is added in-place to that of this object's <code>expression</code>. </p>

</div>
</div>
<a id="a7290addc2d1dfcafc95bff0d5dcc33b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7290addc2d1dfcafc95bff0d5dcc33b7">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&amp; Differentiation::SD::Expression::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Subtraction assignment.</p>
<p>The numerical value of the <code>rhs</code> is subtracted in-place from that of this object's <code>expression</code>. </p>

</div>
</div>
<a id="aa0fff955edd047bbde2454edab394cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0fff955edd047bbde2454edab394cee">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&amp; Differentiation::SD::Expression::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiplication assignment.</p>
<p>This object's <code>expression</code> is multiplied in-place by that of the numerical value of the <code>rhs</code>. </p>

</div>
</div>
<a id="ab6ffcb12abc1cc11a2a06cf13ccbafd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6ffcb12abc1cc11a2a06cf13ccbafd0">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>&amp; Differentiation::SD::Expression::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Division assignment.</p>
<p>This object's <code>expression</code> is divided in-place by that of the numerical value of the <code>rhs</code>. </p>

</div>
</div>
<a id="af1de25e7cd7f7aabe0e4563ffbfcc2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1de25e7cd7f7aabe0e4563ffbfcc2d5">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::differentiate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the derivative of this object's <code>expression</code> with respect to the given <code>symbol</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00261">261</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="acf241db3bc0903648f4aff4cd60f6365"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf241db3bc0903648f4aff4cd60f6365">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::differentiate </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::RCP&lt; const SymEngine::Symbol &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the derivative of this object's <code>expression</code> with respect to the given <code>symbol</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00244">244</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a79ffdd0c612e9ad1488e792811a494d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79ffdd0c612e9ad1488e792811a494d1">&#9670;&nbsp;</a></span>differentiate() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::differentiate </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp;&#160;</td>
          <td class="paramname"><em>symbol</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the derivative of this object's <code>expression</code> with respect to the potential <code>symbol</code>. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00252">252</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a878a213d98c64d599912d2fe57e4e7b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a878a213d98c64d599912d2fe57e4e7b5">&#9670;&nbsp;</a></span>substitute() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform substitution of all symbols found in this object's <code>expression</code> that match a key in the <code>substitution_values</code> map.</p>
<dl class="section note"><dt>Note</dt><dd>The replacement value (the entry in the <code>substitution_values</code> that is paired with a key) need not necessarily be numerical, but may also be another symbolic type.</dd>
<dd>
With dictionary substitution, partial substitution is allowed (i.e. an incomplete substitution map can be used and the return type can be symbolic). </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00294">294</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a5139ab6b522e64a4d03f290995d645f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5139ab6b522e64a4d03f290995d645f3">&#9670;&nbsp;</a></span>substitute() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::substitute </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::map_basic_basic &amp;&#160;</td>
          <td class="paramname"><em>substitution_values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform substitution of all symbols found in this object's <code>expression</code> that match a key in the <code>substitution_values</code> map.</p>
<p>This function is like the one above, but takes in a SymEngine map (one that maps a <code>SymEngine::RCP&lt;const SymEngine::Basic&gt;</code> to another <code>SymEngine::RCP&lt;const SymEngine::Basic&gt;</code>) as an argument.</p>
<dl class="section note"><dt>Note</dt><dd>The replacement value (the entry in the <code>substitution_values</code> that is paired with a key) need not necessarily be numerical, but may also be another symbolic type.</dd>
<dd>
With dictionary substitution, partial substitution is allowed (i.e. an incomplete substitution map can be used and the return type can be symbolic). </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00286">286</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ab57f848ba5a62368f38adc3ccd873f8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab57f848ba5a62368f38adc3ccd873f8a">&#9670;&nbsp;</a></span>substitute() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform substitution of all symbols found in this object's <code>expression</code> that match the <code>symbol</code>. Each <code>symbol</code> will be substituted with the given <code>value</code>.</p>
<dl class="section note"><dt>Note</dt><dd>With dictionary substitution, partial substitution is allowed (i.e. an incomplete substitution map can be used and the return type can be symbolic). </dd></dl>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00303">303</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="a1c28bf2a1124a39e905c38b1dd752bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c28bf2a1124a39e905c38b1dd752bee">&#9670;&nbsp;</a></span>substitute() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NumberType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> Differentiation::SD::Expression::substitute </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classNumberType.html">NumberType</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Perform substitution of all symbols found in this object's <code>expression</code> that match the <code>symbol</code>. Each <code>symbol</code> will be substituted with the given <code>value</code>.</p>
<dl class="section note"><dt>Note</dt><dd>With dictionary substitution, partial substitution is allowed (i.e. an incomplete substitution map can be used and the return type can be symbolic). </dd></dl>

</div>
</div>
<a id="a384aeffc01dd7d6b2c658323ef741a7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384aeffc01dd7d6b2c658323ef741a7d">&#9670;&nbsp;</a></span>substitute_and_evaluate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType Differentiation::SD::Expression::substitute_and_evaluate </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceDifferentiation_1_1SD_1_1types.html#adbe765402ca6453f5f4e8ef744967468">types::substitution_map</a> &amp;&#160;</td>
          <td class="paramname"><em>substitution_values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full substitution and evaluation. This creates a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> by symbol substitution and then immediately computes its numerical value.</p>
<dl class="section note"><dt>Note</dt><dd>All symbols must be resolved by the substitution map in order for this function to return successfully. </dd></dl>

</div>
</div>
<a id="ab21bf0b917a9fefd3e1aaaff67c6e31e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab21bf0b917a9fefd3e1aaaff67c6e31e">&#9670;&nbsp;</a></span>substitute_and_evaluate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ReturnType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">ReturnType Differentiation::SD::Expression::substitute_and_evaluate </td>
          <td>(</td>
          <td class="paramtype">const SymEngine::map_basic_basic &amp;&#160;</td>
          <td class="paramname"><em>substitution_values</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Full substitution and evaluation. This creates a <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> by symbol substitution and then immediately computes its numerical value.</p>
<p>This function is like the one above, but takes in a SymEngine map (one that maps a <code>SymEngine::RCP&lt;const SymEngine::Basic&gt;</code> to another <code>SymEngine::RCP&lt;const SymEngine::Basic&gt;</code>) as an argument.</p>
<dl class="section note"><dt>Note</dt><dd>All symbols must be resolved by the substitution map in order for this function to return successfully. </dd></dl>

</div>
</div>
<a id="a667cb38093dd283a0b87501e21d8fcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a667cb38093dd283a0b87501e21d8fcfa">&#9670;&nbsp;</a></span>operator ResultType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ResultType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::operator ResultType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion operator for real integer or floating point values, and complex integer or floating point values.</p>
<dl class="section note"><dt>Note</dt><dd>This function is marked explicit so that the conversion must be performed using a static_cast. In normal use, one would have expected (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>)*(double) &ndash;&gt; (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>) If this function were not marked as explicit, then we could potentially have (<a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a>)*(double) &ndash;&gt; (double) So, to get out a value on needs to do the following:</dd></dl>
<p><code> const NumberType val = static_cast&lt;NumberType&gt;(Expression); </code></p>
<p>or, probably less desirably,</p>
<p><code> const NumberType val = NumberType(Expression); </code></p>
<dl class="section note"><dt>Note</dt><dd>If the underlying number is a custom type (i.e. encapsulated by a NumberWrapper), then it is necessary to derive a new class from <a class="el" href="classDifferentiation_1_1SD_1_1Expression.html">Expression</a> and define a specialized conversion operator that calls an Evaluator that is specialized for this custom number type. This could be achieved with an overriding conversion function in the base class, for example:</dd></dl>
<div class="fragment"><div class="line">  <span class="keyword">class </span>MyNumber : <span class="keyword">public</span> <a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ad1eed4afe6f1633fc848b36bb04f56d2">Expression</a></div><div class="line">  {</div><div class="line">    ...</div><div class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> ResultType&gt;</div><div class="line">    <span class="keyword">explicit</span> <span class="keyword">operator</span> ResultType()<span class="keyword"> const</span></div><div class="line"><span class="keyword">    </span>{</div><div class="line">      <span class="keywordflow">if</span> (this-&gt;<a class="code" href="classDifferentiation_1_1SD_1_1Expression.html#ade7bba68c27819fcfe2c537dfb3d5bd7">get_value</a>()-&gt;get_type_code() ==</div><div class="line">SymEngine::NUMBER_WRAPPER)</div><div class="line">      {</div><div class="line">        <span class="comment">// Implement custom evaluation function</span></div><div class="line">        <span class="keyword">const</span> ResultType result = ...;</div><div class="line">        <span class="keywordflow">return</span> result;</div><div class="line">      }</div><div class="line">      <span class="keywordflow">else</span></div><div class="line">        <span class="comment">// Call base class conversion operator</span></div><div class="line">        <span class="keywordflow">return</span> Expression::operator ResultType();</div><div class="line">    }</div><div class="line">  }</div></div><!-- fragment --> 
</div>
</div>
<a id="a4d8003cafbe589706900c41ff8b6def3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8003cafbe589706900c41ff8b6def3">&#9670;&nbsp;</a></span>operator const SymEngine::Expression &()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::operator const SymEngine::Expression &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Conversion operator that returns the value or expression that this class instance represents. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00270">270</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<a id="ade7a3d1c21d6102385e1b0737e989773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7a3d1c21d6102385e1b0737e989773">&#9670;&nbsp;</a></span>operator const SymEngine::RCP< const SymEngine::Basic > &()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Differentiation::SD::Expression::operator const SymEngine::RCP&lt; const SymEngine::Basic &gt; &amp; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Conversion operator that returns a SymEngine reference counted pointer to the fundamental type. </p>

</div>
</div>
<a id="aadcbda719f85e606b6bb5c26f593b776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadcbda719f85e606b6bb5c26f593b776">&#9670;&nbsp;</a></span>get_expression() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SE::Expression &amp; Differentiation::SD::Expression::get_expression </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the value or expression that this class instance represents. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8cc_source.html#l00220">220</a> of file <a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aef1df7282f8a447fd716b0b924ac0f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1df7282f8a447fd716b0b924ac0f03">&#9670;&nbsp;</a></span>expression</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SymEngine::Expression Differentiation::SD::Expression::expression</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The value or expression that this instance of this class is to represent. </p>

<p class="definition">Definition at line <a class="el" href="symengine__number__types_8h_source.html#l00871">871</a> of file <a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/differentiation/sd/<a class="el" href="symengine__number__types_8h_source.html">symengine_number_types.h</a></li>
<li>source/differentiation/sd/<a class="el" href="symengine__number__types_8cc_source.html">symengine_number_types.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
