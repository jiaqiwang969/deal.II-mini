<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classPETScWrappers_1_1SparseMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: PETScWrappers::SparseMatrix Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacePETScWrappers.html">PETScWrappers</a></li><li class="navelem"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classPETScWrappers_1_1SparseMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">PETScWrappers::SparseMatrix Class Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__PETScWrappers.html">PETScWrappers</a><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo;  &#124; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="petsc__sparse__matrix_8h_source.html">deal.II/lac/petsc_sparse_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for PETScWrappers::SparseMatrix:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classPETScWrappers_1_1SparseMatrix__inherit__graph.svg" width="226" height="187"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structPETScWrappers_1_1SparseMatrix_1_1Traits.html">Traits</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a29f79582d2d2681b5f55167761d84168"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> = <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td></tr>
<tr class="separator:a29f79582d2d2681b5f55167761d84168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34a2b174fb98ddb568d1aa0f52e332"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a4b34a2b174fb98ddb568d1aa0f52e332"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae584b9befbadcc9293f710bde79b3d21"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">value_type</a> = PetscScalar</td></tr>
<tr class="separator:ae584b9befbadcc9293f710bde79b3d21"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a637dbbd4e8ca9fc07a447c8f31e21647">SparseMatrix</a> ()</td></tr>
<tr class="separator:a637dbbd4e8ca9fc07a447c8f31e21647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdba8e5ef1db617093c727ac293c43a4"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#abdba8e5ef1db617093c727ac293c43a4">SparseMatrix</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_nonzero_per_row, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a>=false)</td></tr>
<tr class="separator:abdba8e5ef1db617093c727ac293c43a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56ce532c27689c8f9946598a07351506"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a56ce532c27689c8f9946598a07351506">SparseMatrix</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a>, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a>=false)</td></tr>
<tr class="separator:a56ce532c27689c8f9946598a07351506"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e03b379abb85784d95e98fc788b0aa2"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a7e03b379abb85784d95e98fc788b0aa2"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a7e03b379abb85784d95e98fc788b0aa2">SparseMatrix</a> (const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations=true)</td></tr>
<tr class="separator:a7e03b379abb85784d95e98fc788b0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#ae2e30c191f788f4e668df2a51fc0aad3">operator=</a> (const <a class="el" href="classdouble.html">double</a> d)</td></tr>
<tr class="separator:ae2e30c191f788f4e668df2a51fc0aad3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f059452b7c5929c91973f9ad3741d8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#ad8f059452b7c5929c91973f9ad3741d8">SparseMatrix</a> (const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:ad8f059452b7c5929c91973f9ad3741d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae26068e8e622e7447f6bf05ad17d41c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#ae26068e8e622e7447f6bf05ad17d41c0">operator=</a> (const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;)=delete</td></tr>
<tr class="separator:ae26068e8e622e7447f6bf05ad17d41c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9edc8d8c00e80b600e5b7245564a5a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#ac9edc8d8c00e80b600e5b7245564a5a2">reinit</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_nonzero_per_row, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a>=false)</td></tr>
<tr class="separator:ac9edc8d8c00e80b600e5b7245564a5a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e8b16f5bb615114210106097992b71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#ad8e8b16f5bb615114210106097992b71">reinit</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a>, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a>=false)</td></tr>
<tr class="separator:ad8e8b16f5bb615114210106097992b71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df7416bac61d19daee27fe41251d85c"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:a4df7416bac61d19daee27fe41251d85c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a4df7416bac61d19daee27fe41251d85c">reinit</a> (const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations=true)</td></tr>
<tr class="separator:a4df7416bac61d19daee27fe41251d85c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fa85242545b5d377c3734526c3c72ee"><td class="memItemLeft" align="right" valign="top">virtual const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a2fa85242545b5d377c3734526c3c72ee">get_mpi_communicator</a> () const override</td></tr>
<tr class="separator:a2fa85242545b5d377c3734526c3c72ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a836390c4d25c6f48519d67b9cff9da97"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a> () const</td></tr>
<tr class="separator:a836390c4d25c6f48519d67b9cff9da97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89169868162a405f5e260ffb3d98ed36"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a> () const</td></tr>
<tr class="separator:a89169868162a405f5e260ffb3d98ed36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a1dbabb70ef99a4be889474c4c5dc4756">mmult</a> (<a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a1dbabb70ef99a4be889474c4c5dc4756"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a446bb9a2e86487360cd8c73c021197e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a446bb9a2e86487360cd8c73c021197e4">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;V=<a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()) const</td></tr>
<tr class="separator:a446bb9a2e86487360cd8c73c021197e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1b895d26bc6c0a0cf96d37d00e5853c4">clear</a> ()</td></tr>
<tr class="separator:a1b895d26bc6c0a0cf96d37d00e5853c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5067751068b7290030fe97cc8cadd02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af5067751068b7290030fe97cc8cadd02">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:af5067751068b7290030fe97cc8cadd02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af2a6e591d33f2af5e44a20c8b3e30943">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:af2a6e591d33f2af5e44a20c8b3e30943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90d04e83f54969c8c504da62bdee60a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a90d04e83f54969c8c504da62bdee60a8">set</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:a90d04e83f54969c8c504da62bdee60a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc988c43c687b2af0b7e4352def7f19b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abc988c43c687b2af0b7e4352def7f19b">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:abc988c43c687b2af0b7e4352def7f19b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae9fe7cc7dd404261b63b7ee651233de1">set</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=false)</td></tr>
<tr class="separator:ae9fe7cc7dd404261b63b7ee651233de1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a017ad4b1e0e18954db42d489e91ed0bb">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j, const PetscScalar value)</td></tr>
<tr class="separator:a017ad4b1e0e18954db42d489e91ed0bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b079c5bf7843592a347a9874752eef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a97b079c5bf7843592a347a9874752eef">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a97b079c5bf7843592a347a9874752eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a068368a605f2661042e104f0ad3eef47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a068368a605f2661042e104f0ad3eef47">add</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_indices, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;full_matrix, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a068368a605f2661042e104f0ad3eef47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8298c20ffaf1ba83c286e119fd53e7d0">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;col_indices, const std::vector&lt; PetscScalar &gt; &amp;values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true)</td></tr>
<tr class="separator:a8298c20ffaf1ba83c286e119fd53e7d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abec5dd7bf11e94aeeeca18e94576c06e">add</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_cols, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *col_indices, const PetscScalar *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:abec5dd7bf11e94aeeeca18e94576c06e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be932238458b6c1cd83b51571891a6a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5be932238458b6c1cd83b51571891a6a">add</a> (const PetscScalar factor, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;other)</td></tr>
<tr class="separator:a5be932238458b6c1cd83b51571891a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af918fe8858fea210e01de289340c2468"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#af918fe8858fea210e01de289340c2468">clear_row</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:af918fe8858fea210e01de289340c2468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25c2d67d301ec5cb4181b071168a6783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a25c2d67d301ec5cb4181b071168a6783">clear_rows</a> (const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;rows, const PetscScalar new_diag_value=0)</td></tr>
<tr class="separator:a25c2d67d301ec5cb4181b071168a6783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae264ec17db96d955590626c8da8e6aad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ae264ec17db96d955590626c8da8e6aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8eddd61ef58cb9f312b47b0e3c165f7a">operator()</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a8eddd61ef58cb9f312b47b0e3c165f7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89476484bfd365c60972c76d3a893925"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> j) const</td></tr>
<tr class="separator:a89476484bfd365c60972c76d3a893925"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a2bb6345b774b4029dc1cc04b6c5ecedf">diag_element</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> i) const</td></tr>
<tr class="separator:a2bb6345b774b4029dc1cc04b6c5ecedf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b350e8500ad00885d36508ded03c159"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size</a> () const</td></tr>
<tr class="separator:a8b350e8500ad00885d36508ded03c159"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca73a7174b92973d2a57e41af737fd1"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adca73a7174b92973d2a57e41af737fd1">local_range</a> () const</td></tr>
<tr class="separator:adca73a7174b92973d2a57e41af737fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a988bc02bfef4479879867a411eb2b682"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a988bc02bfef4479879867a411eb2b682">in_local_range</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> index) const</td></tr>
<tr class="separator:a988bc02bfef4479879867a411eb2b682"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcc9652ade95e371d4191e28461eeb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adfcc9652ade95e371d4191e28461eeb8">n_nonzero_elements</a> () const</td></tr>
<tr class="separator:adfcc9652ade95e371d4191e28461eeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0aee7127b31ea26d3847ce7d4d9236ad">row_length</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> row) const</td></tr>
<tr class="separator:a0aee7127b31ea26d3847ce7d4d9236ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1976b38af71b46e0fa5f3b4837f2fd05">l1_norm</a> () const</td></tr>
<tr class="separator:a1976b38af71b46e0fa5f3b4837f2fd05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd06ba7168f27d27bae50b653587fd8f"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afd06ba7168f27d27bae50b653587fd8f">linfty_norm</a> () const</td></tr>
<tr class="separator:afd06ba7168f27d27bae50b653587fd8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memItemLeft" align="right" valign="top">PetscReal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a5ab9e8f1061cef606eaeb0993ce3d887">frobenius_norm</a> () const</td></tr>
<tr class="separator:a5ab9e8f1061cef606eaeb0993ce3d887"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7e0c76f22865de9a597b7342f87463e"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae7e0c76f22865de9a597b7342f87463e">matrix_norm_square</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:ae7e0c76f22865de9a597b7342f87463e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0aef113fe7fed539cc6e5a75f457571"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0aef113fe7fed539cc6e5a75f457571">matrix_scalar_product</a> (const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;u, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;v) const</td></tr>
<tr class="separator:aa0aef113fe7fed539cc6e5a75f457571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95bff0bbfcb1159616cb078ae9d68374"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a95bff0bbfcb1159616cb078ae9d68374">trace</a> () const</td></tr>
<tr class="separator:a95bff0bbfcb1159616cb078ae9d68374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad4b99bfc37fc183a7d978ec48f83623"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aad4b99bfc37fc183a7d978ec48f83623">operator*=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:aad4b99bfc37fc183a7d978ec48f83623"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455541189a44467806299d3f0e0d2005"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a455541189a44467806299d3f0e0d2005">operator/=</a> (const PetscScalar factor)</td></tr>
<tr class="separator:a455541189a44467806299d3f0e0d2005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a228e08f3caffe58c6213f1a142140d3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a228e08f3caffe58c6213f1a142140d3f">vmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a228e08f3caffe58c6213f1a142140d3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa53f7571665e69020dd5c1c90cf2e04d">Tvmult</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:aa53f7571665e69020dd5c1c90cf2e04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#adb7231c9d5f340181ac3c45827f5b9e4">vmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:adb7231c9d5f340181ac3c45827f5b9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714cb0c98ae635dd7591b40192dc9240"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a714cb0c98ae635dd7591b40192dc9240">Tvmult_add</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;src) const</td></tr>
<tr class="separator:a714cb0c98ae635dd7591b40192dc9240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memItemLeft" align="right" valign="top">PetscScalar&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab7d09f592d2683c8d9cb7e422dfc2e57">residual</a> (<a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;dst, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;x, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;b) const</td></tr>
<tr class="separator:ab7d09f592d2683c8d9cb7e422dfc2e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a417ad4470cefee04a01c4595b609d310"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a417ad4470cefee04a01c4595b609d310">begin</a> () const</td></tr>
<tr class="separator:a417ad4470cefee04a01c4595b609d310"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7d876a5651cfc339c93a5406b4f7eb79">begin</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a7d876a5651cfc339c93a5406b4f7eb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc2141ca2fb58139da5e1f532634958"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a6cc2141ca2fb58139da5e1f532634958">end</a> () const</td></tr>
<tr class="separator:a6cc2141ca2fb58139da5e1f532634958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0748f0b7f03b5b7452a38b92561d2943"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0748f0b7f03b5b7452a38b92561d2943">end</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> r) const</td></tr>
<tr class="separator:a0748f0b7f03b5b7452a38b92561d2943"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac11a01597f3233c1f817a09471c937e3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ac11a01597f3233c1f817a09471c937e3">operator Mat</a> () const</td></tr>
<tr class="separator:ac11a01597f3233c1f817a09471c937e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85273881d243958293bf3155e605ba67"><td class="memItemLeft" align="right" valign="top">Mat &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a85273881d243958293bf3155e605ba67">petsc_matrix</a> ()</td></tr>
<tr class="separator:a85273881d243958293bf3155e605ba67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacd76b6ce3247735964836a82eedff6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aacd76b6ce3247735964836a82eedff6d">transpose</a> ()</td></tr>
<tr class="separator:aacd76b6ce3247735964836a82eedff6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a4a1057a35382b7c328e6c85b0f5ab35e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2f6b575f15d540cf10688b30d09941"><td class="memItemLeft" align="right" valign="top">PetscBool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9f2f6b575f15d540cf10688b30d09941">is_hermitian</a> (const <a class="el" href="classdouble.html">double</a> tolerance=1.e-12)</td></tr>
<tr class="separator:a9f2f6b575f15d540cf10688b30d09941"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad127fd1b40ab452473f96cc298694528"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ad127fd1b40ab452473f96cc298694528">write_ascii</a> (const PetscViewerFormat format=PETSC_VIEWER_DEFAULT)</td></tr>
<tr class="separator:ad127fd1b40ab452473f96cc298694528"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7515e640202d1ad50bd9baa13c404cb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a7515e640202d1ad50bd9baa13c404cb1">print</a> (std::ostream &amp;out, const <a class="el" href="classbool.html">bool</a> alternative_output=false) const</td></tr>
<tr class="separator:a7515e640202d1ad50bd9baa13c404cb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af7a8873fc01cd20682e079dbb8f225"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a0af7a8873fc01cd20682e079dbb8f225">memory_consumption</a> () const</td></tr>
<tr class="separator:a0af7a8873fc01cd20682e079dbb8f225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa059253b9ee3357d06dbd37816a1d22"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#afa059253b9ee3357d06dbd37816a1d22">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:afa059253b9ee3357d06dbd37816a1d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4656c942eaca0ea491fba37a0a6225eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4656c942eaca0ea491fba37a0a6225eb">DeclException2</a> (ExcWrongMode, <a class="el" href="classint.html">int</a>, <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;)</td></tr>
<tr class="separator:a4656c942eaca0ea491fba37a0a6225eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a9795580277a7bc3a4348443768b6c0fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9795580277a7bc3a4348443768b6c0fd">prepare_action</a> (const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> new_action)</td></tr>
<tr class="separator:a9795580277a7bc3a4348443768b6c0fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa0e10ef38e7bb5901bc5678a8a4ffd6d">assert_is_compressed</a> ()</td></tr>
<tr class="separator:aa0e10ef38e7bb5901bc5678a8a4ffd6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#aa6e49d52a74cc86386a9aff01fa88c74">prepare_add</a> ()</td></tr>
<tr class="separator:aa6e49d52a74cc86386a9aff01fa88c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d1b00916f856722282dcd9abb408581"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a9d1b00916f856722282dcd9abb408581">prepare_set</a> ()</td></tr>
<tr class="separator:a9d1b00916f856722282dcd9abb408581"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49501300c99d6fea596a39fbe38b8961"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">mmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:a49501300c99d6fea596a39fbe38b8961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97c266e288f1d409c1b09eae7114792"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">Tmmult</a> (<a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;C, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;B, const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;V) const</td></tr>
<tr class="separator:ab97c266e288f1d409c1b09eae7114792"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:abfce46e53089351cc7fe6b9ea44e167f"><td class="memItemLeft" align="right" valign="top">Mat&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a></td></tr>
<tr class="separator:abfce46e53089351cc7fe6b9ea44e167f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a1deda2ab63ef62230745b4ff99bd26d6">last_action</a></td></tr>
<tr class="separator:a1deda2ab63ef62230745b4ff99bd26d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a29a0ac4497206e4e482eecd3003d144b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a29a0ac4497206e4e482eecd3003d144b">do_reinit</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> n_nonzero_per_row, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a>=false)</td></tr>
<tr class="separator:a29a0ac4497206e4e482eecd3003d144b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac87dda5508f47e6f19b310ec56b94349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#ac87dda5508f47e6f19b310ec56b94349">do_reinit</a> (const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a836390c4d25c6f48519d67b9cff9da97">m</a>, const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> <a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a89169868162a405f5e260ffb3d98ed36">n</a>, const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;row_lengths, const <a class="el" href="classbool.html">bool</a> <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4a1057a35382b7c328e6c85b0f5ab35e">is_symmetric</a>=false)</td></tr>
<tr class="separator:ac87dda5508f47e6f19b310ec56b94349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd1797d200fbd26ca5eeab64eb1c721b"><td class="memTemplParams" colspan="2">template&lt;typename SparsityPatternType &gt; </td></tr>
<tr class="memitem:acd1797d200fbd26ca5eeab64eb1c721b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#acd1797d200fbd26ca5eeab64eb1c721b">do_reinit</a> (const SparsityPatternType &amp;sparsity_pattern, const <a class="el" href="classbool.html">bool</a> preset_nonzero_locations)</td></tr>
<tr class="separator:acd1797d200fbd26ca5eeab64eb1c721b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html#a0eb72d666c41a0ac3c16def795c0c99b">BlockMatrixBase&lt; SparseMatrix &gt;</a></td></tr>
<tr class="separator:a0eb72d666c41a0ac3c16def795c0c99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>实现一个基于PETSc的连续稀疏矩阵类。所有的功能实际上都在基类中，除了生成连续稀疏矩阵的调用。这是可能的，因为PETSc只在一个抽象的矩阵类型上工作，并在内部根据实际的矩阵类型分配给做实际工作的函数（很像使用虚拟函数）。只有创建特定类型矩阵的函数不同，并在这个特定的类中实现。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00046">46</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a29f79582d2d2681b5f55167761d84168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29f79582d2d2681b5f55167761d84168">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">PETScWrappers::MatrixBase::const_iterator</a> =  <a class="el" href="classPETScWrappers_1_1MatrixIterators_1_1const__iterator.html">MatrixIterators::const_iterator</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为迭代器类声明一个别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00277">277</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a4b34a2b174fb98ddb568d1aa0f52e332"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34a2b174fb98ddb568d1aa0f52e332">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">PETScWrappers::MatrixBase::size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明容器大小的类型。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00283">283</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="ae584b9befbadcc9293f710bde79b3d21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae584b9befbadcc9293f710bde79b3d21">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae584b9befbadcc9293f710bde79b3d21">PETScWrappers::MatrixBase::value_type</a> =  PetscScalar</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>声明一个类似于所有其他容器类的别名。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00289">289</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a637dbbd4e8ca9fc07a447c8f31e21647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637dbbd4e8ca9fc07a447c8f31e21647">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>默认构造函数。创建一个空矩阵。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00030">30</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="abdba8e5ef1db617093c727ac293c43a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdba8e5ef1db617093c727ac293c43a4">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_nonzero_per_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一个尺寸为 <code>m</code> 乘以 <code>n</code>, 的稀疏矩阵，每行有 <code>n_nonzero_per_row</code> 个非零元素的初始猜测。PETSc能够应对后来为某一行分配的元素超过这个数量的情况，但这涉及到复制数据，因此很昂贵。 <code>is_symmetric</code> 标志决定了我们是否应该告诉PETSc矩阵将是对称的（如调用<code>MatSetOption(mat, MAT_SYMMETRIC)</code>所示。请注意，PETSc文档指出，对于这个标志被设置为 <code>true</code>, 的矩阵，我们不能形成ILU分解，只能形成ICC。这个标志的默认值是 <code>false</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00040">40</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a56ce532c27689c8f9946598a07351506"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56ce532c27689c8f9946598a07351506">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::<a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化一个具有 <code>m</code> 行和 <code>n</code> 列的矩形矩阵。 每行的最大非零条目数分别由 <code>row_lengths</code> 数组给出。 正如其他构造函数一样。PETSc能够应对后来为某一行分配的元素超过这个数量的情况，但这涉及到复制数据，因此很昂贵。 <code>is_symmetric</code> 标志决定了我们是否应该告诉PETSc矩阵将是对称的（如调用<code>MatSetOption(mat, MAT_SYMMETRIC)</code>所示。请注意，PETSc文档中指出，对于这个标志被设置为 <code>true</code>, 的矩阵，不能形成ILU分解，只能形成ICC。这个标志的默认值是 <code>false</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00050">50</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a7e03b379abb85784d95e98fc788b0aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e03b379abb85784d95e98fc788b0aa2">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::<a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用给定的稀疏模式初始化一个稀疏矩阵。 请注意，如果你不向PETSc提供对行长度的良好估计，它可能会非常慢。使用本函数是一个非常有效的方法，因为它通过使用给定的稀疏模式参数，为矩阵的每一行使用准确的非零条目数。如果 <code>preset_nonzero_locations</code> 标志是 <code>true</code>, ，这个函数不仅预先设置了正确的行大小，而且还预先分配了矩阵中正确的非零条目。 PETsc允许以后向矩阵添加额外的非零条目，只需向这些元素写入即可。然而，这将导致额外的内存分配，效率非常低，将大大降低你的程序速度。因此，从一开始就做好内存分配是非常有效的。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00061">61</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ad8f059452b7c5929c91973f9ad3741d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f059452b7c5929c91973f9ad3741d8">&#9670;&nbsp;</a></span>SparseMatrix() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::SparseMatrix::SparseMatrix </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>复制构造函数被删除。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ae2e30c191f788f4e668df2a51fc0aad3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2e30c191f788f4e668df2a51fc0aad3">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp; <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。由于这通常没有什么意义（我们应该把所有的矩阵条目都设置为这个值吗？仅仅是稀疏模式的非零条目？），这个操作只允许在实际要分配的值为零时进行。这个操作符的存在只是为了允许明显的符号<code>matrix=0</code>，它将矩阵的所有元素设置为零，但保留之前使用的稀疏模式。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00070">70</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ae26068e8e622e7447f6bf05ad17d41c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae26068e8e622e7447f6bf05ad17d41c0">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&amp; PETScWrappers::SparseMatrix::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>拷贝赋值运算符被删除。 </p>

</div>
</div>
<a id="ac9edc8d8c00e80b600e5b7245564a5a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9edc8d8c00e80b600e5b7245564a5a2">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_nonzero_per_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>扔掉现在的矩阵，并生成一个具有相同属性的矩阵，就像它是由这个类的构造函数创建的，参数列表与现在的函数相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00079">79</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ad8e8b16f5bb615114210106097992b71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e8b16f5bb615114210106097992b71">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>扔掉当前的矩阵，并生成一个具有相同属性的矩阵，就像它是由这个类的构造函数创建的一样，参数列表与当前函数相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00095">95</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a4df7416bac61d19daee27fe41251d85c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df7416bac61d19daee27fe41251d85c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用给定的稀疏模式初始化一个稀疏矩阵。 请注意，如果你不向PETSc提供对行长度的良好估计，它可能会非常慢。使用本函数是一个非常有效的方法，因为它通过使用给定的稀疏模式参数，对矩阵的每一行使用准确的非零条目数。如果 <code>preset_nonzero_locations</code> 标志是 <code>true</code>, ，这个函数不仅预先设置了正确的行大小，而且还预先分配了矩阵中正确的非零条目。 PETsc允许以后向矩阵添加额外的非零条目，只需向这些元素写入即可。然而，这将导致额外的内存分配，效率非常低，将大大降低你的程序速度。因此，从一开始就做好内存分配是非常有效的。 尽管这似乎是一个明显的胜利，但将 <code>preset_nonzero_locations</code> 标志设置为 <code>true</code> 似乎并没有加速程序。相反，它似乎能够在一定程度上减慢整个程序。这是令人惊讶的，因为我们可以使用高效的函数调用到PETSc中，允许一次创建多个条目；尽管如此，考虑到这是低效的，各自的标志的默认值等于 <code>false</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00112">112</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a2fa85242545b5d377c3734526c3c72ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fa85242545b5d377c3734526c3c72ee">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp; <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对该矩阵使用的MPI通信器对象的引用。由于这是一个连续的矩阵，它返回MPI_COMM_SELF通信器。 </p>

<p>Implements <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae1aadd5aebcdc166b840df3430a23606">PETScWrappers::MatrixBase</a>.</p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00126">126</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a836390c4d25c6f48519d67b9cff9da97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a836390c4d25c6f48519d67b9cff9da97">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回这个矩阵的行数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00248">248</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a89169868162a405f5e260ffb3d98ed36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89169868162a405f5e260ffb3d98ed36">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回此矩阵的列数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00258">258</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1dbabb70ef99a4be889474c4c5dc4756"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbabb70ef99a4be889474c4c5dc4756">&#9670;&nbsp;</a></span>mmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行矩阵与矩阵的乘法 \(C = AB\) ，或者， \(C = A \text{diag}(V) B\) 给出一个兼容的矢量 \(V\) 。 这个函数调用 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a49501300c99d6fea596a39fbe38b8961">MatrixBase::mmult()</a> 来做实际工作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00268">268</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a446bb9a2e86487360cd8c73c021197e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a446bb9a2e86487360cd8c73c021197e4">&#9670;&nbsp;</a></span>Tmmult() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em> = <code><a class="el" href="classPETScWrappers_1_1MPI_1_1Vector.html">MPI::Vector</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与<code>this</code>的转置进行矩阵-矩阵乘法，即 \(C = A^T B\) ，或者， \(C = A^T \text{diag}(V) B\) 给定一个兼容的向量 \(V\) 。 这个函数调用 <a class="el" href="classPETScWrappers_1_1MatrixBase.html#ab97c266e288f1d409c1b09eae7114792">MatrixBase::Tmmult()</a> 来做实际工作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00279">279</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a29a0ac4497206e4e482eecd3003d144b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a0ac4497206e4e482eecd3003d144b">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_nonzero_per_row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为各自的reinit()函数和匹配的构造函数做实际工作，即创建一个矩阵。摆脱之前的矩阵是留给调用者的。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00138">138</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="ac87dda5508f47e6f19b310ec56b94349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac87dda5508f47e6f19b310ec56b94349">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; number &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_lengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_symmetric</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00160">160</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="acd1797d200fbd26ca5eeab64eb1c721b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd1797d200fbd26ca5eeab64eb1c721b">&#9670;&nbsp;</a></span>do_reinit() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename SparsityPatternType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a>&lt; SparsityPatternType &gt;::do_reinit </td>
          <td>(</td>
          <td class="paramtype">const SparsityPatternType &amp;&#160;</td>
          <td class="paramname"><em>sparsity_pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>preset_nonzero_locations</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>同前面的函数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8cc_source.html#l00194">194</a> of file <a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a>.</p>

</div>
</div>
<a id="a1b895d26bc6c0a0cf96d37d00e5853c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b895d26bc6c0a0cf96d37d00e5853c4">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>释放所有内存并返回到与调用默认构造函数后相同的状态。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00092">92</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af5067751068b7290030fe97cc8cadd02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5067751068b7290030fe97cc8cadd02">&#9670;&nbsp;</a></span>set() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将元素(<em>i,j</em>)设置为 <code>value</code>. 如果现在的对象(来自这个对象的派生类)恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类形成了很大的反差，如果该条目不存在则会抛出错误。如果<code>value</code>不是一个有限的数字，就会抛出一个异常。 </p>

</div>
</div>
<a id="af2a6e591d33f2af5e44a20c8b3e30943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a6e591d33f2af5e44a20c8b3e30943">&#9670;&nbsp;</a></span>set() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素设置为<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素写入调用的矩阵中，对矩阵的行和列都使用<code>indices</code>指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="a90d04e83f54969c8c504da62bdee60a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90d04e83f54969c8c504da62bdee60a8">&#9670;&nbsp;</a></span>set() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的功能相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的局部到全局的索引。 </p>

</div>
</div>
<a id="abc988c43c687b2af0b7e4352def7f19b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc988c43c687b2af0b7e4352def7f19b">&#9670;&nbsp;</a></span>set() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="ae9fe7cc7dd404261b63b7ee651233de1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fe7cc7dd404261b63b7ee651233de1">&#9670;&nbsp;</a></span>set() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将几个元素设置为由<code>values</code>给定的值，在由col_indices给定的列中设置为稀疏矩阵的行。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选的参数<code>elide_zero_values</code>可以用来指定零值是否应该被插入，还是应该被过滤掉。默认值是<code>false</code>，也就是说，即使是零值也要插入/替换。 </p>

</div>
</div>
<a id="a017ad4b1e0e18954db42d489e91ed0bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017ad4b1e0e18954db42d489e91ed0bb">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>value</code> 添加到元素（<em>i,j</em>）。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一个新的条目，如果该条目之前不存在的话，这与SparseMatrix类非常不同，后者在该条目不存在的情况下会抛出一个错误。如果<code>value</code>不是一个有限的数字，就会抛出一个异常。 </p>

</div>
</div>
<a id="a97b079c5bf7843592a347a9874752eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b079c5bf7843592a347a9874752eef">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将FullMatrix&lt;double&gt;中给出的所有元素添加到由<code>indices</code>给出的稀疏矩阵位置。换句话说，这个函数将<code>full_matrix</code>中的元素添加到调用矩阵的相应条目中，使用<code>indices</code>为矩阵的行和列指定的本地到全球索引。这个函数假设一个二次稀疏矩阵和一个二次全矩阵，这是FE计算中的通常情况。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a068368a605f2661042e104f0ad3eef47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a068368a605f2661042e104f0ad3eef47">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1FullMatrix.html">FullMatrix</a>&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>full_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与之前的函数相同，但现在包括了使用矩形full_matrices的可能性，以及在行和列上分别使用不同的本地到全球索引。 </p>

</div>
</div>
<a id="a8298c20ffaf1ba83c286e119fd53e7d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8298c20ffaf1ba83c286e119fd53e7d0">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; PetscScalar &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵的指定行中的几个元素与<code>col_indices</code>给出的列索引设置为相应的值。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类非常不同，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="abec5dd7bf11e94aeeeca18e94576c06e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec5dd7bf11e94aeeeca18e94576c06e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在稀疏矩阵中由col_indices指定的列中添加一个由<code>values</code>给出的数值阵列。 如果现在的对象（来自这个对象的派生类）恰好是一个稀疏矩阵，那么这个函数就会向矩阵添加一些新的条目，如果这些条目之前不存在的话，这与SparseMatrix类形成鲜明对比，后者在条目不存在的时候会抛出一个错误。 可选参数<code>elide_zero_values</code>可以用来指定是无论如何都要添加零值，还是要过滤掉这些零值，只添加非零数据。默认值是<code>true</code>，也就是说，零值不会被添加到矩阵中。 </p>

</div>
</div>
<a id="a5be932238458b6c1cd83b51571891a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be932238458b6c1cd83b51571891a6a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将矩阵 <code>other</code> 按系数 <code>factor</code> 的比例添加到当前矩阵中。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00430">430</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="af918fe8858fea210e01de289340c2468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af918fe8858fea210e01de289340c2468">&#9670;&nbsp;</a></span>clear_row()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将此<code>行</code>中的所有元素设置为零，将其删除。这个函数并不修改分配的非零条目的数量，它只是将一些条目设置为零。不过，它可能会将它们从稀疏模式中删除（但会保留分配的内存，以备以后再次添加新的条目）。 这个操作用于消除约束（例如由于挂起的节点），并确保我们可以将这个修改写入矩阵，而不需要从矩阵中读取条目（例如非零元素的位置）。</p>
<ul>
<li>如果没有这个操作，消除平行矩阵的约束是一个相当复杂的过程。 第二个参数可以用来将该行的对角线条目设置为一个不同于零的值。默认是将其设置为零。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00127">127</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a25c2d67d301ec5cb4181b071168a6783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25c2d67d301ec5cb4181b071168a6783">&#9670;&nbsp;</a></span>clear_rows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::clear_rows </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>new_diag_value</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与clear_row()相同，只是它同时作用于若干行。 第二个参数可以用来将所有被清除的行的对角线条目设置为不同于0的内容。请注意，所有这些对角线项都得到相同的值</p>
<ul>
<li>如果你想要不同的对角线条目的值，你必须手动设置它们。 </li>
</ul>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00136">136</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae264ec17db96d955590626c8da8e6aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae264ec17db96d955590626c8da8e6aad">&#9670;&nbsp;</a></span>compress()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::compress </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>PETSc矩阵存储了它们自己的稀疏性模式。因此，与我们自己的SparsityPattern类相类似，这个函数压缩了稀疏模式，并允许将得到的矩阵用于所有其他操作，而以前只允许使用汇编函数。因此，一旦你组装了矩阵，就必须调用这个函数。 更多信息请参见 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式对象</a> 。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00193">193</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8eddd61ef58cb9f312b47b0e3c165f7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eddd61ef58cb9f312b47b0e3c165f7a">&#9670;&nbsp;</a></span>operator()()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回条目的值（<em>i,j</em>）。 这可能是一个昂贵的操作，你应该始终注意在哪里调用这个函数。 与 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类中的相应函数相比，如果相应的条目不存在于该类的稀疏模式中，我们不会抛出一个异常，因为PETSc并不传输这一信息。 因此这个函数完全等同于<code><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a89476484bfd365c60972c76d3a893925">el()</a></code>函数。 </p>

</div>
</div>
<a id="a89476484bfd365c60972c76d3a893925"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89476484bfd365c60972c76d3a893925">&#9670;&nbsp;</a></span>el()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::el </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵条目的值（<em>i,j</em>）。如果这个条目不存在于稀疏模式中，那么就返回0。虽然这在某些情况下可能很方便，但请注意，由于没有使用矩阵的稀疏性，写出的算法与最优解相比很简单，很慢。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00165">165</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a2bb6345b774b4029dc1cc04b6c5ecedf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bb6345b774b4029dc1cc04b6c5ecedf">&#9670;&nbsp;</a></span>diag_element()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::diag_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回第<em>i</em>行中的主对角线元素。如果矩阵不是二次的，这个函数会抛出一个错误。 由于我们不能直接访问底层数据结构，这个函数并不比使用el()函数的元素访问快。然而，我们提供这个函数是为了与SparseMatrix类兼容。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00181">181</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a8b350e8500ad00885d36508ded03c159"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b350e8500ad00885d36508ded03c159">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的本地维度，即存储在当前MPI进程中的行数。对于顺序矩阵，这个数字与m()相同，但对于并行矩阵，这个数字可能更小。 要想知道到底哪些元素被存储在本地，可以使用local_range()。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00263">263</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adca73a7174b92973d2a57e41af737fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca73a7174b92973d2a57e41af737fd1">&#9670;&nbsp;</a></span>local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a>, <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> &gt; PETScWrappers::MatrixBase::local_range </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一对指数，表明该矩阵的哪些行是本地存储的。第一个数字是存储的第一行的索引，第二个数字是本地存储的最后一行之后的那一行的索引。如果这是一个连续的矩阵，那么结果将是一对(0,m())，否则将是一对(i,i+n)，其中<code>n=<a class="el" href="classPETScWrappers_1_1MatrixBase.html#a8b350e8500ad00885d36508ded03c159">local_size()</a></code>。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00276">276</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a988bc02bfef4479879867a411eb2b682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a988bc02bfef4479879867a411eb2b682">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> PETScWrappers::MatrixBase::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回 <code>index</code> 是否在本地范围内，另见local_range()。 </p>

</div>
</div>
<a id="adfcc9652ade95e371d4191e28461eeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcc9652ade95e371d4191e28461eeb8">&#9670;&nbsp;</a></span>n_nonzero_elements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::n_nonzero_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个矩阵的非零元素的数量。实际上，它返回的是稀疏模式中的条目数；如果任何一个条目碰巧是零，无论如何都会被计算在内。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00290">290</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0aee7127b31ea26d3847ce7d4d9236ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aee7127b31ea26d3847ce7d4d9236ad">&#9670;&nbsp;</a></span>row_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">MatrixBase::size_type</a> PETScWrappers::MatrixBase::row_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>特定行中的条目数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00302">302</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a1976b38af71b46e0fa5f3b4837f2fd05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1976b38af71b46e0fa5f3b4837f2fd05">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的l1准则，即 \(|M|_1=max_{all columns j}\sum_{all rows i} |M_ij|\) ，（最大列数之和）。这是一个自然的矩阵准则，与向量的l1准则兼容，即 \(|Mv|_1\leq |M|_1 |v|_1\) 。(参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00338">338</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afd06ba7168f27d27bae50b653587fd8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd06ba7168f27d27bae50b653587fd8f">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的linfty-norm，即 \(|M|_infty=max_{all rows i}\sum_{all columns j} |M_ij|\) ，（最大行数之和）。这是一个自然的矩阵规范，与向量的linfty-norm兼容，即 \(|Mv|_infty \leq |M|_infty |v|_infty\) 。(参看Haemmerlin-Hoffmann: Numerische Mathematik) </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00351">351</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5ab9e8f1061cef606eaeb0993ce3d887"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ab9e8f1061cef606eaeb0993ce3d887">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscReal PETScWrappers::MatrixBase::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的frobenius norm，即矩阵中所有条目的平方之和的平方根。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00364">364</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ae7e0c76f22865de9a597b7342f87463e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7e0c76f22865de9a597b7342f87463e">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量 \(v\) 相对于该矩阵诱导的准则的平方，即 \(\left(v,Mv\right)\) 。这很有用，例如在有限元背景下，一个函数的 \(L_2\) 规范等于相对于代表有限元函数节点值的向量的质量矩阵的矩阵规范。 很明显，对于这个操作，矩阵需要是二次的。 这个函数的实现没有deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始的，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时向量。 注意，如果当前对象代表一个并行的分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么给出的向量也必须是一个分布式向量。反之，如果矩阵不是分布式的，那么向量也不可能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00376">376</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa0aef113fe7fed539cc6e5a75f457571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0aef113fe7fed539cc6e5a75f457571">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算矩阵标量乘积 \(\left(u,Mv\right)\) 。 这个函数的实现不如deal.II中使用的 <code><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a></code> 类（即原始函数，而不是PETSc封装类）的效率高，因为PETSc不支持这个操作，需要一个临时矢量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00385">385</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a95bff0bbfcb1159616cb078ae9d68374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95bff0bbfcb1159616cb078ae9d68374">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回矩阵的轨迹，即矩阵中所有对角线项的总和。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00395">395</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aad4b99bfc37fc183a7d978ec48f83623"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad4b99bfc37fc183a7d978ec48f83623">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator*= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个矩阵乘以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00408">408</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a455541189a44467806299d3f0e0d2005"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455541189a44467806299d3f0e0d2005">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp; PETScWrappers::MatrixBase::operator/= </td>
          <td>(</td>
          <td class="paramtype">const PetscScalar&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用整个矩阵除以一个固定系数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00419">419</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a228e08f3caffe58c6213f1a142140d3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228e08f3caffe58c6213f1a142140d3f">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M*src</em>与<em>M</em>是这个矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00441">441</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aa53f7571665e69020dd5c1c90cf2e04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa53f7571665e69020dd5c1c90cf2e04d">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>矩阵-向量乘法：让<em>dst = M<sup>T</sup>*src</em>与<em>M</em>为这个矩阵。这个函数与vmult()的作用相同，但需要转置的矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个并行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00452">452</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="adb7231c9d5f340181ac3c45827f5b9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7231c9d5f340181ac3c45827f5b9e4">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。在<em>dst</em>上添加<em>M*src</em>，<em>M</em>为该矩阵。 源和目的不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00463">463</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a714cb0c98ae635dd7591b40192dc9240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a714cb0c98ae635dd7591b40192dc9240">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>加法 矩阵-向量乘法。将<em>M<sup>T</sup>*src</em>加到<em>dst</em>，<em>M</em>是这个矩阵。这个函数与vmult_add()的作用相同，但需要转置的矩阵。 来源和目的地不能是同一个向量。 注意，如果当前对象代表一个并行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么两个向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不可以是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00474">474</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab7d09f592d2683c8d9cb7e422dfc2e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d09f592d2683c8d9cb7e422dfc2e57">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscScalar PETScWrappers::MatrixBase::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算一个方程<em>Mx=b</em>的残差，其中残差被定义为<em>r=b-Mx</em>。将残差写入 <code>dst</code>. 返回残差向量的<em>l<sub>2</sub></em>准则。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 注意，如果当前对象代表一个平行分布式矩阵（类型为 <a class="el" href="classPETScWrappers_1_1MPI_1_1SparseMatrix.html">PETScWrappers::MPI::SparseMatrix</a>), ，那么所有的向量也必须是分布式向量。反之，如果矩阵不是分布式的，那么两个向量都不能是。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00574">574</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a417ad4470cefee04a01c4595b609d310"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a417ad4470cefee04a01c4595b609d310">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器从第一个条目开始。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考以行号为参数的begin()的版本。 </p>

</div>
</div>
<a id="a7d876a5651cfc339c93a5406b4f7eb79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d876a5651cfc339c93a5406b4f7eb79">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>迭代器从第 <code>r</code>. 行的第一个条目开始 注意，如果给定的行是空的，即不包含任何非零条目，那么这个函数返回的迭代器就等于<code>end(r)</code>。还要注意的是，在这种情况下，迭代器可能不能被解除引用。 </p>

</div>
</div>
<a id="a6cc2141ca2fb58139da5e1f532634958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc2141ca2fb58139da5e1f532634958">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>最后的迭代器。这只能在拥有整个矩阵的处理器上调用。在所有其他情况下，请参考end()的版本，以一个行号作为参数。 </p>

</div>
</div>
<a id="a0748f0b7f03b5b7452a38b92561d2943"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0748f0b7f03b5b7452a38b92561d2943">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPETScWrappers_1_1MatrixBase.html#a29f79582d2d2681b5f55167761d84168">const_iterator</a> PETScWrappers::MatrixBase::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html#a4b34a2b174fb98ddb568d1aa0f52e332">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>行<code>r</code>的最终迭代器。它指向超过行 <code>r</code>, 末尾的第一个元素，或者超过整个稀疏模式的末尾。 请注意，结束迭代器不一定是可被解除引用的。特别是如果它是一个矩阵的最后一行的结束迭代器，情况更是如此。 </p>

</div>
</div>
<a id="ac11a01597f3233c1f817a09471c937e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac11a01597f3233c1f817a09471c937e3">&#9670;&nbsp;</a></span>operator Mat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::operator Mat </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>转换操作符，以获得对底层PETSc类型的访问。如果你这样做，你就切断了这个类可能需要的一些信息，所以这个转换操作符应该只在你知道你要做什么的时候使用。特别是，它应该只用于对矩阵的只读操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00590">590</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a85273881d243958293bf3155e605ba67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85273881d243958293bf3155e605ba67">&#9670;&nbsp;</a></span>petsc_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat &amp; PETScWrappers::MatrixBase::petsc_matrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个对底层PETSc类型的引用。它可以用来修改底层数据，所以只有在你知道你在做什么的时候才使用它。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00596">596</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="aacd76b6ce3247735964836a82eedff6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacd76b6ce3247735964836a82eedff6d">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::transpose </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对一个矩阵进行原地转置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00602">602</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a4a1057a35382b7c328e6c85b0f5ab35e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1057a35382b7c328e6c85b0f5ab35e">&#9670;&nbsp;</a></span>is_symmetric()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_symmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试矩阵是否是对称的。 默认公差为 \(1000\times32\) -位机器精度。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00614">614</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a9f2f6b575f15d540cf10688b30d09941"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2f6b575f15d540cf10688b30d09941">&#9670;&nbsp;</a></span>is_hermitian()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PetscBool PETScWrappers::MatrixBase::is_hermitian </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1.e-12</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>测试一个矩阵是否是赫米特的，即它是其转置的复共轭。默认公差为 \(1000\times32\) -位机器精度。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00624">624</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ad127fd1b40ab452473f96cc298694528"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad127fd1b40ab452473f96cc298694528">&#9670;&nbsp;</a></span>write_ascii()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::write_ascii </td>
          <td>(</td>
          <td class="paramtype">const PetscViewerFormat&#160;</td>
          <td class="paramname"><em>format</em> = <code>PETSC_VIEWER_DEFAULT</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>使用PETSc内部矩阵查看器功能<code>MatView</code>打印PETSc矩阵对象的值。默认格式是打印非零矩阵元素。对于其他有效的查看格式，请参考http://www.mcs.anl.gov/petsc/petsc-current/docs/manualpages/Mat/MatView.html </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00636">636</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a7515e640202d1ad50bd9baa13c404cb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7515e640202d1ad50bd9baa13c404cb1">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>alternative_output</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>打印矩阵的元素到给定的输出流。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">out</td><td>要写入的输出流。 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">alternative_output</td><td>这个参数被忽略。它的存在是为了与其他矩阵类中的类似函数兼容。 </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00651">651</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a0af7a8873fc01cd20682e079dbb8f225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af7a8873fc01cd20682e079dbb8f225">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::size_t PETScWrappers::MatrixBase::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该矩阵在该CPU上所消耗的字节数。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00682">682</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="afa059253b9ee3357d06dbd37816a1d22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa059253b9ee3357d06dbd37816a1d22">&#9670;&nbsp;</a></span>DeclExceptionMsg()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclExceptionMsg </td>
          <td>(</td>
          <td class="paramtype">ExcSourceEqualsDestination&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;You are attempting an operation on two matrices that &quot; &quot;are the same&#160;</td>
          <td class="paramname"><em>object</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but the operation requires that the &quot; &quot;two objects are in fact different.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a4656c942eaca0ea491fba37a0a6225eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4656c942eaca0ea491fba37a0a6225eb">&#9670;&nbsp;</a></span>DeclException2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">PETScWrappers::MatrixBase::DeclException2 </td>
          <td>(</td>
          <td class="paramtype">ExcWrongMode&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to do a &quot;&lt;&lt;(arg1==1 ? &quot;'set'&quot; :(arg1==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; operation but the <a class="el" href="classPETScWrappers_1_1MatrixBase.html#abfce46e53089351cc7fe6b9ea44e167f">matrix</a> is currently in &quot;&lt;&lt;(arg2==1 ? &quot;'set'&quot; :(arg2==2 ? &quot;'add'&quot; :&quot;???&quot;))&lt;&lt; &quot; mode. You <a class="el" href="grid__out_8cc.html#a827a345f29da7caeb588b11013869a01">first</a> have to call '<a class="el" href="classPETScWrappers_1_1MatrixBase.html#ae264ec17db96d955590626c8da8e6aad">compress</a>()'.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>异常情况。 </p>

</div>
</div>
<a id="a9795580277a7bc3a4348443768b6c0fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9795580277a7bc3a4348443768b6c0fd">&#9670;&nbsp;</a></span>prepare_action()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_action </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>new_action</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>确保此调用后的动作所需的添加/设置模式与当前模式兼容。应该从所有访问矩阵元素的内部函数中调用。 </p>

</div>
</div>
<a id="aa0e10ef38e7bb5901bc5678a8a4ffd6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0e10ef38e7bb5901bc5678a8a4ffd6d">&#9670;&nbsp;</a></span>assert_is_compressed()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::assert_is_compressed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>内部函数，检查是否有未决的插入/添加操作。否则会抛出一个异常。在调用任何修改矩阵的PETSc内部函数之前，都是有用的。 </p>

</div>
</div>
<a id="aa6e49d52a74cc86386a9aff01fa88c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6e49d52a74cc86386a9aff01fa88c74">&#9670;&nbsp;</a></span>prepare_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_add </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于某些矩阵存储格式，特别是PETSc分布式块状矩阵，单个元素的设置和添加操作不能自由混合。相反，当我们想从设置元素切换到添加元素时，我们必须同步操作。BlockMatrixBase通过为每个块调用这个辅助函数来自动同步访问。这个函数确保矩阵处于允许添加元素的状态；如果它之前已经处于这种状态，那么这个函数什么也不做。 </p>

</div>
</div>
<a id="a9d1b00916f856722282dcd9abb408581"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d1b00916f856722282dcd9abb408581">&#9670;&nbsp;</a></span>prepare_set()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::prepare_set </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>与prepare_add()相同，但如果该类中的元素表示法需要这样的操作，则为设置元素准备矩阵。 </p>

</div>
</div>
<a id="a49501300c99d6fea596a39fbe38b8961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49501300c99d6fea596a39fbe38b8961">&#9670;&nbsp;</a></span>mmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行矩阵-矩阵乘法 \(C = AB\) 的基础函数，或者，如果给出一个大小与B兼容的向量 \(V\) ，则为 \(C = A \text{diag}(V) B\) ，其中 \(\text{diag}(V)\) 定义了一个带有向量项的对角矩阵。 这个函数假定调用矩阵 \(A\) 和 \(B\) 的大小兼容。 \(C\) 的大小将在本函数中设置。 矩阵 \(C\) 的内容和稀疏模式将被这个函数重置，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00558">558</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="ab97c266e288f1d409c1b09eae7114792"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97c266e288f1d409c1b09eae7114792">&#9670;&nbsp;</a></span>Tmmult() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void PETScWrappers::MatrixBase::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1MatrixBase.html">MatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPETScWrappers_1_1VectorBase.html">VectorBase</a> &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>基准函数，用于执行矩阵与<code>this</code>的转置相乘，即 \(C = A^T B\) ，或者，如果给出一个可选矢量 \(V\) ，其大小与 \(B\) 兼容，则为 \(C = A^T \text{diag}(V) B\) ，其中 \(\text{diag}(V)\) 定义了一个带有矢量项的对角矩阵。 这个函数假设调用矩阵 \(A\) 和 \(B\) 的大小兼容。 \(C\) 的大小将在本函数中设置。 矩阵 \(C\) 的内容和稀疏模式将被这个函数改变，所以要确保稀疏模式没有在你的程序中其他地方使用。这是一个昂贵的操作，所以在使用这个函数之前请三思。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8cc_source.html#l00566">566</a> of file <a class="el" href="petsc__matrix__base_8cc_source.html">petsc_matrix_base.cc</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a0eb72d666c41a0ac3c16def795c0c99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eb72d666c41a0ac3c16def795c0c99b">&#9670;&nbsp;</a></span>BlockMatrixBase< SparseMatrix ></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classBlockMatrixBase.html">BlockMatrixBase</a>&lt; <a class="el" href="classPETScWrappers_1_1SparseMatrix.html">SparseMatrix</a> &gt;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="petsc__sparse__matrix_8h_source.html#l00246">246</a> of file <a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="abfce46e53089351cc7fe6b9ea44e167f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfce46e53089351cc7fe6b9ea44e167f">&#9670;&nbsp;</a></span>matrix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Mat PETScWrappers::MatrixBase::matrix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个PETSc中的通用矩阵对象。实际的类型是稀疏矩阵，在构造函数中设置。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00817">817</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<a id="a1deda2ab63ef62230745b4ff99bd26d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1deda2ab63ef62230745b4ff99bd26d6">&#9670;&nbsp;</a></span>last_action</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> PETScWrappers::MatrixBase::last_action</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储最后一个动作是写还是加操作。 </p>

<p class="definition">Definition at line <a class="el" href="petsc__matrix__base_8h_source.html#l00823">823</a> of file <a class="el" href="petsc__matrix__base_8h_source.html">petsc_matrix_base.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="petsc__sparse__matrix_8h_source.html">petsc_sparse_matrix.h</a></li>
<li>source/lac/<a class="el" href="petsc__sparse__matrix_8cc_source.html">petsc_sparse_matrix.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
