<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFullMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FullMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classFullMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FullMatrix&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="full__matrix_8h_source.html">deal.II/lac/full_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FullMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFullMatrix__inherit__graph.svg" width="1067" height="272"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4e8f9ce2c12a56e26b62133edfcc9cef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> = std::size_t</td></tr>
<tr class="separator:a4e8f9ce2c12a56e26b62133edfcc9cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759353fd47e8aa3cb22b95979af27b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a5759353fd47e8aa3cb22b95979af27b9">value_type</a> = number</td></tr>
<tr class="separator:a5759353fd47e8aa3cb22b95979af27b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e14c99dc6090be77b76ac9cfc8b63e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> = typename <a class="el" href="classTable.html">Table</a>&lt; 2, number &gt;::<a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a></td></tr>
<tr class="separator:a5e14c99dc6090be77b76ac9cfc8b63e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030be3ca41e86b9a4a7a8d0683a84962"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> = typename <a class="el" href="classTable.html">Table</a>&lt; 2, number &gt;::<a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a></td></tr>
<tr class="separator:a030be3ca41e86b9a4a7a8d0683a84962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01df0a76d1f2234cf3eb161a953d7ef2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a></td></tr>
<tr class="separator:a01df0a76d1f2234cf3eb161a953d7ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga53b1954eea1b26abc82ace9ce9e79ca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53b1954eea1b26abc82ace9ce9e79ca3">DeclException0</a> (ExcEmptyMatrix)</td></tr>
<tr class="separator:ga53b1954eea1b26abc82ace9ce9e79ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f6d0876e5913281afa87f02c9ef4f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga21f6d0876e5913281afa87f02c9ef4f2">DeclException1</a> (ExcNotRegular, number,&lt;&lt; &quot;The maximal pivot is &quot;&lt;&lt; arg1&lt;&lt; &quot;, which is below the threshold. The matrix may be singular.&quot;)</td></tr>
<tr class="separator:ga21f6d0876e5913281afa87f02c9ef4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1891a6c6aa6e1198780dd866b8914bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf1891a6c6aa6e1198780dd866b8914bb">DeclException3</a> (ExcInvalidDestination, <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>, <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>, <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>,&lt;&lt; &quot;Target region not in matrix: size in this direction=&quot;&lt;&lt; arg1&lt;&lt; &quot;, size of new matrix=&quot;&lt;&lt; arg2&lt;&lt; &quot;, offset=&quot;&lt;&lt; arg3)</td></tr>
<tr class="separator:gaf1891a6c6aa6e1198780dd866b8914bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8caacfdd5f2f7e92f854160a38e9471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab8caacfdd5f2f7e92f854160a38e9471">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:gab8caacfdd5f2f7e92f854160a38e9471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a6ac856c40acd5bb1ed59f6b1b23b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga27a6ac856c40acd5bb1ed59f6b1b23b1">DeclException0</a> (ExcMatrixNotPositiveDefinite)</td></tr>
<tr class="separator:ga27a6ac856c40acd5bb1ed59f6b1b23b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">构造函数和初始化。 也见基类Table。</div></td></tr>
<tr class="memitem:adc08a0718c9110770badd10b5a38892f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#adc08a0718c9110770badd10b5a38892f">FullMatrix</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> <a class="el" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a>=0)</td></tr>
<tr class="separator:adc08a0718c9110770badd10b5a38892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a45e5db015f8adc54f5f48f5376318d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a0a45e5db015f8adc54f5f48f5376318d">FullMatrix</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> rows, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> cols)</td></tr>
<tr class="separator:a0a45e5db015f8adc54f5f48f5376318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc62a1da08095133fdd2515ca644c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7fc62a1da08095133fdd2515ca644c89">FullMatrix</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> rows, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> cols, const number *entries)</td></tr>
<tr class="separator:a7fc62a1da08095133fdd2515ca644c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e195f7eda5b88bbc34dab0eeb17e3e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8e195f7eda5b88bbc34dab0eeb17e3e8">FullMatrix</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a8e195f7eda5b88bbc34dab0eeb17e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">复制到其他矩阵中或从其他矩阵中复制出来</div></td></tr>
<tr class="memitem:a5537bbde546b72ecd718155686ebd15b"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a5537bbde546b72ecd718155686ebd15b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a5537bbde546b72ecd718155686ebd15b">operator=</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;)</td></tr>
<tr class="separator:a5537bbde546b72ecd718155686ebd15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67dc887e44da6c7771eb0e92fc98323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aa67dc887e44da6c7771eb0e92fc98323">operator=</a> (const number d)</td></tr>
<tr class="separator:aa67dc887e44da6c7771eb0e92fc98323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eea4b2a1fc643d6c8b0e70ebb0ac261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8eea4b2a1fc643d6c8b0e70ebb0ac261">operator=</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a8eea4b2a1fc643d6c8b0e70ebb0ac261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8124671c3e3e88e060b5ea32960f6a"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:adb8124671c3e3e88e060b5ea32960f6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#adb8124671c3e3e88e060b5ea32960f6a">operator=</a> (const <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; number2 &gt; &amp;)</td></tr>
<tr class="separator:adb8124671c3e3e88e060b5ea32960f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e8fbf00e15c7b66d527a5de4b31404"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ae9e8fbf00e15c7b66d527a5de4b31404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a> (const MatrixType &amp;)</td></tr>
<tr class="separator:ae9e8fbf00e15c7b66d527a5de4b31404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb901c6e33e90c80a2ed3a9394865156"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:abb901c6e33e90c80a2ed3a9394865156"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abb901c6e33e90c80a2ed3a9394865156">copy_transposed</a> (const MatrixType &amp;)</td></tr>
<tr class="separator:abb901c6e33e90c80a2ed3a9394865156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3555b32b42cdcccfc72ac5ec32c5f83d"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3555b32b42cdcccfc72ac5ec32c5f83d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a3555b32b42cdcccfc72ac5ec32c5f83d">copy_from</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;T, const unsigned <a class="el" href="classint.html">int</a> src_r_i=0, const unsigned <a class="el" href="classint.html">int</a> src_r_j=dim - 1, const unsigned <a class="el" href="classint.html">int</a> src_c_i=0, const unsigned <a class="el" href="classint.html">int</a> src_c_j=dim - 1, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_r=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_c=0)</td></tr>
<tr class="separator:a3555b32b42cdcccfc72ac5ec32c5f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7437dbce381ba72d029c67a719826fcc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7437dbce381ba72d029c67a719826fcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7437dbce381ba72d029c67a719826fcc">copy_to</a> (<a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;T, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_r_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_r_j=dim - 1, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_c_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_c_j=dim - 1, const unsigned <a class="el" href="classint.html">int</a> dst_r=0, const unsigned <a class="el" href="classint.html">int</a> dst_c=0) const</td></tr>
<tr class="separator:a7437dbce381ba72d029c67a719826fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94bda7e32ea0082326e4fbf151fb868"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename index_type &gt; </td></tr>
<tr class="memitem:ae94bda7e32ea0082326e4fbf151fb868"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae94bda7e32ea0082326e4fbf151fb868">extract_submatrix_from</a> (const MatrixType &amp;matrix, const std::vector&lt; index_type &gt; &amp;row_index_set, const std::vector&lt; index_type &gt; &amp;column_index_set)</td></tr>
<tr class="separator:ae94bda7e32ea0082326e4fbf151fb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b63ee8ecc6a5a2f072a469ac95a95"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename index_type &gt; </td></tr>
<tr class="memitem:a6f9b63ee8ecc6a5a2f072a469ac95a95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a6f9b63ee8ecc6a5a2f072a469ac95a95">scatter_matrix_to</a> (const std::vector&lt; index_type &gt; &amp;row_index_set, const std::vector&lt; index_type &gt; &amp;column_index_set, MatrixType &amp;matrix) const</td></tr>
<tr class="separator:a6f9b63ee8ecc6a5a2f072a469ac95a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdf2b89ab7f7a0d5a7e988e43162361"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9bdf2b89ab7f7a0d5a7e988e43162361"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9bdf2b89ab7f7a0d5a7e988e43162361">fill</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_j=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_j=0)</td></tr>
<tr class="separator:a9bdf2b89ab7f7a0d5a7e988e43162361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c7f313a4ce3432ea12e0f93145f23"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ab65c7f313a4ce3432ea12e0f93145f23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ab65c7f313a4ce3432ea12e0f93145f23">fill</a> (const number2 *)</td></tr>
<tr class="separator:ab65c7f313a4ce3432ea12e0f93145f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c1c072eb09809311fed47a03da2858"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a15c1c072eb09809311fed47a03da2858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a15c1c072eb09809311fed47a03da2858">fill_permutation</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;p_rows, const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;p_cols)</td></tr>
<tr class="separator:a15c1c072eb09809311fed47a03da2858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f43cd7abf5122bfc95c6442f08397a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4f43cd7abf5122bfc95c6442f08397a6">set</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j, const number value)</td></tr>
<tr class="separator:a4f43cd7abf5122bfc95c6442f08397a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">非修饰性操作符</div></td></tr>
<tr class="memitem:a81478c422e681504c6f5fca0a3a49090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a81478c422e681504c6f5fca0a3a49090">operator==</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;) const</td></tr>
<tr class="separator:a81478c422e681504c6f5fca0a3a49090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae353e09fdd66b9df250520434f9c9275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae353e09fdd66b9df250520434f9c9275">m</a> () const</td></tr>
<tr class="separator:ae353e09fdd66b9df250520434f9c9275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94aa6df67b8da6a1a31c052ff74bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a> () const</td></tr>
<tr class="separator:a4f94aa6df67b8da6a1a31c052ff74bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677adb3e579c61c2710470d71aee0515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a677adb3e579c61c2710470d71aee0515">all_zero</a> () const</td></tr>
<tr class="separator:a677adb3e579c61c2710470d71aee0515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76715ebcd64c97475ae26b03ff35f3f4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a76715ebcd64c97475ae26b03ff35f3f4"><td class="memTemplItemLeft" align="right" valign="top">number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a76715ebcd64c97475ae26b03ff35f3f4">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a76715ebcd64c97475ae26b03ff35f3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86461e3010387d63b16952f51c7e3a85"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a86461e3010387d63b16952f51c7e3a85"><td class="memTemplItemLeft" align="right" valign="top">number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a86461e3010387d63b16952f51c7e3a85">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a86461e3010387d63b16952f51c7e3a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502a2f65ebaba3c24cd4201fee0beee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#af502a2f65ebaba3c24cd4201fee0beee">l1_norm</a> () const</td></tr>
<tr class="separator:af502a2f65ebaba3c24cd4201fee0beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97598e75580f535f7b0418eb32de722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#af97598e75580f535f7b0418eb32de722">linfty_norm</a> () const</td></tr>
<tr class="separator:af97598e75580f535f7b0418eb32de722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a8a1ea24b18624dc2ddcb6b88d03b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ace5a8a1ea24b18624dc2ddcb6b88d03b">frobenius_norm</a> () const</td></tr>
<tr class="separator:ace5a8a1ea24b18624dc2ddcb6b88d03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f90f68aa267b0a8c67ab8a7c34acd41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a2f90f68aa267b0a8c67ab8a7c34acd41">relative_symmetry_norm2</a> () const</td></tr>
<tr class="separator:a2f90f68aa267b0a8c67ab8a7c34acd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b187e4b8b3e2758118f3c2794c14b"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aa75b187e4b8b3e2758118f3c2794c14b">determinant</a> () const</td></tr>
<tr class="separator:aa75b187e4b8b3e2758118f3c2794c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d78d2cf76d82a52e2d761bb2e5c69"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a455d78d2cf76d82a52e2d761bb2e5c69">trace</a> () const</td></tr>
<tr class="separator:a455d78d2cf76d82a52e2d761bb2e5c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc67a688b9a282a8403acedf1e5304d6"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:abc67a688b9a282a8403acedf1e5304d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abc67a688b9a282a8403acedf1e5304d6">print</a> (StreamType &amp;s, const unsigned <a class="el" href="classint.html">int</a> width=5, const unsigned <a class="el" href="classint.html">int</a> precision=2) const</td></tr>
<tr class="separator:abc67a688b9a282a8403acedf1e5304d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd86a102fefa37a3916a612d8e329bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abdd86a102fefa37a3916a612d8e329bd">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1., const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:abdd86a102fefa37a3916a612d8e329bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7fe46def6d7eada6e4bae55e2778ef"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a0d7fe46def6d7eada6e4bae55e2778ef">memory_consumption</a> () const</td></tr>
<tr class="separator:a0d7fe46def6d7eada6e4bae55e2778ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator functions</div></td></tr>
<tr class="memitem:ac621d0e04198f9b07fe31a459034278c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ac621d0e04198f9b07fe31a459034278c">begin</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r)</td></tr>
<tr class="separator:ac621d0e04198f9b07fe31a459034278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3e01acdaea19d0cd0c00e7bdcbe14c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#acb3e01acdaea19d0cd0c00e7bdcbe14c">end</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r)</td></tr>
<tr class="separator:acb3e01acdaea19d0cd0c00e7bdcbe14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee5943508259f916ea5387ce22a80b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aeee5943508259f916ea5387ce22a80b1">begin</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r) const</td></tr>
<tr class="separator:aeee5943508259f916ea5387ce22a80b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f65316c85da072ceba7ca8e99625fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7f65316c85da072ceba7ca8e99625fa1">end</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r) const</td></tr>
<tr class="separator:a7f65316c85da072ceba7ca8e99625fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying operators</div></td></tr>
<tr class="memitem:a9fa9af1ab8afd166bb3e5382d188727d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9fa9af1ab8afd166bb3e5382d188727d">operator*=</a> (const number factor)</td></tr>
<tr class="separator:a9fa9af1ab8afd166bb3e5382d188727d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e08c4944365290db46508cedf01989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a63e08c4944365290db46508cedf01989">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a63e08c4944365290db46508cedf01989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ea8b35b3d4a53deeabdd6edccea3a"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9f2ea8b35b3d4a53deeabdd6edccea3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9f2ea8b35b3d4a53deeabdd6edccea3a">add</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A)</td></tr>
<tr class="separator:a9f2ea8b35b3d4a53deeabdd6edccea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7147f8e1ce0ec51d042f6d2ffe036a"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:acd7147f8e1ce0ec51d042f6d2ffe036a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#acd7147f8e1ce0ec51d042f6d2ffe036a">add</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B)</td></tr>
<tr class="separator:acd7147f8e1ce0ec51d042f6d2ffe036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617058ea25768fbd562220462dff409e"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a617058ea25768fbd562220462dff409e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a617058ea25768fbd562220462dff409e">add</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const number c, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C)</td></tr>
<tr class="separator:a617058ea25768fbd562220462dff409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211b9a2c46404cdcf84abdbaba70032"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a7211b9a2c46404cdcf84abdbaba70032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7211b9a2c46404cdcf84abdbaba70032">add</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const number factor, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_j=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_j=0)</td></tr>
<tr class="separator:a7211b9a2c46404cdcf84abdbaba70032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556863808164142f559bcce1d92a09e"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a6556863808164142f559bcce1d92a09e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a6556863808164142f559bcce1d92a09e">Tadd</a> (const number s, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B)</td></tr>
<tr class="separator:a6556863808164142f559bcce1d92a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79daca87844eec1680018f196a3df0c"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ad79daca87844eec1680018f196a3df0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ad79daca87844eec1680018f196a3df0c">Tadd</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const number factor, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_j=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_j=0)</td></tr>
<tr class="separator:ad79daca87844eec1680018f196a3df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a913e14db890a6992849b1c238644e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a31a913e14db890a6992849b1c238644e">add</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> row, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> column, const number value)</td></tr>
<tr class="separator:a31a913e14db890a6992849b1c238644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5cbf09cba49593f2c86d7f06b5eadb"><td class="memTemplParams" colspan="2">template&lt;typename number2 , typename index_type &gt; </td></tr>
<tr class="memitem:a8b5cbf09cba49593f2c86d7f06b5eadb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8b5cbf09cba49593f2c86d7f06b5eadb">add</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> row, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> n_cols, const index_type *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a8b5cbf09cba49593f2c86d7f06b5eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b59247b8ddc428a47342525152691b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a1b59247b8ddc428a47342525152691b2">add_row</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:a1b59247b8ddc428a47342525152691b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eccc2e4b7b2113f568f31046a8b239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a52eccc2e4b7b2113f568f31046a8b239">add_row</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j, const number t, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> k)</td></tr>
<tr class="separator:a52eccc2e4b7b2113f568f31046a8b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb599d984e3375067f615aefd5c9393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8bb599d984e3375067f615aefd5c9393">add_col</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:a8bb599d984e3375067f615aefd5c9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b837f07f41a19e0d57377e31ec61569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a6b837f07f41a19e0d57377e31ec61569">add_col</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j, const number t, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> k)</td></tr>
<tr class="separator:a6b837f07f41a19e0d57377e31ec61569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7118bb0c55702e741002db02ac6f0e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7118bb0c55702e741002db02ac6f0e04">swap_row</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:a7118bb0c55702e741002db02ac6f0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4046dea183a3d5ef191cbe18e674881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae4046dea183a3d5ef191cbe18e674881">swap_col</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:ae4046dea183a3d5ef191cbe18e674881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12566fc371d78838435583c4f59e942d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a12566fc371d78838435583c4f59e942d">diagadd</a> (const number s)</td></tr>
<tr class="separator:a12566fc371d78838435583c4f59e942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7880cb55e5cecc96a033f390d5d00210"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a7880cb55e5cecc96a033f390d5d00210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7880cb55e5cecc96a033f390d5d00210">equ</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A)</td></tr>
<tr class="separator:a7880cb55e5cecc96a033f390d5d00210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4180de5a8d453af9bb5e3b328078e19f"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a4180de5a8d453af9bb5e3b328078e19f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4180de5a8d453af9bb5e3b328078e19f">equ</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B)</td></tr>
<tr class="separator:a4180de5a8d453af9bb5e3b328078e19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae444a21f6b0cc9da4edd5a127a79e61"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:aae444a21f6b0cc9da4edd5a127a79e61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aae444a21f6b0cc9da4edd5a127a79e61">equ</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const number c, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C)</td></tr>
<tr class="separator:aae444a21f6b0cc9da4edd5a127a79e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3790a7f3ad399a0f093a3d94f03d6846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a3790a7f3ad399a0f093a3d94f03d6846">symmetrize</a> ()</td></tr>
<tr class="separator:a3790a7f3ad399a0f093a3d94f03d6846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898466c57e11e6f2599165071ffe5df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a898466c57e11e6f2599165071ffe5df3">gauss_jordan</a> ()</td></tr>
<tr class="separator:a898466c57e11e6f2599165071ffe5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940ea10266174ad366d10bd806177ace"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a940ea10266174ad366d10bd806177ace"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a940ea10266174ad366d10bd806177ace">invert</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;M)</td></tr>
<tr class="separator:a940ea10266174ad366d10bd806177ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6cd3d2dee462237eed86073be061a4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9b6cd3d2dee462237eed86073be061a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9b6cd3d2dee462237eed86073be061a4">cholesky</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A)</td></tr>
<tr class="separator:a9b6cd3d2dee462237eed86073be061a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbaa7791d02c34d71a751234a188087"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:acdbaa7791d02c34d71a751234a188087"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#acdbaa7791d02c34d71a751234a188087">outer_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;W)</td></tr>
<tr class="separator:acdbaa7791d02c34d71a751234a188087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2388c76685e3fc4efdaab4cad185518"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac2388c76685e3fc4efdaab4cad185518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ac2388c76685e3fc4efdaab4cad185518">left_invert</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;M)</td></tr>
<tr class="separator:ac2388c76685e3fc4efdaab4cad185518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a25dc4075f341f18e014037cd34f9b"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a45a25dc4075f341f18e014037cd34f9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a45a25dc4075f341f18e014037cd34f9b">right_invert</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;M)</td></tr>
<tr class="separator:a45a25dc4075f341f18e014037cd34f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:a21b873fcd180999ad0d268c3278a71ec"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a21b873fcd180999ad0d268c3278a71ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">mmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a21b873fcd180999ad0d268c3278a71ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850654dea1494fffc80677d3f58142a0"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a850654dea1494fffc80677d3f58142a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a850654dea1494fffc80677d3f58142a0">Tmmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a850654dea1494fffc80677d3f58142a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac074fc1dc416f8cd75bb01d820e74aa0"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac074fc1dc416f8cd75bb01d820e74aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ac074fc1dc416f8cd75bb01d820e74aa0">mTmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:ac074fc1dc416f8cd75bb01d820e74aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098a0fb764e74c7a4a524c9572e47b18"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a098a0fb764e74c7a4a524c9572e47b18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a098a0fb764e74c7a4a524c9572e47b18">TmTmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a098a0fb764e74c7a4a524c9572e47b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087ad6f60a4a0c365aeaee4760ad5cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a087ad6f60a4a0c365aeaee4760ad5cb9">triple_product</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;A, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;B, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;D, const <a class="el" href="classbool.html">bool</a> transpose_B=false, const <a class="el" href="classbool.html">bool</a> transpose_D=false, const number scaling=number(1.))</td></tr>
<tr class="separator:a087ad6f60a4a0c365aeaee4760ad5cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a409eeef6388d99ac15e2bbe8045f6"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a65a409eeef6388d99ac15e2bbe8045f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a65a409eeef6388d99ac15e2bbe8045f6">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a65a409eeef6388d99ac15e2bbe8045f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edeb234359c99ccbc3a21e4890f61d7"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a8edeb234359c99ccbc3a21e4890f61d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8edeb234359c99ccbc3a21e4890f61d7">vmult_add</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a8edeb234359c99ccbc3a21e4890f61d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219d4fa962f1b041a506221a7a15379"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a8219d4fa962f1b041a506221a7a15379"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8219d4fa962f1b041a506221a7a15379">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a8219d4fa962f1b041a506221a7a15379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed6fffa5cb201496d751a4427cb59d6"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:abed6fffa5cb201496d751a4427cb59d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abed6fffa5cb201496d751a4427cb59d6">Tvmult_add</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:abed6fffa5cb201496d751a4427cb59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca64e608a864f4e6c80e6a05fbe2b31"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a8ca64e608a864f4e6c80e6a05fbe2b31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8ca64e608a864f4e6c80e6a05fbe2b31">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a8ca64e608a864f4e6c80e6a05fbe2b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf7a776bf5778590c6997eeb53d277f"><td class="memTemplParams" colspan="2">template&lt;typename number2 , typename number3 &gt; </td></tr>
<tr class="memitem:a0bf7a776bf5778590c6997eeb53d277f"><td class="memTemplItemLeft" align="right" valign="top">number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a0bf7a776bf5778590c6997eeb53d277f">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; number3 &gt; &amp;b) const</td></tr>
<tr class="separator:a0bf7a776bf5778590c6997eeb53d277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2241691e3b13448df6acbc37b39ab06"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ad2241691e3b13448df6acbc37b39ab06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ad2241691e3b13448df6acbc37b39ab06">forward</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:ad2241691e3b13448df6acbc37b39ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9add855bcb711cd778e6a99026eff59"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae9add855bcb711cd778e6a99026eff59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae9add855bcb711cd778e6a99026eff59">backward</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:ae9add855bcb711cd778e6a99026eff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class FullMatrix&lt; number &gt;</h3>

<p>实现一个经典的矩形数字方案。条目的数据类型由模板参数<code>number</code>提供。 该接口相当肥大，事实上，每次需要新的功能时，它都会增长。所以，提供了很多功能。 内部计算通常是以函数的向量参数的精度来完成的。如果没有数字类型的参数，则使用矩阵数字类型。</p>
<dl class="section note"><dt>Note</dt><dd>本模板的实例化提供给<code> &lt;float&gt;, &lt;double&gt;, &lt;std::complex&lt;float&gt;&gt;, &lt;std::complex&lt;double&gt;&gt;</code>. 其他可以在应用程序中生成，详见 <a class="el" href="Instantiations.html">Template instantiations</a> 。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00069">69</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4e8f9ce2c12a56e26b62133edfcc9cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f9ce2c12a56e26b62133edfcc9cef">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用于对该容器进行索引的一种类型。 </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00082">82</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a5759353fd47e8aa3cb22b95979af27b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5759353fd47e8aa3cb22b95979af27b9">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a5759353fd47e8aa3cb22b95979af27b9">value_type</a> =  number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵条目的类型。这个别名类似于标准库容器中的<code>value_type</code>。 </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00088">88</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a5e14c99dc6090be77b76ac9cfc8b63e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e14c99dc6090be77b76ac9cfc8b63e6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> =  typename <a class="el" href="classTable.html">Table</a>&lt;2, number&gt;::<a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用基类的可变迭代器类型。 </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00094">94</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a030be3ca41e86b9a4a7a8d0683a84962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030be3ca41e86b9a4a7a8d0683a84962">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> =  typename <a class="el" href="classTable.html">Table</a>&lt;2, number&gt;::<a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用基类的常数迭代器类型。 </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00100">100</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a01df0a76d1f2234cf3eb161a953d7ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01df0a76d1f2234cf3eb161a953d7ef2">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>声明一个类型，该类型持有与本类的模板参数相同精度的实值数。如果这个类的模板参数是一个实数数据类型，那么real_type就等于模板参数。 如果模板参数是一个 std::complex 类型，那么real_type等于复数的基础类型。 这个别名被用来表示规范的返回类型。 </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00121">121</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc08a0718c9110770badd10b5a38892f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc08a0718c9110770badd10b5a38892f">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>构造函数。将矩阵初始化为一个维度为<code>n</code>的正方形矩阵。 为了避免整数和其他类型的矩阵的隐式转换，这个构造函数被声明为<code>explicit</code>。 默认情况下，不分配内存。 </p>

</div>
</div>
<a id="a0a45e5db015f8adc54f5f48f5376318d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a45e5db015f8adc54f5f48f5376318d">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数。将矩阵初始化为一个矩形矩阵。 </p>

</div>
</div>
<a id="a7fc62a1da08095133fdd2515ca644c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc62a1da08095133fdd2515ca644c89">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构造函数从一个数组中初始化。该数组被逐行排列。不进行范围检查。 </p>

</div>
</div>
<a id="a8e195f7eda5b88bbc34dab0eeb17e3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e195f7eda5b88bbc34dab0eeb17e3e8">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构建一个全矩阵，等于参数大小的身份矩阵。使用这个构造函数，我们可以很容易地创建一个大小为 <code>n</code> 的身份矩阵，方法是说 </p><div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> M(<a class="code" href="classIdentityMatrix.html">IdentityMatrix</a>(<a class="code" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a>));</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5537bbde546b72ecd718155686ebd15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5537bbde546b72ecd718155686ebd15b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>变量赋值运算符。 </p>

</div>
</div>
<a id="aa67dc887e44da6c7771eb0e92fc98323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67dc887e44da6c7771eb0e92fc98323">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个操作符将一个标量分配给一个矩阵。为了避免与这个函数的语义相混淆，0是<code>d</code>唯一允许的值，允许你以一种直观的方式清除一个矩阵。 </p><dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a8eea4b2a1fc643d6c8b0e70ebb0ac261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eea4b2a1fc643d6c8b0e70ebb0ac261">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制操作符，创建一个完整的矩阵，等于参数大小的身份矩阵。这样一来，人们可以很容易地创建一个大小为 <code>n</code> 的身份矩阵，只要说 </p><div class="fragment"><div class="line">M = <a class="code" href="classIdentityMatrix.html">IdentityMatrix</a>(<a class="code" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="adb8124671c3e3e88e060b5ea32960f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8124671c3e3e88e060b5ea32960f6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>LapackFullMatrix的赋值操作。调用的矩阵必须与LAPACK矩阵的大小相同。 </p>

</div>
</div>
<a id="ae9e8fbf00e15c7b66d527a5de4b31404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e8fbf00e15c7b66d527a5de4b31404">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>来自不同矩阵类的赋值。这个赋值运算符使用类型名MatrixType的迭代器。因此，稀疏矩阵是可能的来源。 </p>

</div>
</div>
<a id="abb901c6e33e90c80a2ed3a9394865156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb901c6e33e90c80a2ed3a9394865156">&#9670;&nbsp;</a></span>copy_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_transposed </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>来自不同矩阵类的转置赋值。这个赋值运算符使用了typename MatrixType的迭代器。因此，稀疏矩阵是可能的来源。 </p>

</div>
</div>
<a id="a3555b32b42cdcccfc72ac5ec32c5f83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3555b32b42cdcccfc72ac5ec32c5f83d">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_r_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_r_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_c_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_c_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_r</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_c</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用从张量中提取的元素填充矩阵，取包括在<code>r_i</code>和<code>r_j</code>之间的行以及<code>c_i</code>和<code>c_j</code>之间的列。然后将得到的矩阵插入目标矩阵的<code>(dst_r, dst_c)</code>位置，对索引进行检查。 </p>

</div>
</div>
<a id="a7437dbce381ba72d029c67a719826fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7437dbce381ba72d029c67a719826fcc">&#9670;&nbsp;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_r_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_r_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_c_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_c_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dst_r</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dst_c</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将一个子矩阵（也是矩形的）插入张量中，将其左上角的元素放在指定的位置<code>(dst_r, dst_c)</code>，其他元素也随之插入。默认值的选择是，如果张量的大小和矩阵的大小一致，则不需要指定参数。 </p>

</div>
</div>
<a id="ae94bda7e32ea0082326e4fbf151fb868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94bda7e32ea0082326e4fbf151fb868">&#9670;&nbsp;</a></span>extract_submatrix_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::extract_submatrix_from </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_index_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将另一个矩阵的行和列的一个子集复制到当前对象中。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">矩阵</td><td>要从中提取子集的矩阵。 </td></tr>
    <tr><td class="paramname">row_index_set</td><td>要提取的 <code>matrix</code> 的行的集合。 </td></tr>
    <tr><td class="paramname">column_index_set</td><td>要提取的 <code>matrix</code> 的列的集合。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>row_index_set</code> 和 <code>column_index_set中的元素数量应等于当前对象的行和列的数量。换句话说，在这个操作中，当前对象的大小不会被调整。</code> </dd></dl>

</div>
</div>
<a id="a6f9b63ee8ecc6a5a2f072a469ac95a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9b63ee8ecc6a5a2f072a469ac95a95">&#9670;&nbsp;</a></span>scatter_matrix_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::scatter_matrix_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将当前矩阵对象的元素复制到另一个矩阵的指定行和列集合中。因此，这是一个散点操作。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index_set</td><td>要写入的 <code>matrix</code> 的行。 </td></tr>
    <tr><td class="paramname">column_index_set</td><td>要写入的 <code>matrix</code> 的列。 </td></tr>
    <tr><td class="paramname">matrix</td><td>某些元素要被替换的矩阵。 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd><code>row_index_set</code> 和 <code>column_index_set中的元素数量应等于当前对象的行和列的数量。换句话说，在这个操作中，当前对象的大小不会被调整。</code> </dd></dl>

</div>
</div>
<a id="a9bdf2b89ab7f7a0d5a7e988e43162361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdf2b89ab7f7a0d5a7e988e43162361">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_j</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>填充矩形块。 矩阵<code>src</code>的一个矩形块被复制到<code>this</code>。被复制的块的左上角是&lt;tt&gt;(src_offset_i,src_offset_j)。 被复制块的左上角是&lt;tt&gt;(dst_offset_i,dst_offset_j)。 被复制的矩形块的尺寸是可能的最大尺寸，由<code>this</code>或<code>src</code>的尺寸决定。 </p>

</div>
</div>
<a id="ab65c7f313a4ce3432ea12e0f93145f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65c7f313a4ce3432ea12e0f93145f23">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使基类的功能可用。 </p>

</div>
</div>
<a id="a15c1c072eb09809311fed47a03da2858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c1c072eb09809311fed47a03da2858">&#9670;&nbsp;</a></span>fill_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::fill_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用另一个矩阵的permutation来填充。 矩阵<code>src</code>被复制到目标中。两个互换<code>p_r</code>和<code>p_c</code>的操作方式，使得<code>result(i,j) = src(p_r[i], p_c[j]) </code>。 如果矩阵<code>src</code>更大的话，向量也可能是从更大的整数集中选择出来的。也可以通过这种方法来复制行或列。 </p>

</div>
</div>
<a id="a4f43cd7abf5122bfc95c6442f08397a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f43cd7abf5122bfc95c6442f08397a6">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将矩阵的某一特定条目设置为一个值。因此，调用 <code>A.set(1,2,3.141);</code> 完全等同于操作 <code>A(1,2) = 3.141;</code> 。这个函数的存在是为了与各种稀疏矩阵对象兼容。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>要设置的元素的行索引。 </td></tr>
    <tr><td class="paramname">j</td><td>要设置的元素的列索引。 </td></tr>
    <tr><td class="paramname">value</td><td>要写进元素的值。 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81478c422e681504c6f5fca0a3a49090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81478c422e681504c6f5fca0a3a49090">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>比较运算符。对这个东西要小心，它可能会吞噬大量的计算时间 它最常用于程序的内部一致性检查。 </p>

</div>
</div>
<a id="ae353e09fdd66b9df250520434f9c9275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae353e09fdd66b9df250520434f9c9275">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个矩阵的行数。 注意，这个矩阵的维度是<em>m x n</em>。 </p>

</div>
</div>
<a id="a4f94aa6df67b8da6a1a31c052ff74bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94aa6df67b8da6a1a31c052ff74bcd">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该矩阵的列数。 请注意，该矩阵的维度为<em>m x n</em>。 </p>

</div>
</div>
<a id="a677adb3e579c61c2710470d71aee0515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677adb3e579c61c2710470d71aee0515">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回该矩阵是否只包含数值为0的元素。这个函数主要用于内部一致性检查，在非调试模式下应该很少使用，因为它需要花费相当多的时间。 </p>

</div>
</div>
<a id="a76715ebcd64c97475ae26b03ff35f3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76715ebcd64c97475ae26b03ff35f3f4">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number2 <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回由该矩阵引起的向量<code>v</code>的规范的平方，即&lt;i&gt;(v,Mv)。这很有用，例如在有限元背景下，一个函数的<em>L<sup>2</sup></em>规范等于相对于代表有限元函数节点值的向量矩阵的矩阵规范。 显然，对于这个操作，矩阵需要是二次的，而且为了使结果真正成为一个规范，它还需要是实数对称的或复数隐式的。 该矩阵和给定向量的基础模板类型应该都是实值或复值，但不是混合的，这样这个函数才有意义。 </p>

</div>
</div>
<a id="a86461e3010387d63b16952f51c7e3a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86461e3010387d63b16952f51c7e3a85">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number2 <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>建立矩阵标量乘积<code>u<sup>T</sup>M v</code>。这个函数在有限元背景下建立两个函数的单元标量积时大多有用。 这个矩阵和给定向量的基本模板类型应该都是实数或复数，但不是混合的，这样这个函数才有意义。 </p>

</div>
</div>
<a id="af502a2f65ebaba3c24cd4201fee0beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502a2f65ebaba3c24cd4201fee0beee">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的<em>l<sub>1</sub></em>-norm，其中 \(||M||_1 = \max_j \sum_i |M_{ij}|\) （列上之和的最大值）。 </p>

</div>
</div>
<a id="af97598e75580f535f7b0418eb32de722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97598e75580f535f7b0418eb32de722">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的 \(l_\infty\) -Norm，其中 \(||M||_\infty = \max_i \sum_j |M_{ij}|\) （行上和的最大值）。 </p>

</div>
</div>
<a id="ace5a8a1ea24b18624dc2ddcb6b88d03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5a8a1ea24b18624dc2ddcb6b88d03b">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵的Frobenius规范。 返回值是所有矩阵条目的平方和的根。 </p><dl class="section note"><dt>Note</dt><dd>对于我们中的胆小鬼：这个规范不是与向量空间的<em>l<sub>2</sub></em>规范兼容的规范。 </dd></dl>

</div>
</div>
<a id="a2f90f68aa267b0a8c67ab8a7c34acd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f90f68aa267b0a8c67ab8a7c34acd41">&#9670;&nbsp;</a></span>relative_symmetry_norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::relative_symmetry_norm2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算歪斜对称部分的相对规范。返回值是矩阵的倾斜对称部分的Frobenius规范除以矩阵的规范。 这个函数的主要目的是检查，一个矩阵是否在一定的精度范围内是对称的。 </p>

</div>
</div>
<a id="aa75b187e4b8b3e2758118f3c2794c14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b187e4b8b3e2758118f3c2794c14b">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算矩阵的行列式。 这个功能只在一维、二维和三维空间实现，因为对于更高的维度，数值工作就会爆发。 很明显，对于这个函数来说，矩阵需要是二次的。 </p>

</div>
</div>
<a id="a455d78d2cf76d82a52e2d761bb2e5c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455d78d2cf76d82a52e2d761bb2e5c69">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回矩阵的轨迹，即对角线值的总和（恰好也等于矩阵的特征值的总和）。 很明显，对于这个函数来说，矩阵需要是二次的。 </p>

</div>
</div>
<a id="abc67a688b9a282a8403acedf1e5304d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc67a688b9a282a8403acedf1e5304d6">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>以用户定义的格式输出由指定的精度和宽度给出的矩阵。这个函数在为输出设置这些给定值之前保存了流的宽度和精度，并在输出后恢复之前的值。 </p>

</div>
</div>
<a id="abdd86a102fefa37a3916a612d8e329bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd86a102fefa37a3916a612d8e329bd">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>打印矩阵并允许对条目进行格式化。 参数允许对输出格式进行灵活设置。 </p><ul>
<li><code>precision</code>表示尾数的数量。 </li>
<li><code>scientific</code>用于确定数字格式，其中<code>scientific</code> = <code>false</code>表示固定点符号。 </li>
<li><code>width</code>表示每列的与。<code>width</code>的零条目使函数计算出一个宽度，但如果输出粗略，可以将其改为正值。 </li>
<li><code>zero_string</code>为零条目指定一个打印的字符串。 </li>
<li><code>denominator</code> 将整个矩阵乘以这个共同的分母，得到更漂亮的数字。 </li>
<li><code>阈值</code>：所有绝对值小于此值的条目都被视为零。 </li>
</ul>

</div>
</div>
<a id="a0d7fe46def6d7eada6e4bae55e2778ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7fe46def6d7eada6e4bae55e2778ef">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>确定这个对象的内存消耗（以字节为单位）的估计值。 </p>

</div>
</div>
<a id="ac621d0e04198f9b07fe31a459034278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac621d0e04198f9b07fe31a459034278c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>可变的迭代器，从<code>r</code>行的第一个条目开始。 </p>

</div>
</div>
<a id="acb3e01acdaea19d0cd0c00e7bdcbe14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3e01acdaea19d0cd0c00e7bdcbe14c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>超过行<code>r</code>末尾的一个可变迭代器。 </p>

</div>
</div>
<a id="aeee5943508259f916ea5387ce22a80b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee5943508259f916ea5387ce22a80b1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从<code>r</code>行的第一个条目开始的恒定迭代器。 </p>

</div>
</div>
<a id="a7f65316c85da072ceba7ca8e99625fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f65316c85da072ceba7ca8e99625fa1">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从第<code>r</code>行的最后一条开始的恒定迭代器。 </p>

</div>
</div>
<a id="a9fa9af1ab8afd166bb3e5382d188727d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa9af1ab8afd166bb3e5382d188727d">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用一个固定的因子来缩放整个矩阵。 </p>

</div>
</div>
<a id="a63e08c4944365290db46508cedf01989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e08c4944365290db46508cedf01989">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用给定系数的逆数来缩放整个矩阵。 </p>

</div>
</div>
<a id="a9f2ea8b35b3d4a53deeabdd6edccea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2ea8b35b3d4a53deeabdd6edccea3a">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放后的矩阵的简单加法，即<code>*this += a*A</code>。 矩阵<code>A</code>可以是一个任意底层标量类型上的全矩阵，只要其数据类型可以转换为该矩阵的数据类型。 </p>

</div>
</div>
<a id="acd7147f8e1ce0ec51d042f6d2ffe036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7147f8e1ce0ec51d042f6d2ffe036a">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放矩阵的多重加法，即<code>*this += a*A + b*B</code>。 矩阵<code>A</code>和<code>B</code>可以是一个任意底层标量类型上的全矩阵，只要其数据类型可以转换为该矩阵的数据类型。 </p>

</div>
</div>
<a id="a617058ea25768fbd562220462dff409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617058ea25768fbd562220462dff409e">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放矩阵的多重加法，即<code>*this += a*A + b*B + c*C</code>。 矩阵<code>A</code>, <code>B</code>和<code>C</code>可以是一个任意底层标量类型上的全矩阵，只要其数据类型可以转换为这个矩阵的数据类型。 </p>

</div>
</div>
<a id="a7211b9a2c46404cdcf84abdbaba70032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7211b9a2c46404cdcf84abdbaba70032">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_j</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加矩形块。 矩阵<code>src</code>的一个矩形块被添加到<code>this</code>。 被复制的块的左上角是&lt;tt&gt;(src_offset_i,src_offset_j)/tt&gt;。 被复制块的左上角是&lt;tt&gt;(dst_offset_i,dst_offset_j)。 被复制的矩形块的尺寸是可能的最大尺寸，由<code>this</code>或<code>src</code>的尺寸和给定的偏移量决定。 </p>

</div>
</div>
<a id="a6556863808164142f559bcce1d92a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6556863808164142f559bcce1d92a09e">&#9670;&nbsp;</a></span>Tadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tadd </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将<code>B</code>的转置加到<code>this</code>。 <em>A += s B<sup>T</sup></em> </p>

</div>
</div>
<a id="ad79daca87844eec1680018f196a3df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79daca87844eec1680018f196a3df0c">&#9670;&nbsp;</a></span>Tadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_j</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>增加一个矩形块的转置。 矩阵<code>src</code>的一个矩形块被转置并添加到<code>this</code>。被复制的块的左上角是&lt;tt&gt;(src_offset_i,src_offset_j)在<b>non</b>转置的矩阵的坐标。 被复制块的左上角是&lt;tt&gt;(dst_offset_i,dst_offset_j)。 被复制的矩形块的尺寸是可能的最大尺寸，由<code>this</code>或<code>src</code>的尺寸决定。 </p>

</div>
</div>
<a id="a31a913e14db890a6992849b1c238644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a913e14db890a6992849b1c238644e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的位置添加一个单一元素。 </p>

</div>
</div>
<a id="a8b5cbf09cba49593f2c86d7f06b5eadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5cbf09cba49593f2c86d7f06b5eadb">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 , typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const index_type *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在给定的全局矩阵行中，在全局矩阵中由col_indices指定的列上添加一个由<code>values</code>给出的数值数组。这个函数的出现是为了与deal.II中的各种稀疏矩阵兼容。特别是，两个布尔字段 <code>elide_zero_values</code> 和 <code>col_indices_are_sorted</code> 并不影响这个例程的性能，与稀疏矩阵的情况不同，在实现中确实被忽略了。 </p>

</div>
</div>
<a id="a1b59247b8ddc428a47342525152691b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b59247b8ddc428a47342525152691b2">&#9670;&nbsp;</a></span>add_row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(i,1...n) += s*A(j,1...n)</em>. 简单地增加这一行的数量 </p>

</div>
</div>
<a id="a52eccc2e4b7b2113f568f31046a8b239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52eccc2e4b7b2113f568f31046a8b239">&#9670;&nbsp;</a></span>add_row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(i,1...n) += s*A(j,1...n) + t*A(k,1...n)</em>. 多次增加这的行数。 </p>

</div>
</div>
<a id="a8bb599d984e3375067f615aefd5c9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb599d984e3375067f615aefd5c9393">&#9670;&nbsp;</a></span>add_col() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(1...n,i) += s*A(1...n,j)</em>. 简单添加这的列。 </p>

</div>
</div>
<a id="a6b837f07f41a19e0d57377e31ec61569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b837f07f41a19e0d57377e31ec61569">&#9670;&nbsp;</a></span>add_col() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(1...n,i) += s*A(1...n,j) + t*A(1...n,k)</em>. 多次增加此列。 </p>

</div>
</div>
<a id="a7118bb0c55702e741002db02ac6f0e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7118bb0c55702e741002db02ac6f0e04">&#9670;&nbsp;</a></span>swap_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::swap_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换 <em>A(i,1...n) &lt;-&gt; A(j,1...n)</em>. 交换这个的第i行和第j行 </p>

</div>
</div>
<a id="ae4046dea183a3d5ef191cbe18e674881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4046dea183a3d5ef191cbe18e674881">&#9670;&nbsp;</a></span>swap_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::swap_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换<em>A(1...n,i) &lt;-&gt; A(1...n,j)</em>。 交换这个的第i列和第j列 </p>

</div>
</div>
<a id="a12566fc371d78838435583c4f59e942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12566fc371d78838435583c4f59e942d">&#9670;&nbsp;</a></span>diagadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::diagadd </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给这个的对角线元素添加常数，即添加身份矩阵的一个倍数。 </p>

</div>
</div>
<a id="a7880cb55e5cecc96a033f390d5d00210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7880cb55e5cecc96a033f390d5d00210">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>赋值 <code>*this = a*A</code>. </p>

</div>
</div>
<a id="a4180de5a8d453af9bb5e3b328078e19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4180de5a8d453af9bb5e3b328078e19f">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>分配 <code>*this = a*A + b*B</code>. </p>

</div>
</div>
<a id="aae444a21f6b0cc9da4edd5a127a79e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae444a21f6b0cc9da4edd5a127a79e61">&#9670;&nbsp;</a></span>equ() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>分配 <code>*this = a*A + b*B + c*C</code>. </p>

</div>
</div>
<a id="a3790a7f3ad399a0f093a3d94f03d6846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3790a7f3ad399a0f093a3d94f03d6846">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>通过形成现有矩阵和它的转置<em>A = 1/2(A+A<sup>T</sup>)</em>之间的平均值，对矩阵进行对称。 很明显，矩阵必须是二次方的，才能进行这一操作。 </p>

</div>
</div>
<a id="a898466c57e11e6f2599165071ffe5df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898466c57e11e6f2599165071ffe5df3">&#9670;&nbsp;</a></span>gauss_jordan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::gauss_jordan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A=Inverse(A)。A必须是一个方形矩阵。 通过高斯-乔丹算法对该矩阵进行反演，并进行部分透视。 这个过程对于正定矩阵来说表现良好，但要注意在不确定的情况下的舍入误差。 在deal.II被配置为LAPACK的情况下，函数Xgetrf和Xgetri建立了一个LU因式分解，并在该因式分解的基础上反转矩阵，提供了最好的性能，直到有几百个行和列的矩阵。 对一个<code>n x n</code>矩阵进行反转的数值努力是<code>n*3</code>。 </p>

</div>
</div>
<a id="a940ea10266174ad366d10bd806177ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940ea10266174ad366d10bd806177ace">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定矩阵的逆运算分配给<code>*this</code>。这个函数是针对一到四维的二次元矩阵的硬编码。然而，由于所需的代码量增长很快，如果维数更大，则隐含地调用gauss_jordan()方法。 </p>

</div>
</div>
<a id="a9b6cd3d2dee462237eed86073be061a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6cd3d2dee462237eed86073be061a4">&#9670;&nbsp;</a></span>cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定矩阵 \(A\) 的Cholesky分解 \(A=:L L^T\) 分配给<code>*this</code>，其中 \(L\) 为下三角矩阵。给定的矩阵必须是对称正定的。 如果矩阵不是正定的，就会抛出ExcMatrixNotPositiveDefinite。 </p>

</div>
</div>
<a id="acdbaa7791d02c34d71a751234a188087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbaa7791d02c34d71a751234a188087">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>*this(i,j)</code> = \(V(i) W(j)\) 其中 \(V,W\) 是相同长度的向量。 </p>

</div>
</div>
<a id="ac2388c76685e3fc4efdaab4cad185518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2388c76685e3fc4efdaab4cad185518">&#9670;&nbsp;</a></span>left_invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::left_invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定矩阵的左逆分配给<code>*this</code>。正在进行的计算是<em>(A<sup>T</sup>*A)<sup>-1</sup> A<sup>T</sup></em>。 </p>

</div>
</div>
<a id="a45a25dc4075f341f18e014037cd34f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a25dc4075f341f18e014037cd34f9b">&#9670;&nbsp;</a></span>right_invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::right_invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定矩阵的右逆分配给<code>*this</code>。正在执行的计算是<em>A<sup>T</sup>*(A*A<sup>T</sup>) <sup>-1</sup></em>。 </p>

</div>
</div>
<a id="a21b873fcd180999ad0d268c3278a71ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b873fcd180999ad0d268c3278a71ec">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-矩阵-乘法。 可选参数<code>adding</code>决定，结果是存储在<code>C</code>中，还是添加到<code>C</code>中。 if (adding) <em>C += A*B</em> if (!adding) <em>C = A*B</em> 假设<code>A</code>和<code>B</code>的大小兼容，并且<code>C</code>已经具有正确大小。 如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 </p>

</div>
</div>
<a id="a850654dea1494fffc80677d3f58142a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850654dea1494fffc80677d3f58142a0">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-矩阵-乘法，使用<code>this</code>的转置。 可选的参数<code>adding</code>决定了结果是存储在<code>C</code>中还是添加到<code>C</code>中。 if (adding) <em>C += A<sup>T</sup>*B</em> if (!adding) <em>C = A<sup>T</sup>*B</em> 假设<code>A</code>和<code>B</code>具有兼容的大小，并且<code>C</code>已经具有正确大小。 如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 </p>

</div>
</div>
<a id="ac074fc1dc416f8cd75bb01d820e74aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac074fc1dc416f8cd75bb01d820e74aa0">&#9670;&nbsp;</a></span>mTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用<code>B</code>的转置进行矩阵-矩阵乘法。 可选的参数<code>adding</code>决定了结果是存储在<code>C</code>中还是添加到<code>C</code>中。 if (adding) <em>C += A*B<sup>T</sup></em> if (!adding) <em>C = A*B<sup>T</sup></em> 假设<code>A</code>和<code>B</code>具有兼容的大小，并且<code>C</code>已经具有正确大小。 如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 </p>

</div>
</div>
<a id="a098a0fb764e74c7a4a524c9572e47b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098a0fb764e74c7a4a524c9572e47b18">&#9670;&nbsp;</a></span>TmTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::TmTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用<code>this</code>和<code>B</code>的转置进行矩阵-矩阵乘法。 可选的参数<code>adding</code>决定了结果是存储在<code>C</code>中还是添加到<code>C</code>中。 if (adding) <em>C += A<sup>T</sup>*B<sup>T</sup></em> if (!adding) <em>C = A<sup>T</sup>*B<sup>T</sup></em> 假设<code>A</code>和<code>B</code>具有兼容的大小，并且<code>C</code>已经具有正确大小。 如果三个矩阵维度的乘积大于300，并且在配置过程中检测到BLAS，则该函数使用BLAS函数Xgemm。使用BLAS通常会带来相当大的性能提升。 </p>

</div>
</div>
<a id="a087ad6f60a4a0c365aeaee4760ad5cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087ad6f60a4a0c365aeaee4760ad5cb9">&#9670;&nbsp;</a></span>triple_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::triple_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_B</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_D</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>number(1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>在当前矩阵中加入三乘积<b>B A D</b>。可以选择使用矩阵的转置<b>B</b>和<b>D</b>。缩放因子对整个乘积进行缩放，这在向矩阵添加三乘积的倍数时很有帮助。 这个乘积是在考虑到舒尔补码<b>B<sup>T</sup> A<sup>-1</sup> D</b>的情况下编写的。 请注意，在这种情况下，<code>A</code>的参数必须是矩阵<b>A</b>的逆值。 </p>

</div>
</div>
<a id="a65a409eeef6388d99ac15e2bbe8045f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a409eeef6388d99ac15e2bbe8045f6">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>矩阵-向量-乘法。 可选参数<code>adding</code>决定，结果是存储在<code>w</code>中，还是添加到<code>w</code>中。 if (adding) <em>w += A*v</em> if (!adding) <em>w = A*v</em> 源和目的必须不是同一个向量。 </p>

</div>
</div>
<a id="a8edeb234359c99ccbc3a21e4890f61d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edeb234359c99ccbc3a21e4890f61d7">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>加法 矩阵-向量-乘法。 <em>w += A*v</em> 源和目的必须不是同一个向量。 </p>

</div>
</div>
<a id="a8219d4fa962f1b041a506221a7a15379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8219d4fa962f1b041a506221a7a15379">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>转置矩阵-向量-乘法。 可选参数<code>adding</code>决定，结果是存储在<code>w</code>中，还是添加到<code>w</code>中。 if (adding) <em>w += A<sup>T</sup>*v</em> if (!adding) <em>w = A<sup>T</sup>*v</em> 源和目的必须不是同一个向量。 </p>

</div>
</div>
<a id="abed6fffa5cb201496d751a4427cb59d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed6fffa5cb201496d751a4427cb59d6">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>添加转置矩阵-向量-乘法。 <em>w += A<sup>T</sup>*v</em> 源和目的必须不是同一个向量。 </p>

</div>
</div>
<a id="a8ca64e608a864f4e6c80e6a05fbe2b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca64e608a864f4e6c80e6a05fbe2b31">&#9670;&nbsp;</a></span>precondition_Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>应用雅可比预处理程序，将<code>src</code>向量的每个元素乘以各自对角线元素的逆值，并将结果与阻尼系数<code>omega</code>相乘。 </p>

</div>
</div>
<a id="a0bf7a776bf5778590c6997eeb53d277f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf7a776bf5778590c6997eeb53d277f">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 , typename number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>dst=b-A*x</em>. 残差计算，返回<em>l<sub>2</sub></em>-norm|<em>dst</em>|。 源<em>x</em>和目的<em>dst</em>不能是同一个向量。 </p>

</div>
</div>
<a id="ad2241691e3b13448df6acbc37b39ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2241691e3b13448df6acbc37b39ab06">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>正向消除下三角。 对于一个给定的右手边，反转矩形矩阵的下三角。 如果矩阵的列数多于行数，该函数只对左边的二次元子矩阵进行操作。如果行数多，则考虑矩阵的上二次方部分。 </p><dl class="section note"><dt>Note</dt><dd>对 <code>dst</code> 和 <code>src</code>. 使用同一个对象是安全的。 </dd></dl>

</div>
</div>
<a id="ae9add855bcb711cd778e6a99026eff59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9add855bcb711cd778e6a99026eff59">&#9670;&nbsp;</a></span>backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>向后消除上三角。 参见forward() </p><dl class="section note"><dt>Note</dt><dd>对 <code>dst</code> 和 <code>src</code>. 使用同一对象是安全的。 </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="full__matrix_8h_source.html">full_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
