<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classFullMatrix.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: FullMatrix&lt; number &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classFullMatrix-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">FullMatrix&lt; number &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Matrices.html">Matrix classes</a> &raquo; <a class="el" href="group__Matrix1.html">Basic matrices</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="full__matrix_8h_source.html">deal.II/lac/full_matrix.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for FullMatrix&lt; number &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classFullMatrix__inherit__graph.svg" width="971" height="272"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4e8f9ce2c12a56e26b62133edfcc9cef"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> = std::size_t</td></tr>
<tr class="separator:a4e8f9ce2c12a56e26b62133edfcc9cef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5759353fd47e8aa3cb22b95979af27b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a5759353fd47e8aa3cb22b95979af27b9">value_type</a> = number</td></tr>
<tr class="separator:a5759353fd47e8aa3cb22b95979af27b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e14c99dc6090be77b76ac9cfc8b63e6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> = typename <a class="el" href="classTable.html">Table</a>&lt; 2, number &gt;::<a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a></td></tr>
<tr class="separator:a5e14c99dc6090be77b76ac9cfc8b63e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030be3ca41e86b9a4a7a8d0683a84962"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> = typename <a class="el" href="classTable.html">Table</a>&lt; 2, number &gt;::<a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a></td></tr>
<tr class="separator:a030be3ca41e86b9a4a7a8d0683a84962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01df0a76d1f2234cf3eb161a953d7ef2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a></td></tr>
<tr class="separator:a01df0a76d1f2234cf3eb161a953d7ef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ga53b1954eea1b26abc82ace9ce9e79ca3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga53b1954eea1b26abc82ace9ce9e79ca3">DeclException0</a> (ExcEmptyMatrix)</td></tr>
<tr class="separator:ga53b1954eea1b26abc82ace9ce9e79ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga21f6d0876e5913281afa87f02c9ef4f2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga21f6d0876e5913281afa87f02c9ef4f2">DeclException1</a> (ExcNotRegular, number,&lt;&lt; &quot;The maximal pivot is &quot;&lt;&lt; arg1&lt;&lt; &quot;, which is below the threshold. The matrix may be singular.&quot;)</td></tr>
<tr class="separator:ga21f6d0876e5913281afa87f02c9ef4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf1891a6c6aa6e1198780dd866b8914bb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf1891a6c6aa6e1198780dd866b8914bb">DeclException3</a> (ExcInvalidDestination, <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>, <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>, <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>,&lt;&lt; &quot;Target region not in matrix: size in this direction=&quot;&lt;&lt; arg1&lt;&lt; &quot;, size of new matrix=&quot;&lt;&lt; arg2&lt;&lt; &quot;, offset=&quot;&lt;&lt; arg3)</td></tr>
<tr class="separator:gaf1891a6c6aa6e1198780dd866b8914bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8caacfdd5f2f7e92f854160a38e9471"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab8caacfdd5f2f7e92f854160a38e9471">DeclExceptionMsg</a> (ExcSourceEqualsDestination, &quot;You are attempting an operation on two matrices that &quot; &quot;are the same object, but the operation requires that the &quot; &quot;two objects are in fact different.&quot;)</td></tr>
<tr class="separator:gab8caacfdd5f2f7e92f854160a38e9471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27a6ac856c40acd5bb1ed59f6b1b23b1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga27a6ac856c40acd5bb1ed59f6b1b23b1">DeclException0</a> (ExcMatrixNotPositiveDefinite)</td></tr>
<tr class="separator:ga27a6ac856c40acd5bb1ed59f6b1b23b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and initialization. See also the base class Table.</div></td></tr>
<tr class="memitem:adc08a0718c9110770badd10b5a38892f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#adc08a0718c9110770badd10b5a38892f">FullMatrix</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> <a class="el" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a>=0)</td></tr>
<tr class="separator:adc08a0718c9110770badd10b5a38892f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a45e5db015f8adc54f5f48f5376318d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a0a45e5db015f8adc54f5f48f5376318d">FullMatrix</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> rows, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> cols)</td></tr>
<tr class="separator:a0a45e5db015f8adc54f5f48f5376318d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc62a1da08095133fdd2515ca644c89"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7fc62a1da08095133fdd2515ca644c89">FullMatrix</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> rows, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> cols, const number *entries)</td></tr>
<tr class="separator:a7fc62a1da08095133fdd2515ca644c89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e195f7eda5b88bbc34dab0eeb17e3e8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8e195f7eda5b88bbc34dab0eeb17e3e8">FullMatrix</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a8e195f7eda5b88bbc34dab0eeb17e3e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Copying into and out of other matrices</div></td></tr>
<tr class="memitem:a5537bbde546b72ecd718155686ebd15b"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a5537bbde546b72ecd718155686ebd15b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a5537bbde546b72ecd718155686ebd15b">operator=</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;)</td></tr>
<tr class="separator:a5537bbde546b72ecd718155686ebd15b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa67dc887e44da6c7771eb0e92fc98323"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aa67dc887e44da6c7771eb0e92fc98323">operator=</a> (const number d)</td></tr>
<tr class="separator:aa67dc887e44da6c7771eb0e92fc98323"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8eea4b2a1fc643d6c8b0e70ebb0ac261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8eea4b2a1fc643d6c8b0e70ebb0ac261">operator=</a> (const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;id)</td></tr>
<tr class="separator:a8eea4b2a1fc643d6c8b0e70ebb0ac261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8124671c3e3e88e060b5ea32960f6a"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:adb8124671c3e3e88e060b5ea32960f6a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#adb8124671c3e3e88e060b5ea32960f6a">operator=</a> (const <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; number2 &gt; &amp;)</td></tr>
<tr class="separator:adb8124671c3e3e88e060b5ea32960f6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e8fbf00e15c7b66d527a5de4b31404"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:ae9e8fbf00e15c7b66d527a5de4b31404"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae9e8fbf00e15c7b66d527a5de4b31404">copy_from</a> (const MatrixType &amp;)</td></tr>
<tr class="separator:ae9e8fbf00e15c7b66d527a5de4b31404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb901c6e33e90c80a2ed3a9394865156"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType &gt; </td></tr>
<tr class="memitem:abb901c6e33e90c80a2ed3a9394865156"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abb901c6e33e90c80a2ed3a9394865156">copy_transposed</a> (const MatrixType &amp;)</td></tr>
<tr class="separator:abb901c6e33e90c80a2ed3a9394865156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3555b32b42cdcccfc72ac5ec32c5f83d"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a3555b32b42cdcccfc72ac5ec32c5f83d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a3555b32b42cdcccfc72ac5ec32c5f83d">copy_from</a> (const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;T, const unsigned <a class="el" href="classint.html">int</a> src_r_i=0, const unsigned <a class="el" href="classint.html">int</a> src_r_j=dim - 1, const unsigned <a class="el" href="classint.html">int</a> src_c_i=0, const unsigned <a class="el" href="classint.html">int</a> src_c_j=dim - 1, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_r=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_c=0)</td></tr>
<tr class="separator:a3555b32b42cdcccfc72ac5ec32c5f83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7437dbce381ba72d029c67a719826fcc"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7437dbce381ba72d029c67a719826fcc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7437dbce381ba72d029c67a719826fcc">copy_to</a> (<a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;T, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_r_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_r_j=dim - 1, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_c_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_c_j=dim - 1, const unsigned <a class="el" href="classint.html">int</a> dst_r=0, const unsigned <a class="el" href="classint.html">int</a> dst_c=0) const</td></tr>
<tr class="separator:a7437dbce381ba72d029c67a719826fcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae94bda7e32ea0082326e4fbf151fb868"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename index_type &gt; </td></tr>
<tr class="memitem:ae94bda7e32ea0082326e4fbf151fb868"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae94bda7e32ea0082326e4fbf151fb868">extract_submatrix_from</a> (const MatrixType &amp;matrix, const std::vector&lt; index_type &gt; &amp;row_index_set, const std::vector&lt; index_type &gt; &amp;column_index_set)</td></tr>
<tr class="separator:ae94bda7e32ea0082326e4fbf151fb868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f9b63ee8ecc6a5a2f072a469ac95a95"><td class="memTemplParams" colspan="2">template&lt;typename MatrixType , typename index_type &gt; </td></tr>
<tr class="memitem:a6f9b63ee8ecc6a5a2f072a469ac95a95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a6f9b63ee8ecc6a5a2f072a469ac95a95">scatter_matrix_to</a> (const std::vector&lt; index_type &gt; &amp;row_index_set, const std::vector&lt; index_type &gt; &amp;column_index_set, MatrixType &amp;matrix) const</td></tr>
<tr class="separator:a6f9b63ee8ecc6a5a2f072a469ac95a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bdf2b89ab7f7a0d5a7e988e43162361"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9bdf2b89ab7f7a0d5a7e988e43162361"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9bdf2b89ab7f7a0d5a7e988e43162361">fill</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_j=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_j=0)</td></tr>
<tr class="separator:a9bdf2b89ab7f7a0d5a7e988e43162361"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65c7f313a4ce3432ea12e0f93145f23"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ab65c7f313a4ce3432ea12e0f93145f23"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ab65c7f313a4ce3432ea12e0f93145f23">fill</a> (const number2 *)</td></tr>
<tr class="separator:ab65c7f313a4ce3432ea12e0f93145f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c1c072eb09809311fed47a03da2858"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a15c1c072eb09809311fed47a03da2858"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a15c1c072eb09809311fed47a03da2858">fill_permutation</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;p_rows, const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;p_cols)</td></tr>
<tr class="separator:a15c1c072eb09809311fed47a03da2858"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f43cd7abf5122bfc95c6442f08397a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4f43cd7abf5122bfc95c6442f08397a6">set</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j, const number value)</td></tr>
<tr class="separator:a4f43cd7abf5122bfc95c6442f08397a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Non-modifying operators</div></td></tr>
<tr class="memitem:a81478c422e681504c6f5fca0a3a49090"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a81478c422e681504c6f5fca0a3a49090">operator==</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;) const</td></tr>
<tr class="separator:a81478c422e681504c6f5fca0a3a49090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae353e09fdd66b9df250520434f9c9275"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae353e09fdd66b9df250520434f9c9275">m</a> () const</td></tr>
<tr class="separator:ae353e09fdd66b9df250520434f9c9275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f94aa6df67b8da6a1a31c052ff74bcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a> () const</td></tr>
<tr class="separator:a4f94aa6df67b8da6a1a31c052ff74bcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a677adb3e579c61c2710470d71aee0515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a677adb3e579c61c2710470d71aee0515">all_zero</a> () const</td></tr>
<tr class="separator:a677adb3e579c61c2710470d71aee0515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76715ebcd64c97475ae26b03ff35f3f4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a76715ebcd64c97475ae26b03ff35f3f4"><td class="memTemplItemLeft" align="right" valign="top">number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a76715ebcd64c97475ae26b03ff35f3f4">matrix_norm_square</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a76715ebcd64c97475ae26b03ff35f3f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86461e3010387d63b16952f51c7e3a85"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a86461e3010387d63b16952f51c7e3a85"><td class="memTemplItemLeft" align="right" valign="top">number2&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a86461e3010387d63b16952f51c7e3a85">matrix_scalar_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;u, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a86461e3010387d63b16952f51c7e3a85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502a2f65ebaba3c24cd4201fee0beee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#af502a2f65ebaba3c24cd4201fee0beee">l1_norm</a> () const</td></tr>
<tr class="separator:af502a2f65ebaba3c24cd4201fee0beee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af97598e75580f535f7b0418eb32de722"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#af97598e75580f535f7b0418eb32de722">linfty_norm</a> () const</td></tr>
<tr class="separator:af97598e75580f535f7b0418eb32de722"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace5a8a1ea24b18624dc2ddcb6b88d03b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ace5a8a1ea24b18624dc2ddcb6b88d03b">frobenius_norm</a> () const</td></tr>
<tr class="separator:ace5a8a1ea24b18624dc2ddcb6b88d03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f90f68aa267b0a8c67ab8a7c34acd41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a2f90f68aa267b0a8c67ab8a7c34acd41">relative_symmetry_norm2</a> () const</td></tr>
<tr class="separator:a2f90f68aa267b0a8c67ab8a7c34acd41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa75b187e4b8b3e2758118f3c2794c14b"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aa75b187e4b8b3e2758118f3c2794c14b">determinant</a> () const</td></tr>
<tr class="separator:aa75b187e4b8b3e2758118f3c2794c14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455d78d2cf76d82a52e2d761bb2e5c69"><td class="memItemLeft" align="right" valign="top">number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a455d78d2cf76d82a52e2d761bb2e5c69">trace</a> () const</td></tr>
<tr class="separator:a455d78d2cf76d82a52e2d761bb2e5c69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc67a688b9a282a8403acedf1e5304d6"><td class="memTemplParams" colspan="2">template&lt;class StreamType &gt; </td></tr>
<tr class="memitem:abc67a688b9a282a8403acedf1e5304d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abc67a688b9a282a8403acedf1e5304d6">print</a> (StreamType &amp;s, const unsigned <a class="el" href="classint.html">int</a> width=5, const unsigned <a class="el" href="classint.html">int</a> precision=2) const</td></tr>
<tr class="separator:abc67a688b9a282a8403acedf1e5304d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdd86a102fefa37a3916a612d8e329bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abdd86a102fefa37a3916a612d8e329bd">print_formatted</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const unsigned <a class="el" href="classint.html">int</a> width=0, const char *zero_string=&quot; &quot;, const <a class="el" href="classdouble.html">double</a> denominator=1., const <a class="el" href="classdouble.html">double</a> threshold=0.) const</td></tr>
<tr class="separator:abdd86a102fefa37a3916a612d8e329bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d7fe46def6d7eada6e4bae55e2778ef"><td class="memItemLeft" align="right" valign="top">std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a0d7fe46def6d7eada6e4bae55e2778ef">memory_consumption</a> () const</td></tr>
<tr class="separator:a0d7fe46def6d7eada6e4bae55e2778ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Iterator functions</div></td></tr>
<tr class="memitem:ac621d0e04198f9b07fe31a459034278c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ac621d0e04198f9b07fe31a459034278c">begin</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r)</td></tr>
<tr class="separator:ac621d0e04198f9b07fe31a459034278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3e01acdaea19d0cd0c00e7bdcbe14c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#acb3e01acdaea19d0cd0c00e7bdcbe14c">end</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r)</td></tr>
<tr class="separator:acb3e01acdaea19d0cd0c00e7bdcbe14c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeee5943508259f916ea5387ce22a80b1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aeee5943508259f916ea5387ce22a80b1">begin</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r) const</td></tr>
<tr class="separator:aeee5943508259f916ea5387ce22a80b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f65316c85da072ceba7ca8e99625fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7f65316c85da072ceba7ca8e99625fa1">end</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> r) const</td></tr>
<tr class="separator:a7f65316c85da072ceba7ca8e99625fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Modifying operators</div></td></tr>
<tr class="memitem:a9fa9af1ab8afd166bb3e5382d188727d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9fa9af1ab8afd166bb3e5382d188727d">operator*=</a> (const number factor)</td></tr>
<tr class="separator:a9fa9af1ab8afd166bb3e5382d188727d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63e08c4944365290db46508cedf01989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classFullMatrix.html">FullMatrix</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a63e08c4944365290db46508cedf01989">operator/=</a> (const number factor)</td></tr>
<tr class="separator:a63e08c4944365290db46508cedf01989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f2ea8b35b3d4a53deeabdd6edccea3a"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9f2ea8b35b3d4a53deeabdd6edccea3a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9f2ea8b35b3d4a53deeabdd6edccea3a">add</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A)</td></tr>
<tr class="separator:a9f2ea8b35b3d4a53deeabdd6edccea3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd7147f8e1ce0ec51d042f6d2ffe036a"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:acd7147f8e1ce0ec51d042f6d2ffe036a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#acd7147f8e1ce0ec51d042f6d2ffe036a">add</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B)</td></tr>
<tr class="separator:acd7147f8e1ce0ec51d042f6d2ffe036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617058ea25768fbd562220462dff409e"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a617058ea25768fbd562220462dff409e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a617058ea25768fbd562220462dff409e">add</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const number c, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C)</td></tr>
<tr class="separator:a617058ea25768fbd562220462dff409e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211b9a2c46404cdcf84abdbaba70032"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a7211b9a2c46404cdcf84abdbaba70032"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7211b9a2c46404cdcf84abdbaba70032">add</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const number factor, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_j=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_j=0)</td></tr>
<tr class="separator:a7211b9a2c46404cdcf84abdbaba70032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6556863808164142f559bcce1d92a09e"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a6556863808164142f559bcce1d92a09e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a6556863808164142f559bcce1d92a09e">Tadd</a> (const number s, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B)</td></tr>
<tr class="separator:a6556863808164142f559bcce1d92a09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad79daca87844eec1680018f196a3df0c"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ad79daca87844eec1680018f196a3df0c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ad79daca87844eec1680018f196a3df0c">Tadd</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;src, const number factor, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> dst_offset_j=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_i=0, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> src_offset_j=0)</td></tr>
<tr class="separator:ad79daca87844eec1680018f196a3df0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a913e14db890a6992849b1c238644e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a31a913e14db890a6992849b1c238644e">add</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> row, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> column, const number value)</td></tr>
<tr class="separator:a31a913e14db890a6992849b1c238644e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b5cbf09cba49593f2c86d7f06b5eadb"><td class="memTemplParams" colspan="2">template&lt;typename number2 , typename index_type &gt; </td></tr>
<tr class="memitem:a8b5cbf09cba49593f2c86d7f06b5eadb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8b5cbf09cba49593f2c86d7f06b5eadb">add</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> row, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> n_cols, const index_type *col_indices, const number2 *values, const <a class="el" href="classbool.html">bool</a> elide_zero_values=true, const <a class="el" href="classbool.html">bool</a> col_indices_are_sorted=false)</td></tr>
<tr class="separator:a8b5cbf09cba49593f2c86d7f06b5eadb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b59247b8ddc428a47342525152691b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a1b59247b8ddc428a47342525152691b2">add_row</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:a1b59247b8ddc428a47342525152691b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52eccc2e4b7b2113f568f31046a8b239"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a52eccc2e4b7b2113f568f31046a8b239">add_row</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j, const number t, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> k)</td></tr>
<tr class="separator:a52eccc2e4b7b2113f568f31046a8b239"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bb599d984e3375067f615aefd5c9393"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8bb599d984e3375067f615aefd5c9393">add_col</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:a8bb599d984e3375067f615aefd5c9393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b837f07f41a19e0d57377e31ec61569"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a6b837f07f41a19e0d57377e31ec61569">add_col</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const number s, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j, const number t, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> k)</td></tr>
<tr class="separator:a6b837f07f41a19e0d57377e31ec61569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7118bb0c55702e741002db02ac6f0e04"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7118bb0c55702e741002db02ac6f0e04">swap_row</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:a7118bb0c55702e741002db02ac6f0e04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4046dea183a3d5ef191cbe18e674881"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae4046dea183a3d5ef191cbe18e674881">swap_col</a> (const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> i, const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> j)</td></tr>
<tr class="separator:ae4046dea183a3d5ef191cbe18e674881"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12566fc371d78838435583c4f59e942d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a12566fc371d78838435583c4f59e942d">diagadd</a> (const number s)</td></tr>
<tr class="separator:a12566fc371d78838435583c4f59e942d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7880cb55e5cecc96a033f390d5d00210"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a7880cb55e5cecc96a033f390d5d00210"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a7880cb55e5cecc96a033f390d5d00210">equ</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A)</td></tr>
<tr class="separator:a7880cb55e5cecc96a033f390d5d00210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4180de5a8d453af9bb5e3b328078e19f"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a4180de5a8d453af9bb5e3b328078e19f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a4180de5a8d453af9bb5e3b328078e19f">equ</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B)</td></tr>
<tr class="separator:a4180de5a8d453af9bb5e3b328078e19f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae444a21f6b0cc9da4edd5a127a79e61"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:aae444a21f6b0cc9da4edd5a127a79e61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#aae444a21f6b0cc9da4edd5a127a79e61">equ</a> (const number a, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A, const number b, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const number c, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C)</td></tr>
<tr class="separator:aae444a21f6b0cc9da4edd5a127a79e61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3790a7f3ad399a0f093a3d94f03d6846"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a3790a7f3ad399a0f093a3d94f03d6846">symmetrize</a> ()</td></tr>
<tr class="separator:a3790a7f3ad399a0f093a3d94f03d6846"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a898466c57e11e6f2599165071ffe5df3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a898466c57e11e6f2599165071ffe5df3">gauss_jordan</a> ()</td></tr>
<tr class="separator:a898466c57e11e6f2599165071ffe5df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a940ea10266174ad366d10bd806177ace"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a940ea10266174ad366d10bd806177ace"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a940ea10266174ad366d10bd806177ace">invert</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;M)</td></tr>
<tr class="separator:a940ea10266174ad366d10bd806177ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b6cd3d2dee462237eed86073be061a4"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a9b6cd3d2dee462237eed86073be061a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a9b6cd3d2dee462237eed86073be061a4">cholesky</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;A)</td></tr>
<tr class="separator:a9b6cd3d2dee462237eed86073be061a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdbaa7791d02c34d71a751234a188087"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:acdbaa7791d02c34d71a751234a188087"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#acdbaa7791d02c34d71a751234a188087">outer_product</a> (const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;V, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;W)</td></tr>
<tr class="separator:acdbaa7791d02c34d71a751234a188087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2388c76685e3fc4efdaab4cad185518"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac2388c76685e3fc4efdaab4cad185518"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ac2388c76685e3fc4efdaab4cad185518">left_invert</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;M)</td></tr>
<tr class="separator:ac2388c76685e3fc4efdaab4cad185518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45a25dc4075f341f18e014037cd34f9b"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a45a25dc4075f341f18e014037cd34f9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a45a25dc4075f341f18e014037cd34f9b">right_invert</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;M)</td></tr>
<tr class="separator:a45a25dc4075f341f18e014037cd34f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Multiplications</div></td></tr>
<tr class="memitem:a21b873fcd180999ad0d268c3278a71ec"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a21b873fcd180999ad0d268c3278a71ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a21b873fcd180999ad0d268c3278a71ec">mmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a21b873fcd180999ad0d268c3278a71ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a850654dea1494fffc80677d3f58142a0"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a850654dea1494fffc80677d3f58142a0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a850654dea1494fffc80677d3f58142a0">Tmmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a850654dea1494fffc80677d3f58142a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac074fc1dc416f8cd75bb01d820e74aa0"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ac074fc1dc416f8cd75bb01d820e74aa0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ac074fc1dc416f8cd75bb01d820e74aa0">mTmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:ac074fc1dc416f8cd75bb01d820e74aa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098a0fb764e74c7a4a524c9572e47b18"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a098a0fb764e74c7a4a524c9572e47b18"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a098a0fb764e74c7a4a524c9572e47b18">TmTmult</a> (<a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;C, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;B, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a098a0fb764e74c7a4a524c9572e47b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a087ad6f60a4a0c365aeaee4760ad5cb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a087ad6f60a4a0c365aeaee4760ad5cb9">triple_product</a> (const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;A, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;B, const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;D, const <a class="el" href="classbool.html">bool</a> transpose_B=false, const <a class="el" href="classbool.html">bool</a> transpose_D=false, const number scaling=number(1.))</td></tr>
<tr class="separator:a087ad6f60a4a0c365aeaee4760ad5cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65a409eeef6388d99ac15e2bbe8045f6"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a65a409eeef6388d99ac15e2bbe8045f6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a65a409eeef6388d99ac15e2bbe8045f6">vmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a65a409eeef6388d99ac15e2bbe8045f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8edeb234359c99ccbc3a21e4890f61d7"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a8edeb234359c99ccbc3a21e4890f61d7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8edeb234359c99ccbc3a21e4890f61d7">vmult_add</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:a8edeb234359c99ccbc3a21e4890f61d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219d4fa962f1b041a506221a7a15379"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:a8219d4fa962f1b041a506221a7a15379"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8219d4fa962f1b041a506221a7a15379">Tvmult</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v, const <a class="el" href="classbool.html">bool</a> adding=false) const</td></tr>
<tr class="separator:a8219d4fa962f1b041a506221a7a15379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abed6fffa5cb201496d751a4427cb59d6"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:abed6fffa5cb201496d751a4427cb59d6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#abed6fffa5cb201496d751a4427cb59d6">Tvmult_add</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;w, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;v) const</td></tr>
<tr class="separator:abed6fffa5cb201496d751a4427cb59d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ca64e608a864f4e6c80e6a05fbe2b31"><td class="memTemplParams" colspan="2">template&lt;typename somenumber &gt; </td></tr>
<tr class="memitem:a8ca64e608a864f4e6c80e6a05fbe2b31"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a8ca64e608a864f4e6c80e6a05fbe2b31">precondition_Jacobi</a> (<a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;src, const number omega=1.) const</td></tr>
<tr class="separator:a8ca64e608a864f4e6c80e6a05fbe2b31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bf7a776bf5778590c6997eeb53d277f"><td class="memTemplParams" colspan="2">template&lt;typename number2 , typename number3 &gt; </td></tr>
<tr class="memitem:a0bf7a776bf5778590c6997eeb53d277f"><td class="memTemplItemLeft" align="right" valign="top">number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#a0bf7a776bf5778590c6997eeb53d277f">residual</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;x, const <a class="el" href="classVector.html">Vector</a>&lt; number3 &gt; &amp;b) const</td></tr>
<tr class="separator:a0bf7a776bf5778590c6997eeb53d277f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2241691e3b13448df6acbc37b39ab06"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ad2241691e3b13448df6acbc37b39ab06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ad2241691e3b13448df6acbc37b39ab06">forward</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:ad2241691e3b13448df6acbc37b39ab06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9add855bcb711cd778e6a99026eff59"><td class="memTemplParams" colspan="2">template&lt;typename number2 &gt; </td></tr>
<tr class="memitem:ae9add855bcb711cd778e6a99026eff59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classFullMatrix.html#ae9add855bcb711cd778e6a99026eff59">backward</a> (<a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;dst, const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;src) const</td></tr>
<tr class="separator:ae9add855bcb711cd778e6a99026eff59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename number&gt;<br />
class FullMatrix&lt; number &gt;</h3>

<p>Implementation of a classical rectangular scheme of numbers. The data type of the entries is provided in the template argument <code>number</code>. The interface is quite fat and in fact has grown every time a new feature was needed. So, a lot of functions are provided.</p>
<p>Internal calculations are usually done with the accuracy of the vector argument to functions. If there is no argument with a number type, the matrix number type is used.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt;, &lt;double&gt;, &lt;std::complex&lt;float&gt;&gt;, &lt;std::complex&lt;double&gt;&gt;</code>. Others can be generated in application programs, see <a class="el" href="Instantiations.html">Template instantiations</a> for details. </dd></dl>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00069">69</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a4e8f9ce2c12a56e26b62133edfcc9cef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e8f9ce2c12a56e26b62133edfcc9cef">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> =  std::size_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A type of used to index into this container. </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00081">81</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a5759353fd47e8aa3cb22b95979af27b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5759353fd47e8aa3cb22b95979af27b9">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a5759353fd47e8aa3cb22b95979af27b9">value_type</a> =  number</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type of matrix entries. This alias is analogous to <code>value_type</code> in the standard library containers. </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00087">87</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a5e14c99dc6090be77b76ac9cfc8b63e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e14c99dc6090be77b76ac9cfc8b63e6">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> =  typename <a class="el" href="classTable.html">Table</a>&lt;2, number&gt;::<a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the base class mutable iterator type. </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00092">92</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a030be3ca41e86b9a4a7a8d0683a84962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030be3ca41e86b9a4a7a8d0683a84962">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> =  typename <a class="el" href="classTable.html">Table</a>&lt;2, number&gt;::<a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the base class constant iterator type. </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00097">97</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<a id="a01df0a76d1f2234cf3eb161a953d7ef2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01df0a76d1f2234cf3eb161a953d7ef2">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;number&gt;::<a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare a type that has holds real-valued numbers with the same precision as the template argument to this class. If the template argument of this class is a real data type, then real_type equals the template argument. If the template argument is a std::complex type then real_type equals the type underlying the complex numbers.</p>
<p>This alias is used to represent the return type of norms. </p>

<p class="definition">Definition at line <a class="el" href="full__matrix_8h_source.html#l00118">118</a> of file <a class="el" href="full__matrix_8h_source.html">full_matrix.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="adc08a0718c9110770badd10b5a38892f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc08a0718c9110770badd10b5a38892f">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>n</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructor. Initialize the matrix as a square matrix with dimension <code>n</code>.</p>
<p>In order to avoid the implicit conversion of integers and other types to a matrix, this constructor is declared <code>explicit</code>.</p>
<p>By default, no memory is allocated. </p>

</div>
</div>
<a id="a0a45e5db015f8adc54f5f48f5376318d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a45e5db015f8adc54f5f48f5376318d">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. Initialize the matrix as a rectangular matrix. </p>

</div>
</div>
<a id="a7fc62a1da08095133fdd2515ca644c89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc62a1da08095133fdd2515ca644c89">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number *&#160;</td>
          <td class="paramname"><em>entries</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor initializing from an array of numbers. The array is arranged line by line. No range checking is performed. </p>

</div>
</div>
<a id="a8e195f7eda5b88bbc34dab0eeb17e3e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e195f7eda5b88bbc34dab0eeb17e3e8">&#9670;&nbsp;</a></span>FullMatrix() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::<a class="el" href="classFullMatrix.html">FullMatrix</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a full matrix that equals the identity matrix of the size of the argument. Using this constructor, one can easily create an identity matrix of size <code>n</code> by saying </p><div class="fragment"><div class="line"><a class="code" href="classFullMatrix.html">FullMatrix&lt;double&gt;</a> M(<a class="code" href="classIdentityMatrix.html">IdentityMatrix</a>(<a class="code" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a>));</div></div><!-- fragment --> 
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5537bbde546b72ecd718155686ebd15b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5537bbde546b72ecd718155686ebd15b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Variable assignment operator. </p>

</div>
</div>
<a id="aa67dc887e44da6c7771eb0e92fc98323"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa67dc887e44da6c7771eb0e92fc98323">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>d</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This operator assigns a scalar to a matrix. To avoid confusion with the semantics of this function, zero is the only value allowed for <code>d</code>, allowing you to clear a matrix in an intuitive way.</p>
<dl class="section note"><dt>Note</dt><dd>If deal.II is configured with threads, this operation will run multi-threaded by splitting the work into smaller chunks (assuming there is enough work to make this worthwhile). </dd></dl>

</div>
</div>
<a id="a8eea4b2a1fc643d6c8b0e70ebb0ac261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8eea4b2a1fc643d6c8b0e70ebb0ac261">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIdentityMatrix.html">IdentityMatrix</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy operator to create a full matrix that equals the identity matrix of the size of the argument. This way, one can easily create an identity matrix of size <code>n</code> by saying </p><div class="fragment"><div class="line">M = <a class="code" href="classIdentityMatrix.html">IdentityMatrix</a>(<a class="code" href="classFullMatrix.html#a4f94aa6df67b8da6a1a31c052ff74bcd">n</a>);</div></div><!-- fragment --> 
</div>
</div>
<a id="adb8124671c3e3e88e060b5ea32960f6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8124671c3e3e88e060b5ea32960f6a">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt;number&gt;&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLAPACKFullMatrix.html">LAPACKFullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment operator for a LapackFullMatrix. The calling matrix must be of the same size as the LAPACK matrix. </p>

</div>
</div>
<a id="ae9e8fbf00e15c7b66d527a5de4b31404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e8fbf00e15c7b66d527a5de4b31404">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment from different matrix classes. This assignment operator uses iterators of the typename MatrixType. Therefore, sparse matrices are possible sources. </p>

</div>
</div>
<a id="abb901c6e33e90c80a2ed3a9394865156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb901c6e33e90c80a2ed3a9394865156">&#9670;&nbsp;</a></span>copy_transposed()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_transposed </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transposing assignment from different matrix classes. This assignment operator uses iterators of the typename MatrixType. Therefore, sparse matrices are possible sources. </p>

</div>
</div>
<a id="a3555b32b42cdcccfc72ac5ec32c5f83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3555b32b42cdcccfc72ac5ec32c5f83d">&#9670;&nbsp;</a></span>copy_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_r_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_r_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_c_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>src_c_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_r</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_c</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill matrix with elements extracted from a tensor, taking rows included between <code>r_i</code> and <code>r_j</code> and columns between <code>c_i</code> and <code>c_j</code>. The resulting matrix is then inserted in the destination matrix at position <code>(dst_r, dst_c)</code> Checks on the indices are made. </p>

</div>
</div>
<a id="a7437dbce381ba72d029c67a719826fcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7437dbce381ba72d029c67a719826fcc">&#9670;&nbsp;</a></span>copy_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::copy_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classTensor.html">Tensor</a>&lt; 2, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>T</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_r_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_r_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_c_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_c_j</em> = <code>dim&#160;-&#160;1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dst_r</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>dst_c</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a submatrix (also rectangular) into a tensor, putting its upper left element at the specified position <code>(dst_r, dst_c)</code> and the other elements consequently. Default values are chosen so that no parameter needs to be specified if the size of the tensor and that of the matrix coincide. </p>

</div>
</div>
<a id="ae94bda7e32ea0082326e4fbf151fb868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae94bda7e32ea0082326e4fbf151fb868">&#9670;&nbsp;</a></span>extract_submatrix_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::extract_submatrix_from </td>
          <td>(</td>
          <td class="paramtype">const MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_index_set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy a subset of the rows and columns of another matrix into the current object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">matrix</td><td>The matrix from which a subset is to be taken from. </td></tr>
    <tr><td class="paramname">row_index_set</td><td>The set of rows of <code>matrix</code> from which to extract. </td></tr>
    <tr><td class="paramname">column_index_set</td><td>The set of columns of <code>matrix</code> from which to extract. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The number of elements in <code>row_index_set</code> and <code>column_index_set</code> shall be equal to the number of rows and columns in the current object. In other words, the current object is not resized for this operation. </dd></dl>

</div>
</div>
<a id="a6f9b63ee8ecc6a5a2f072a469ac95a95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f9b63ee8ecc6a5a2f072a469ac95a95">&#9670;&nbsp;</a></span>scatter_matrix_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename MatrixType , typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::scatter_matrix_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>row_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; index_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>column_index_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">MatrixType &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy the elements of the current matrix object into a specified set of rows and columns of another matrix. Thus, this is a scatter operation.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">row_index_set</td><td>The rows of <code>matrix</code> into which to write. </td></tr>
    <tr><td class="paramname">column_index_set</td><td>The columns of <code>matrix</code> into which to write. </td></tr>
    <tr><td class="paramname">matrix</td><td>The matrix within which certain elements are to be replaced. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section pre"><dt>Precondition</dt><dd>The number of elements in <code>row_index_set</code> and <code>column_index_set</code> shall be equal to the number of rows and columns in the current object. In other words, the current object is not resized for this operation. </dd></dl>

</div>
</div>
<a id="a9bdf2b89ab7f7a0d5a7e988e43162361"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bdf2b89ab7f7a0d5a7e988e43162361">&#9670;&nbsp;</a></span>fill() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_j</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill rectangular block.</p>
<p>A rectangular block of the matrix <code>src</code> is copied into <code>this</code>. The upper left corner of the block being copied is <code>(src_offset_i,src_offset_j)</code>. The upper left corner of the copied block is <code>(dst_offset_i,dst_offset_j)</code>. The size of the rectangular block being copied is the maximum size possible, determined either by the size of <code>this</code> or <code>src</code>. </p>

</div>
</div>
<a id="ab65c7f313a4ce3432ea12e0f93145f23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65c7f313a4ce3432ea12e0f93145f23">&#9670;&nbsp;</a></span>fill() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::fill </td>
          <td>(</td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make function of base class available. </p>

</div>
</div>
<a id="a15c1c072eb09809311fed47a03da2858"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c1c072eb09809311fed47a03da2858">&#9670;&nbsp;</a></span>fill_permutation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::fill_permutation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>p_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill with permutation of another matrix.</p>
<p>The matrix <code>src</code> is copied into the target. The two permutation <code>p_r</code> and <code>p_c</code> operate in a way, such that <code>result(i,j) = src(p_r[i], p_c[j])</code>.</p>
<p>The vectors may also be a selection from a larger set of integers, if the matrix <code>src</code> is bigger. It is also possible to duplicate rows or columns by this method. </p>

</div>
</div>
<a id="a4f43cd7abf5122bfc95c6442f08397a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f43cd7abf5122bfc95c6442f08397a6">&#9670;&nbsp;</a></span>set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::set </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set a particular entry of the matrix to a value. Thus, calling <code>A.set(1,2,3.141);</code> is entirely equivalent to the operation <code>A(1,2) = 3.141;</code>. This function exists for compatibility with the various sparse matrix objects.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The row index of the element to be set. </td></tr>
    <tr><td class="paramname">j</td><td>The columns index of the element to be set. </td></tr>
    <tr><td class="paramname">value</td><td>The value to be written into the element. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a81478c422e681504c6f5fca0a3a49090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81478c422e681504c6f5fca0a3a49090">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Comparison operator. Be careful with this thing, it may eat up huge amounts of computing time! It is most commonly used for internal consistency checks of programs. </p>

</div>
</div>
<a id="ae353e09fdd66b9df250520434f9c9275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae353e09fdd66b9df250520434f9c9275">&#9670;&nbsp;</a></span>m()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::m </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of rows of this matrix. Note that the matrix is of dimension <em>m x n</em>. </p>

</div>
</div>
<a id="a4f94aa6df67b8da6a1a31c052ff74bcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f94aa6df67b8da6a1a31c052ff74bcd">&#9670;&nbsp;</a></span>n()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::n </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Number of columns of this matrix. Note that the matrix is of dimension <em>m x n</em>. </p>

</div>
</div>
<a id="a677adb3e579c61c2710470d71aee0515"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a677adb3e579c61c2710470d71aee0515">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the matrix contains only elements with value zero. This function is mainly for internal consistency checks and should seldom be used when not in debug mode since it uses quite some time. </p>

</div>
</div>
<a id="a76715ebcd64c97475ae26b03ff35f3f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76715ebcd64c97475ae26b03ff35f3f4">&#9670;&nbsp;</a></span>matrix_norm_square()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number2 <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::matrix_norm_square </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the norm of the vector <code>v</code> induced by this matrix, i.e. <em>(v,Mv)</em>. This is useful, e.g. in the finite element context, where the <em>L<sup>2</sup></em> norm of a function equals the matrix norm with respect to the mass matrix of the vector representing the nodal values of the finite element function.</p>
<p>Obviously, the matrix needs to be quadratic for this operation, and for the result to actually be a norm it also needs to be either real symmetric or complex hermitian.</p>
<p>The underlying template types of both this matrix and the given vector should either both be real or complex-valued, but not mixed, for this function to make sense. </p>

</div>
</div>
<a id="a86461e3010387d63b16952f51c7e3a85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86461e3010387d63b16952f51c7e3a85">&#9670;&nbsp;</a></span>matrix_scalar_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number2 <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::matrix_scalar_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Build the matrix scalar product <code>u<sup>T</sup> M v</code>. This function is mostly useful when building the cellwise scalar product of two functions in the finite element context.</p>
<p>The underlying template types of both this matrix and the given vector should either both be real or complex-valued, but not mixed, for this function to make sense. </p>

</div>
</div>
<a id="af502a2f65ebaba3c24cd4201fee0beee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502a2f65ebaba3c24cd4201fee0beee">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the <em>l<sub>1</sub></em>-norm of the matrix, where \(||M||_1 = \max_j \sum_i |M_{ij}|\) (maximum of the sums over columns). </p>

</div>
</div>
<a id="af97598e75580f535f7b0418eb32de722"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af97598e75580f535f7b0418eb32de722">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the \(l_\infty\)-norm of the matrix, where \(||M||_\infty = \max_i \sum_j |M_{ij}|\) (maximum of the sums over rows). </p>

</div>
</div>
<a id="ace5a8a1ea24b18624dc2ddcb6b88d03b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace5a8a1ea24b18624dc2ddcb6b88d03b">&#9670;&nbsp;</a></span>frobenius_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::frobenius_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the Frobenius norm of the matrix. Return value is the root of the square sum of all matrix entries.</p>
<dl class="section note"><dt>Note</dt><dd>For the timid among us: this norm is not the norm compatible with the <em>l<sub>2</sub></em>-norm of the vector space. </dd></dl>

</div>
</div>
<a id="a2f90f68aa267b0a8c67ab8a7c34acd41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f90f68aa267b0a8c67ab8a7c34acd41">&#9670;&nbsp;</a></span>relative_symmetry_norm2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a01df0a76d1f2234cf3eb161a953d7ef2">real_type</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::relative_symmetry_norm2 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the relative norm of the skew-symmetric part. The return value is the Frobenius norm of the skew-symmetric part of the matrix divided by that of the matrix.</p>
<p>Main purpose of this function is to check, if a matrix is symmetric within a certain accuracy, or not. </p>

</div>
</div>
<a id="aa75b187e4b8b3e2758118f3c2794c14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa75b187e4b8b3e2758118f3c2794c14b">&#9670;&nbsp;</a></span>determinant()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::determinant </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the determinant of a matrix. This is only implemented for one, two, and three dimensions, since for higher dimensions the numerical work explodes. Obviously, the matrix needs to be quadratic for this function. </p>

</div>
</div>
<a id="a455d78d2cf76d82a52e2d761bb2e5c69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455d78d2cf76d82a52e2d761bb2e5c69">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::trace </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the trace of the matrix, i.e. the sum of the diagonal values (which happens to also equal the sum of the eigenvalues of a matrix). Obviously, the matrix needs to be quadratic for this function. </p>

</div>
</div>
<a id="abc67a688b9a282a8403acedf1e5304d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc67a688b9a282a8403acedf1e5304d6">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;class StreamType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::print </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>2</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Output of the matrix in user-defined format given by the specified precision and width. This function saves width and precision of the stream before setting these given values for output, and restores the previous values after output. </p>

</div>
</div>
<a id="abdd86a102fefa37a3916a612d8e329bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdd86a102fefa37a3916a612d8e329bd">&#9670;&nbsp;</a></span>print_formatted()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::print_formatted </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>width</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>zero_string</em> = <code>&quot;&#160;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>denominator</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>threshold</em> = <code>0.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the matrix and allow formatting of entries.</p>
<p>The parameters allow for a flexible setting of the output format:</p>
<ul>
<li><code>precision</code> denotes the number of trailing digits.</li>
</ul>
<ul>
<li><code>scientific</code> is used to determine the number format, where <code>scientific</code> = <code>false</code> means fixed point notation.</li>
</ul>
<ul>
<li><code>width</code> denotes the with of each column. A zero entry for <code>width</code> makes the function compute a width, but it may be changed to a positive value, if output is crude.</li>
</ul>
<ul>
<li><code>zero_string</code> specifies a string printed for zero entries.</li>
</ul>
<ul>
<li><code>denominator</code> Multiply the whole matrix by this common denominator to get nicer numbers.</li>
</ul>
<ul>
<li><code>threshold</code>: all entries with absolute value smaller than this are considered zero. </li>
</ul>

</div>
</div>
<a id="a0d7fe46def6d7eada6e4bae55e2778ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d7fe46def6d7eada6e4bae55e2778ef">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::size_t <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine an estimate for the memory consumption (in bytes) of this object. </p>

</div>
</div>
<a id="ac621d0e04198f9b07fe31a459034278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac621d0e04198f9b07fe31a459034278c">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mutable iterator starting at the first entry of row <code>r</code>. </p>

</div>
</div>
<a id="acb3e01acdaea19d0cd0c00e7bdcbe14c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3e01acdaea19d0cd0c00e7bdcbe14c">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a5e14c99dc6090be77b76ac9cfc8b63e6">iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One past the end mutable iterator of row <code>r</code>. </p>

</div>
</div>
<a id="aeee5943508259f916ea5387ce22a80b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeee5943508259f916ea5387ce22a80b1">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constant iterator starting at the first entry of row <code>r</code>. </p>

</div>
</div>
<a id="a7f65316c85da072ceba7ca8e99625fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f65316c85da072ceba7ca8e99625fa1">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html#a030be3ca41e86b9a4a7a8d0683a84962">const_iterator</a> <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>One past the end constant iterator of row <code>r</code>. </p>

</div>
</div>
<a id="a9fa9af1ab8afd166bb3e5382d188727d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa9af1ab8afd166bb3e5382d188727d">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the entire matrix by a fixed factor. </p>

</div>
</div>
<a id="a63e08c4944365290db46508cedf01989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63e08c4944365290db46508cedf01989">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classFullMatrix.html">FullMatrix</a>&amp; <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale the entire matrix by the inverse of the given factor. </p>

</div>
</div>
<a id="a9f2ea8b35b3d4a53deeabdd6edccea3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f2ea8b35b3d4a53deeabdd6edccea3a">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simple addition of a scaled matrix, i.e. <code>*this += a*A</code>.</p>
<p>The matrix <code>A</code> may be a full matrix over an arbitrary underlying scalar type, as long as its data type is convertible to the data type of this matrix. </p>

</div>
</div>
<a id="acd7147f8e1ce0ec51d042f6d2ffe036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd7147f8e1ce0ec51d042f6d2ffe036a">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled matrices, i.e. <code>*this += a*A + b*B</code>.</p>
<p>The matrices <code>A</code> and <code>B</code> may be a full matrix over an arbitrary underlying scalar type, as long as its data type is convertible to the data type of this matrix. </p>

</div>
</div>
<a id="a617058ea25768fbd562220462dff409e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617058ea25768fbd562220462dff409e">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Multiple addition of scaled matrices, i.e. <code>*this += a*A + b*B + c*C</code>.</p>
<p>The matrices <code>A</code>, <code>B</code> and <code>C</code> may be a full matrix over an arbitrary underlying scalar type, as long as its data type is convertible to the data type of this matrix. </p>

</div>
</div>
<a id="a7211b9a2c46404cdcf84abdbaba70032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7211b9a2c46404cdcf84abdbaba70032">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_j</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add rectangular block.</p>
<p>A rectangular block of the matrix <code>src</code> is added to <code>this</code>. The upper left corner of the block being copied is <code>(src_offset_i,src_offset_j)</code>. The upper left corner of the copied block is <code>(dst_offset_i,dst_offset_j)</code>. The size of the rectangular block being copied is the maximum size possible, determined either by the size of <code>this</code> or <code>src</code> and the given offsets. </p>

</div>
</div>
<a id="a6556863808164142f559bcce1d92a09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6556863808164142f559bcce1d92a09e">&#9670;&nbsp;</a></span>Tadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tadd </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Weighted addition of the transpose of <code>B</code> to <code>this</code>.</p>
<p><em>A += s B<sup>T</sup></em> </p>

</div>
</div>
<a id="ad79daca87844eec1680018f196a3df0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad79daca87844eec1680018f196a3df0c">&#9670;&nbsp;</a></span>Tadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tadd </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>dst_offset_j</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_i</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>src_offset_j</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add transpose of a rectangular block.</p>
<p>A rectangular block of the matrix <code>src</code> is transposed and addedadded to <code>this</code>. The upper left corner of the block being copied is <code>(src_offset_i,src_offset_j)</code> in the coordinates of the <b>non</b>-transposed matrix. The upper left corner of the copied block is <code>(dst_offset_i,dst_offset_j)</code>. The size of the rectangular block being copied is the maximum size possible, determined either by the size of <code>this</code> or <code>src</code>. </p>

</div>
</div>
<a id="a31a913e14db890a6992849b1c238644e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a913e14db890a6992849b1c238644e">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a single element at the given position. </p>

</div>
</div>
<a id="a8b5cbf09cba49593f2c86d7f06b5eadb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b5cbf09cba49593f2c86d7f06b5eadb">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 , typename index_type &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>n_cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const index_type *&#160;</td>
          <td class="paramname"><em>col_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number2 *&#160;</td>
          <td class="paramname"><em>values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>elide_zero_values</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>col_indices_are_sorted</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an array of values given by <code>values</code> in the given global matrix row at columns specified by col_indices in the full matrix. This function is present for compatibility with the various sparse matrices in deal.II. In particular, the two boolean fields <code>elide_zero_values</code> and <code>col_indices_are_sorted</code> do not impact the performance of this routine, as opposed to the sparse matrix case and are indeed ignored in the implementation. </p>

</div>
</div>
<a id="a1b59247b8ddc428a47342525152691b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b59247b8ddc428a47342525152691b2">&#9670;&nbsp;</a></span>add_row() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(i,1...n) += s*A(j,1...n)</em>. Simple addition of rows of this </p>

</div>
</div>
<a id="a52eccc2e4b7b2113f568f31046a8b239"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52eccc2e4b7b2113f568f31046a8b239">&#9670;&nbsp;</a></span>add_row() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(i,1...n) += s*A(j,1...n) + t*A(k,1...n)</em>. Multiple addition of rows of this. </p>

</div>
</div>
<a id="a8bb599d984e3375067f615aefd5c9393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bb599d984e3375067f615aefd5c9393">&#9670;&nbsp;</a></span>add_col() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(1...n,i) += s*A(1...n,j)</em>. Simple addition of columns of this. </p>

</div>
</div>
<a id="a6b837f07f41a19e0d57377e31ec61569"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b837f07f41a19e0d57377e31ec61569">&#9670;&nbsp;</a></span>add_col() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::add_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>A(1...n,i) += s*A(1...n,j) + t*A(1...n,k)</em>. Multiple addition of columns of this. </p>

</div>
</div>
<a id="a7118bb0c55702e741002db02ac6f0e04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7118bb0c55702e741002db02ac6f0e04">&#9670;&nbsp;</a></span>swap_row()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::swap_row </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap <em>A(i,1...n) &lt;-&gt; A(j,1...n)</em>. Swap rows i and j of this </p>

</div>
</div>
<a id="ae4046dea183a3d5ef191cbe18e674881"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4046dea183a3d5ef191cbe18e674881">&#9670;&nbsp;</a></span>swap_col()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::swap_col </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html#a4e8f9ce2c12a56e26b62133edfcc9cef">size_type</a>&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap <em>A(1...n,i) &lt;-&gt; A(1...n,j)</em>. Swap columns i and j of this </p>

</div>
</div>
<a id="a12566fc371d78838435583c4f59e942d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12566fc371d78838435583c4f59e942d">&#9670;&nbsp;</a></span>diagadd()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::diagadd </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add constant to diagonal elements of this, i.e. add a multiple of the identity matrix. </p>

</div>
</div>
<a id="a7880cb55e5cecc96a033f390d5d00210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7880cb55e5cecc96a033f390d5d00210">&#9670;&nbsp;</a></span>equ() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*A</code>. </p>

</div>
</div>
<a id="a4180de5a8d453af9bb5e3b328078e19f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4180de5a8d453af9bb5e3b328078e19f">&#9670;&nbsp;</a></span>equ() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*A + b*B</code>. </p>

</div>
</div>
<a id="aae444a21f6b0cc9da4edd5a127a79e61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae444a21f6b0cc9da4edd5a127a79e61">&#9670;&nbsp;</a></span>equ() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*A + b*B + c*C</code>. </p>

</div>
</div>
<a id="a3790a7f3ad399a0f093a3d94f03d6846"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3790a7f3ad399a0f093a3d94f03d6846">&#9670;&nbsp;</a></span>symmetrize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::symmetrize </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Symmetrize the matrix by forming the mean value between the existing matrix and its transpose, <em>A = 1/2(A+A<sup>T</sup>)</em>.</p>
<p>Obviously the matrix must be quadratic for this operation. </p>

</div>
</div>
<a id="a898466c57e11e6f2599165071ffe5df3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a898466c57e11e6f2599165071ffe5df3">&#9670;&nbsp;</a></span>gauss_jordan()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::gauss_jordan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A=Inverse(A). A must be a square matrix. Inversion of this matrix by Gauss-Jordan algorithm with partial pivoting. This process is well- behaved for positive definite matrices, but be aware of round-off errors in the indefinite case.</p>
<p>In case deal.II was configured with LAPACK, the functions Xgetrf and Xgetri build an LU factorization and invert the matrix upon that factorization, providing best performance up to matrices with a few hundreds rows and columns.</p>
<p>The numerical effort to invert an <code>n x n</code> matrix is of the order <code>n**3</code>. </p>

</div>
</div>
<a id="a940ea10266174ad366d10bd806177ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a940ea10266174ad366d10bd806177ace">&#9670;&nbsp;</a></span>invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign the inverse of the given matrix to <code>*this</code>. This function is hardcoded for quadratic matrices of dimension one to four. However, since the amount of code needed grows quickly, the method <a class="el" href="classFullMatrix.html#a898466c57e11e6f2599165071ffe5df3">gauss_jordan()</a> is invoked implicitly if the dimension is larger. </p>

</div>
</div>
<a id="a9b6cd3d2dee462237eed86073be061a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b6cd3d2dee462237eed86073be061a4">&#9670;&nbsp;</a></span>cholesky()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::cholesky </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign the Cholesky decomposition \(A=:L L^T\) of the given matrix \(A\) to <code>*this</code>, where \(L\) is lower triangular matrix. The given matrix must be symmetric positive definite.</p>
<p>ExcMatrixNotPositiveDefinite will be thrown in the case that the matrix is not positive definite. </p>

</div>
</div>
<a id="acdbaa7791d02c34d71a751234a188087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdbaa7791d02c34d71a751234a188087">&#9670;&nbsp;</a></span>outer_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::outer_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>*this(i,j)</code> = \(V(i) W(j)\) where \(V,W\) are vectors of the same length. </p>

</div>
</div>
<a id="ac2388c76685e3fc4efdaab4cad185518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2388c76685e3fc4efdaab4cad185518">&#9670;&nbsp;</a></span>left_invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::left_invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign the left_inverse of the given matrix to <code>*this</code>. The calculation being performed is <em>(A<sup>T</sup>*A)<sup>-1</sup> *A<sup>T</sup></em>. </p>

</div>
</div>
<a id="a45a25dc4075f341f18e014037cd34f9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45a25dc4075f341f18e014037cd34f9b">&#9670;&nbsp;</a></span>right_invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::right_invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>M</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assign the right_inverse of the given matrix to <code>*this</code>. The calculation being performed is <em>A<sup>T</sup>*(A*A<sup>T</sup>) <sup>-1</sup></em>. </p>

</div>
</div>
<a id="a21b873fcd180999ad0d268c3278a71ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b873fcd180999ad0d268c3278a71ec">&#9670;&nbsp;</a></span>mmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::mmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication.</p>
<p>The optional parameter <code>adding</code> determines, whether the result is stored in <code>C</code> or added to <code>C</code>.</p>
<p>if (adding) <em>C += A*B</em></p>
<p>if (!adding) <em>C = A*B</em></p>
<p>Assumes that <code>A</code> and <code>B</code> have compatible sizes and that <code>C</code> already has the right size.</p>
<p>This function uses the BLAS function Xgemm if the product of the three matrix dimensions is larger than 300 and BLAS was detected during configuration. Using BLAS usually results in considerable performance gains. </p>

</div>
</div>
<a id="a850654dea1494fffc80677d3f58142a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a850654dea1494fffc80677d3f58142a0">&#9670;&nbsp;</a></span>Tmmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tmmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of <code>this</code>.</p>
<p>The optional parameter <code>adding</code> determines, whether the result is stored in <code>C</code> or added to <code>C</code>.</p>
<p>if (adding) <em>C += A<sup>T</sup>*B</em></p>
<p>if (!adding) <em>C = A<sup>T</sup>*B</em></p>
<p>Assumes that <code>A</code> and <code>B</code> have compatible sizes and that <code>C</code> already has the right size.</p>
<p>This function uses the BLAS function Xgemm if the product of the three matrix dimensions is larger than 300 and BLAS was detected during configuration. Using BLAS usually results in considerable performance gains. </p>

</div>
</div>
<a id="ac074fc1dc416f8cd75bb01d820e74aa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac074fc1dc416f8cd75bb01d820e74aa0">&#9670;&nbsp;</a></span>mTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::mTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of <code>B</code>.</p>
<p>The optional parameter <code>adding</code> determines, whether the result is stored in <code>C</code> or added to <code>C</code>.</p>
<p>if (adding) <em>C += A*B<sup>T</sup></em></p>
<p>if (!adding) <em>C = A*B<sup>T</sup></em></p>
<p>Assumes that <code>A</code> and <code>B</code> have compatible sizes and that <code>C</code> already has the right size.</p>
<p>This function uses the BLAS function Xgemm if the product of the three matrix dimensions is larger than 300 and BLAS was detected during configuration. Using BLAS usually results in considerable performance gains. </p>

</div>
</div>
<a id="a098a0fb764e74c7a4a524c9572e47b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098a0fb764e74c7a4a524c9572e47b18">&#9670;&nbsp;</a></span>TmTmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::TmTmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>C</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-matrix-multiplication using transpose of <code>this</code> and <code>B</code>.</p>
<p>The optional parameter <code>adding</code> determines, whether the result is stored in <code>C</code> or added to <code>C</code>.</p>
<p>if (adding) <em>C += A<sup>T</sup>*B<sup>T</sup></em></p>
<p>if (!adding) <em>C = A<sup>T</sup>*B<sup>T</sup></em></p>
<p>Assumes that <code>A</code> and <code>B</code> have compatible sizes and that <code>C</code> already has the right size.</p>
<p>This function uses the BLAS function Xgemm if the product of the three matrix dimensions is larger than 300 and BLAS was detected during configuration. Using BLAS usually results in considerable performance gains. </p>

</div>
</div>
<a id="a087ad6f60a4a0c365aeaee4760ad5cb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a087ad6f60a4a0c365aeaee4760ad5cb9">&#9670;&nbsp;</a></span>triple_product()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::triple_product </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>D</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_B</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>transpose_D</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>scaling</em> = <code>number(1.)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add to the current matrix the triple product <b>B A D</b>. Optionally, use the transposes of the matrices <b>B</b> and <b>D</b>. The scaling factor scales the whole product, which is helpful when adding a multiple of the triple product to the matrix.</p>
<p>This product was written with the Schur complement <b>B<sup>T</sup> A<sup>-1</sup> D</b> in mind. Note that in this case the argument for <code>A</code> must be the inverse of the matrix <b>A</b>. </p>

</div>
</div>
<a id="a65a409eeef6388d99ac15e2bbe8045f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65a409eeef6388d99ac15e2bbe8045f6">&#9670;&nbsp;</a></span>vmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::vmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Matrix-vector-multiplication.</p>
<p>The optional parameter <code>adding</code> determines, whether the result is stored in <code>w</code> or added to <code>w</code>.</p>
<p>if (adding) <em>w += A*v</em></p>
<p>if (!adding) <em>w = A*v</em></p>
<p>Source and destination must not be the same vector. </p>

</div>
</div>
<a id="a8edeb234359c99ccbc3a21e4890f61d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8edeb234359c99ccbc3a21e4890f61d7">&#9670;&nbsp;</a></span>vmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::vmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding Matrix-vector-multiplication. <em>w += A*v</em></p>
<p>Source and destination must not be the same vector. </p>

</div>
</div>
<a id="a8219d4fa962f1b041a506221a7a15379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8219d4fa962f1b041a506221a7a15379">&#9670;&nbsp;</a></span>Tvmult()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tvmult </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>adding</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transpose matrix-vector-multiplication.</p>
<p>The optional parameter <code>adding</code> determines, whether the result is stored in <code>w</code> or added to <code>w</code>.</p>
<p>if (adding) <em>w += A<sup>T</sup>*v</em></p>
<p>if (!adding) <em>w = A<sup>T</sup>*v</em></p>
<p>Source and destination must not be the same vector. </p>

</div>
</div>
<a id="abed6fffa5cb201496d751a4427cb59d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abed6fffa5cb201496d751a4427cb59d6">&#9670;&nbsp;</a></span>Tvmult_add()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::Tvmult_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>w</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Adding transpose matrix-vector-multiplication. <em>w += A<sup>T</sup>*v</em></p>
<p>Source and destination must not be the same vector. </p>

</div>
</div>
<a id="a8ca64e608a864f4e6c80e6a05fbe2b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ca64e608a864f4e6c80e6a05fbe2b31">&#9670;&nbsp;</a></span>precondition_Jacobi()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename somenumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::precondition_Jacobi </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; somenumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const number&#160;</td>
          <td class="paramname"><em>omega</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply the Jacobi preconditioner, which multiplies every element of the <code>src</code> vector by the inverse of the respective diagonal element and multiplies the result with the damping factor <code>omega</code>. </p>

</div>
</div>
<a id="a0bf7a776bf5778590c6997eeb53d277f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bf7a776bf5778590c6997eeb53d277f">&#9670;&nbsp;</a></span>residual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 , typename number3 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">number <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::residual </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><em>dst=b-A*x</em>. Residual calculation, returns the <em>l<sub>2</sub></em>-norm |<em>dst</em>|.</p>
<p>Source <em>x</em> and destination <em>dst</em> must not be the same vector. </p>

</div>
</div>
<a id="ad2241691e3b13448df6acbc37b39ab06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2241691e3b13448df6acbc37b39ab06">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Forward elimination of lower triangle. Inverts the lower triangle of a rectangular matrix for a given right hand side.</p>
<p>If the matrix has more columns than rows, this function only operates on the left quadratic submatrix. If there are more rows, the upper quadratic part of the matrix is considered.</p>
<dl class="section note"><dt>Note</dt><dd>It is safe to use the same object for <code>dst</code> and <code>src</code>. </dd></dl>

</div>
</div>
<a id="ae9add855bcb711cd778e6a99026eff59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9add855bcb711cd778e6a99026eff59">&#9670;&nbsp;</a></span>backward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename number&gt; </div>
<div class="memtemplate">
template&lt;typename number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classFullMatrix.html">FullMatrix</a>&lt; number &gt;::backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>dst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classVector.html">Vector</a>&lt; number2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward elimination of upper triangle.</p>
<p>See <a class="el" href="classFullMatrix.html#ad2241691e3b13448df6acbc37b39ab06">forward()</a></p>
<dl class="section note"><dt>Note</dt><dd>It is safe to use the same object for <code>dst</code> and <code>src</code>. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/lac/<a class="el" href="full__matrix_8h_source.html">full_matrix.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
