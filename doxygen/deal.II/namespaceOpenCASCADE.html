<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/namespaceOpenCASCADE.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: OpenCASCADE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">OpenCASCADE Namespace Reference<div class="ingroups"><a class="el" href="group__OpenCASCADE.html">OpenCASCADE</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html">ArclengthProjectionLineManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html">DirectionalProjectionManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html">NormalProjectionManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html">NormalToMeshProjectionManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html">NURBSPatchManifold</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3e3e0df474c0e4f9abb627753c8754e9"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a3e3e0df474c0e4f9abb627753c8754e9">count_elements</a> (const TopoDS_Shape &amp;shape)</td></tr>
<tr class="separator:a3e3e0df474c0e4f9abb627753c8754e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe07b496f4edf844d5f4e8d7a540295"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#affe07b496f4edf844d5f4e8d7a540295">read_IGES</a> (const std::string &amp;filename, const <a class="el" href="classdouble.html">double</a> scale_factor=1e-3)</td></tr>
<tr class="separator:affe07b496f4edf844d5f4e8d7a540295"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd63e8b33d9ed7a231da9212f6acc391"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#afd63e8b33d9ed7a231da9212f6acc391">write_IGES</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename)</td></tr>
<tr class="separator:afd63e8b33d9ed7a231da9212f6acc391"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4e15bf85bc1c9565ab2418bc70ca826"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad4e15bf85bc1c9565ab2418bc70ca826">read_STL</a> (const std::string &amp;filename)</td></tr>
<tr class="separator:ad4e15bf85bc1c9565ab2418bc70ca826"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad30b48a943a55104e5233b5a97b34eee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad30b48a943a55104e5233b5a97b34eee">write_STL</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename, const <a class="el" href="classdouble.html">double</a> deflection, const <a class="el" href="classbool.html">bool</a> sew_different_faces=false, const <a class="el" href="classdouble.html">double</a> sewer_tolerance=1e-6, const bool is_relative=false, const double angular_deflection=0.5, const bool in_parallel=false)</td></tr>
<tr class="separator:ad30b48a943a55104e5233b5a97b34eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614ec9f581086ad423513dd407e9e520"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a614ec9f581086ad423513dd407e9e520">read_STEP</a> (const std::string &amp;filename, const <a class="el" href="classdouble.html">double</a> scale_factor=1e-3)</td></tr>
<tr class="separator:a614ec9f581086ad423513dd407e9e520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42404c99252b6da0977f40a4eccf05d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a42404c99252b6da0977f40a4eccf05d9">write_STEP</a> (const TopoDS_Shape &amp;shape, const std::string &amp;filename)</td></tr>
<tr class="separator:a42404c99252b6da0977f40a4eccf05d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed838d4999b4707c48781b8d732058fe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classdouble.html">double</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aed838d4999b4707c48781b8d732058fe">get_shape_tolerance</a> (const TopoDS_Shape &amp;shape)</td></tr>
<tr class="separator:aed838d4999b4707c48781b8d732058fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7143020c8f7d45356e6fe0b347f73d7"><td class="memItemLeft" align="right" valign="top">TopoDS_Shape&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad7143020c8f7d45356e6fe0b347f73d7">intersect_plane</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classdouble.html">double</a> c_x, const <a class="el" href="classdouble.html">double</a> c_y, const <a class="el" href="classdouble.html">double</a> c_z, const <a class="el" href="classdouble.html">double</a> c, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:ad7143020c8f7d45356e6fe0b347f73d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c5d614d74c4091fe75f61de5242b0a"><td class="memItemLeft" align="right" valign="top">TopoDS_Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a59c5d614d74c4091fe75f61de5242b0a">join_edges</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a59c5d614d74c4091fe75f61de5242b0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89d772fdfdfe4d8cbeab798389737932"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a89d772fdfdfe4d8cbeab798389737932"><td class="memTemplItemLeft" align="right" valign="top">TopoDS_Edge&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a89d772fdfdfe4d8cbeab798389737932">interpolation_curve</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;curve_points, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;direction=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;(), const <a class="el" href="classbool.html">bool</a> closed=false, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a89d772fdfdfe4d8cbeab798389737932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d463f21e1fedb10a8c64eb9aefe2e6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a54d463f21e1fedb10a8c64eb9aefe2e6">extract_geometrical_shapes</a> (const TopoDS_Shape &amp;shape, std::vector&lt; TopoDS_Face &gt; &amp;faces, std::vector&lt; TopoDS_Edge &gt; &amp;edges, std::vector&lt; TopoDS_Vertex &gt; &amp;<a class="el" href="data__out__base_8cc.html#accc45da40beb7ae1b485306984e904a2">vertices</a>)</td></tr>
<tr class="separator:a54d463f21e1fedb10a8c64eb9aefe2e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad437c01354d11be7891457b24f64f31b"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ad437c01354d11be7891457b24f64f31b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad437c01354d11be7891457b24f64f31b">create_triangulation</a> (const TopoDS_Face &amp;face, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;tria)</td></tr>
<tr class="separator:ad437c01354d11be7891457b24f64f31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7a2b7eda01f714fd2efa446b6216107"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:ad7a2b7eda01f714fd2efa446b6216107"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; TopoDS_Edge &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad7a2b7eda01f714fd2efa446b6216107">create_curves_from_triangulation_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, spacedim &gt; &amp;mapping=<a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt; 2, spacedim &gt;::mapping)</td></tr>
<tr class="separator:ad7a2b7eda01f714fd2efa446b6216107"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e49f50433c835c841eed35f40862560"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a1e49f50433c835c841eed35f40862560">extract_compound_shapes</a> (const TopoDS_Shape &amp;shape, std::vector&lt; TopoDS_Compound &gt; &amp;compounds, std::vector&lt; TopoDS_CompSolid &gt; &amp;compsolids, std::vector&lt; TopoDS_Solid &gt; &amp;solids, std::vector&lt; TopoDS_Shell &gt; &amp;shells, std::vector&lt; TopoDS_Wire &gt; &amp;wires)</td></tr>
<tr class="separator:a1e49f50433c835c841eed35f40862560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb3e8e294b26a9d1122739fb6c05bf39"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:acb3e8e294b26a9d1122739fb6c05bf39"><td class="memTemplItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#acb3e8e294b26a9d1122739fb6c05bf39">project_point_and_pull_back</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:acb3e8e294b26a9d1122739fb6c05bf39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94c26d2fd39062b95c4dc0394dc9a70c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a94c26d2fd39062b95c4dc0394dc9a70c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a94c26d2fd39062b95c4dc0394dc9a70c">closest_point</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a94c26d2fd39062b95c4dc0394dc9a70c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9797278e83bc72d10fc2b66adb045c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ace9797278e83bc72d10fc2b66adb045c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ace9797278e83bc72d10fc2b66adb045c">push_forward</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classdouble.html">double</a> v)</td></tr>
<tr class="separator:ace9797278e83bc72d10fc2b66adb045c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17c7b59ea0d1fee16c815c7e40237aa5"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a17c7b59ea0d1fee16c815c7e40237aa5">push_forward_and_differential_forms</a> (const TopoDS_Face &amp;face, const <a class="el" href="classdouble.html">double</a> u, const <a class="el" href="classdouble.html">double</a> v, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a17c7b59ea0d1fee16c815c7e40237aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476712b60ff6cb2ad783f34552ef9843"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a476712b60ff6cb2ad783f34552ef9843">closest_point_and_differential_forms</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:a476712b60ff6cb2ad783f34552ef9843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e467e8f4db2ca53322908dec25b42d"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:ad2e467e8f4db2ca53322908dec25b42d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad2e467e8f4db2ca53322908dec25b42d">line_intersection</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;origin, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;direction, const <a class="el" href="classdouble.html">double</a> tolerance=1e-7)</td></tr>
<tr class="separator:ad2e467e8f4db2ca53322908dec25b42d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9509efa83e3b2fa42616fe0623cba696"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:a9509efa83e3b2fa42616fe0623cba696"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> (const gp_Pnt &amp;p, const <a class="el" href="classdouble.html">double</a> tolerance=1e-10)</td></tr>
<tr class="separator:a9509efa83e3b2fa42616fe0623cba696"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3c9ea93645e89d325289cb9d8b14788"><td class="memTemplParams" colspan="2">template&lt;int spacedim&gt; </td></tr>
<tr class="memitem:aa3c9ea93645e89d325289cb9d8b14788"><td class="memTemplItemLeft" align="right" valign="top">gp_Pnt&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aa3c9ea93645e89d325289cb9d8b14788">point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p)</td></tr>
<tr class="separator:aa3c9ea93645e89d325289cb9d8b14788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a919a5ebb75e67a4baa0ddd0caf8f15"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7a919a5ebb75e67a4baa0ddd0caf8f15"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7a919a5ebb75e67a4baa0ddd0caf8f15">point_compare</a> (const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;p2, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;direction=<a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt;(), const <a class="el" href="classdouble.html">double</a> tolerance=1e-10)</td></tr>
<tr class="separator:a7a919a5ebb75e67a4baa0ddd0caf8f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7626fe6de3509bc3d811f44b677eedba"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a7626fe6de3509bc3d811f44b677eedba"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7626fe6de3509bc3d811f44b677eedba">DeclException1</a> (ExcPointNotOnManifold, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;,&lt;&lt; &quot;The <a class="el" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> [ &quot;&lt;&lt; arg1&lt;&lt; &quot; ] is not on the manifold.&quot;)</td></tr>
<tr class="separator:a7626fe6de3509bc3d811f44b677eedba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a894474b611ddf3914dc49ab2897bd33c"><td class="memTemplParams" colspan="2">template&lt;int dim&gt; </td></tr>
<tr class="memitem:a894474b611ddf3914dc49ab2897bd33c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a894474b611ddf3914dc49ab2897bd33c">DeclException1</a> (ExcProjectionFailed, <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;,&lt;&lt; &quot;Projection of <a class="el" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a> [ &quot;&lt;&lt; arg1&lt;&lt; &quot; ] failed.&quot;)</td></tr>
<tr class="separator:a894474b611ddf3914dc49ab2897bd33c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a384cba2c54d3b21005b852bcc416a804"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a384cba2c54d3b21005b852bcc416a804">DeclException1</a> (ExcOCCError, IFSelect_ReturnStatus,&lt;&lt; &quot;An OpenCASCADE routine failed with return status &quot;&lt;&lt; arg1)</td></tr>
<tr class="separator:a384cba2c54d3b21005b852bcc416a804"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac514c33b40a9d3e06de28458b1ab5f95"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ac514c33b40a9d3e06de28458b1ab5f95">DeclException0</a> (ExcEdgeIsDegenerate)</td></tr>
<tr class="separator:ac514c33b40a9d3e06de28458b1ab5f95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad67c15ae928d972508b0c4f27d4e73fa"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad67c15ae928d972508b0c4f27d4e73fa">DeclException0</a> (ExcUnsupportedShape)</td></tr>
<tr class="separator:ad67c15ae928d972508b0c4f27d4e73fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa478ba4bb573e11b7117c97273efff0a"><td class="memItemLeft" align="right" valign="top">template std::vector&lt; TopoDS_Edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aa478ba4bb573e11b7117c97273efff0a">create_curves_from_triangulation_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, 2 &gt; &amp;mapping)</td></tr>
<tr class="separator:aa478ba4bb573e11b7117c97273efff0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3165c3e53baed239c4cd953c807609b7"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a3165c3e53baed239c4cd953c807609b7">point_compare</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p2, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; &amp;direction, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a3165c3e53baed239c4cd953c807609b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a375276d21bb0d1a58887cafeb70d2e15"><td class="memItemLeft" align="right" valign="top">template gp_Pnt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a375276d21bb0d1a58887cafeb70d2e15">point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;p)</td></tr>
<tr class="separator:a375276d21bb0d1a58887cafeb70d2e15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dcf2839082dc073b41996947cb803d0"><td class="memItemLeft" align="right" valign="top">template TopoDS_Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a8dcf2839082dc073b41996947cb803d0">interpolation_curve</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&gt; &amp;curve_points, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> closed, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a8dcf2839082dc073b41996947cb803d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af413b2b0c651655cdf90aa16629ff8cb"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#af413b2b0c651655cdf90aa16629ff8cb">line_intersection</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;origin, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; &amp;direction, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:af413b2b0c651655cdf90aa16629ff8cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0039678272fc1333c78d0ae49fd34d03"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a0039678272fc1333c78d0ae49fd34d03">create_triangulation</a> (const TopoDS_Face &amp;face, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;tria)</td></tr>
<tr class="separator:a0039678272fc1333c78d0ae49fd34d03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce3b530dd1bfa84740b66973cc9e5f8"><td class="memItemLeft" align="right" valign="top">template std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a7ce3b530dd1bfa84740b66973cc9e5f8">project_point_and_pull_back</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a7ce3b530dd1bfa84740b66973cc9e5f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07f68caac5ab104e5ef99e8ecfd6260f"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a07f68caac5ab104e5ef99e8ecfd6260f">closest_point</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a07f68caac5ab104e5ef99e8ecfd6260f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ee18b0f9337dfb018c275f46dec0ff7"><td class="memItemLeft" align="right" valign="top">template std::vector&lt; TopoDS_Edge &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a0ee18b0f9337dfb018c275f46dec0ff7">create_curves_from_triangulation_boundary</a> (const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;<a class="el" href="p4est__wrappers_8cc.html#ace00f2f80d9780ef9aa1007e1c22c6a4">triangulation</a>, const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, 3 &gt; &amp;mapping)</td></tr>
<tr class="separator:a0ee18b0f9337dfb018c275f46dec0ff7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b920cb6577469bfd3c24d6efe0f9ca"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a21b920cb6577469bfd3c24d6efe0f9ca">point_compare</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p2, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;direction, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a21b920cb6577469bfd3c24d6efe0f9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeffe7e9c64ee3afa78207652cf1dddbd"><td class="memItemLeft" align="right" valign="top">template gp_Pnt&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#aeffe7e9c64ee3afa78207652cf1dddbd">point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;p)</td></tr>
<tr class="separator:aeffe7e9c64ee3afa78207652cf1dddbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da05cba61b0fc3459c7230441342ac5"><td class="memItemLeft" align="right" valign="top">template TopoDS_Edge&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a9da05cba61b0fc3459c7230441342ac5">interpolation_curve</a> (std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;curve_points, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;direction, const <a class="el" href="classbool.html">bool</a> closed, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a9da05cba61b0fc3459c7230441342ac5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3de39c036882c7f56412c05a71980f6"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ac3de39c036882c7f56412c05a71980f6">line_intersection</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;direction, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:ac3de39c036882c7f56412c05a71980f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5744cbf483daee9cfb3a9769010d37"><td class="memItemLeft" align="right" valign="top">template void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a3e5744cbf483daee9cfb3a9769010d37">create_triangulation</a> (const TopoDS_Face &amp;face, <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;tria)</td></tr>
<tr class="separator:a3e5744cbf483daee9cfb3a9769010d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f1d8081ec0c7b15ccf160468d0426c"><td class="memItemLeft" align="right" valign="top">template std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#a34f1d8081ec0c7b15ccf160468d0426c">project_point_and_pull_back</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:a34f1d8081ec0c7b15ccf160468d0426c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0206904cf16cd633f1cde073267f691"><td class="memItemLeft" align="right" valign="top">template <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceOpenCASCADE.html#ad0206904cf16cd633f1cde073267f691">closest_point</a> (const TopoDS_Shape &amp;in_shape, const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;origin, const <a class="el" href="classdouble.html">double</a> tolerance)</td></tr>
<tr class="separator:ad0206904cf16cd633f1cde073267f691"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>我们在这个命名空间中收集所有对OpenCASCADE实体进行操作的实用程序。OpenCASCADE把每个物体分成了一个拓扑描述和一个几何实体。基本的拓扑描述是一个TopoDS_Shape。TopoDS_Shape是轻型物体，可以被复制。最接近deal.II的类似物是一个TriaIterator。 OpenCASCADE的拓扑结构是参照STEP标准ISO-10303-42设计的。 该结构是一个定向的单行图，父指其子，没有反向引用。抽象结构是以TopoDS包的C++类实现的。一个TopoDS_Shape是通过值来操作的，包含3个字段：位置、方向和一个myTShape句柄（TopoDS_TShape类型的）。根据OpenCASCADE的文档，myTShape和Location是用来在各种形状之间共享数据以节省内存。例如，一条属于两个面的边有相等的位置和myTShape字段，但有不同的方向（在一个面的上下文中是向前的，而在另一个面中是相反的）。 有效的形状包括其他形状的集合、实体、面、边、顶点，等等。 一旦有了拓扑描述，如果可以创建一个具体的几何对象，BRep类允许人们从一个形状中提取实际的几何信息。 这是通过实现边界表示模型（来自BRep包）的人继承TopoDS包中的抽象拓扑学类来实现的。只有3种类型的拓扑对象具有几何表示法</p>
<p>-顶点、边缘和面。 每个TopoDS_Shape都可以被查询到它是什么类型的形状，而实际的几何对象，如曲面、曲线或点，可以用BRepTools提取。 在这个命名空间中，我们提供了读取标准CAD文件并返回TopoDS_Shape的读取器和写入器，或者在给出TopoDS_Shape的情况下写入CAD文件。OpenCASCADE命名空间中的大多数函数都处理一种或另一种类型的TopoDS_Shape，并提供普通deal.II对象的接口，如Triangulation、Manifold等。 注意，这些工具中的大多数只有在spacedim等于3时才有用，因为OpenCASCADE只在三维模式下工作。在某些情况下，它们也可以在二维模式下使用，而第三维将被设置为零。 如果你希望在空间的维度为二时使用这些工具，那么请确保你的CAD文件实际上是平的，并且所有的Z坐标都等于零，否则你会得到许多异常。 </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a3e3e0df474c0e4f9abb627753c8754e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3e0df474c0e4f9abb627753c8754e9">&#9670;&nbsp;</a></span>count_elements()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a>, unsigned <a class="el" href="classint.html">int</a> &gt; OpenCASCADE::count_elements </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>计算一个形状的子对象。这个函数对于收集作为参数传递的TopoDS_Shape的信息很有用。它返回包含在给定形状中的面、边和顶点（唯一与实际几何图形相关的拓扑实体）的数量。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00088">88</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="affe07b496f4edf844d5f4e8d7a540295"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe07b496f4edf844d5f4e8d7a540295">&#9670;&nbsp;</a></span>read_IGES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_IGES </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取IGES文件并将其内容翻译成openCascade拓扑实体。选项scale_factor用于补偿在IGES文件和目标应用程序中使用的不同单位。IGES文件的标准单位是毫英寸。返回的对象是一个TopoDS_Shape，包含文件中的所有对象。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00238">238</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="afd63e8b33d9ed7a231da9212f6acc391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd63e8b33d9ed7a231da9212f6acc391">&#9670;&nbsp;</a></span>write_IGES()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_IGES </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的拓扑形状写入一个IGES文件中。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00267">267</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad4e15bf85bc1c9565ab2418bc70ca826"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4e15bf85bc1c9565ab2418bc70ca826">&#9670;&nbsp;</a></span>read_STL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_STL </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取STL文件并将其内容翻译成openCascade拓扑实体。 返回的对象是一个TopoDS_Shape，其中包含文件中的所有对象。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00280">280</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad30b48a943a55104e5233b5a97b34eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad30b48a943a55104e5233b5a97b34eee">&#9670;&nbsp;</a></span>write_STL()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_STL </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>deflection</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>sew_different_faces</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>sewer_tolerance</em> = <code>1e-6</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>is_relative</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>angular_deflection</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>in_parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的拓扑形状写入一个STL文件中。为了做到这一点，该形状必须包含一个网格结构，该函数检查该形状的所有面是否有一个附加的网格，如果不是这样，它将自动进行网格化。我们注意到，OpenCASCADE的自动网格生成只考虑到形状和网格之间的几何相似性，要控制三角形的形状和规则性，你应该使用其他网格软件。两个参数<code>deflection</code>和<code>angular_deflection</code>选择创建的三角形相对于原始拓扑形状的精度。参数<code>sew_different_faces</code>给出了使用OpenCASCADE的Sewer的可能性，使用参数<code>sewer_tolerance</code>创建一个水密的封闭STL。参数<code>is_relative</code>指定距离是否是相对的，<code>in_parallel</code>如果执行应该是并行的。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00290">290</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a614ec9f581086ad423513dd407e9e520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614ec9f581086ad423513dd407e9e520">&#9670;&nbsp;</a></span>read_STEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::read_STEP </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>scale_factor</em> = <code>1e-3</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取STEP文件并将其内容翻译成openCascade拓扑实体。选项scale_factor用于补偿在STEP文件和目标应用程序中使用的不同单位。STEP文件的标准单位是毫英寸。返回的对象是一个TopoDS_Shape，包含文件中的所有对象。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00355">355</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a42404c99252b6da0977f40a4eccf05d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42404c99252b6da0977f40a4eccf05d9">&#9670;&nbsp;</a></span>write_STEP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::write_STEP </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将给定的拓扑形状写入一个STEP文件中。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00384">384</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aed838d4999b4707c48781b8d732058fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed838d4999b4707c48781b8d732058fe">&#9670;&nbsp;</a></span>get_shape_tolerance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classdouble.html">double</a> OpenCASCADE::get_shape_tolerance </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该函数返回与该形状相关的公差。每个CAD几何对象都被定义了一个公差，它表示其位置可能的不精确性。例如，顶点的公差表示它可以位于以名义位置为中心、半径为tol的球体中的任何一点。在执行一个操作时，例如将一个点投影到一个曲面上（这反过来也有它的公差），我们必须记住，投影的精度将受到建立曲面的公差的限制。 公差的计算是以组成形状的子形状中的最大公差为依据。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00400">400</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad7143020c8f7d45356e6fe0b347f73d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7143020c8f7d45356e6fe0b347f73d7">&#9670;&nbsp;</a></span>intersect_plane()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Shape OpenCASCADE::intersect_plane </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c_y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c_z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>执行给定的拓扑形状与平面 \(c_x x + c_y y + c_z z +c = 0\) 的交点。返回的拓扑形状将包含尽可能少的bsplines。如果相交产生一个空的形状，会产生一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00424">424</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a59c5d614d74c4091fe75f61de5242b0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c5d614d74c4091fe75f61de5242b0a">&#9670;&nbsp;</a></span>join_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Edge OpenCASCADE::join_edges </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>尝试将给定的TopoDS_Shape中包含的所有边连接成一个TopoDS_Edge，包含尽可能少的BSP线。如果输入的形状包含面，它们将被这个函数忽略。如果包含的边不能被连接成一个单一的边，也就是说，它们形成了不相连的曲线，那么将抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00438">438</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a89d772fdfdfe4d8cbeab798389737932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89d772fdfdfe4d8cbeab798389737932">&#9670;&nbsp;</a></span>interpolation_curve() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">TopoDS_Edge OpenCASCADE::interpolation_curve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>curve_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;dim&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>closed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>创建一条通过指定向量中的点的平滑BSpline曲线，并将其存储在返回的TopoDS_Shape中（TopoDS_Edge类型）。如果方向与零不同，这些点将根据它们与方向的标量乘积在内部重新排序，否则，它们将被作为传递的点使用。注意，如果算法需要，这个函数会改变输入的点。 该类用于插值一条通过数组点的BsplineCurve，具有C2连续性。如果可选的参数 <code>closed</code> 被设置为 "true"，那么除了第一个点之外，曲线在所有的点上都是C2的（这里只给出C1的连续性），并且它将是一条封闭的曲线。 该曲线保证与输入点的距离为 <code>tolerance</code> 。如果算法不能生成这样的曲线，就会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00552">552</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a54d463f21e1fedb10a8c64eb9aefe2e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d463f21e1fedb10a8c64eb9aefe2e6">&#9670;&nbsp;</a></span>extract_geometrical_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::extract_geometrical_shapes </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Face &gt; &amp;&#160;</td>
          <td class="paramname"><em>faces</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Edge &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Vertex &gt; &amp;&#160;</td>
          <td class="paramname"><em>vertices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从TopoDS_Shape中提取所有子形状，并将结果存储到标准容器中。如果该形状不包含某种类型的形状，相应的容器将是空的。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00107">107</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad437c01354d11be7891457b24f64f31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad437c01354d11be7891457b24f64f31b">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从一个单一的面创建一个三角结构。这个类提取构成这个面的参数化曲面的第一个u和v参数，并创建一个三角形&lt;2,spacedim&gt;，包含反映这个面的单个粗略的单元。如果这个面不是一个修剪过的面，这个单元的顶点将与原始TopoDS_Face的TopoDS_Vertex顶点重合。然而，情况往往不是这样的，用户应该注意如何使用这个网格。 如果你用Triangulation&lt;2,2&gt;调用这个函数，请确保输入的面的所有Z坐标都设置为零，否则你会得到一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00885">885</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad7a2b7eda01f714fd2efa446b6216107"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7a2b7eda01f714fd2efa446b6216107">&#9670;&nbsp;</a></span>create_curves_from_triangulation_boundary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; TopoDS_Edge &gt; OpenCASCADE::create_curves_from_triangulation_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em> = <code><a class="el" href="structStaticMappingQ1.html">StaticMappingQ1</a>&lt;2,&#160;spacedim&gt;::mapping</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给定一个Triangulation和一个可选的Mapping，创建一个平滑曲线的向量，对Triangulation的边界顶点的连接部分进行插值，并作为TopoDS_Edge对象的向量返回。 这个函数构造封闭的Bspline曲线对象，通过三角形边界的所有顶点，每个顶点都有 \(C^2\) 连续性，除了第一个顶点，那里只保证 \(C^1\) 连续性。 返回的曲线是按照构成三角形边界的面的索引排序的，即第一条曲线是从索引最低的面开始提取的，以此类推。 </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">triangulation</td><td>输入三角形 </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">mapping</td><td>可选的输入映射 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>TopoDS_Edge对象的一个 std::vector ，代表 "三角形 "边界的平滑插值。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00595">595</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a1e49f50433c835c841eed35f40862560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e49f50433c835c841eed35f40862560">&#9670;&nbsp;</a></span>extract_compound_shapes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OpenCASCADE::extract_compound_shapes </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Compound &gt; &amp;&#160;</td>
          <td class="paramname"><em>compounds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_CompSolid &gt; &amp;&#160;</td>
          <td class="paramname"><em>compsolids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Solid &gt; &amp;&#160;</td>
          <td class="paramname"><em>solids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Shell &gt; &amp;&#160;</td>
          <td class="paramname"><em>shells</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; TopoDS_Wire &gt; &amp;&#160;</td>
          <td class="paramname"><em>wires</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>从TopoDS_Shape中提取所有复合形状，并将结果存储到标准容器中。如果形状不包含某种类型的化合物，相应的容器将是空的。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00133">133</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="acb3e8e294b26a9d1122739fb6c05bf39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb3e8e294b26a9d1122739fb6c05bf39">&#9670;&nbsp;</a></span>project_point_and_pull_back() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; dim &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; OpenCASCADE::project_point_and_pull_back </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将点 <code>origin</code> 投射到由 <code>in_shape给出的拓扑形状上，并返回投射的点，包含该点的子形状以及该点在结果形状中的参数u和v坐标。如果形状不是基本的，它的所有子形状都会被迭代，首先是面，然后是边，返回的形状是离点最近的一个</code> <code>origin</code>. 如果返回的形状是一个边，那么只有u坐标被填上合理的信息，而v坐标被设置为零。 这个函数返回一个包含投影点、形状、u坐标和v坐标的元组（只有当得到的形状是一个面时，v坐标才会与零不同）。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00698">698</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a94c26d2fd39062b95c4dc0394dc9a70c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94c26d2fd39062b95c4dc0394dc9a70c">&#9670;&nbsp;</a></span>closest_point() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; OpenCASCADE::closest_point </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回点 <code>origin</code> 在 <code>in_shape</code>. 给出的拓扑形状上的投影。如果该形状不是基本形状，它的所有子形状都会被迭代，首先是面，然后是边，返回的点是与 <code>in_shape</code>, 最接近的点，无论其类型如何。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00781">781</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ace9797278e83bc72d10fc2b66adb045c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9797278e83bc72d10fc2b66adb045c">&#9670;&nbsp;</a></span>push_forward()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::push_forward </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个基本形状 <code>in_shape</code> 和形状中的参考坐标，返回实空间中的相应点。如果该形状是TopoDS_Edge， <code>v</code> 坐标被忽略。只有由函数project_point_and_pull_back()返回的边或面可以作为该函数的输入。如果不是这样，就会抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00827">827</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a17c7b59ea0d1fee16c815c7e40237aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17c7b59ea0d1fee16c815c7e40237aa5">&#9670;&nbsp;</a></span>push_forward_and_differential_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; OpenCASCADE::push_forward_and_differential_forms </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>给出一个TopoDS_Face <code>face</code> 和这个面内的参考坐标，返回实空间中的对应点，该点的表面法线，以及最小和最大曲率，作为一个元组。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00848">848</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a476712b60ff6cb2ad783f34552ef9843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476712b60ff6cb2ad783f34552ef9843">&#9670;&nbsp;</a></span>closest_point_and_differential_forms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt;, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a> &gt; OpenCASCADE::closest_point_and_differential_forms </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取与给定的拓扑形状最接近的点，以及该点的法线和最小及最大曲率。如果该形状不是基本的，它的所有子面（只有面）都会被迭代，先是面，然后只返回最近的点。如果 <code>in_shape</code> 不包含至少一个面，这个函数将抛出一个异常。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00791">791</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="ad2e467e8f4db2ca53322908dec25b42d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e467e8f4db2ca53322908dec25b42d">&#9670;&nbsp;</a></span>line_intersection() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt; OpenCASCADE::line_intersection </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-7</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>沿着 <code>方向与给定的</code> <code>origin</code> 点和给定的拓扑形状相交的一条线。如果有一个以上的交点，它将返回最近的一个。 可选的 <code>tolerance</code> 参数是用来计算距离的。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00506">506</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a9509efa83e3b2fa42616fe0623cba696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9509efa83e3b2fa42616fe0623cba696">&#9670;&nbsp;</a></span>point() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const gp_Pnt &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将OpenCASCADE点转换成Point&lt;spacedim&gt;。 容差参数用于检查OpenCASCADE点的非使用成分是否接近于零。如果不是这样，在调试模式下会抛出一个断言。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00188">188</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="aa3c9ea93645e89d325289cb9d8b14788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3c9ea93645e89d325289cb9d8b14788">&#9670;&nbsp;</a></span>point() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int spacedim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">gp_Pnt OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将Point&lt;3&gt;转换成OpenCASCADE点。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00171">171</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7a919a5ebb75e67a4baa0ddd0caf8f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a919a5ebb75e67a4baa0ddd0caf8f15">&#9670;&nbsp;</a></span>point_compare() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> OpenCASCADE::point_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, dim &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em> = <code><a class="el" href="classTensor.html">Tensor</a>&lt;1,&#160;dim&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code>1e-10</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>根据两个点与方向的标量乘积对其进行排序。如果方向的规范是零，那么就使用lexicographical排序。可选的参数在比较对象时被用作相对公差。 </p>

<p class="definition">Definition at line <a class="el" href="opencascade_2utilities_8cc_source.html#l00215">215</a> of file <a class="el" href="opencascade_2utilities_8cc_source.html">utilities.cc</a>.</p>

</div>
</div>
<a id="a7626fe6de3509bc3d811f44b677eedba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7626fe6de3509bc3d811f44b677eedba">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenCASCADE::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcPointNotOnManifold&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;The <a class="el" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>  is not on the manifold.&quot;&#160;</td>
          <td class="paramname">[&quot;&lt;&lt; arg1&lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>当作为参数指定的点不在给定的TopoDS_Shape的 <code>tolerance</code> 之间时抛出异常。 </p>

</div>
</div>
<a id="a894474b611ddf3914dc49ab2897bd33c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a894474b611ddf3914dc49ab2897bd33c">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">OpenCASCADE::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcProjectionFailed&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classPoint.html">Point</a>&lt; dim &gt;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Projection of <a class="el" href="namespaceOpenCASCADE.html#a9509efa83e3b2fa42616fe0623cba696">point</a>  failed.&quot;&#160;</td>
          <td class="paramname">[&quot;&lt;&lt; arg1&lt;&lt; &quot;]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>当作为参数指定的点不能被投影到流形上时，会产生异常。 </p>

</div>
</div>
<a id="a384cba2c54d3b21005b852bcc416a804"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a384cba2c54d3b21005b852bcc416a804">&#9670;&nbsp;</a></span>DeclException1() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCASCADE::DeclException1 </td>
          <td>(</td>
          <td class="paramtype">ExcOCCError&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IFSelect_ReturnStatus&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;An OpenCASCADE routine failed with return status &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>当内部的OpenCASCADE工具不能返回OK状态时被抛出。 </p>

</div>
</div>
<a id="ac514c33b40a9d3e06de28458b1ab5f95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac514c33b40a9d3e06de28458b1ab5f95">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCASCADE::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcEdgeIsDegenerate&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>试图对一个退化的边缘进行曲线操作。 </p>

</div>
</div>
<a id="ad67c15ae928d972508b0c4f27d4e73fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67c15ae928d972508b0c4f27d4e73fa">&#9670;&nbsp;</a></span>DeclException0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OpenCASCADE::DeclException0 </td>
          <td>(</td>
          <td class="paramtype">ExcUnsupportedShape&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>试图对错误的形状类型进行操作。 </p>

</div>
</div>
<a id="aa478ba4bb573e11b7117c97273efff0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa478ba4bb573e11b7117c97273efff0a">&#9670;&nbsp;</a></span>create_curves_from_triangulation_boundary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::vector&lt;TopoDS_Edge&gt; OpenCASCADE::create_curves_from_triangulation_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3165c3e53baed239c4cd953c807609b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3165c3e53baed239c4cd953c807609b7">&#9670;&nbsp;</a></span>point_compare() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classbool.html">bool</a> OpenCASCADE::point_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a375276d21bb0d1a58887cafeb70d2e15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a375276d21bb0d1a58887cafeb70d2e15">&#9670;&nbsp;</a></span>point() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template gp_Pnt OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dcf2839082dc073b41996947cb803d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dcf2839082dc073b41996947cb803d0">&#9670;&nbsp;</a></span>interpolation_curve() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template TopoDS_Edge OpenCASCADE::interpolation_curve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>curve_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af413b2b0c651655cdf90aa16629ff8cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af413b2b0c651655cdf90aa16629ff8cb">&#9670;&nbsp;</a></span>line_intersection() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; OpenCASCADE::line_intersection </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0039678272fc1333c78d0ae49fd34d03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0039678272fc1333c78d0ae49fd34d03">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void OpenCASCADE::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ce3b530dd1bfa84740b66973cc9e5f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce3b530dd1bfa84740b66973cc9e5f8">&#9670;&nbsp;</a></span>project_point_and_pull_back() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::tuple&lt;<a class="el" href="classPoint.html">Point</a>&lt; 2 &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>&gt; OpenCASCADE::project_point_and_pull_back </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07f68caac5ab104e5ef99e8ecfd6260f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07f68caac5ab104e5ef99e8ecfd6260f">&#9670;&nbsp;</a></span>closest_point() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; OpenCASCADE::closest_point </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ee18b0f9337dfb018c275f46dec0ff7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee18b0f9337dfb018c275f46dec0ff7">&#9670;&nbsp;</a></span>create_curves_from_triangulation_boundary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::vector&lt;TopoDS_Edge&gt; OpenCASCADE::create_curves_from_triangulation_boundary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>triangulation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMapping.html">Mapping</a>&lt; 2, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21b920cb6577469bfd3c24d6efe0f9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b920cb6577469bfd3c24d6efe0f9ca">&#9670;&nbsp;</a></span>point_compare() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classbool.html">bool</a> OpenCASCADE::point_compare </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeffe7e9c64ee3afa78207652cf1dddbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeffe7e9c64ee3afa78207652cf1dddbd">&#9670;&nbsp;</a></span>point() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template gp_Pnt OpenCASCADE::point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9da05cba61b0fc3459c7230441342ac5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da05cba61b0fc3459c7230441342ac5">&#9670;&nbsp;</a></span>interpolation_curve() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template TopoDS_Edge OpenCASCADE::interpolation_curve </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>curve_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>closed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3de39c036882c7f56412c05a71980f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3de39c036882c7f56412c05a71980f6">&#9670;&nbsp;</a></span>line_intersection() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::line_intersection </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTensor.html">Tensor</a>&lt; 1, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e5744cbf483daee9cfb3a9769010d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5744cbf483daee9cfb3a9769010d37">&#9670;&nbsp;</a></span>create_triangulation() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template void OpenCASCADE::create_triangulation </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Face &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classTriangulation.html">Triangulation</a>&lt; 2, 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>tria</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a34f1d8081ec0c7b15ccf160468d0426c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f1d8081ec0c7b15ccf160468d0426c">&#9670;&nbsp;</a></span>project_point_and_pull_back() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template std::tuple&lt;<a class="el" href="classPoint.html">Point</a>&lt; 3 &gt;, TopoDS_Shape, <a class="el" href="classdouble.html">double</a>, <a class="el" href="classdouble.html">double</a>&gt; OpenCASCADE::project_point_and_pull_back </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0206904cf16cd633f1cde073267f691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0206904cf16cd633f1cde073267f691">&#9670;&nbsp;</a></span>closest_point() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">template <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; OpenCASCADE::closest_point </td>
          <td>(</td>
          <td class="paramtype">const TopoDS_Shape &amp;&#160;</td>
          <td class="paramname"><em>in_shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; 3 &gt; &amp;&#160;</td>
          <td class="paramname"><em>origin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
