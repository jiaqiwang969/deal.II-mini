<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classLinearAlgebra_1_1distributed_1_1Vector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLinearAlgebra.html">LinearAlgebra</a></li><li class="navelem"><a class="el" href="namespaceLinearAlgebra_1_1distributed.html">distributed</a></li><li class="navelem"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classLinearAlgebra_1_1distributed_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="la__parallel__vector_8h_source.html">deal.II/lac/la_parallel_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classLinearAlgebra_1_1distributed_1_1Vector__inherit__graph.svg" width="307" height="247"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae018e039c0ca78a063c6a075be461283"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae018e039c0ca78a063c6a075be461283">memory_space</a> = MemorySpace</td></tr>
<tr class="separator:ae018e039c0ca78a063c6a075be461283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4439cf261c308591c649e442d097ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> = Number</td></tr>
<tr class="separator:aca4439cf261c308591c649e442d097ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3b93ed114bc9795c0e3b3d5902393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae5c3b93ed114bc9795c0e3b3d5902393">pointer</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:ae5c3b93ed114bc9795c0e3b3d5902393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84413e605d193829856edbaa9d75b57b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a84413e605d193829856edbaa9d75b57b">const_pointer</a> = const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:a84413e605d193829856edbaa9d75b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35abed3e6b898142990cecf00e8387da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:a35abed3e6b898142990cecf00e8387da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a990da0f1e95dd6004fbf0cf711c53d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> = const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:a4a990da0f1e95dd6004fbf0cf711c53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae1224f3b1fbee6cc8ffa59901d6c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae2ae1224f3b1fbee6cc8ffa59901d6c8">reference</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td></tr>
<tr class="separator:ae2ae1224f3b1fbee6cc8ffa59901d6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa37d6cce7c7fe31452d2bae09dc7ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1aa37d6cce7c7fe31452d2bae09dc7ba">const_reference</a> = const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td></tr>
<tr class="separator:a1aa37d6cce7c7fe31452d2bae09dc7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301cc0a1214a6aeb04bb4e1dd06a8dfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a301cc0a1214a6aeb04bb4e1dd06a8dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34599939674e79cdc3808bb074bcf0ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a></td></tr>
<tr class="separator:a34599939674e79cdc3808bb074bcf0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gaf1654b3bfb9f92ebaa5dc7f33a323c94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf1654b3bfb9f92ebaa5dc7f33a323c94">DeclException0</a> (ExcVectorTypeNotCompatible)</td></tr>
<tr class="separator:gaf1654b3bfb9f92ebaa5dc7f33a323c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e037285504065eb4bf05124dd20600"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab1e037285504065eb4bf05124dd20600">DeclException0</a> (ExcNotAllowedForCuda)</td></tr>
<tr class="separator:gab1e037285504065eb4bf05124dd20600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc9e52579ffedc85d0c0ef0e0936f06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abcc9e52579ffedc85d0c0ef0e0936f06">DeclException3</a> (ExcNonMatchingElements, Number, Number, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;Called <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a>(<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>), but&quot;&lt;&lt; &quot; the element received from a remote processor, value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg1&lt;&lt; &quot;, does not match with the value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg2&lt;&lt; &quot; on the owner processor &quot;&lt;&lt; arg3)</td></tr>
<tr class="separator:abcc9e52579ffedc85d0c0ef0e0936f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab281998c9483096f9573b0dfd99a3f07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab281998c9483096f9573b0dfd99a3f07">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>,&lt;&lt; &quot;You tried to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed vector, but this element is not &quot;&lt;&lt; &quot;stored on the current processor. Note: The range of &quot;&lt;&lt; &quot;locally owned elements is [&quot;&lt;&lt; arg2&lt;&lt; &quot;,&quot;&lt;&lt; arg3&lt;&lt; &quot;], and there are &quot;&lt;&lt; arg4&lt;&lt; &quot; ghost elements &quot;&lt;&lt; &quot;that this vector can access.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' vector into a function &quot;&lt;&lt; &quot;that needs read access to vector elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells (or at least to &quot;&lt;&lt; &quot;'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot;'locally owned'). You need to pass a vector that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;)</td></tr>
<tr class="separator:ab281998c9483096f9573b0dfd99a3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c6facf38639f49f73a041b901a2c76"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a12c6facf38639f49f73a041b901a2c76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a12c6facf38639f49f73a041b901a2c76">operator=</a> (const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:a12c6facf38639f49f73a041b901a2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6207efeaeff0d0f321b35d29d58e8df2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a6207efeaeff0d0f321b35d29d58e8df2">compress</a> (<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:a6207efeaeff0d0f321b35d29d58e8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: Basic Object-handling</div></td></tr>
<tr class="memitem:a702bf4533c5ce7e4144d3d86afb31195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a702bf4533c5ce7e4144d3d86afb31195">Vector</a> ()</td></tr>
<tr class="separator:a702bf4533c5ce7e4144d3d86afb31195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60510dc0ed5441f1875cea6800645d3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a60510dc0ed5441f1875cea6800645d3c">Vector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:a60510dc0ed5441f1875cea6800645d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c0dfcbb628855e45e18385c0f03b8d2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3c0dfcbb628855e45e18385c0f03b8d2">Vector</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&amp;in_vector)</td></tr>
<tr class="separator:a3c0dfcbb628855e45e18385c0f03b8d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be6c4ce529bb9b6c13eb831d0a86f55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3be6c4ce529bb9b6c13eb831d0a86f55">Vector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99297a298764249d0c0b5adf9a96e1c7">size</a>)</td></tr>
<tr class="separator:a3be6c4ce529bb9b6c13eb831d0a86f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31393977fc00f2d9c46f259330ef2a23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a31393977fc00f2d9c46f259330ef2a23">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_indices, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:a31393977fc00f2d9c46f259330ef2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44feea9fec2eeab75baf051b65fa8094"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a44feea9fec2eeab75baf051b65fa8094">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:a44feea9fec2eeab75baf051b65fa8094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe52b52803ff7d23233e37083689b8f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afe52b52803ff7d23233e37083689b8f1">Vector</a> (const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a>)</td></tr>
<tr class="separator:afe52b52803ff7d23233e37083689b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e3faeced0e8afcf1208a6955e88ffd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99e3faeced0e8afcf1208a6955e88ffd">~Vector</a> () override</td></tr>
<tr class="separator:a99e3faeced0e8afcf1208a6955e88ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace027311492ed2f6e07fbd74d723e3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99297a298764249d0c0b5adf9a96e1c7">size</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ace027311492ed2f6e07fbd74d723e3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a79ca37d7f7a8cfd04f5dd61d350ae5">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;in_vector, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7415120211cbfb0b525423f5e028791e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a7415120211cbfb0b525423f5e028791e">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_indices, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:a7415120211cbfb0b525423f5e028791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86885392f82f70c0acdc2cc2fe272d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac86885392f82f70c0acdc2cc2fe272d5">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:ac86885392f82f70c0acdc2cc2fe272d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4afb6f468e902618d2f3bf41da181c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1a4afb6f468e902618d2f3bf41da181c">reinit</a> (const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a>, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:a1a4afb6f468e902618d2f3bf41da181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c95ee056cdf27d171711cd7c8f5701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac6c95ee056cdf27d171711cd7c8f5701">reinit</a> (const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abebeb6ebf3dedc1123663eae12374b06">local_size</a>, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> ghost_size, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:ac6c95ee056cdf27d171711cd7c8f5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca1b9394ef76f792c06e3d4f006b4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2ca1b9394ef76f792c06e3d4f006b4e1">swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;v)</td></tr>
<tr class="separator:a2ca1b9394ef76f792c06e3d4f006b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2a2d81a821ae954545ca77a89fa240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abb2a2d81a821ae954545ca77a89fa240">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:abb2a2d81a821ae954545ca77a89fa240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad364c47c5b3b7b991490cd626c729f0b"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ad364c47c5b3b7b991490cd626c729f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad364c47c5b3b7b991490cd626c729f0b">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:ad364c47c5b3b7b991490cd626c729f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2: Parallel data exchange</div></td></tr>
<tr class="memitem:a8a204103e550697467d933388b732bda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation) override</td></tr>
<tr class="separator:a8a204103e550697467d933388b732bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6cb7d50e02022283af53c2ae14f878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a> () const</td></tr>
<tr class="separator:a2a6cb7d50e02022283af53c2ae14f878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0c01436acde21cc2dbb5576d8f2375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aab0c01436acde21cc2dbb5576d8f2375">compress_start</a> (const unsigned <a class="el" href="classint.html">int</a> communication_channel=0, ::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>)</td></tr>
<tr class="separator:aab0c01436acde21cc2dbb5576d8f2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0b48d524285ca7b302da593b3321a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada0b48d524285ca7b302da593b3321a9">compress_finish</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ada0b48d524285ca7b302da593b3321a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7045a29ddd2b5fb86ce56c3806e08d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab7045a29ddd2b5fb86ce56c3806e08d3">update_ghost_values_start</a> (const unsigned <a class="el" href="classint.html">int</a> communication_channel=0) const</td></tr>
<tr class="separator:ab7045a29ddd2b5fb86ce56c3806e08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305a49968449aa44e998f4364838479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab305a49968449aa44e998f4364838479">update_ghost_values_finish</a> () const</td></tr>
<tr class="separator:ab305a49968449aa44e998f4364838479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc3fd03c7851d5577c159703282548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac0dc3fd03c7851d5577c159703282548">zero_out_ghosts</a> () const</td></tr>
<tr class="separator:ac0dc3fd03c7851d5577c159703282548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0242ed0c3e3664e6b4204d28a726a0b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values</a> () const</td></tr>
<tr class="separator:a0242ed0c3e3664e6b4204d28a726a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17719d884e60b2ad0077a03b92382975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a17719d884e60b2ad0077a03b92382975">has_ghost_elements</a> () const</td></tr>
<tr class="separator:a17719d884e60b2ad0077a03b92382975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab792ddb04b95a220e489f2d7f9eee990"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab792ddb04b95a220e489f2d7f9eee990"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab792ddb04b95a220e489f2d7f9eee990">copy_locally_owned_data_from</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;src)</td></tr>
<tr class="separator:ab792ddb04b95a220e489f2d7f9eee990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b743d761233b92e0ed23e6bf37a409"><td class="memTemplParams" colspan="2">template&lt;typename MemorySpace2 &gt; </td></tr>
<tr class="memitem:af7b743d761233b92e0ed23e6bf37a409"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af7b743d761233b92e0ed23e6bf37a409">import</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace2 &gt; &amp;src, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:af7b743d761233b92e0ed23e6bf37a409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3: Implementation of VectorSpaceVector</div></td></tr>
<tr class="memitem:a7bde7122a6d05d6815f507f7cb27819a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a7bde7122a6d05d6815f507f7cb27819a">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:a7bde7122a6d05d6815f507f7cb27819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85b449afaa8f491f01d7670bcc48099"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad85b449afaa8f491f01d7670bcc48099">operator*=</a> (const Number factor) override</td></tr>
<tr class="separator:ad85b449afaa8f491f01d7670bcc48099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16146ad677e926f3bdbed2aca3248247"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a16146ad677e926f3bdbed2aca3248247">operator/=</a> (const Number factor) override</td></tr>
<tr class="separator:a16146ad677e926f3bdbed2aca3248247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eabb34382bc0694390f97616742bcdf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3eabb34382bc0694390f97616742bcdf">operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a3eabb34382bc0694390f97616742bcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132ecfef78dfec86c1b6a5423d642ae0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a132ecfef78dfec86c1b6a5423d642ae0">operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a132ecfef78dfec86c1b6a5423d642ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad947177e38381c4fd058876a4f27f771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad947177e38381c4fd058876a4f27f771">import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={}) override</td></tr>
<tr class="separator:ad947177e38381c4fd058876a4f27f771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829281a9ccc9f1cf9720ee5a535efd21"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a829281a9ccc9f1cf9720ee5a535efd21">operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const override</td></tr>
<tr class="separator:a829281a9ccc9f1cf9720ee5a535efd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029174b48a0707da587b6ce3bc25047"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a> (const Number a) override</td></tr>
<tr class="separator:ac029174b48a0707da587b6ce3bc25047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d70c674b55edbb3595acaedc310996"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab7d70c674b55edbb3595acaedc310996">add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ab7d70c674b55edbb3595acaedc310996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d752a33b33192932b0dd8054d2c40e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a25d752a33b33192932b0dd8054d2c40e">add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:a25d752a33b33192932b0dd8054d2c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883f439a5130ebbbc15f765928a0ad92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a883f439a5130ebbbc15f765928a0ad92">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, const std::vector&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:a883f439a5130ebbbc15f765928a0ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6376a098589519491fc452d1529f57b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aa6376a098589519491fc452d1529f57b">sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:aa6376a098589519491fc452d1529f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf6bfd4533c47587ba0debe177710e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aacdf6bfd4533c47587ba0debe177710e">scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors) override</td></tr>
<tr class="separator:aacdf6bfd4533c47587ba0debe177710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c64a6bebc56d849307ef1fcad62c23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a43c64a6bebc56d849307ef1fcad62c23">equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a43c64a6bebc56d849307ef1fcad62c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e93518655d2231061f4eb916e98a130"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0e93518655d2231061f4eb916e98a130">l1_norm</a> () const override</td></tr>
<tr class="separator:a0e93518655d2231061f4eb916e98a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355599021a687026ab9818efd57e82d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a> () const override</td></tr>
<tr class="separator:af355599021a687026ab9818efd57e82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc4f641fb6c425eb9f12048d7e8efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aeecc4f641fb6c425eb9f12048d7e8efd">norm_sqr</a> () const</td></tr>
<tr class="separator:aeecc4f641fb6c425eb9f12048d7e8efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7bf945225df27d522ec30f1530c0aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2e7bf945225df27d522ec30f1530c0aa">linfty_norm</a> () const override</td></tr>
<tr class="separator:a2e7bf945225df27d522ec30f1530c0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc41a177aadb6a2f6d0d7c2cf41eba"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af1dc41a177aadb6a2f6d0d7c2cf41eba">add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:af1dc41a177aadb6a2f6d0d7c2cf41eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99297a298764249d0c0b5adf9a96e1c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99297a298764249d0c0b5adf9a96e1c7">size</a> () const override</td></tr>
<tr class="separator:a99297a298764249d0c0b5adf9a96e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5265a5af79342c77ac50d584c9d3e4"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aff5265a5af79342c77ac50d584c9d3e4">locally_owned_elements</a> () const override</td></tr>
<tr class="separator:aff5265a5af79342c77ac50d584c9d3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2218dcb909cf45f3e495ac250ea9260"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab2218dcb909cf45f3e495ac250ea9260">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const override</td></tr>
<tr class="separator:ab2218dcb909cf45f3e495ac250ea9260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493afd09167ce2c18d27252178d88c59"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a493afd09167ce2c18d27252178d88c59">memory_consumption</a> () const override</td></tr>
<tr class="separator:a493afd09167ce2c18d27252178d88c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">4: Other vector operations not included in VectorSpaceVector</div></td></tr>
<tr class="memitem:a85d501a9f8c20d9142fe6a0f88bb12a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a85d501a9f8c20d9142fe6a0f88bb12a4">operator=</a> (const Number s) override</td></tr>
<tr class="separator:a85d501a9f8c20d9142fe6a0f88bb12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cb76c50ddfade06995373dfc14cdb4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a79cb76c50ddfade06995373dfc14cdb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a79cb76c50ddfade06995373dfc14cdb4">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:a79cb76c50ddfade06995373dfc14cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a001329c576451c1a77557212527a"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a428a001329c576451c1a77557212527a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a428a001329c576451c1a77557212527a">add</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> n_elements, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> *indices, const OtherNumber *values)</td></tr>
<tr class="separator:a428a001329c576451c1a77557212527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cbdb2b9d3612d549e544dcd11a33ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a44cbdb2b9d3612d549e544dcd11a33ed">sadd</a> (const Number s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;V)</td></tr>
<tr class="separator:a44cbdb2b9d3612d549e544dcd11a33ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">5: Entry access and local data representation</div></td></tr>
<tr class="memitem:abebeb6ebf3dedc1123663eae12374b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abebeb6ebf3dedc1123663eae12374b06">local_size</a> () const</td></tr>
<tr class="separator:abebeb6ebf3dedc1123663eae12374b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db2bea96180138f039b9d2934534492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a> () const</td></tr>
<tr class="separator:a3db2bea96180138f039b9d2934534492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc3d0924b59159a50ed9838d8a6592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae8fc3d0924b59159a50ed9838d8a6592">in_local_range</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:ae8fc3d0924b59159a50ed9838d8a6592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd750879bde459ccb63936c74a0e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afdcd750879bde459ccb63936c74a0e87">begin</a> ()</td></tr>
<tr class="separator:afdcd750879bde459ccb63936c74a0e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae038db1a3998888e469398031da2b980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae038db1a3998888e469398031da2b980">begin</a> () const</td></tr>
<tr class="separator:ae038db1a3998888e469398031da2b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a4b780b6b8fded62768da4164d2378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab0a4b780b6b8fded62768da4164d2378">end</a> ()</td></tr>
<tr class="separator:ab0a4b780b6b8fded62768da4164d2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362987561884296cee4ba45f4fe85abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a362987561884296cee4ba45f4fe85abe">end</a> () const</td></tr>
<tr class="separator:a362987561884296cee4ba45f4fe85abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac551bfa7fd898a0a8e85f59109c091ed"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac551bfa7fd898a0a8e85f59109c091ed">operator()</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:ac551bfa7fd898a0a8e85f59109c091ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b7c43da3b837f4b811ad4cc813d899"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a58b7c43da3b837f4b811ad4cc813d899">operator()</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index)</td></tr>
<tr class="separator:a58b7c43da3b837f4b811ad4cc813d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c497852ad2b7d6917a4b60f6c7b28bf"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a5c497852ad2b7d6917a4b60f6c7b28bf">operator[]</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:a5c497852ad2b7d6917a4b60f6c7b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc5f6e645477d457a68784b83bdf582"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1bc5f6e645477d457a68784b83bdf582">operator[]</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index)</td></tr>
<tr class="separator:a1bc5f6e645477d457a68784b83bdf582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4bc946b94f19d7e11c00f41a39db02"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> local_index) const</td></tr>
<tr class="separator:a1c4bc946b94f19d7e11c00f41a39db02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397872125364fdcaf89e62f8616d7d62"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a397872125364fdcaf89e62f8616d7d62">local_element</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> local_index)</td></tr>
<tr class="separator:a397872125364fdcaf89e62f8616d7d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db545d71e642710a044554d6df060d9"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8db545d71e642710a044554d6df060d9">get_values</a> () const</td></tr>
<tr class="separator:a8db545d71e642710a044554d6df060d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49497fa8fad0250a2bd0f4a36179ff2"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ad49497fa8fad0250a2bd0f4a36179ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad49497fa8fad0250a2bd0f4a36179ff2">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;values) const</td></tr>
<tr class="separator:ad49497fa8fad0250a2bd0f4a36179ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9494a9258d9f0b06b97550921c5e0e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:aeb9494a9258d9f0b06b97550921c5e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aeb9494a9258d9f0b06b97550921c5e0e">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:aeb9494a9258d9f0b06b97550921c5e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed7dc1d792f9344f1c8720e5f639351"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a5ed7dc1d792f9344f1c8720e5f639351">all_zero</a> () const override</td></tr>
<tr class="separator:a5ed7dc1d792f9344f1c8720e5f639351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f0fddbf542f0e6ff6344e0fa7d55f9"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a64f0fddbf542f0e6ff6344e0fa7d55f9">mean_value</a> () const override</td></tr>
<tr class="separator:a64f0fddbf542f0e6ff6344e0fa7d55f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8c57a134cf1c5f27dab3a5cc1edf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8bf8c57a134cf1c5f27dab3a5cc1edf5">lp_norm</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> p) const</td></tr>
<tr class="separator:a8bf8c57a134cf1c5f27dab3a5cc1edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">6: Mixed stuff</div></td></tr>
<tr class="memitem:a995b4962ed8eee92cb0db9678c2047eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a995b4962ed8eee92cb0db9678c2047eb">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a995b4962ed8eee92cb0db9678c2047eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d72f160499a5f0bc289da5b5187546"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a57d72f160499a5f0bc289da5b5187546">get_partitioner</a> () const</td></tr>
<tr class="separator:a57d72f160499a5f0bc289da5b5187546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121c9b5aa9c34d0fe36486fecf08b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1121c9b5aa9c34d0fe36486fecf08b58">partitioners_are_compatible</a> (const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;part) const</td></tr>
<tr class="separator:a1121c9b5aa9c34d0fe36486fecf08b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f678da4f2dec42cd6f9bc383c0f3c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8f678da4f2dec42cd6f9bc383c0f3c11">partitioners_are_globally_compatible</a> (const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;part) const</td></tr>
<tr class="separator:a8f678da4f2dec42cd6f9bc383c0f3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662fd533f2cae84a902e7a587fc6f36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a662fd533f2cae84a902e7a587fc6f36c">set_ghost_state</a> (const <a class="el" href="classbool.html">bool</a> ghosted) const</td></tr>
<tr class="separator:a662fd533f2cae84a902e7a587fc6f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16bd935d90fe664309c52be1615bd4b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const Number &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad16bd935d90fe664309c52be1615bd4b">shared_vector_data</a> () const</td></tr>
<tr class="separator:ad16bd935d90fe664309c52be1615bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9f9fec5521e69ebd55f8d7dac02cf610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a9f9fec5521e69ebd55f8d7dac02cf610">add_local</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a9f9fec5521e69ebd55f8d7dac02cf610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b56c7dbbe54762d35b9f536e9d9c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac7b56c7dbbe54762d35b9f536e9d9c76">sadd_local</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ac7b56c7dbbe54762d35b9f536e9d9c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8a0511ae8151672f9a92a699523c52"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aec8a0511ae8151672f9a92a699523c52"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aec8a0511ae8151672f9a92a699523c52">inner_product_local</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;V) const</td></tr>
<tr class="separator:aec8a0511ae8151672f9a92a699523c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45739e3cb34a433f67b5c0e23fa5dcf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a45739e3cb34a433f67b5c0e23fa5dcf7">norm_sqr_local</a> () const</td></tr>
<tr class="separator:a45739e3cb34a433f67b5c0e23fa5dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab16fed261f1579c11ea5c81cb0eb7"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0cab16fed261f1579c11ea5c81cb0eb7">mean_value_local</a> () const</td></tr>
<tr class="separator:a0cab16fed261f1579c11ea5c81cb0eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df86018fd6619067a0749deb49c6288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2df86018fd6619067a0749deb49c6288">l1_norm_local</a> () const</td></tr>
<tr class="separator:a2df86018fd6619067a0749deb49c6288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b149f392aea2068ad62632dd865e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac6b149f392aea2068ad62632dd865e5c">lp_norm_local</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> p) const</td></tr>
<tr class="separator:ac6b149f392aea2068ad62632dd865e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc694084db3eb69bd8bb9439787131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a21bc694084db3eb69bd8bb9439787131">linfty_norm_local</a> () const</td></tr>
<tr class="separator:a21bc694084db3eb69bd8bb9439787131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb83d9dd19884023fb6c739c1958a7a"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1fb83d9dd19884023fb6c739c1958a7a">add_and_dot_local</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;W)</td></tr>
<tr class="separator:a1fb83d9dd19884023fb6c739c1958a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaa85ec1704806392274242fa705ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4aaa85ec1704806392274242fa705ed8">clear_mpi_requests</a> ()</td></tr>
<tr class="separator:a4aaa85ec1704806392274242fa705ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5a3788d6c951791217cd59f8cd9fbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0f5a3788d6c951791217cd59f8cd9fbc">resize_val</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> new_allocated_size, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:a0f5a3788d6c951791217cd59f8cd9fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3f1e1f118b38f6731b99f2f5bed7cd18"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a></td></tr>
<tr class="separator:a3f1e1f118b38f6731b99f2f5bed7cd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654b450369a501269a65e8fe917ef7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3654b450369a501269a65e8fe917ef7b">allocated_size</a></td></tr>
<tr class="separator:a3654b450369a501269a65e8fe917ef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e986decf5878ef8fc13c691910bf263"><td class="memItemLeft" align="right" valign="top">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt; Number, MemorySpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2e986decf5878ef8fc13c691910bf263">data</a></td></tr>
<tr class="separator:a2e986decf5878ef8fc13c691910bf263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22a8f4e80c1fe4ff79779dcda71a0b9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aa22a8f4e80c1fe4ff79779dcda71a0b9">thread_loop_partitioner</a></td></tr>
<tr class="separator:aa22a8f4e80c1fe4ff79779dcda71a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e2584032a7c664c2c28c0436cd6ce"><td class="memItemLeft" align="right" valign="top">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt; Number, MemorySpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2c7e2584032a7c664c2c28c0436cd6ce">import_data</a></td></tr>
<tr class="separator:a2c7e2584032a7c664c2c28c0436cd6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41fb0de7a379de6c6a58801bd93827b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af41fb0de7a379de6c6a58801bd93827b">vector_is_ghosted</a></td></tr>
<tr class="separator:af41fb0de7a379de6c6a58801bd93827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53eaaa25a65ca1ce774e713dd37154c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classMPI__Request.html">MPI_Request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae53eaaa25a65ca1ce774e713dd37154c">compress_requests</a></td></tr>
<tr class="separator:ae53eaaa25a65ca1ce774e713dd37154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6604e63e86194c350e0c1ab9d70387"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classMPI__Request.html">MPI_Request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada6604e63e86194c350e0c1ab9d70387">update_ghost_values_requests</a></td></tr>
<tr class="separator:ada6604e63e86194c350e0c1ab9d70387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ca9ef90490cbf818d17fcca54a76f2"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af2ca9ef90490cbf818d17fcca54a76f2">mutex</a></td></tr>
<tr class="separator:af2ca9ef90490cbf818d17fcca54a76f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d06704d2372317ea90b5e5bd9c1dc9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a></td></tr>
<tr class="separator:a4d06704d2372317ea90b5e5bd9c1dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac14c06b74acbf135ede85924e7b3d521"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename MemorySpace2 &gt; </td></tr>
<tr class="memitem:ac14c06b74acbf135ede85924e7b3d521"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac14c06b74acbf135ede85924e7b3d521">Vector</a></td></tr>
<tr class="separator:ac14c06b74acbf135ede85924e7b3d521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c61e4419c2e58a70f3798109c14fac"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a07c61e4419c2e58a70f3798109c14fac"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a07c61e4419c2e58a70f3798109c14fac">BlockVector</a></td></tr>
<tr class="separator:a07c61e4419c2e58a70f3798109c14fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt;<br />
class LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</h3>

<p>Implementation of a parallel vector class. The design of this class is similar to the standard <a class="el" href="classVector.html">Vector</a> class in deal.II, with the exception that storage is distributed with MPI.</p>
<p>The vector is designed for the following scheme of parallel partitioning: </p><ul>
<li>
The indices held by individual processes (locally owned part) in the MPI parallelization form a contiguous range <code>[my_first_index,my_last_index)</code>. </li>
<li>
Ghost indices residing on arbitrary positions of other processors are allowed. It is in general more efficient if ghost indices are clustered, since they are stored as a set of intervals. The communication pattern of the ghost indices is determined when calling the function <code>reinit (locally_owned, ghost_indices, communicator)</code>, and retained until the partitioning is changed. This allows for efficient parallel communication of indices. In particular, it stores the communication pattern, rather than having to compute it again for every communication. For more information on ghost vectors, see also the <a class="el" href="DEALGlossary.html#GlossGhostedVector">glossary entry on vectors with ghost elements</a>. </li>
<li>
Besides the usual global access operator() it is also possible to access vector entries in the local index space with the function <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element()</a></code>. Locally owned indices are placed first, [0, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>), and then all ghost indices follow after them contiguously, [<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>+n_ghost_entries()). </li>
</ul>
<p><a class="el" href="namespaceFunctions.html">Functions</a> related to parallel functionality: </p><ul>
<li>
The function <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a></code> goes through the data associated with ghost indices and communicates it to the owner process, which can then add it to the correct position. This can be used e.g. after having run an assembly routine involving ghosts that fill this vector. Note that the <code>insert</code> mode of <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a></code> does not set the elements included in ghost entries but simply discards them, assuming that the owning processor has set them to the desired value already (See also the <a class="el" href="DEALGlossary.html#GlossCompress">glossary entry on compress</a>). </li>
<li>
The <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> function imports the data from the owning processor to the ghost indices in order to provide read access to the data associated with ghosts. </li>
<li>
It is possible to split the above functions into two phases, where the first initiates the communication and the second one finishes it. These functions can be used to overlap communication with computations in other parts of the code. </li>
<li>
Of course, reduction operations (like norms) make use of collective all-to-all MPI communications. </li>
</ul>
<p>This vector can take two different states with respect to ghost elements: </p><ul>
<li>
After creation and whenever <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values()</a> is called (or <code>operator= (0.)</code>), the vector does only allow writing into ghost elements but not reading from ghost elements. </li>
<li>
After a call to <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a>, the vector does not allow writing into ghost elements but only reading from them. This is to avoid undesired ghost data artifacts when calling <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a> after modifying some vector entries. The current status of the ghost entries (read mode or write mode) can be queried by the method <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a17719d884e60b2ad0077a03b92382975">has_ghost_elements()</a>, which returns <code>true</code> exactly when ghost elements have been updated and <code>false</code> otherwise, irrespective of the actual number of ghost entries in the vector layout (for that information, use n_ghost_entries() instead). </li>
</ul>
<p>This vector uses the facilities of the class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;Number&gt;</a> for implementing the operations on the local range of the vector. In particular, it also inherits thread parallelism that splits most vector-vector operations into smaller chunks if the program uses multiple threads. This may or may not be desired when working also with MPI.</p>
<h4>Limitations regarding the vector size</h4>
<p>This vector class is based on two different number types for indexing. The so-called global index type encodes the overall size of the vector. Its type is <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>. The largest possible value is <code>2^32-1</code> or approximately 4 billion in case 64 bit integers are disabled at configuration of deal.II (default case) or <code>2^64-1</code> or approximately <code>10^19</code> if 64 bit integers are enabled (see the glossary entry on <a class="el" href="GlobalDoFIndex.html">When to use types::global_dof_index instead of unsigned int</a> for further information).</p>
<p>The second relevant index type is the local index used within one MPI rank. As opposed to the global index, the implementation assumes 32-bit unsigned integers unconditionally. In other words, to actually use a vector with more than four billion entries, you need to use MPI with more than one rank (which in general is a safe assumption since four billion entries consume at least 16 GB of memory for floats or 32 GB of memory for doubles) and enable 64-bit indices. If more than 4 billion local elements are present, the implementation tries to detect that, which triggers an exception and aborts the code. Note, however, that the detection of overflow is tricky and the detection mechanism might fail in some circumstances. Therefore, it is strongly recommended to not rely on this class to automatically detect the unsupported case.</p>
<h4>CUDA support</h4>
<p>This vector class supports two different memory spaces: Host and CUDA. By default, the memory space is Host and all the data are allocated on the CPU. When the memory space is CUDA, all the data is allocated on the GPU. The operations on the vector are performed on the chosen memory space. * From the host, there are two methods to access the elements of the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> when using the CUDA memory space: </p><ul>
<li>
use <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8db545d71e642710a044554d6df060d9">get_values()</a>: <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double, MemorySpace::CUDA&gt;</a> vector(local_range, comm);</div><div class="line"><span class="keywordtype">double</span>* vector_dev = vector.get_values();</div><div class="line">std::vector&lt;double&gt; vector_host(local_range.n_elements(), 1.);</div><div class="line"><a class="code" href="namespaceUtilities_1_1CUDA.html#ac1dc5c1fa14486b8cdb971eca200bd9d">Utilities::CUDA::copy_to_dev</a>(vector_host, vector_dev);</div></div><!-- fragment --> </li>
<li>
use <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af7b743d761233b92e0ed23e6bf37a409">import()</a>: <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double, MemorySpace::CUDA&gt;</a> vector(local_range, comm);</div><div class="line">ReadWriteVector&lt;double&gt; rw_vector(local_range);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; val : rw_vector)</div><div class="line">  val = 1.;</div><div class="line">vector.import(rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --> </li>
</ul>
<p>The import method is a lot safer and will perform an MPI communication if necessary. Since an MPI communication may be performed, import needs to be called on all the processors.</p>
<dl class="section note"><dt>Note</dt><dd>By default, all the ranks will try to access the device 0. This is fine is if you have one rank per node and one gpu per node. If you have multiple GPUs on one node, we need each process to access a different GPU. If each node has the same number of GPUs, this can be done as follows: <code> int n_devices = 0; cudaGetDeviceCount(&amp;n_devices); int device_id = my_rank % n_devices; cudaSetDevice(device_id); </code></dd></dl>
<h4>MPI-3 shared-memory support</h4>
<p>In Host mode, this class allows to use MPI-3 shared-memory features by providing a separate MPI communicator that consists of processes on the same shared-memory domain. By calling <code>vector.shared_vector_data();</code>, users have read-only access to both locally-owned and ghost values of processes combined in the shared-memory communicator (<code>comm_sm</code> in <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit()</a>).</p>
<p>For this to work, you have to call the constructor or one of the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit()</a> functions of this class with a non-default value for the <code>comm_sm</code> argument, where the argument corresponds to a communicator consisting of all processes on the same shared-memory domain. This kind of communicator can be created using the following code snippet: </p><div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>;</div><div class="line">MPI_Comm_split_type(comm, MPI_COMM_TYPE_SHARED, rank, MPI_INFO_NULL,</div><div class="line">                    &amp;comm_sm);</div></div><!-- fragment --><dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceLinearAlgebra_1_1CUDAWrappers.html">CUDAWrappers</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00248">248</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae018e039c0ca78a063c6a075be461283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae018e039c0ca78a063c6a075be461283">&#9670;&nbsp;</a></span>memory_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae018e039c0ca78a063c6a075be461283">memory_space</a> =  MemorySpace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00252">252</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="aca4439cf261c308591c649e442d097ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4439cf261c308591c649e442d097ea">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00253">253</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ae5c3b93ed114bc9795c0e3b3d5902393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c3b93ed114bc9795c0e3b3d5902393">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae5c3b93ed114bc9795c0e3b3d5902393">pointer</a> =  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00254">254</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a84413e605d193829856edbaa9d75b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84413e605d193829856edbaa9d75b57b">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a84413e605d193829856edbaa9d75b57b">const_pointer</a> =  const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00255">255</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a35abed3e6b898142990cecf00e8387da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35abed3e6b898142990cecf00e8387da">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> =  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00256">256</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a4a990da0f1e95dd6004fbf0cf711c53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a990da0f1e95dd6004fbf0cf711c53d">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> =  const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00257">257</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ae2ae1224f3b1fbee6cc8ffa59901d6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae1224f3b1fbee6cc8ffa59901d6c8">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae2ae1224f3b1fbee6cc8ffa59901d6c8">reference</a> =  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00258">258</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a1aa37d6cce7c7fe31452d2bae09dc7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa37d6cce7c7fe31452d2bae09dc7ba">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1aa37d6cce7c7fe31452d2bae09dc7ba">const_reference</a> =  const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00259">259</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a301cc0a1214a6aeb04bb4e1dd06a8dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301cc0a1214a6aeb04bb4e1dd06a8dfc">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00260">260</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a34599939674e79cdc3808bb074bcf0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34599939674e79cdc3808bb074bcf0ee">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00261">261</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a702bf4533c5ce7e4144d3d86afb31195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702bf4533c5ce7e4144d3d86afb31195">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Empty constructor. </p>

</div>
</div>
<a id="a60510dc0ed5441f1875cea6800645d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60510dc0ed5441f1875cea6800645d3c">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copy constructor. Uses the parallel partitioning of <code>in_vector</code>. It should be noted that this constructor automatically sets ghost values to zero. Call <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> directly following construction if a ghosted vector is required. </p>

</div>
</div>
<a id="a3c0dfcbb628855e45e18385c0f03b8d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c0dfcbb628855e45e18385c0f03b8d2">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Move constructor. Uses the swap method.</p>
<dl class="section note"><dt>Note</dt><dd>In order for this constructor to leave the moved-from object in a valid state it must allocate memory (in this case, an empty partitioner) - hence it cannot be marked as noexcept. </dd></dl>

</div>
</div>
<a id="a3be6c4ce529bb9b6c13eb831d0a86f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be6c4ce529bb9b6c13eb831d0a86f55">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a parallel vector of the given global size without any actual parallel distribution. </p>

</div>
</div>
<a id="a31393977fc00f2d9c46f259330ef2a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31393977fc00f2d9c46f259330ef2a23">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a parallel vector. The local range is specified by <code>locally_owned_set</code> (note that this must be a contiguous interval, multiple intervals are not possible). The <a class="el" href="classIndexSet.html">IndexSet</a> <code>ghost_indices</code> specifies ghost indices, i.e., indices which one might need to read data from or accumulate data from. It is allowed that the set of ghost indices also contains the local range, but it does not need to.</p>
<p>This function involves global communication, so it should only be called once for a given layout. Use the constructor with <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;Number&gt;</a> argument to create additional vectors with the same parallel layout.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="a44feea9fec2eeab75baf051b65fa8094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44feea9fec2eeab75baf051b65fa8094">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same constructor as above but without any ghost indices. </p>

</div>
</div>
<a id="afe52b52803ff7d23233e37083689b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe52b52803ff7d23233e37083689b8f1">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the vector based on the parallel partitioning described in <code>partitioner</code>. The input argument is a shared pointer, which stores the partitioner data only once and share it between several vectors with the same layout. </p>

</div>
</div>
<a id="a99e3faeced0e8afcf1208a6955e88ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e3faeced0e8afcf1208a6955e88ffd">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::~<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace027311492ed2f6e07fbd74d723e3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace027311492ed2f6e07fbd74d723e3a9">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the global size of the vector to <code>size</code> without any actual parallel distribution. </p>

</div>
</div>
<a id="a8a79ca37d7f7a8cfd04f5dd61d350ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a79ca37d7f7a8cfd04f5dd61d350ae5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uses the parallel layout of the input vector <code>in_vector</code> and allocates memory for this vector. Recommended initialization function when several vectors with the same layout should be created.</p>
<p>If the flag <code>omit_zeroing_entries</code> is set to false, the memory will be initialized with zero, otherwise the memory will be untouched (and the user must make sure to fill it with reasonable data before using it). </p>

</div>
</div>
<a id="a7415120211cbfb0b525423f5e028791e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7415120211cbfb0b525423f5e028791e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector. The local range is specified by <code>locally_owned_set</code> (note that this must be a contiguous interval, multiple intervals are not possible). The <a class="el" href="classIndexSet.html">IndexSet</a> <code>ghost_indices</code> specifies ghost indices, i.e., indices which one might need to read data from or accumulate data from. It is allowed that the set of ghost indices also contains the local range, but it does not need to.</p>
<p>This function involves global communication, so it should only be called once for a given layout. Use the <code>reinit</code> function with <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;Number&gt;</a> argument to create additional vectors with the same parallel layout.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="ac86885392f82f70c0acdc2cc2fe272d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86885392f82f70c0acdc2cc2fe272d5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but without ghost entries. </p>

</div>
</div>
<a id="a1a4afb6f468e902618d2f3bf41da181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4afb6f468e902618d2f3bf41da181c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the vector given to the parallel partitioning described in <code>partitioner</code>. The input argument is a shared pointer, which stores the partitioner data only once and share it between several vectors with the same layout.</p>
<p>The optional argument <code>comm_sm</code>, which consists of processes on the same shared-memory domain, allows users have read-only access to both locally-owned and ghost values of processes combined in the shared-memory communicator. See the general documentation of this class for more information about this argument. </p>

</div>
</div>
<a id="ac6c95ee056cdf27d171711cd7c8f5701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c95ee056cdf27d171711cd7c8f5701">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>local_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>ghost_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize vector with <code>local_size</code> locally-owned and <code>ghost_size</code> ghost degrees of freedoms.</p>
<p>The optional argument <code>comm_sm</code>, which consists of processes on the same shared-memory domain, allows users have read-only access to both locally-owned and ghost values of processes combined in the shared-memory communicator. See the general documentation of this class for more information about this argument.</p>
<dl class="section note"><dt>Note</dt><dd>In the created underlying partitioner, the local index range is translated to global indices in an ascending and one-to-one fashion, i.e., the indices of process \(p\) sit exactly between the indices of the processes \(p-1\) and \(p+1\), respectively. Setting the <code>ghost_size</code> variable to an appropriate value provides memory space for the ghost data in a vector's memory allocation as and allows access to it via <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>. However, the associated global indices must be handled externally in this case. </dd></dl>

</div>
</div>
<a id="a2ca1b9394ef76f792c06e3d4f006b4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca1b9394ef76f792c06e3d4f006b4e1">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Swap the contents of this vector and the other vector <code>v</code>. One could do this operation with a temporary variable and copying over the data elements, but this function is significantly more efficient since it only swaps the pointers to the data of the two vectors and therefore does not need to allocate temporary storage and move data around.</p>
<p>This function is analogous to the <code>swap</code> function of all C++ standard containers. Also, there is a global function <code>swap(u,v)</code> that simply calls <code>u.swap(v)</code>, again in analogy to standard functions. </p>

</div>
</div>
<a id="abb2a2d81a821ae954545ca77a89fa240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2a2d81a821ae954545ca77a89fa240">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns the vector to the parallel partitioning of the input vector <code>in_vector</code>, and copies all the data.</p>
<p>If one of the input vector or the calling vector (to the left of the assignment operator) had ghost elements set before this operation, the calling vector will have ghost values set. Otherwise, it will be in write mode. If the input vector does not have any ghost elements at all, the vector will also update its ghost values in analogy to the respective setting the Trilinos and PETSc vectors. </p>

</div>
</div>
<a id="ad364c47c5b3b7b991490cd626c729f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad364c47c5b3b7b991490cd626c729f0b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assigns the vector to the parallel partitioning of the input vector <code>in_vector</code>, and copies all the data.</p>
<p>If one of the input vector or the calling vector (to the left of the assignment operator) had ghost elements set before this operation, the calling vector will have ghost values set. Otherwise, it will be in write mode. If the input vector does not have any ghost elements at all, the vector will also update its ghost values in analogy to the respective setting the Trilinos and PETSc vectors. </p>

</div>
</div>
<a id="a8a204103e550697467d933388b732bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a204103e550697467d933388b732bda">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function copies the data that has accumulated in the data buffer for ghost indices to the owning processor. For the meaning of the argument <code>operation</code>, see the entry on <a class="el" href="DEALGlossary.html#GlossCompress">Compressing distributed vectors and matrices</a> in the glossary.</p>
<p>There are four variants for this function. If called with argument <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code> adds all the data accumulated in ghost elements to the respective elements on the owning processor and clears the ghost array afterwards. If called with argument <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a></code>, a set operation is performed. Since setting elements in a vector with ghost elements is ambiguous (as one can set both the element on the ghost site as well as the owning site), this operation makes the assumption that all data is set correctly on the owning processor. Upon call of compress(VectorOperation::insert), all ghost entries are thus simply zeroed out (using zero_ghost_values()). In debug mode, a check is performed for whether the data set is actually consistent between processors, i.e., whenever a non-zero ghost element is found, it is compared to the value on the owning processor and an exception is thrown if these elements do not agree. If called with <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a> or <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>, the minimum or maximum on all elements across the processors is set. </p><dl class="section note"><dt>Note</dt><dd>This vector class has a fixed set of ghost entries attached to the local representation. As a consequence, all ghost entries are assumed to be valid and will be exchanged unconditionally according to the given <a class="el" href="structVectorOperation.html">VectorOperation</a>. Make sure to initialize all ghost entries with the neutral element of the given <a class="el" href="structVectorOperation.html">VectorOperation</a> or touch all ghost entries. The neutral element is zero for <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a> and <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>, <code>+inf</code> for <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a>, and <code>-inf</code> for <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>. If all values are initialized with values below zero and compress is called with <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a> two times subsequently, the maximal value after the second calculation will be zero. </dd></dl>

</div>
</div>
<a id="a2a6cb7d50e02022283af53c2ae14f878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6cb7d50e02022283af53c2ae14f878">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills the data field for ghost indices with the values stored in the respective positions of the owning processor. This function is needed before reading from ghosts. The function is <code>const</code> even though ghost data is changed. This is needed to allow functions with a <code>const</code> vector to perform the data exchange without creating temporaries.</p>
<p>After calling this method, write access to ghost elements of the vector is forbidden and an exception is thrown. Only read access to ghost elements is allowed in this state. Note that all subsequent operations on this vector, like global vector addition, etc., will also update the ghost values by a call to this method after the operation. However, global reduction operations like norms or the inner product will always ignore ghost elements in order to avoid counting the ghost data more than once. To allow writing to ghost elements again, call <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values()</a>.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="aab0c01436acde21cc2dbb5576d8f2375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0c01436acde21cc2dbb5576d8f2375">&#9670;&nbsp;</a></span>compress_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_start </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>communication_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates communication for the <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a></code> function with non- blocking communication. This function does not wait for the transfer to finish, in order to allow for other computations during the time it takes until all data arrives.</p>
<p>Before the data is actually exchanged, the function must be followed by a call to <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada0b48d524285ca7b302da593b3321a9">compress_finish()</a></code>.</p>
<p>In case this function is called for more than one vector before <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada0b48d524285ca7b302da593b3321a9">compress_finish()</a></code> is invoked, it is mandatory to specify a unique communication channel to each such call, in order to avoid several messages with the same ID that will corrupt this operation. Any communication channel less than 100 is a valid value (in particular, the range \([100, 200)\) is reserved for <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>). </p>

</div>
</div>
<a id="ada0b48d524285ca7b302da593b3321a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0b48d524285ca7b302da593b3321a9">&#9670;&nbsp;</a></span>compress_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_finish </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all requests that have been initiated in compress_start, wait for the communication to finish. Once it is finished, add or set the data (depending on the flag operation) to the respective positions in the owning processor, and clear the contents in the ghost data fields. The meaning of this argument is the same as in <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a>.</p>
<p>This function should be called exactly once per vector after calling compress_start, otherwise the result is undefined. In particular, it is not well-defined to call compress_start on the same vector again before compress_finished has been called. However, there is no warning to prevent this situation.</p>
<p>Must follow a call to the <code>compress_start</code> function.</p>
<p>When the <a class="el" href="namespaceMemorySpace.html">MemorySpace</a> is CUDA and MPI is not CUDA-aware, data changed on the device after the call to compress_start will be lost. </p>

</div>
</div>
<a id="ab7045a29ddd2b5fb86ce56c3806e08d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7045a29ddd2b5fb86ce56c3806e08d3">&#9670;&nbsp;</a></span>update_ghost_values_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_start </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>communication_channel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates communication for the <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> function with non-blocking communication. This function does not wait for the transfer to finish, in order to allow for other computations during the time it takes until all data arrives.</p>
<p>Before the data is actually exchanged, the function must be followed by a call to <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab305a49968449aa44e998f4364838479">update_ghost_values_finish()</a></code>.</p>
<p>In case this function is called for more than one vector before <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab305a49968449aa44e998f4364838479">update_ghost_values_finish()</a></code> is invoked, it is mandatory to specify a unique communication channel to each such call, in order to avoid several messages with the same ID that will corrupt this operation. Any communication channel less than 100 is a valid value (in particular, the range \([100, 200)\) is reserved for <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>). </p>

</div>
</div>
<a id="ab305a49968449aa44e998f4364838479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab305a49968449aa44e998f4364838479">&#9670;&nbsp;</a></span>update_ghost_values_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For all requests that have been started in update_ghost_values_start, wait for the communication to finish.</p>
<p>Must follow a call to the <code>update_ghost_values_start</code> function before reading data from ghost indices. </p>

</div>
</div>
<a id="ac0dc3fd03c7851d5577c159703282548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dc3fd03c7851d5577c159703282548">&#9670;&nbsp;</a></span>zero_out_ghosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::zero_out_ghosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000044">Deprecated:</a></b></dt><dd>Use <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values()</a> instead. </dd></dl>

</div>
</div>
<a id="a0242ed0c3e3664e6b4204d28a726a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0242ed0c3e3664e6b4204d28a726a0b7">&#9670;&nbsp;</a></span>zero_out_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::zero_out_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method zeros the entries on ghost dofs, but does not touch locally owned DoFs.</p>
<p>After calling this method, read access to ghost elements of the vector is forbidden and an exception is thrown. Only write access to ghost elements is allowed in this state. </p>

</div>
</div>
<a id="a17719d884e60b2ad0077a03b92382975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17719d884e60b2ad0077a03b92382975">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return whether the vector currently is in a state where ghost values can be read or not. This is the same functionality as other parallel vectors have. If this method returns false, this only means that read-access to ghost elements is prohibited whereas write access is still possible (to those entries specified as ghosts during initialization), not that there are no ghost elements at all.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">vectors with ghost elements</a> </dd></dl>

</div>
</div>
<a id="ab792ddb04b95a220e489f2d7f9eee990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab792ddb04b95a220e489f2d7f9eee990">&#9670;&nbsp;</a></span>copy_locally_owned_data_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::copy_locally_owned_data_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This method copies the data in the locally owned range from another distributed vector <code>src</code> into the calling vector. As opposed to operator= that also includes ghost entries, this operation ignores the ghost range. The only prerequisite is that the local range on the calling vector and the given vector <code>src</code> are the same on all processors. It is explicitly allowed that the two vectors have different ghost elements that might or might not be related to each other.</p>
<p>Since no data exchange is performed, make sure that neither <code>src</code> nor the calling vector have pending communications in order to obtain correct results. </p>

</div>
</div>
<a id="af7b743d761233b92e0ed23e6bf37a409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b743d761233b92e0ed23e6bf37a409">&#9670;&nbsp;</a></span>import() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename MemorySpace2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Import all the elements present in the distributed vector <code>src</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The main purpose of this function is to get data from one memory space, e.g. CUDA, to the other, e.g. the Host.</p>
<dl class="section note"><dt>Note</dt><dd>The partitioners of the two distributed vectors need to be the same as no MPI communication is performed. </dd></dl>

</div>
</div>
<a id="a7bde7122a6d05d6815f507f7cb27819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bde7122a6d05d6815f507f7cb27819a">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Change the dimension to that of the vector V. The elements of V are not copied. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ad85b449afaa8f491f01d7670bcc48099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85b449afaa8f491f01d7670bcc48099">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiply the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a16146ad677e926f3bdbed2aca3248247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16146ad677e926f3bdbed2aca3248247">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Divide the entire vector by a fixed factor. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a3eabb34382bc0694390f97616742bcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eabb34382bc0694390f97616742bcdf">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add the vector <code>V</code> to the present one. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a132ecfef78dfec86c1b6a5423d642ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132ecfef78dfec86c1b6a5423d642ae0">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subtract the vector <code>V</code> from the present one. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ad947177e38381c4fd058876a4f27f771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad947177e38381c4fd058876a4f27f771">&#9670;&nbsp;</a></span>import() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Import all the elements present in the vector's <a class="el" href="classIndexSet.html">IndexSet</a> from the input vector <code>V</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> is used to decide if the elements in <code>V</code> should be added to the current vector or replace the current elements. The last parameter can be used if the same communication pattern is used multiple times. This can be used to improve performance.</p>
<dl class="section note"><dt>Note</dt><dd>If the <a class="el" href="namespaceMemorySpace.html">MemorySpace</a> is CUDA, the data in the <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">ReadWriteVector</a> will be moved to the device. </dd></dl>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a829281a9ccc9f1cf9720ee5a535efd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829281a9ccc9f1cf9720ee5a535efd21">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the scalar product of two vectors. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#abe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ac029174b48a0707da587b6ce3bc25047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029174b48a0707da587b6ce3bc25047">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add <code>a</code> to all components. Note that <code>a</code> is a scalar not a vector. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ab7d70c674b55edbb3595acaedc310996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d70c674b55edbb3595acaedc310996">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a25d752a33b33192932b0dd8054d2c40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d752a33b33192932b0dd8054d2c40e">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Multiple addition of scaled vectors, i.e. <code>*this += a*V+b*W</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#abc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a883f439a5130ebbbc15f765928a0ad92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883f439a5130ebbbc15f765928a0ad92">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A collective add operation: This function adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="aa6376a098589519491fc452d1529f57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6376a098589519491fc452d1529f57b">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code>*this = s*(*this)+a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="aacdf6bfd4533c47587ba0debe177710e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf6bfd4533c47587ba0debe177710e">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scale each element of this vector by the corresponding element in the argument. This function is mostly meant to simulate multiplication (and immediate re-assignment) by a diagonal scaling matrix. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a43c64a6bebc56d849307ef1fcad62c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c64a6bebc56d849307ef1fcad62c23">&#9670;&nbsp;</a></span>equ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assignment <code>*this = a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a0e93518655d2231061f4eb916e98a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e93518655d2231061f4eb916e98a130">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the l<sub>1</sub> norm of the vector (i.e., the sum of the absolute values of all entries among all processors). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="af355599021a687026ab9818efd57e82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af355599021a687026ab9818efd57e82d">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the \(l_2\) norm of the vector (i.e., the square root of the sum of the square of all entries among all processors). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="aeecc4f641fb6c425eb9f12048d7e8efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc4f641fb6c425eb9f12048d7e8efd">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the square of the \(l_2\) norm of the vector. </p>

</div>
</div>
<a id="a2e7bf945225df27d522ec30f1530c0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7bf945225df27d522ec30f1530c0aa">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the maximum norm of the vector (i.e., the maximum absolute value among all entries and among all processors). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#af84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="af1dc41a177aadb6a2f6d0d7c2cf41eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dc41a177aadb6a2f6d0d7c2cf41eba">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Perform a combined operation of a vector addition and a subsequent inner product, returning the value of the inner product. In other words, the result of this function is the same as if the user called </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value = *<span class="keyword">this</span> * W;</div></div><!-- fragment --><p>The reason this function exists is that this operation involves less memory transfer than calling the two functions separately. This method only needs to load three vectors, <code>this</code>, <code>V</code>, <code>W</code>, whereas calling separate methods means to load the calling vector <code>this</code> twice. Since most vector operations are memory transfer limited, this reduces the time by 25% (or 50% if <code>W</code> equals <code>this</code>).</p>
<p>For complex-valued vectors, the scalar product in the second step is implemented as \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\). </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a99297a298764249d0c0b5adf9a96e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99297a298764249d0c0b5adf9a96e1c7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the global size of the vector, equal to the sum of the number of locally owned indices among all processors. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="aff5265a5af79342c77ac50d584c9d3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5265a5af79342c77ac50d584c9d3e4">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an index set that describes which elements of this vector are owned by the current processor. As a consequence, the index sets returned on different processors if this is a distributed vector will form disjoint sets that add up to the complete index set. Obviously, if a vector is created on only one processor, then the result would satisfy </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div></div><!-- fragment --> 
<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ab2218dcb909cf45f3e495ac250ea9260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2218dcb909cf45f3e495ac250ea9260">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print the vector to the output stream <code>out</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a493afd09167ce2c18d27252178d88c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493afd09167ce2c18d27252178d88c59">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the memory consumption of this class in bytes. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a85d501a9f8c20d9142fe6a0f88bb12a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d501a9f8c20d9142fe6a0f88bb12a4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets all elements of the vector to the scalar <code>s</code>. If the scalar is zero, also ghost elements are set to zero, otherwise they remain unchanged. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#ae5dd9195f5c8988b1c8d9cd7878228cb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a79cb76c50ddfade06995373dfc14cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cb76c50ddfade06995373dfc14cdb4">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This is a collective add operation that adds a whole set of values stored in <code>values</code> to the vector components specified by <code>indices</code>. </p>

</div>
</div>
<a id="a428a001329c576451c1a77557212527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428a001329c576451c1a77557212527a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take an address where n_elements are stored contiguously and add them into the vector. </p>

</div>
</div>
<a id="a44cbdb2b9d3612d549e544dcd11a33ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cbdb2b9d3612d549e544dcd11a33ed">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scaling and simple vector addition, i.e. <code>*this = s*(*this)+V</code>. </p>

</div>
</div>
<a id="abebeb6ebf3dedc1123663eae12374b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebeb6ebf3dedc1123663eae12374b06">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local size of the vector, i.e., the number of indices owned locally.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>Use <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a> instead. </dd></dl>

</div>
</div>
<a id="a3db2bea96180138f039b9d2934534492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db2bea96180138f039b9d2934534492">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the local size of the vector, i.e., the number of indices owned locally. </p>

</div>
</div>
<a id="ae8fc3d0924b59159a50ed9838d8a6592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc3d0924b59159a50ed9838d8a6592">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given global index is in the local range of this processor. </p>

</div>
</div>
<a id="afdcd750879bde459ccb63936c74a0e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd750879bde459ccb63936c74a0e87">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make the <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></code> class a bit like the <code>vector&lt;&gt;</code> class of the C++ standard library by returning iterators to the start and end of the <em>locally owned</em> elements of this vector.</p>
<p>It holds that <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab0a4b780b6b8fded62768da4164d2378">end()</a> - <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afdcd750879bde459ccb63936c74a0e87">begin()</a> == <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="ae038db1a3998888e469398031da2b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae038db1a3998888e469398031da2b980">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return constant iterator to the start of the locally owned elements of the vector.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="ab0a4b780b6b8fded62768da4164d2378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a4b780b6b8fded62768da4164d2378">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return an iterator pointing to the element past the end of the array of locally owned entries.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="a362987561884296cee4ba45f4fe85abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362987561884296cee4ba45f4fe85abe">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a constant iterator pointing to the element past the end of the array of the locally owned entries.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the iterator points to memory on the device. </dd></dl>

</div>
</div>
<a id="ac551bfa7fd898a0a8e85f59109c091ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac551bfa7fd898a0a8e85f59109c091ed">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>Performance: <code>O(1)</code> for locally owned elements that represent a contiguous range and <code>O(log(n<sub>ranges</sub>))</code> for ghost elements (quite fast, but slower than <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>). </p>

</div>
</div>
<a id="a58b7c43da3b837f4b811ad4cc813d899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b7c43da3b837f4b811ad4cc813d899">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>Performance: <code>O(1)</code> for locally owned elements that represent a contiguous range and <code>O(log(n<sub>ranges</sub>))</code> for ghost elements (quite fast, but slower than <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>). </p>

</div>
</div>
<a id="a5c497852ad2b7d6917a4b60f6c7b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c497852ad2b7d6917a4b60f6c7b28bf">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="a1bc5f6e645477d457a68784b83bdf582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc5f6e645477d457a68784b83bdf582">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data in the position corresponding to <code>global_index</code>. The index must be either in the local range of the vector or be specified as a ghost index at construction.</p>
<p>This function does the same thing as operator(). </p>

</div>
</div>
<a id="a1c4bc946b94f19d7e11c00f41a39db02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4bc946b94f19d7e11c00f41a39db02">&#9670;&nbsp;</a></span>local_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read access to the data field specified by <code>local_index</code>. Locally owned indices can be accessed with indices <code>[0,locally_owned_size)</code>, and ghost indices with indices <code>[locally_owned_size,locally_owned_size+ n_ghost_entries]</code>.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="a397872125364fdcaf89e62f8616d7d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397872125364fdcaf89e62f8616d7d62">&#9670;&nbsp;</a></span>local_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read and write access to the data field specified by <code>local_index</code>. Locally owned indices can be accessed with indices <code>[0,<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>)</code>, and ghost indices with indices <code>[<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>+n_ghosts]</code>.</p>
<p>Performance: Direct array access (fast). </p>

</div>
</div>
<a id="a8db545d71e642710a044554d6df060d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db545d71e642710a044554d6df060d9">&#9670;&nbsp;</a></span>get_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the pointer to the underlying raw array.</p>
<dl class="section note"><dt>Note</dt><dd>For the CUDA memory space, the pointer points to memory on the device. </dd></dl>

</div>
</div>
<a id="ad49497fa8fad0250a2bd0f4a36179ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49497fa8fad0250a2bd0f4a36179ff2">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. The indices of the elements to be read are stated in the first argument, the corresponding values are returned in the second.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>The sizes of the <code>indices</code> and <code>values</code> arrays must be identical.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function is not implemented for CUDA memory space. </dd></dl>

</div>
</div>
<a id="aeb9494a9258d9f0b06b97550921c5e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9494a9258d9f0b06b97550921c5e0e">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of getting individual elements of a vector via operator(), this function allows getting a whole set of elements at once. In contrast to the previous function, this function obtains the indices of the elements by dereferencing all elements of the iterator range provided by the first two arguments, and puts the vector values into memory locations obtained by dereferencing a range of iterators starting at the location pointed to by the third argument.</p>
<p>If the current vector is called <code>v</code>, then this function is the equivalent to the code </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line">  *values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --><dl class="section pre"><dt>Precondition</dt><dd>It must be possible to write into as many memory locations starting at <code>values_begin</code> as there are iterators between <code>indices_begin</code> and <code>indices_end</code>. </dd></dl>

</div>
</div>
<a id="a5ed7dc1d792f9344f1c8720e5f639351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed7dc1d792f9344f1c8720e5f639351">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return whether the vector contains only elements with value zero. This is a collective operation. This function is expensive, because potentially all elements have to be checked. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a64f0fddbf542f0e6ff6344e0fa7d55f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f0fddbf542f0e6ff6344e0fa7d55f9">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the mean value of all the entries in the vector. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#ab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a8bf8c57a134cf1c5f27dab3a5cc1edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf8c57a134cf1c5f27dab3a5cc1edf5">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\)-norm of the vector. The pth root of the sum of the pth powers of the absolute values of the elements. </p>

</div>
</div>
<a id="a995b4962ed8eee92cb0db9678c2047eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b4962ed8eee92cb0db9678c2047eb">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a reference to the MPI communicator object in use with this vector. </p>

</div>
</div>
<a id="a57d72f160499a5f0bc289da5b5187546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d72f160499a5f0bc289da5b5187546">&#9670;&nbsp;</a></span>get_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the MPI partitioner that describes the parallel layout of the vector. This object can be used to initialize another vector with the respective <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit()</a> call, for additional queries regarding the parallel communication, or the compatibility of partitioners. </p>

</div>
</div>
<a id="a1121c9b5aa9c34d0fe36486fecf08b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1121c9b5aa9c34d0fe36486fecf08b58">&#9670;&nbsp;</a></span>partitioners_are_compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioners_are_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the given partitioner is compatible with the partitioner used for this vector. Two partitioners are compatible if they have the same local size and the same ghost indices. They do not necessarily need to be the same data field of the shared pointer. This is a local operation only, i.e., if only some processors decide that the partitioning is not compatible, only these processors will return <code>false</code>, whereas the other processors will return <code>true</code>. </p>

</div>
</div>
<a id="a8f678da4f2dec42cd6f9bc383c0f3c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f678da4f2dec42cd6f9bc383c0f3c11">&#9670;&nbsp;</a></span>partitioners_are_globally_compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioners_are_globally_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether the given partitioner is compatible with the partitioner used for this vector. Two partitioners are compatible if they have the same local size and the same ghost indices. They do not necessarily need to be the same data field. As opposed to <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1121c9b5aa9c34d0fe36486fecf08b58">partitioners_are_compatible()</a>, this method checks for compatibility among all processors and the method only returns <code>true</code> if the partitioner is the same on all processors.</p>
<p>This method performs global communication, so make sure to use it only in a context where all processors call it the same number of times. </p>

</div>
</div>
<a id="a662fd533f2cae84a902e7a587fc6f36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662fd533f2cae84a902e7a587fc6f36c">&#9670;&nbsp;</a></span>set_ghost_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::set_ghost_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ghosted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ghost state of this vector to <code>ghosted</code>. </p>

</div>
</div>
<a id="ad16bd935d90fe664309c52be1615bd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16bd935d90fe664309c52be1615bd4b">&#9670;&nbsp;</a></span>shared_vector_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classArrayView.html">ArrayView</a>&lt;const Number&gt; &gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::shared_vector_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get pointers to the beginning of the values of the other processes of the same shared-memory domain. </p>

</div>
</div>
<a id="abcc9e52579ffedc85d0c0ef0e0936f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc9e52579ffedc85d0c0ef0e0936f06">&#9670;&nbsp;</a></span>DeclException3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::DeclException3 </td>
          <td>(</td>
          <td class="paramtype">ExcNonMatchingElements&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Called &#160;</td>
          <td class="paramname"><em>compress</em>VectorOperation::insert, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but&quot;&lt;&lt; &quot; the element received from a remote&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">does not match with the value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg2&lt;&lt; &quot; on the owner processor &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="ab281998c9483096f9573b0dfd99a3f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab281998c9483096f9573b0dfd99a3f07">&#9670;&nbsp;</a></span>DeclException4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcAccessToNonLocalElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this element is not &quot;&lt;&lt; &quot;stored on the current processor. Note:The range of &quot;&lt;&lt; &quot;locally owned elements&#160;</td>
          <td class="paramname"><em>is</em>[&quot;&lt;&lt; arg2&lt;&lt; &quot;,&quot;&lt;&lt; arg3&lt;&lt; &quot;], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and there are &quot;&lt;&lt; arg4&lt;&lt; &quot; ghost elements &quot;&lt;&lt; &quot;that this vector can access.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' vector into a function &quot;&lt;&lt; &quot;that needs read access to vector elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells(or at least to &quot;&lt;&lt; &quot; 'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot; 'locally owned'). You need to pass a vector that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Exception </p>

</div>
</div>
<a id="a9f9fec5521e69ebd55f8d7dac02cf610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9fec5521e69ebd55f8d7dac02cf610">&#9670;&nbsp;</a></span>add_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Simple addition of a multiple of a vector, i.e. <code>*this += a*V</code> without MPI communication. </p>

</div>
</div>
<a id="ac7b56c7dbbe54762d35b9f536e9d9c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b56c7dbbe54762d35b9f536e9d9c76">&#9670;&nbsp;</a></span>sadd_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Scaling and simple addition of a multiple of a vector, i.e. <code>*this = s*(*this)+a*V</code> without MPI communication. </p>

</div>
</div>
<a id="aec8a0511ae8151672f9a92a699523c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8a0511ae8151672f9a92a699523c52">&#9670;&nbsp;</a></span>inner_product_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::inner_product_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of the inner product of two vectors. </p>

</div>
</div>
<a id="a45739e3cb34a433f67b5c0e23fa5dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45739e3cb34a433f67b5c0e23fa5dcf7">&#9670;&nbsp;</a></span>norm_sqr_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::norm_sqr_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aeecc4f641fb6c425eb9f12048d7e8efd">norm_sqr()</a>. </p>

</div>
</div>
<a id="a0cab16fed261f1579c11ea5c81cb0eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab16fed261f1579c11ea5c81cb0eb7">&#9670;&nbsp;</a></span>mean_value_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mean_value_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a64f0fddbf542f0e6ff6344e0fa7d55f9">mean_value()</a>. </p>

</div>
</div>
<a id="a2df86018fd6619067a0749deb49c6288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df86018fd6619067a0749deb49c6288">&#9670;&nbsp;</a></span>l1_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l1_norm_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0e93518655d2231061f4eb916e98a130">l1_norm()</a>. </p>

</div>
</div>
<a id="ac6b149f392aea2068ad62632dd865e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b149f392aea2068ad62632dd865e5c">&#9670;&nbsp;</a></span>lp_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::lp_norm_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8bf8c57a134cf1c5f27dab3a5cc1edf5">lp_norm()</a>. </p>

</div>
</div>
<a id="a21bc694084db3eb69bd8bb9439787131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc694084db3eb69bd8bb9439787131">&#9670;&nbsp;</a></span>linfty_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::linfty_norm_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2e7bf945225df27d522ec30f1530c0aa">linfty_norm()</a>. </p>

</div>
</div>
<a id="a1fb83d9dd19884023fb6c739c1958a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb83d9dd19884023fb6c739c1958a7a">&#9670;&nbsp;</a></span>add_and_dot_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_and_dot_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Local part of the addition followed by an inner product of two vectors. The same applies for complex-valued vectors as for the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af1dc41a177aadb6a2f6d0d7c2cf41eba">add_and_dot()</a> function. </p>

</div>
</div>
<a id="a4aaa85ec1704806392274242fa705ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaa85ec1704806392274242fa705ed8">&#9670;&nbsp;</a></span>clear_mpi_requests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::clear_mpi_requests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that clears the compress_requests and update_ghost_values_requests field. Used in <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit()</a> functions. </p>

</div>
</div>
<a id="a0f5a3788d6c951791217cd59f8cd9fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5a3788d6c951791217cd59f8cd9fbc">&#9670;&nbsp;</a></span>resize_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::resize_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>new_allocated_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A helper function that is used to resize the val array. </p>

</div>
</div>
<a id="a12c6facf38639f49f73a041b901a2c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c6facf38639f49f73a041b901a2c76">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00496">496</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a6207efeaeff0d0f321b35d29d58e8df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6207efeaeff0d0f321b35d29d58e8df2">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This function does nothing and only exists for backward compatibility. </p>

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00225">225</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac14c06b74acbf135ede85924e7b3d521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14c06b74acbf135ede85924e7b3d521">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename MemorySpace2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the vector type used</p>
<p>Typedef for the vector type used. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01423">1423</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a07c61e4419c2e58a70f3798109c14fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c61e4419c2e58a70f3798109c14fac">&#9670;&nbsp;</a></span>BlockVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Typedef for the block-vector type used</p>
<p>Typedef for the type used to describe vectors that consist of multiple blocks.</p>
<p>An implementation of block vectors based on distributed deal.II vectors. While the base class provides for most of the interface, this class handles the actual allocation of vectors and provides functions that are specific to the underlying vector type.</p>
<dl class="section note"><dt>Note</dt><dd>Instantiations for this template are provided for <code>&lt;float&gt; and &lt;double&gt;</code>; others can be generated in application programs (see the section on <a class="el" href="Instantiations.html">Template instantiations</a> in the manual).</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">Block (linear algebra)</a></dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>Use <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a> instead. </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01427">1427</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f1e1f118b38f6731b99f2f5bed7cd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1e1f118b38f6731b99f2f5bed7cd18">&#9670;&nbsp;</a></span>partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Shared pointer to store the parallel partitioning information. This information can be shared between several vectors that have the same partitioning. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01340">1340</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a3654b450369a501269a65e8fe917ef7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3654b450369a501269a65e8fe917ef7b">&#9670;&nbsp;</a></span>allocated_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::allocated_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The size that is currently allocated in the val array. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01345">1345</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2e986decf5878ef8fc13c691910bf263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e986decf5878ef8fc13c691910bf263">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt;Number, MemorySpace&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Underlying data structure storing the local elements of this vector. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01350">1350</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="aa22a8f4e80c1fe4ff79779dcda71a0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22a8f4e80c1fe4ff79779dcda71a0b9">&#9670;&nbsp;</a></span>thread_loop_partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>For parallel loops with TBB, this member variable stores the affinity information of loops. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01357">1357</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2c7e2584032a7c664c2c28c0436cd6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7e2584032a7c664c2c28c0436cd6ce">&#9670;&nbsp;</a></span>import_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt;Number, MemorySpace&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Temporary storage that holds the data that is sent to this processor in <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a> or sent from this processor in <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a>. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01364">1364</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="af41fb0de7a379de6c6a58801bd93827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41fb0de7a379de6c6a58801bd93827b">&#9670;&nbsp;</a></span>vector_is_ghosted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::vector_is_ghosted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores whether the vector currently allows for reading ghost elements or not. Note that this is to ensure consistent ghost data and does not indicate whether the vector actually can store ghost elements. In particular, when assembling a vector we do not allow reading elements, only writing them. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01373">1373</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ae53eaaa25a65ca1ce774e713dd37154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53eaaa25a65ca1ce774e713dd37154c">&#9670;&nbsp;</a></span>compress_requests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classMPI__Request.html">MPI_Request</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_requests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector that collects all requests from <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a> operations. This class uses persistent MPI communicators, i.e., the communication channels are stored during successive calls to a given function. This reduces the overhead involved with setting up the MPI machinery, but it does not remove the need for a receive operation to be posted before the data can actually be sent. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01384">1384</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ada6604e63e86194c350e0c1ab9d70387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6604e63e86194c350e0c1ab9d70387">&#9670;&nbsp;</a></span>update_ghost_values_requests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classMPI__Request.html">MPI_Request</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_requests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A vector that collects all requests from <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a> operations. This class uses persistent MPI communicators. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01390">1390</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="af2ca9ef90490cbf818d17fcca54a76f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ca9ef90490cbf818d17fcca54a76f2">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>A lock that makes sure that the <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a> and <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a> functions give reasonable results also when used with several threads. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01398">1398</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a4d06704d2372317ea90b5e5bd9c1dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d06704d2372317ea90b5e5bd9c1dc9f">&#9670;&nbsp;</a></span>comm_sm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::comm_sm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Communicator to be used for the shared-memory domain. See the general documentation of this class for more information about the purpose of <code>comm_sm</code>. </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01405">1405</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a></li>
<li>source/lac/<a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
