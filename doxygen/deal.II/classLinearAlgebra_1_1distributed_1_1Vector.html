<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classLinearAlgebra_1_1distributed_1_1Vector.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceLinearAlgebra.html">LinearAlgebra</a></li><li class="navelem"><a class="el" href="namespaceLinearAlgebra_1_1distributed.html">distributed</a></li><li class="navelem"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classLinearAlgebra_1_1distributed_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt; Class Template Reference<div class="ingroups"><a class="el" href="group__LAC.html">Linear algebra classes</a> &raquo; <a class="el" href="group__Vectors.html">Vector classes</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="la__parallel__vector_8h_source.html">deal.II/lac/la_parallel_vector.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classLinearAlgebra_1_1distributed_1_1Vector__inherit__graph.svg" width="839" height="118"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe></div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ae018e039c0ca78a063c6a075be461283"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae018e039c0ca78a063c6a075be461283">memory_space</a> = MemorySpace</td></tr>
<tr class="separator:ae018e039c0ca78a063c6a075be461283"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4439cf261c308591c649e442d097ea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> = Number</td></tr>
<tr class="separator:aca4439cf261c308591c649e442d097ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5c3b93ed114bc9795c0e3b3d5902393"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae5c3b93ed114bc9795c0e3b3d5902393">pointer</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:ae5c3b93ed114bc9795c0e3b3d5902393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84413e605d193829856edbaa9d75b57b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a84413e605d193829856edbaa9d75b57b">const_pointer</a> = const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:a84413e605d193829856edbaa9d75b57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35abed3e6b898142990cecf00e8387da"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:a35abed3e6b898142990cecf00e8387da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a990da0f1e95dd6004fbf0cf711c53d"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> = const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td></tr>
<tr class="separator:a4a990da0f1e95dd6004fbf0cf711c53d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ae1224f3b1fbee6cc8ffa59901d6c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae2ae1224f3b1fbee6cc8ffa59901d6c8">reference</a> = <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td></tr>
<tr class="separator:ae2ae1224f3b1fbee6cc8ffa59901d6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa37d6cce7c7fe31452d2bae09dc7ba"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1aa37d6cce7c7fe31452d2bae09dc7ba">const_reference</a> = const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td></tr>
<tr class="separator:a1aa37d6cce7c7fe31452d2bae09dc7ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301cc0a1214a6aeb04bb4e1dd06a8dfc"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> = <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td></tr>
<tr class="separator:a301cc0a1214a6aeb04bb4e1dd06a8dfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34599939674e79cdc3808bb074bcf0ee"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> = typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt; Number &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a></td></tr>
<tr class="separator:a34599939674e79cdc3808bb074bcf0ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:gaf1654b3bfb9f92ebaa5dc7f33a323c94"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gaf1654b3bfb9f92ebaa5dc7f33a323c94">DeclException0</a> (ExcVectorTypeNotCompatible)</td></tr>
<tr class="separator:gaf1654b3bfb9f92ebaa5dc7f33a323c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1e037285504065eb4bf05124dd20600"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gab1e037285504065eb4bf05124dd20600">DeclException0</a> (ExcNotAllowedForCuda)</td></tr>
<tr class="separator:gab1e037285504065eb4bf05124dd20600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc9e52579ffedc85d0c0ef0e0936f06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abcc9e52579ffedc85d0c0ef0e0936f06">DeclException3</a> (ExcNonMatchingElements, Number, Number, unsigned <a class="el" href="classint.html">int</a>,&lt;&lt; &quot;Called <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a>(<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>), but&quot;&lt;&lt; &quot; the element received from a remote processor, value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg1&lt;&lt; &quot;, does not match with the value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg2&lt;&lt; &quot; on the owner processor &quot;&lt;&lt; arg3)</td></tr>
<tr class="separator:abcc9e52579ffedc85d0c0ef0e0936f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab281998c9483096f9573b0dfd99a3f07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab281998c9483096f9573b0dfd99a3f07">DeclException4</a> (ExcAccessToNonLocalElement, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>,&lt;&lt; &quot;You tried to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed vector, but this element is not &quot;&lt;&lt; &quot;stored on the current processor. Note: The range of &quot;&lt;&lt; &quot;locally owned elements is [&quot;&lt;&lt; arg2&lt;&lt; &quot;,&quot;&lt;&lt; arg3&lt;&lt; &quot;], and there are &quot;&lt;&lt; arg4&lt;&lt; &quot; ghost elements &quot;&lt;&lt; &quot;that this vector can access.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' vector into a function &quot;&lt;&lt; &quot;that needs read access to vector elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells (or at least to &quot;&lt;&lt; &quot;'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot;'locally owned'). You need to pass a vector that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;)</td></tr>
<tr class="separator:ab281998c9483096f9573b0dfd99a3f07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12c6facf38639f49f73a041b901a2c76"><td class="memTemplParams" colspan="2">template&lt;typename number &gt; </td></tr>
<tr class="memitem:a12c6facf38639f49f73a041b901a2c76"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a12c6facf38639f49f73a041b901a2c76">operator=</a> (const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; number &gt; &amp;v)</td></tr>
<tr class="separator:a12c6facf38639f49f73a041b901a2c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6207efeaeff0d0f321b35d29d58e8df2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a6207efeaeff0d0f321b35d29d58e8df2">compress</a> (<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>)</td></tr>
<tr class="separator:a6207efeaeff0d0f321b35d29d58e8df2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">1: 基本对象处理</div></td></tr>
<tr class="memitem:a702bf4533c5ce7e4144d3d86afb31195"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a702bf4533c5ce7e4144d3d86afb31195">Vector</a> ()</td></tr>
<tr class="separator:a702bf4533c5ce7e4144d3d86afb31195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60510dc0ed5441f1875cea6800645d3c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a60510dc0ed5441f1875cea6800645d3c">Vector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:a60510dc0ed5441f1875cea6800645d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3be6c4ce529bb9b6c13eb831d0a86f55"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3be6c4ce529bb9b6c13eb831d0a86f55">Vector</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99297a298764249d0c0b5adf9a96e1c7">size</a>)</td></tr>
<tr class="separator:a3be6c4ce529bb9b6c13eb831d0a86f55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31393977fc00f2d9c46f259330ef2a23"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a31393977fc00f2d9c46f259330ef2a23">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_indices, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:a31393977fc00f2d9c46f259330ef2a23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44feea9fec2eeab75baf051b65fa8094"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a44feea9fec2eeab75baf051b65fa8094">Vector</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:a44feea9fec2eeab75baf051b65fa8094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe52b52803ff7d23233e37083689b8f1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afe52b52803ff7d23233e37083689b8f1">Vector</a> (const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a>)</td></tr>
<tr class="separator:afe52b52803ff7d23233e37083689b8f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e3faeced0e8afcf1208a6955e88ffd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99e3faeced0e8afcf1208a6955e88ffd">~Vector</a> () override</td></tr>
<tr class="separator:a99e3faeced0e8afcf1208a6955e88ffd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace027311492ed2f6e07fbd74d723e3a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99297a298764249d0c0b5adf9a96e1c7">size</a>, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:ace027311492ed2f6e07fbd74d723e3a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a79ca37d7f7a8cfd04f5dd61d350ae5">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;in_vector, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false)</td></tr>
<tr class="separator:a8a79ca37d7f7a8cfd04f5dd61d350ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7415120211cbfb0b525423f5e028791e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a7415120211cbfb0b525423f5e028791e">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;ghost_indices, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:a7415120211cbfb0b525423f5e028791e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac86885392f82f70c0acdc2cc2fe272d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac86885392f82f70c0acdc2cc2fe272d5">reinit</a> (const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;local_range, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;communicator)</td></tr>
<tr class="separator:ac86885392f82f70c0acdc2cc2fe272d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4afb6f468e902618d2f3bf41da181c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1a4afb6f468e902618d2f3bf41da181c">reinit</a> (const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a>, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:a1a4afb6f468e902618d2f3bf41da181c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6c95ee056cdf27d171711cd7c8f5701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac6c95ee056cdf27d171711cd7c8f5701">reinit</a> (const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abebeb6ebf3dedc1123663eae12374b06">local_size</a>, const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a> ghost_size, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;comm, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:ac6c95ee056cdf27d171711cd7c8f5701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ca1b9394ef76f792c06e3d4f006b4e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2ca1b9394ef76f792c06e3d4f006b4e1">swap</a> (<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;v)</td></tr>
<tr class="separator:a2ca1b9394ef76f792c06e3d4f006b4e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2a2d81a821ae954545ca77a89fa240"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abb2a2d81a821ae954545ca77a89fa240">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:abb2a2d81a821ae954545ca77a89fa240"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad364c47c5b3b7b991490cd626c729f0b"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ad364c47c5b3b7b991490cd626c729f0b"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad364c47c5b3b7b991490cd626c729f0b">operator=</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;in_vector)</td></tr>
<tr class="separator:ad364c47c5b3b7b991490cd626c729f0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">2：并行数据交换</div></td></tr>
<tr class="memitem:a8a204103e550697467d933388b732bda"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation) override</td></tr>
<tr class="separator:a8a204103e550697467d933388b732bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a6cb7d50e02022283af53c2ae14f878"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values</a> () const</td></tr>
<tr class="separator:a2a6cb7d50e02022283af53c2ae14f878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab0c01436acde21cc2dbb5576d8f2375"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aab0c01436acde21cc2dbb5576d8f2375">compress_start</a> (const unsigned <a class="el" href="classint.html">int</a> communication_channel=0, ::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation=<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a>)</td></tr>
<tr class="separator:aab0c01436acde21cc2dbb5576d8f2375"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada0b48d524285ca7b302da593b3321a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada0b48d524285ca7b302da593b3321a9">compress_finish</a> (::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:ada0b48d524285ca7b302da593b3321a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7045a29ddd2b5fb86ce56c3806e08d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab7045a29ddd2b5fb86ce56c3806e08d3">update_ghost_values_start</a> (const unsigned <a class="el" href="classint.html">int</a> communication_channel=0) const</td></tr>
<tr class="separator:ab7045a29ddd2b5fb86ce56c3806e08d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab305a49968449aa44e998f4364838479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab305a49968449aa44e998f4364838479">update_ghost_values_finish</a> () const</td></tr>
<tr class="separator:ab305a49968449aa44e998f4364838479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0dc3fd03c7851d5577c159703282548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac0dc3fd03c7851d5577c159703282548">zero_out_ghosts</a> () const</td></tr>
<tr class="separator:ac0dc3fd03c7851d5577c159703282548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0242ed0c3e3664e6b4204d28a726a0b7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0242ed0c3e3664e6b4204d28a726a0b7">zero_out_ghost_values</a> () const</td></tr>
<tr class="separator:a0242ed0c3e3664e6b4204d28a726a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17719d884e60b2ad0077a03b92382975"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a17719d884e60b2ad0077a03b92382975">has_ghost_elements</a> () const</td></tr>
<tr class="separator:a17719d884e60b2ad0077a03b92382975"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab792ddb04b95a220e489f2d7f9eee990"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:ab792ddb04b95a220e489f2d7f9eee990"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab792ddb04b95a220e489f2d7f9eee990">copy_locally_owned_data_from</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;src)</td></tr>
<tr class="separator:ab792ddb04b95a220e489f2d7f9eee990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7b743d761233b92e0ed23e6bf37a409"><td class="memTemplParams" colspan="2">template&lt;typename MemorySpace2 &gt; </td></tr>
<tr class="memitem:af7b743d761233b92e0ed23e6bf37a409"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af7b743d761233b92e0ed23e6bf37a409">import</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace2 &gt; &amp;src, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation)</td></tr>
<tr class="separator:af7b743d761233b92e0ed23e6bf37a409"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">3：VectorSpaceVector的实现</div></td></tr>
<tr class="memitem:a7bde7122a6d05d6815f507f7cb27819a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a7bde7122a6d05d6815f507f7cb27819a">reinit</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classbool.html">bool</a> omit_zeroing_entries=false) override</td></tr>
<tr class="separator:a7bde7122a6d05d6815f507f7cb27819a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85b449afaa8f491f01d7670bcc48099"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad85b449afaa8f491f01d7670bcc48099">operator*=</a> (const Number factor) override</td></tr>
<tr class="separator:ad85b449afaa8f491f01d7670bcc48099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16146ad677e926f3bdbed2aca3248247"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a16146ad677e926f3bdbed2aca3248247">operator/=</a> (const Number factor) override</td></tr>
<tr class="separator:a16146ad677e926f3bdbed2aca3248247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eabb34382bc0694390f97616742bcdf"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3eabb34382bc0694390f97616742bcdf">operator+=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a3eabb34382bc0694390f97616742bcdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132ecfef78dfec86c1b6a5423d642ae0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a132ecfef78dfec86c1b6a5423d642ae0">operator-=</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a132ecfef78dfec86c1b6a5423d642ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad947177e38381c4fd058876a4f27f771"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad947177e38381c4fd058876a4f27f771">import</a> (const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;V, <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> operation, std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt; communication_pattern={}) override</td></tr>
<tr class="separator:ad947177e38381c4fd058876a4f27f771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a829281a9ccc9f1cf9720ee5a535efd21"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a829281a9ccc9f1cf9720ee5a535efd21">operator*</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) const override</td></tr>
<tr class="separator:a829281a9ccc9f1cf9720ee5a535efd21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac029174b48a0707da587b6ce3bc25047"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a> (const Number a) override</td></tr>
<tr class="separator:ac029174b48a0707da587b6ce3bc25047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7d70c674b55edbb3595acaedc310996"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab7d70c674b55edbb3595acaedc310996">add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:ab7d70c674b55edbb3595acaedc310996"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25d752a33b33192932b0dd8054d2c40e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a25d752a33b33192932b0dd8054d2c40e">add</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const Number b, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:a25d752a33b33192932b0dd8054d2c40e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883f439a5130ebbbc15f765928a0ad92"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a883f439a5130ebbbc15f765928a0ad92">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, const std::vector&lt; Number &gt; &amp;values)</td></tr>
<tr class="separator:a883f439a5130ebbbc15f765928a0ad92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6376a098589519491fc452d1529f57b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aa6376a098589519491fc452d1529f57b">sadd</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:aa6376a098589519491fc452d1529f57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacdf6bfd4533c47587ba0debe177710e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aacdf6bfd4533c47587ba0debe177710e">scale</a> (const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;scaling_factors) override</td></tr>
<tr class="separator:aacdf6bfd4533c47587ba0debe177710e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c64a6bebc56d849307ef1fcad62c23"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a43c64a6bebc56d849307ef1fcad62c23">equ</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V) override</td></tr>
<tr class="separator:a43c64a6bebc56d849307ef1fcad62c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e93518655d2231061f4eb916e98a130"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0e93518655d2231061f4eb916e98a130">l1_norm</a> () const override</td></tr>
<tr class="separator:a0e93518655d2231061f4eb916e98a130"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af355599021a687026ab9818efd57e82d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af355599021a687026ab9818efd57e82d">l2_norm</a> () const override</td></tr>
<tr class="separator:af355599021a687026ab9818efd57e82d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeecc4f641fb6c425eb9f12048d7e8efd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aeecc4f641fb6c425eb9f12048d7e8efd">norm_sqr</a> () const</td></tr>
<tr class="separator:aeecc4f641fb6c425eb9f12048d7e8efd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e7bf945225df27d522ec30f1530c0aa"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2e7bf945225df27d522ec30f1530c0aa">linfty_norm</a> () const override</td></tr>
<tr class="separator:a2e7bf945225df27d522ec30f1530c0aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1dc41a177aadb6a2f6d0d7c2cf41eba"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af1dc41a177aadb6a2f6d0d7c2cf41eba">add_and_dot</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;W) override</td></tr>
<tr class="separator:af1dc41a177aadb6a2f6d0d7c2cf41eba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99297a298764249d0c0b5adf9a96e1c7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a99297a298764249d0c0b5adf9a96e1c7">size</a> () const override</td></tr>
<tr class="separator:a99297a298764249d0c0b5adf9a96e1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5265a5af79342c77ac50d584c9d3e4"><td class="memItemLeft" align="right" valign="top">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aff5265a5af79342c77ac50d584c9d3e4">locally_owned_elements</a> () const override</td></tr>
<tr class="separator:aff5265a5af79342c77ac50d584c9d3e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2218dcb909cf45f3e495ac250ea9260"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab2218dcb909cf45f3e495ac250ea9260">print</a> (std::ostream &amp;out, const unsigned <a class="el" href="classint.html">int</a> precision=3, const <a class="el" href="classbool.html">bool</a> scientific=true, const <a class="el" href="classbool.html">bool</a> across=true) const override</td></tr>
<tr class="separator:ab2218dcb909cf45f3e495ac250ea9260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493afd09167ce2c18d27252178d88c59"><td class="memItemLeft" align="right" valign="top">virtual std::size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a493afd09167ce2c18d27252178d88c59">memory_consumption</a> () const override</td></tr>
<tr class="separator:a493afd09167ce2c18d27252178d88c59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">4：不包括在VectorSpaceVector中的其他向量操作</div></td></tr>
<tr class="memitem:a85d501a9f8c20d9142fe6a0f88bb12a4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a85d501a9f8c20d9142fe6a0f88bb12a4">operator=</a> (const Number s) override</td></tr>
<tr class="separator:a85d501a9f8c20d9142fe6a0f88bb12a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79cb76c50ddfade06995373dfc14cdb4"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a79cb76c50ddfade06995373dfc14cdb4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a79cb76c50ddfade06995373dfc14cdb4">add</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;values)</td></tr>
<tr class="separator:a79cb76c50ddfade06995373dfc14cdb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a428a001329c576451c1a77557212527a"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:a428a001329c576451c1a77557212527a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a428a001329c576451c1a77557212527a">add</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> n_elements, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> *indices, const OtherNumber *values)</td></tr>
<tr class="separator:a428a001329c576451c1a77557212527a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44cbdb2b9d3612d549e544dcd11a33ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a44cbdb2b9d3612d549e544dcd11a33ed">sadd</a> (const Number s, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;V)</td></tr>
<tr class="separator:a44cbdb2b9d3612d549e544dcd11a33ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">5：条目访问和本地数据表示法</div></td></tr>
<tr class="memitem:abebeb6ebf3dedc1123663eae12374b06"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#abebeb6ebf3dedc1123663eae12374b06">local_size</a> () const</td></tr>
<tr class="separator:abebeb6ebf3dedc1123663eae12374b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3db2bea96180138f039b9d2934534492"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size</a> () const</td></tr>
<tr class="separator:a3db2bea96180138f039b9d2934534492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fc3d0924b59159a50ed9838d8a6592"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae8fc3d0924b59159a50ed9838d8a6592">in_local_range</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:ae8fc3d0924b59159a50ed9838d8a6592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdcd750879bde459ccb63936c74a0e87"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afdcd750879bde459ccb63936c74a0e87">begin</a> ()</td></tr>
<tr class="separator:afdcd750879bde459ccb63936c74a0e87"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae038db1a3998888e469398031da2b980"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae038db1a3998888e469398031da2b980">begin</a> () const</td></tr>
<tr class="separator:ae038db1a3998888e469398031da2b980"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0a4b780b6b8fded62768da4164d2378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab0a4b780b6b8fded62768da4164d2378">end</a> ()</td></tr>
<tr class="separator:ab0a4b780b6b8fded62768da4164d2378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a362987561884296cee4ba45f4fe85abe"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a362987561884296cee4ba45f4fe85abe">end</a> () const</td></tr>
<tr class="separator:a362987561884296cee4ba45f4fe85abe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac551bfa7fd898a0a8e85f59109c091ed"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac551bfa7fd898a0a8e85f59109c091ed">operator()</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:ac551bfa7fd898a0a8e85f59109c091ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b7c43da3b837f4b811ad4cc813d899"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a58b7c43da3b837f4b811ad4cc813d899">operator()</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index)</td></tr>
<tr class="separator:a58b7c43da3b837f4b811ad4cc813d899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c497852ad2b7d6917a4b60f6c7b28bf"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a5c497852ad2b7d6917a4b60f6c7b28bf">operator[]</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index) const</td></tr>
<tr class="separator:a5c497852ad2b7d6917a4b60f6c7b28bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc5f6e645477d457a68784b83bdf582"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1bc5f6e645477d457a68784b83bdf582">operator[]</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> global_index)</td></tr>
<tr class="separator:a1bc5f6e645477d457a68784b83bdf582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4bc946b94f19d7e11c00f41a39db02"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> local_index) const</td></tr>
<tr class="separator:a1c4bc946b94f19d7e11c00f41a39db02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397872125364fdcaf89e62f8616d7d62"><td class="memItemLeft" align="right" valign="top">Number &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a397872125364fdcaf89e62f8616d7d62">local_element</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> local_index)</td></tr>
<tr class="separator:a397872125364fdcaf89e62f8616d7d62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db545d71e642710a044554d6df060d9"><td class="memItemLeft" align="right" valign="top">Number *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8db545d71e642710a044554d6df060d9">get_values</a> () const</td></tr>
<tr class="separator:a8db545d71e642710a044554d6df060d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad49497fa8fad0250a2bd0f4a36179ff2"><td class="memTemplParams" colspan="2">template&lt;typename OtherNumber &gt; </td></tr>
<tr class="memitem:ad49497fa8fad0250a2bd0f4a36179ff2"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad49497fa8fad0250a2bd0f4a36179ff2">extract_subvector_to</a> (const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;indices, std::vector&lt; OtherNumber &gt; &amp;values) const</td></tr>
<tr class="separator:ad49497fa8fad0250a2bd0f4a36179ff2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9494a9258d9f0b06b97550921c5e0e"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:aeb9494a9258d9f0b06b97550921c5e0e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aeb9494a9258d9f0b06b97550921c5e0e">extract_subvector_to</a> (ForwardIterator indices_begin, const ForwardIterator indices_end, OutputIterator values_begin) const</td></tr>
<tr class="separator:aeb9494a9258d9f0b06b97550921c5e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed7dc1d792f9344f1c8720e5f639351"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a5ed7dc1d792f9344f1c8720e5f639351">all_zero</a> () const override</td></tr>
<tr class="separator:a5ed7dc1d792f9344f1c8720e5f639351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f0fddbf542f0e6ff6344e0fa7d55f9"><td class="memItemLeft" align="right" valign="top">virtual Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a64f0fddbf542f0e6ff6344e0fa7d55f9">mean_value</a> () const override</td></tr>
<tr class="separator:a64f0fddbf542f0e6ff6344e0fa7d55f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8c57a134cf1c5f27dab3a5cc1edf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8bf8c57a134cf1c5f27dab3a5cc1edf5">lp_norm</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> p) const</td></tr>
<tr class="separator:a8bf8c57a134cf1c5f27dab3a5cc1edf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">6：混合东西</div></td></tr>
<tr class="memitem:a995b4962ed8eee92cb0db9678c2047eb"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a995b4962ed8eee92cb0db9678c2047eb">get_mpi_communicator</a> () const</td></tr>
<tr class="separator:a995b4962ed8eee92cb0db9678c2047eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d72f160499a5f0bc289da5b5187546"><td class="memItemLeft" align="right" valign="top">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a57d72f160499a5f0bc289da5b5187546">get_partitioner</a> () const</td></tr>
<tr class="separator:a57d72f160499a5f0bc289da5b5187546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1121c9b5aa9c34d0fe36486fecf08b58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1121c9b5aa9c34d0fe36486fecf08b58">partitioners_are_compatible</a> (const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;part) const</td></tr>
<tr class="separator:a1121c9b5aa9c34d0fe36486fecf08b58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f678da4f2dec42cd6f9bc383c0f3c11"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8f678da4f2dec42cd6f9bc383c0f3c11">partitioners_are_globally_compatible</a> (const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;part) const</td></tr>
<tr class="separator:a8f678da4f2dec42cd6f9bc383c0f3c11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a662fd533f2cae84a902e7a587fc6f36c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a662fd533f2cae84a902e7a587fc6f36c">set_ghost_state</a> (const <a class="el" href="classbool.html">bool</a> ghosted) const</td></tr>
<tr class="separator:a662fd533f2cae84a902e7a587fc6f36c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad16bd935d90fe664309c52be1615bd4b"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classArrayView.html">ArrayView</a>&lt; const Number &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ad16bd935d90fe664309c52be1615bd4b">shared_vector_data</a> () const</td></tr>
<tr class="separator:ad16bd935d90fe664309c52be1615bd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor功能 从Subscriptor派生的类提供了一个订阅此对象的设施。这主要是由SmartPointer类使用。</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9f9fec5521e69ebd55f8d7dac02cf610"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a9f9fec5521e69ebd55f8d7dac02cf610">add_local</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:a9f9fec5521e69ebd55f8d7dac02cf610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7b56c7dbbe54762d35b9f536e9d9c76"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac7b56c7dbbe54762d35b9f536e9d9c76">sadd_local</a> (const Number s, const Number a, const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;V)</td></tr>
<tr class="separator:ac7b56c7dbbe54762d35b9f536e9d9c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec8a0511ae8151672f9a92a699523c52"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:aec8a0511ae8151672f9a92a699523c52"><td class="memTemplItemLeft" align="right" valign="top">Number&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aec8a0511ae8151672f9a92a699523c52">inner_product_local</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;V) const</td></tr>
<tr class="separator:aec8a0511ae8151672f9a92a699523c52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45739e3cb34a433f67b5c0e23fa5dcf7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a45739e3cb34a433f67b5c0e23fa5dcf7">norm_sqr_local</a> () const</td></tr>
<tr class="separator:a45739e3cb34a433f67b5c0e23fa5dcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cab16fed261f1579c11ea5c81cb0eb7"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0cab16fed261f1579c11ea5c81cb0eb7">mean_value_local</a> () const</td></tr>
<tr class="separator:a0cab16fed261f1579c11ea5c81cb0eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df86018fd6619067a0749deb49c6288"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2df86018fd6619067a0749deb49c6288">l1_norm_local</a> () const</td></tr>
<tr class="separator:a2df86018fd6619067a0749deb49c6288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6b149f392aea2068ad62632dd865e5c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac6b149f392aea2068ad62632dd865e5c">lp_norm_local</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> p) const</td></tr>
<tr class="separator:ac6b149f392aea2068ad62632dd865e5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc694084db3eb69bd8bb9439787131"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a21bc694084db3eb69bd8bb9439787131">linfty_norm_local</a> () const</td></tr>
<tr class="separator:a21bc694084db3eb69bd8bb9439787131"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb83d9dd19884023fb6c739c1958a7a"><td class="memItemLeft" align="right" valign="top">Number&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1fb83d9dd19884023fb6c739c1958a7a">add_and_dot_local</a> (const Number a, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;V, const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;W)</td></tr>
<tr class="separator:a1fb83d9dd19884023fb6c739c1958a7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4aaa85ec1704806392274242fa705ed8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4aaa85ec1704806392274242fa705ed8">clear_mpi_requests</a> ()</td></tr>
<tr class="separator:a4aaa85ec1704806392274242fa705ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f5a3788d6c951791217cd59f8cd9fbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0f5a3788d6c951791217cd59f8cd9fbc">resize_val</a> (const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> new_allocated_size, const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>=MPI_COMM_SELF)</td></tr>
<tr class="separator:a0f5a3788d6c951791217cd59f8cd9fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a3f1e1f118b38f6731b99f2f5bed7cd18"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3f1e1f118b38f6731b99f2f5bed7cd18">partitioner</a></td></tr>
<tr class="separator:a3f1e1f118b38f6731b99f2f5bed7cd18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654b450369a501269a65e8fe917ef7b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3654b450369a501269a65e8fe917ef7b">allocated_size</a></td></tr>
<tr class="separator:a3654b450369a501269a65e8fe917ef7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e986decf5878ef8fc13c691910bf263"><td class="memItemLeft" align="right" valign="top">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt; Number, MemorySpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2e986decf5878ef8fc13c691910bf263">data</a></td></tr>
<tr class="separator:a2e986decf5878ef8fc13c691910bf263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa22a8f4e80c1fe4ff79779dcda71a0b9"><td class="memItemLeft" align="right" valign="top">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aa22a8f4e80c1fe4ff79779dcda71a0b9">thread_loop_partitioner</a></td></tr>
<tr class="separator:aa22a8f4e80c1fe4ff79779dcda71a0b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7e2584032a7c664c2c28c0436cd6ce"><td class="memItemLeft" align="right" valign="top">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt; Number, MemorySpace &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2c7e2584032a7c664c2c28c0436cd6ce">import_data</a></td></tr>
<tr class="separator:a2c7e2584032a7c664c2c28c0436cd6ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41fb0de7a379de6c6a58801bd93827b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classbool.html">bool</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af41fb0de7a379de6c6a58801bd93827b">vector_is_ghosted</a></td></tr>
<tr class="separator:af41fb0de7a379de6c6a58801bd93827b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae53eaaa25a65ca1ce774e713dd37154c"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classMPI__Request.html">MPI_Request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae53eaaa25a65ca1ce774e713dd37154c">compress_requests</a></td></tr>
<tr class="separator:ae53eaaa25a65ca1ce774e713dd37154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6604e63e86194c350e0c1ab9d70387"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classMPI__Request.html">MPI_Request</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada6604e63e86194c350e0c1ab9d70387">update_ghost_values_requests</a></td></tr>
<tr class="separator:ada6604e63e86194c350e0c1ab9d70387"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ca9ef90490cbf818d17fcca54a76f2"><td class="memItemLeft" align="right" valign="top">std::mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#af2ca9ef90490cbf818d17fcca54a76f2">mutex</a></td></tr>
<tr class="separator:af2ca9ef90490cbf818d17fcca54a76f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d06704d2372317ea90b5e5bd9c1dc9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classMPI__Comm.html">MPI_Comm</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a></td></tr>
<tr class="separator:a4d06704d2372317ea90b5e5bd9c1dc9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ac14c06b74acbf135ede85924e7b3d521"><td class="memTemplParams" colspan="2">template&lt;typename Number2 , typename MemorySpace2 &gt; </td></tr>
<tr class="memitem:ac14c06b74acbf135ede85924e7b3d521"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac14c06b74acbf135ede85924e7b3d521">Vector</a></td></tr>
<tr class="separator:ac14c06b74acbf135ede85924e7b3d521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c61e4419c2e58a70f3798109c14fac"><td class="memTemplParams" colspan="2">template&lt;typename Number2 &gt; </td></tr>
<tr class="memitem:a07c61e4419c2e58a70f3798109c14fac"><td class="memTemplItemLeft" align="right" valign="top">class&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a07c61e4419c2e58a70f3798109c14fac">BlockVector</a></td></tr>
<tr class="separator:a07c61e4419c2e58a70f3798109c14fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt;<br />
class LinearAlgebra::distributed::Vector&lt; Number, MemorySpace &gt;</h3>

<p>并行向量类的实现。这个类的设计与deal.II中的标准 <a class="el" href="classVector.html">Vector</a> 类相似，不同的是，存储是用MPI分布的。 矢量被设计为以下平行分区的方案。 </p><ul>
<li>
MPI并行化中各个进程（本地拥有的部分）所持有的索引形成一个连续的范围 <code>[my_first_index,my_last_index)</code> 。 </li>
<li>
驻留在其他处理器任意位置的幽灵指数是允许的。一般来说，如果鬼魂索引被聚在一起，效率会更高，因为它们被存储为一组间隔。在调用函数<code>reinit (local_owned, ghost_indices, communicator)</code>时，鬼魂索引的通信模式被确定，并保留到分区被改变。 这允许指数的有效并行通信。特别是，它存储了通信模式，而不是在每次通信时都要再次计算它。关于鬼魂向量的更多信息，也可参见 <a class="el" href="DEALGlossary.html#GlossGhostedVector">关于有鬼魂元素的向量的词汇表条目</a>。 </li>
<li>
除了通常的全局访问操作符()，还可以用函数 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1c4bc946b94f19d7e11c00f41a39db02">local_element()</a>访问本地索引空间的向量条目。本地拥有的索引被放在首位，</code>[0，local_owned_size()]，然后所有的鬼魂索引在它们之后连续排列，[local_owned_size(), <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>+n_ghost_entries()]。 </li>
</ul>
<p>与并行功能有关的函数。 </p><ul>
<li>
函数 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a></code> 穿过与鬼魂索引相关的数据，并将其传达给所有者进程，然后它可以将其添加到正确的位置。例如，这可以在运行了一个涉及到填充这个向量的鬼魂的汇编程序之后使用。注意， <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a></code> 的 <code>insert</code> 模式并不设置包含在ghost条目中的元素，而是简单地丢弃它们，假设拥有的处理器已经将它们设置为所需的值（也见 <a class="el" href="DEALGlossary.html#GlossCompress">关于压缩的词汇条</a>）。 </li>
<li>
<code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> 函数将数据从拥有处理器导入到ghost索引中，以便提供对与ghost相关的数据的读取访问。 </li>
<li>
可以将上述函数分成两个阶段，第一个阶段启动通信，第二个阶段完成通信。 这些函数可以用来将通信与代码中其他部分的计算重叠起来。 </li>
<li>
当然，还原操作（如规范）利用了集体的全对全MPI通信。 </li>
</ul>
<p>这个向量相对于鬼魂元素来说可以采取两种不同的状态。 </p><ul>
<li>
在创建后，只要调用zero_out_ghost_values()(或 <code>operator= (0.)</code> )，该向量只允许向鬼魂元素写入，而不允许从鬼魂元素中读出。 </li>
<li>
在调用update_ghost_values()后，向量不允许写进ghost元素，只允许读出ghost元素。这是为了避免在修改一些向量条目后调用compress()时出现不希望出现的ghost数据假象。ghost条目的当前状态（读模式或写模式）可以通过has_ghost_elements()方法查询，当ghost元素被更新时，该方法准确地返回 <code>true</code> ，否则返回 <code>false</code> ，而不考虑向量布局中ghost条目的实际数量（要获得该信息，请使用n_ghost_entries()代替）。 </li>
</ul>
<p>这个向量使用类 <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector&lt;Number&gt;</a> 的设施来实现对向量的本地范围的操作。特别是，它还继承了线程并行性，如果程序使用多个线程，它可以将大多数向量-向量操作分割成更小的块。这在与MPI一起工作时可能需要也可能不需要。 </p><h4>Limitations regarding the vector size</h4>
<p>这个向量类是基于两种不同的数字类型进行索引的。 所谓的全局索引类型是对向量的整体大小进行编码。 它的类型是 <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>. ，最大的可能值是 <code>2^32-1</code> 或大约40亿，如果在配置deal.II时禁用64位整数（默认情况），或者如果启用64位整数，则为 <code>2^64-1</code> or approximately <code>10^19</code> （进一步信息见术语表中的 <a class="el" href="GlobalDoFIndex.html">When to use types::global_dof_index instead of unsigned int</a> 条目）。 第二个相关的索引类型是在一个MPI等级内使用的本地索引。与全局索引相反，该实现无条件地假定为32位无符号整数。换句话说，要实际使用一个超过40亿条目的向量，你需要使用一个以上等级的MPI（一般来说，这是一个安全的假设，因为40亿条目对于浮点数来说至少要消耗16GB的内存，对于双数来说至少要消耗32GB的内存），并启用64位索引。如果有超过40亿的局部元素存在，实现会尝试检测，这将触发一个异常并中止代码。然而，请注意，对溢出的检测是很棘手的，在某些情况下，检测机制可能会失败。因此，强烈建议不要依赖这个类来自动检测不支持的情况。 </p><h4>CUDA support</h4>
<p>这个向量类支持两个不同的内存空间。主机和CUDA。默认情况下，内存空间是Host，所有的数据都分配在CPU上。当内存空间为CUDA时，所有的数据都被分配在GPU上。 对向量的操作是在选择的内存空间上进行的。 从主机来看，当使用CUDA内存空间时，有两种方法可以访问向量的元素。 </p><ul>
<li>
使用get_values（）。 <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double, MemorySpace::CUDA&gt;</a> vector(local_range, comm);</div><div class="line"><span class="keywordtype">double</span>* vector_dev = vector.get_values();</div><div class="line">std::vector&lt;double&gt; vector_host(local_range.n_elements(), 1.);</div><div class="line"><a class="code" href="namespaceUtilities_1_1CUDA.html#ac1dc5c1fa14486b8cdb971eca200bd9d">Utilities::CUDA::copy_to_dev</a>(vector_host, vector_dev);</div></div><!-- fragment --> </li>
<li>
使用import()。 <div class="fragment"><div class="line"><a class="code" href="classVector.html">Vector&lt;double, MemorySpace::CUDA&gt;</a> vector(local_range, comm);</div><div class="line">ReadWriteVector&lt;double&gt; rw_vector(local_range);</div><div class="line"><span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp; val : rw_vector)</div><div class="line">val = 1.;</div><div class="line">vector.import(rw_vector, <a class="code" href="namespaceVectorTools_1_1EvaluationFlags.html#ac6721740e24732d6afabcf28ddfc1ffda4ed1da4f7c4036896a6aeb19338d1a81">VectorOperations::insert</a>);</div></div><!-- fragment --> </li>
</ul>
<p>import方法要安全得多，必要时将执行MPI通信。因为可能会执行MPI通信，所以需要在所有处理器上调用import。 </p><dl class="section note"><dt>Note</dt><dd>默认情况下，所有的等级将尝试访问设备0。 如果你每个节点有一个等级，每个节点有一个GPU，这就很好。如果你在一个节点上有多个GPU，我们需要每个进程访问一个不同的GPU。如果每个节点有相同数量的GPU，这可以按以下方式进行。 <code> int n_devices = 0; cudaGetDeviceCount(&amp;n_devices); int device_id = my_rank % n_devices; cudaSetDevice(device_id); </code> <h4>MPI-3 shared-memory support</h4>
</dd></dl>
<p>在主机模式下，该类允许使用MPI-3共享内存功能，提供一个单独的MPI通信器，由同一共享内存域中的进程组成。通过调用<code>vector.shared_vector_data();</code>，用户可以只读访问共享内存通信器中的进程的本地所有值和幽灵值（ <code>comm_sm</code> in <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ace027311492ed2f6e07fbd74d723e3a9">reinit()</a> ）。 要做到这一点，你必须调用这个类的构造函数或其中一个reinit()函数的<code>comm_sm</code>参数的非默认值，该参数对应于一个由同一共享内存域的所有进程组成的通信器。这种通信器可以用下面的代码片断来创建。 </p><div class="fragment"><div class="line"><a class="code" href="classMPI__Comm.html">MPI_Comm</a> <a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4d06704d2372317ea90b5e5bd9c1dc9f">comm_sm</a>;</div><div class="line">MPI_Comm_split_type(comm, MPI_COMM_TYPE_SHARED, rank, MPI_INFO_NULL,</div><div class="line">                    &amp;comm_sm);</div></div><!-- fragment --> <dl class="section see"><dt>See also</dt><dd><a class="el" href="namespaceLinearAlgebra_1_1CUDAWrappers.html">CUDAWrappers</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00121">121</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ae018e039c0ca78a063c6a075be461283"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae018e039c0ca78a063c6a075be461283">&#9670;&nbsp;</a></span>memory_space</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae018e039c0ca78a063c6a075be461283">memory_space</a> =  MemorySpace</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00125">125</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="aca4439cf261c308591c649e442d097ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4439cf261c308591c649e442d097ea">&#9670;&nbsp;</a></span>value_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> =  Number</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00126">126</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ae5c3b93ed114bc9795c0e3b3d5902393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5c3b93ed114bc9795c0e3b3d5902393">&#9670;&nbsp;</a></span>pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae5c3b93ed114bc9795c0e3b3d5902393">pointer</a> =  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00127">127</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a84413e605d193829856edbaa9d75b57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84413e605d193829856edbaa9d75b57b">&#9670;&nbsp;</a></span>const_pointer</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a84413e605d193829856edbaa9d75b57b">const_pointer</a> =  const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00128">128</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a35abed3e6b898142990cecf00e8387da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35abed3e6b898142990cecf00e8387da">&#9670;&nbsp;</a></span>iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> =  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00129">129</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a4a990da0f1e95dd6004fbf0cf711c53d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a990da0f1e95dd6004fbf0cf711c53d">&#9670;&nbsp;</a></span>const_iterator</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> =  const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> *</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00130">130</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ae2ae1224f3b1fbee6cc8ffa59901d6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ae1224f3b1fbee6cc8ffa59901d6c8">&#9670;&nbsp;</a></span>reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ae2ae1224f3b1fbee6cc8ffa59901d6c8">reference</a> =  <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00131">131</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a1aa37d6cce7c7fe31452d2bae09dc7ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa37d6cce7c7fe31452d2bae09dc7ba">&#9670;&nbsp;</a></span>const_reference</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a1aa37d6cce7c7fe31452d2bae09dc7ba">const_reference</a> =  const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aca4439cf261c308591c649e442d097ea">value_type</a> &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00132">132</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a301cc0a1214a6aeb04bb4e1dd06a8dfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a301cc0a1214a6aeb04bb4e1dd06a8dfc">&#9670;&nbsp;</a></span>size_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> =  <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00133">133</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a34599939674e79cdc3808bb074bcf0ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34599939674e79cdc3808bb074bcf0ee">&#9670;&nbsp;</a></span>real_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> =  typename <a class="el" href="structnumbers_1_1NumberTraits.html">numbers::NumberTraits</a>&lt;Number&gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l00134">134</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a702bf4533c5ce7e4144d3d86afb31195"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a702bf4533c5ce7e4144d3d86afb31195">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>空的构造器。 </p>

</div>
</div>
<a id="a60510dc0ed5441f1875cea6800645d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60510dc0ed5441f1875cea6800645d3c">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>复制构造函数。使用 <code>in_vector</code>. 的并行分区 应该注意的是，这个构造函数会自动将ghost值设置为零。如果需要一个重影向量，请在构造后直接调用 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> 。 </p>

</div>
</div>
<a id="a3be6c4ce529bb9b6c13eb831d0a86f55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3be6c4ce529bb9b6c13eb831d0a86f55">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构建一个给定的全局大小的平行向量，没有任何实际的平行分布。 </p>

</div>
</div>
<a id="a31393977fc00f2d9c46f259330ef2a23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31393977fc00f2d9c46f259330ef2a23">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>构建一个平行向量。本地范围由 <code>local_owned_set指定（注意，这必须是一个连续的区间，多个区间是不可能的）。IndexSet</code> <code>ghost_indices</code> 指定了鬼魂索引，即人们可能需要从中读取数据或积累数据的索引。允许鬼魂索引集也包含本地范围，但不需要。 这个函数涉及到全局通信，所以对于一个给定的布局，它应该只被调用一次。使用带有Vector&lt;Number&gt;参数的构造函数来创建具有相同平行布局的额外向量。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> </dd></dl>

</div>
</div>
<a id="a44feea9fec2eeab75baf051b65fa8094"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44feea9fec2eeab75baf051b65fa8094">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述构造函数相同，但没有任何鬼魂索引。 </p>

</div>
</div>
<a id="afe52b52803ff7d23233e37083689b8f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe52b52803ff7d23233e37083689b8f1">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>基于 <code>分区器中描述的并行分区来创建向量。输入参数是一个共享指针，它只存储一次分区器数据，并在具有相同布局的几个向量之间共享它。</code> </p>

</div>
</div>
<a id="a99e3faeced0e8afcf1208a6955e88ffd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e3faeced0e8afcf1208a6955e88ffd">&#9670;&nbsp;</a></span>~Vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::~<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>解构器。 </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ace027311492ed2f6e07fbd74d723e3a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace027311492ed2f6e07fbd74d723e3a9">&#9670;&nbsp;</a></span>reinit() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量的全局大小设置为 <code>size</code> ，而没有任何实际的并行分布。 </p>

</div>
</div>
<a id="a8a79ca37d7f7a8cfd04f5dd61d350ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a79ca37d7f7a8cfd04f5dd61d350ae5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使用输入向量 <code>in_vector</code> 的并行布局，并为该向量分配内存。当需要创建多个具有相同布局的向量时，推荐使用初始化函数。 如果标志 <code>omit_zeroing_entries</code> 被设置为false，内存将被初始化为0，否则内存将不被动用（用户在使用前必须确保用合理的数据填充）。 </p>

</div>
</div>
<a id="a7415120211cbfb0b525423f5e028791e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7415120211cbfb0b525423f5e028791e">&#9670;&nbsp;</a></span>reinit() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>ghost_indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化向量。本地范围由 <code>local_owned_set指定（注意，这必须是一个连续的区间，多个区间是不可能的）。IndexSet</code> <code>ghost_indices</code> 指定了鬼魂索引，即人们可能需要从中读取数据或积累数据的索引。允许鬼魂索引集也包含本地范围，但不需要。 这个函数涉及到全局通信，所以对于一个给定的布局，它应该只被调用一次。使用带有Vector&lt;Number&gt;参数的 <code>reinit</code> 函数来创建具有相同平行布局的额外向量。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> </dd></dl>

</div>
</div>
<a id="ac86885392f82f70c0acdc2cc2fe272d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac86885392f82f70c0acdc2cc2fe272d5">&#9670;&nbsp;</a></span>reinit() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classIndexSet.html">IndexSet</a> &amp;&#160;</td>
          <td class="paramname"><em>local_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>communicator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与上述相同，但没有鬼魂条目。 </p>

</div>
</div>
<a id="a1a4afb6f468e902618d2f3bf41da181c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4afb6f468e902618d2f3bf41da181c">&#9670;&nbsp;</a></span>reinit() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>partitioner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>初始化给与 <code>partitioner</code>. 中描述的并行分区的向量，输入参数是一个共享指针，它只存储一次分区器数据，并在具有相同布局的几个向量之间共享。 可选的参数 <code>comm_sm</code>, 由同一共享内存域上的进程组成，允许用户对共享内存通信器中合并的进程的本地拥有值和幽灵值进行只读访问。关于这个参数的更多信息，请参见该类的一般文档。 </p>

</div>
</div>
<a id="ac6c95ee056cdf27d171711cd7c8f5701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6c95ee056cdf27d171711cd7c8f5701">&#9670;&nbsp;</a></span>reinit() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>local_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacetypes.html#a3543786f7dc7c57385fc923a6afd5917">types::global_dof_index</a>&#160;</td>
          <td class="paramname"><em>ghost_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用 <code>local_size</code> 本地拥有和 <code>ghost_size</code> 幽灵自由度初始化向量。 可选的参数 <code>comm_sm</code>, 由同一共享内存域的进程组成，允许用户对共享内存通信器中的进程的本地拥有值和幽灵值进行只读访问。关于这个参数的更多信息，请参见该类的一般文档。 </p><dl class="section note"><dt>Note</dt><dd>在创建的底层分区器中，本地索引范围以升序和一对一的方式转化为全局索引，即进程 \(p\) 的索引正好位于进程 \(p-1\) 和 \(p+1\) 的索引之间，分别。将 <code>ghost_size</code> 变量设置为一个适当的值，在向量的内存分配中为幽灵数据提供内存空间，并允许通过local_element()访问它。然而，在这种情况下，相关的全局索引必须由外部来处理。 </dd></dl>

</div>
</div>
<a id="a2ca1b9394ef76f792c06e3d4f006b4e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ca1b9394ef76f792c06e3d4f006b4e1">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::swap </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>交换这个向量和另一个向量的内容 <code>v</code>. 人们可以通过一个临时变量和复制数据元素来完成这个操作，但是这个函数明显更有效率，因为它只交换两个向量的数据指针，因此不需要分配临时存储和移动数据。 这个函数类似于所有C++标准容器的 <code>swap</code> 函数。此外，还有一个全局函数<code>swap(u,v)</code>，它简单地调用<code>u.swap(v)</code>，同样与标准函数相类似。 </p>

</div>
</div>
<a id="abb2a2d81a821ae954545ca77a89fa240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2a2d81a821ae954545ca77a89fa240">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量分配给输入向量 <code>in_vector</code>, 的并行分区，并复制所有数据。 如果输入向量或调用向量中的一个（在赋值运算符的左边）在此操作之前设置了鬼魂元素，调用向量将设置鬼魂值。否则，它将处于写模式。如果输入向量根本没有任何鬼魂元素，该向量也将更新其鬼魂值，类似于Trilinos和PETSc向量的各自设置。 </p>

</div>
</div>
<a id="ad364c47c5b3b7b991490cd626c729f0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad364c47c5b3b7b991490cd626c729f0b">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>in_vector</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将向量分配给输入向量 <code>in_vector</code>, 的并行分区，并复制所有数据。 如果输入向量或调用向量中的一个（在赋值运算符的左边）在此操作之前设置了鬼魂元素，调用向量将设置鬼魂值。否则，它将处于写模式。如果输入向量根本没有任何鬼魂元素，该向量也将更新其鬼魂值，类似于Trilinos和PETSc向量的各自设置。 </p>

</div>
</div>
<a id="a8a204103e550697467d933388b732bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a204103e550697467d933388b732bda">&#9670;&nbsp;</a></span>compress() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数将积累在数据缓冲器中的鬼魂索引的数据复制到拥有的处理器中。关于参数 <code>operation</code>, 的含义，见术语表中的 <a class="el" href="DEALGlossary.html#GlossCompress">压缩分布式向量和矩阵 </a> 条目。 这个函数有四个变体。如果用参数 <code>调用</code> <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a> ，则将所有积累在幽灵元素中的数据添加到拥有处理器的相应元素中，并在之后清除幽灵阵列。如果用参数 <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a></code>, 调用，则执行设置操作。因为在一个有鬼魂元素的向量中设置元素是不明确的（因为可以同时设置鬼魂位置和拥有位置上的元素），这个操作假设所有的数据都在拥有处理器上正确设置。因此在调用 compress(VectorOperation::insert), 时，所有的ghost条目都被简单地清零（使用zero_ghost_values()）。 在调试模式下，会对数据集在处理器之间是否真的一致进行检查，也就是说，每当发现一个非零的ghost元素，就会与拥有处理器上的值进行比较，如果这些元素不一致，就会抛出一个异常。 如果与 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a> 或 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>, 一起调用，将设置所有处理器上的元素的最小值或最大值。 </p><dl class="section note"><dt>Note</dt><dd>这个向量类有一组固定的鬼魂条目附加到本地表示。因此，所有的ghost条目都被认为是有效的，并将根据给定的VectorOperation无条件地进行交换。确保用给定的VectorOperation的中性元素初始化所有的ghost条目，或者触摸所有的ghost条目。对于 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a> 和 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae5042eefddc828c7c31e1e8e26da8b09">VectorOperation::insert</a>, 来说，中性元素是零 <code>+inf</code>对于 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964ca5e8042e5d04399d125cb923eda7a8d8b">VectorOperation::min</a>, 来说，<code>-inf</code>对于 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a>. 来说，如果所有的值被初始化为低于零的值，并且随后用 <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964caaae8b002691d4887ce68ecf3e785c13e">VectorOperation::max</a> 调用compress两次，第二次计算后的最大值将是零。 </dd></dl>

</div>
</div>
<a id="a2a6cb7d50e02022283af53c2ae14f878"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a6cb7d50e02022283af53c2ae14f878">&#9670;&nbsp;</a></span>update_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>用存储在所属处理器各自位置上的值来填充ghost索引的数据域。在从鬼魂中读取数据之前需要这个函数。该函数是 <code>const</code> ，即使ghost数据被改变。需要这样做是为了让具有 <code>常量向量的函数在不创建临时性的情况下进行数据交换。</code> 调用这个方法后，禁止对向量的ghost元素进行写入访问，并抛出一个异常。在这种状态下，只允许对鬼魂元素进行读取访问。请注意，随后对这个向量的所有操作，比如全局向量加法等，也会在操作后通过调用这个方法来更新ghost值。然而，像规范或内积这样的全局缩减操作将总是忽略幽灵元素，以避免多次计算幽灵数据。为了允许再次写入ghost元素，可以调用zero_out_ghost_values()。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有鬼魂元素的向量</a> </dd></dl>

</div>
</div>
<a id="aab0c01436acde21cc2dbb5576d8f2375"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab0c01436acde21cc2dbb5576d8f2375">&#9670;&nbsp;</a></span>compress_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_start </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>communication_channel</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em> = <code><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964cae1077e8dbf4afea5d2df8c8b723c0708">VectorOperation::add</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8a204103e550697467d933388b732bda">compress()</a></code> 函数启动非阻塞式通信。该函数不等待传输完成，以便在所有数据到达之前的时间内进行其他计算。 在数据实际交换之前，该函数必须接着调用 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada0b48d524285ca7b302da593b3321a9">compress_finish()</a></code>. 。如果在调用 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ada0b48d524285ca7b302da593b3321a9">compress_finish()</a>之前，该函数被调用超过一个向量，则必须为每个此类调用指定一个唯一的通信通道，以避免几个具有相同ID的消息破坏该操作。任何小于100的通信通道都是有效值（特别是，</code> \([100, 200)\) 范围保留给 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>). 。 </p>

</div>
</div>
<a id="ada0b48d524285ca7b302da593b3321a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada0b48d524285ca7b302da593b3321a9">&#9670;&nbsp;</a></span>compress_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_finish </td>
          <td>(</td>
          <td class="paramtype">::<a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于所有在compress_start中启动的请求，等待通信结束。一旦完成，将数据（取决于标志操作）添加或设置到拥有处理器的相应位置，并清除幽灵数据字段中的内容。 这个参数的含义与compress()中的相同。 这个函数应该在调用compress_start后，每个向量精确地调用一次，否则结果就无法定义。特别是，在调用compress_finished之前，对同一个向量再次调用compress_start是不好定义的。然而，没有警告来防止这种情况。 必须在对 <code>compress_start</code> 函数的调用之后。 当MemorySpace是CUDA并且MPI不支持CUDA时，调用compress_start后设备上改变的数据将丢失。 </p>

</div>
</div>
<a id="ab7045a29ddd2b5fb86ce56c3806e08d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7045a29ddd2b5fb86ce56c3806e08d3">&#9670;&nbsp;</a></span>update_ghost_values_start()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_start </td>
          <td>(</td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>communication_channel</em> = <code>0</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>为 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2a6cb7d50e02022283af53c2ae14f878">update_ghost_values()</a></code> 函数启动非阻塞式通信。这个函数不等待传输完成，以便在所有数据到达之前的时间内允许进行其他计算。 在数据实际交换之前，该函数必须紧接着调用 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab305a49968449aa44e998f4364838479">update_ghost_values_finish()</a></code>. 。如果在调用 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ab305a49968449aa44e998f4364838479">update_ghost_values_finish()</a>之前，该函数被调用超过一个向量，则必须为每个此类调用指定一个唯一的通信通道，以避免几个相同ID的消息破坏该操作。</code> 任何小于100的通信通道都是有效值（特别是， \([100, 200)\) 范围保留给 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a>). 。 </p>

</div>
</div>
<a id="ab305a49968449aa44e998f4364838479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab305a49968449aa44e998f4364838479">&#9670;&nbsp;</a></span>update_ghost_values_finish()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_finish </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对于所有在update_ghost_values_start中启动的请求，等待通信结束。 必须在调用 <code>update_ghost_values_start</code> 函数之后，才能从ghost索引中读取数据。 </p>

</div>
</div>
<a id="ac0dc3fd03c7851d5577c159703282548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0dc3fd03c7851d5577c159703282548">&#9670;&nbsp;</a></span>zero_out_ghosts()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::zero_out_ghosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个方法将ghost dofs上的条目清零，但不触及本地拥有的DoF。 调用此方法后，禁止对向量的ghost元素进行读取访问，并抛出一个异常。在这种状态下，只允许对鬼魂元素进行写入访问。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000045">Deprecated:</a></b></dt><dd>使用zero_out_ghost_values()代替。</dd></dl>

</div>
</div>
<a id="a0242ed0c3e3664e6b4204d28a726a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0242ed0c3e3664e6b4204d28a726a0b7">&#9670;&nbsp;</a></span>zero_out_ghost_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::zero_out_ghost_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个方法将ghost dofs上的条目清零，但不涉及本地拥有的DoF。 调用该方法后，禁止对向量中的ghost元素进行读取访问，并且会抛出一个异常。在这种状态下，只允许对鬼魂元素进行写入访问。 </p>

</div>
</div>
<a id="a17719d884e60b2ad0077a03b92382975"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17719d884e60b2ad0077a03b92382975">&#9670;&nbsp;</a></span>has_ghost_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::has_ghost_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量当前是否处于可以读取ghost值的状态。这与其他并行向量的功能相同。如果这个方法返回false，这只意味着对ghost元素的读访问被禁止，而写访问仍然是可能的（对那些在初始化时指定为ghost的条目），而不是说根本就没有ghost元素。 </p><dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossGhostedVector">有幽灵元素的向量</a> </dd></dl>

</div>
</div>
<a id="ab792ddb04b95a220e489f2d7f9eee990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab792ddb04b95a220e489f2d7f9eee990">&#9670;&nbsp;</a></span>copy_locally_owned_data_from()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::copy_locally_owned_data_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>该方法将本地拥有的范围内的数据从另一个分布式向量 <code>src</code> 复制到调用向量中。与同样包括鬼魂条目的operator=相反，这个操作忽略了鬼魂范围。唯一的前提是调用向量和给定向量 <code>src</code> 的本地范围在所有处理器上是相同的。明确允许两个向量有不同的重影元素，这些元素可能是也可能不是相互关联的。 由于没有进行数据交换，确保 <code>src</code> 和调用向量都没有待处理的通信，以便获得正确的结果。 </p>

</div>
</div>
<a id="af7b743d761233b92e0ed23e6bf37a409"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7b743d761233b92e0ed23e6bf37a409">&#9670;&nbsp;</a></span>import() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename MemorySpace2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>导入分布式向量中存在的所有元素 <code>src</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> 用于决定 <code>V</code> 中的元素是否应该添加到当前向量中或替换当前元素。这个函数的主要目的是将数据从一个内存空间，如CUDA，获取到另一个内存空间，如Host。 </p><dl class="section note"><dt>Note</dt><dd>两个分布式向量的分区器需要相同，因为没有进行MPI通信。 </dd></dl>

</div>
</div>
<a id="a7bde7122a6d05d6815f507f7cb27819a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bde7122a6d05d6815f507f7cb27819a">&#9670;&nbsp;</a></span>reinit() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::reinit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>omit_zeroing_entries</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将维度改为向量V的维度，V的元素不被复制。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a786d97fd050d53e86d523b1b0766f568">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ad85b449afaa8f491f01d7670bcc48099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85b449afaa8f491f01d7670bcc48099">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将整个向量乘以一个固定的因子。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a02349286c5e57d29396dfac9290d302f">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a16146ad677e926f3bdbed2aca3248247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16146ad677e926f3bdbed2aca3248247">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>factor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用整个向量除以一个固定的因子。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a198b28b1759b52bd5df5345be6ff8868">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a3eabb34382bc0694390f97616742bcdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3eabb34382bc0694390f97616742bcdf">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将向量 <code>V</code> 添加到现在的向量中。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8b581c9b2dd4a55c2a5998e62b195bd9">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a132ecfef78dfec86c1b6a5423d642ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132ecfef78dfec86c1b6a5423d642ae0">&#9670;&nbsp;</a></span>operator-=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从现在的向量中减去向量 <code>V</code> 。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a61e201954ade41d8b8ba290e5841efb2">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ad947177e38381c4fd058876a4f27f771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad947177e38381c4fd058876a4f27f771">&#9670;&nbsp;</a></span>import() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1ReadWriteVector.html">LinearAlgebra::ReadWriteVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; const <a class="el" href="classUtilities_1_1MPI_1_1CommunicationPatternBase.html">Utilities::MPI::CommunicationPatternBase</a> &gt;&#160;</td>
          <td class="paramname"><em>communication_pattern</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从输入向量 <code>V</code>. <a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a> <code>operation</code> 中导入所有存在于向量IndexSet中的元素，用于决定 <code>V</code> 中的元素是否应该被添加到当前向量中，或者替换当前元素。如果多次使用同一通信模式，可以使用最后一个参数。这可以用来提高性能。 </p><dl class="section note"><dt>Note</dt><dd>如果MemorySpace是CUDA，ReadWriteVector中的数据将被移动到设备上。 </dd></dl>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a0c05d3725740bda0feab10c660582669">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a829281a9ccc9f1cf9720ee5a535efd21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a829281a9ccc9f1cf9720ee5a535efd21">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回两个向量的标量乘积。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#abe15b048b316e02c2c88644713f9bda8">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ac029174b48a0707da587b6ce3bc25047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac029174b48a0707da587b6ce3bc25047">&#9670;&nbsp;</a></span>add() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将 <code>a</code> 加到所有分量上。注意 <code>a</code> 是一个标量而不是一个向量。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a3dbc94fab7a9b8490941588107b5d27b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ab7d70c674b55edbb3595acaedc310996"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7d70c674b55edbb3595acaedc310996">&#9670;&nbsp;</a></span>add() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>向量的倍数的简单加法，即<code>*this += a*V</code>。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a5d989f75097f8bb45e5297a262ed941d">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a25d752a33b33192932b0dd8054d2c40e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d752a33b33192932b0dd8054d2c40e">&#9670;&nbsp;</a></span>add() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩放向量的多重加法，即：<code>*this += a*V+b*W</code>。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#abc8bff328d603ccb5978a6b7d6543c8c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a883f439a5130ebbbc15f765928a0ad92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883f439a5130ebbbc15f765928a0ad92">&#9670;&nbsp;</a></span>add() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个集体加法操作。这个函数将存储在 <code>values</code> 中的一整套数值添加到 <code>indices</code>. 指定的向量成分中。 </p>

</div>
</div>
<a id="aa6376a098589519491fc452d1529f57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6376a098589519491fc452d1529f57b">&#9670;&nbsp;</a></span>sadd() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>缩放和简单的向量倍数相加，即<code>*this = s*(*this)+a*V</code>。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8f8a5799eb407e559540aae082f9ec87">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="aacdf6bfd4533c47587ba0debe177710e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacdf6bfd4533c47587ba0debe177710e">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::scale </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>scaling_factors</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用参数中的相应元素来缩放这个向量的每个元素。这个函数主要是为了模拟对角线缩放矩阵的乘法（和立即重新分配）。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a27c492ff183de02d4f75f3d152c6f0ac">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a43c64a6bebc56d849307ef1fcad62c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c64a6bebc56d849307ef1fcad62c23">&#9670;&nbsp;</a></span>equ()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::equ </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>赋值 <code>*this = a*V</code>. </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a344fbb1ede704fb7b14e6e60048e9da3">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a0e93518655d2231061f4eb916e98a130"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e93518655d2231061f4eb916e98a130">&#9670;&nbsp;</a></span>l1_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l1_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的l<sub>1</sub>规范（即所有处理器中所有条目的绝对值之和）。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a6ad9146f2c4a36cc762456b4cba21b4c">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="af355599021a687026ab9818efd57e82d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af355599021a687026ab9818efd57e82d">&#9670;&nbsp;</a></span>l2_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l2_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的 \(l_2\) 准则（即所有处理器中所有条目的平方之和的平方根）。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a2d4822289e1415f1bf35c84c4b7ee292">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="aeecc4f641fb6c425eb9f12048d7e8efd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeecc4f641fb6c425eb9f12048d7e8efd">&#9670;&nbsp;</a></span>norm_sqr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::norm_sqr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的 \(l_2\) 规范的平方。 </p>

</div>
</div>
<a id="a2e7bf945225df27d522ec30f1530c0aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e7bf945225df27d522ec30f1530c0aa">&#9670;&nbsp;</a></span>linfty_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::linfty_norm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的最大规范（即所有条目和所有处理器中的最大绝对值）。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#af84f65fc1f6ebc21534271c42c33d159">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="af1dc41a177aadb6a2f6d0d7c2cf41eba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1dc41a177aadb6a2f6d0d7c2cf41eba">&#9670;&nbsp;</a></span>add_and_dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_and_dot </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>执行一个向量加法和后续内积的组合操作，返回内积的值。换句话说，这个函数的结果与用户调用的 </p><div class="fragment"><div class="line">this-&gt;<a class="code" href="classLinearAlgebra_1_1distributed_1_1Vector.html#ac029174b48a0707da587b6ce3bc25047">add</a>(a, <a class="code" href="namespaceLAPACKSupport.html#aee5ef58d11434eb1d6a665e64bf17292">V</a>);</div><div class="line">return_value =<span class="keyword">this</span> W;</div></div><!-- fragment --><p> 这个函数存在的原因是这个操作比单独调用这两个函数涉及的内存转移要少。这个方法只需要加载三个向量， <code>this</code>, <code>V</code>, <code>W</code>, ，而调用单独的方法意味着要加载调用向量 <code>this</code> 两次。由于大多数向量操作都有内存传输限制，这就使时间减少了25%（如果 <code>W</code> 等于 <code>this</code>). ，则减少50%）对于复值向量，第二步中的标量乘法被实现为 \(\left&lt;v,w\right&gt;=\sum_i v_i \bar{w_i}\) 。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a89ae394fb53af7daf23705d5992f9f11">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a99297a298764249d0c0b5adf9a96e1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99297a298764249d0c0b5adf9a96e1c7">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回向量的全局大小，等于所有处理器中本地拥有的索引数之和。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a79b24c9cc50ac00221c89466a021c62a">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="aff5265a5af79342c77ac50d584c9d3e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5265a5af79342c77ac50d584c9d3e4">&#9670;&nbsp;</a></span>locally_owned_elements()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ::<a class="el" href="classIndexSet.html">IndexSet</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::locally_owned_elements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回一个索引集，描述这个向量的哪些元素为当前处理器所拥有。因此，如果这是一个分布式向量，在不同处理器上返回的索引集将形成不相交的集合，加起来就是完整的索引集。很明显，如果一个向量只在一个处理器上创建，那么结果将满足 </p><div class="fragment"><div class="line">vec.locally_owned_elements() == <a class="code" href="index__set_8h.html#ad28b2e725afda38ffdef1bf61d5cadd4">complete_index_set</a>(vec.size())</div></div><!-- fragment --> 
<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a47e92627a68a0a778490b5694af4212b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="ab2218dcb909cf45f3e495ac250ea9260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2218dcb909cf45f3e495ac250ea9260">&#9670;&nbsp;</a></span>print()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::print </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>precision</em> = <code>3</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>scientific</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>across</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将向量打印到输出流 <code>out</code>. 。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a1fcac5e46eb6bc858f1715e30db75031">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a493afd09167ce2c18d27252178d88c59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493afd09167ce2c18d27252178d88c59">&#9670;&nbsp;</a></span>memory_consumption()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::size_t <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::memory_consumption </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回这个类的内存消耗，单位是字节。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a4760b791f71d963298a5d49917f46555">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a85d501a9f8c20d9142fe6a0f88bb12a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85d501a9f8c20d9142fe6a0f88bb12a4">&#9670;&nbsp;</a></span>operator=() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt;Number, MemorySpace&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>将向量的所有元素设置为标量 <code>s</code>. 如果标量为零，也将鬼魂元素设置为零，否则它们保持不变。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#ae5dd9195f5c8988b1c8d9cd7878228cb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a79cb76c50ddfade06995373dfc14cdb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79cb76c50ddfade06995373dfc14cdb4">&#9670;&nbsp;</a></span>add() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这是一个集体添加操作，将存储在 <code>values</code> 中的整组值添加到 <code>indices</code>. 指定的向量成分中。 </p>

</div>
</div>
<a id="a428a001329c576451c1a77557212527a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428a001329c576451c1a77557212527a">&#9670;&nbsp;</a></span>add() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>n_elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OtherNumber *&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>取一个连续存储n_elements的地址，将它们添加到向量中。 </p>

</div>
</div>
<a id="a44cbdb2b9d3612d549e544dcd11a33ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44cbdb2b9d3612d549e544dcd11a33ed">&#9670;&nbsp;</a></span>sadd() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>缩放和简单的向量添加，即<code>*this = s*(*this)+V</code>。 </p>

</div>
</div>
<a id="abebeb6ebf3dedc1123663eae12374b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebeb6ebf3dedc1123663eae12374b06">&#9670;&nbsp;</a></span>local_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的本地大小，即本地拥有的索引数。 </p><dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000046">Deprecated:</a></b></dt><dd>使用local_owned_size()代替。</dd></dl>

</div>
</div>
<a id="a3db2bea96180138f039b9d2934534492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3db2bea96180138f039b9d2934534492">&#9670;&nbsp;</a></span>locally_owned_size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::locally_owned_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回向量的本地大小，即本地拥有的索引数。 </p>

</div>
</div>
<a id="ae8fc3d0924b59159a50ed9838d8a6592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fc3d0924b59159a50ed9838d8a6592">&#9670;&nbsp;</a></span>in_local_range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::in_local_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>如果给定的全局索引在这个处理器的本地范围内，则返回true。 </p>

</div>
</div>
<a id="afdcd750879bde459ccb63936c74a0e87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdcd750879bde459ccb63936c74a0e87">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>使 <code><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></code> 类有点像C++标准库中的<code>vector&lt;&gt;/tt&gt;类，返回该向量的<em>locally owned</em>元素的开始和结束的迭代器。 它认为，end()</code></p>
<p><code></p><ul>
<li><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#afdcd750879bde459ccb63936c74a0e87">begin()</a> == local_owned_size()。 <dl class="section note"><dt>Note</dt><dd>对于CUDA内存空间，迭代器指向设备上的内存。 </dd></dl>
</li>
</ul>
<p></code></p>

</div>
</div>
<a id="ae038db1a3998888e469398031da2b980"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae038db1a3998888e469398031da2b980">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回常数迭代器，指向向量中本地拥有的元素的起点。 </p><dl class="section note"><dt>Note</dt><dd>对于CUDA内存空间，该迭代器指向设备上的内存。 </dd></dl>

</div>
</div>
<a id="ab0a4b780b6b8fded62768da4164d2378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0a4b780b6b8fded62768da4164d2378">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a35abed3e6b898142990cecf00e8387da">iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个迭代器，指向本地拥有的条目数组结束后的元素。 </p><dl class="section note"><dt>Note</dt><dd>对于CUDA内存空间，该迭代器指向设备上的内存。 </dd></dl>

</div>
</div>
<a id="a362987561884296cee4ba45f4fe85abe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a362987561884296cee4ba45f4fe85abe">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a4a990da0f1e95dd6004fbf0cf711c53d">const_iterator</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个恒定的迭代器，指向本地拥有的条目数组末端之后的元素。 </p><dl class="section note"><dt>Note</dt><dd>对于CUDA内存空间，该迭代器指向设备上的内存。 </dd></dl>

</div>
</div>
<a id="ac551bfa7fd898a0a8e85f59109c091ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac551bfa7fd898a0a8e85f59109c091ed">&#9670;&nbsp;</a></span>operator()() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对 <code>global_index对应位置的数据进行读取访问。该索引必须在向量的本地范围内，或者在构造时被指定为一个幽灵索引。</code> 性能。<code>O(1)</code>对于代表连续范围的本地拥有的元素，<code>O(log(n<sub>ranges</sub>))</code>对于幽灵元素（相当快，但是比local_element()慢）。 </p>

</div>
</div>
<a id="a58b7c43da3b837f4b811ad4cc813d899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b7c43da3b837f4b811ad4cc813d899">&#9670;&nbsp;</a></span>operator()() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator() </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取和写入对应于 <code>global_index位置的数据。该索引必须在向量的本地范围内，或者在构造时被指定为一个幽灵索引。</code> 性能。<code>O(1)</code>对于代表连续范围的本地拥有的元素，<code>O(log(n<sub>ranges</sub>))</code>对于幽灵元素（相当快，但是比local_element()慢）。 </p>

</div>
</div>
<a id="a5c497852ad2b7d6917a4b60f6c7b28bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c497852ad2b7d6917a4b60f6c7b28bf">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取访问对应于 <code>global_index位置的数据。该索引必须在向量的本地范围内，或者在构造时被指定为一个鬼魂索引。</code> 这个函数与operator()的作用相同。 </p>

</div>
</div>
<a id="a1bc5f6e645477d457a68784b83bdf582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc5f6e645477d457a68784b83bdf582">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>global_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取和写入对应于 <code>global_index位置的数据。该索引必须在向量的本地范围内，或者在构造时被指定为一个幽灵索引。</code> 这个函数与operator()的作用相同。 </p>

</div>
</div>
<a id="a1c4bc946b94f19d7e11c00f41a39db02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4bc946b94f19d7e11c00f41a39db02">&#9670;&nbsp;</a></span>local_element() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>读取访问由 <code>local_index</code>. 指定的数据字段 本地拥有的指数可以用指数 <code>[0,locally_owned_size)</code> 访问，而鬼魂指数可以用指数 <code>[locally_owned_size,locally_owned_size+ n_ghost_entries]</code> 访问。 性能。直接数组访问（快速）。 </p>

</div>
</div>
<a id="a397872125364fdcaf89e62f8616d7d62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397872125364fdcaf89e62f8616d7d62">&#9670;&nbsp;</a></span>local_element() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::local_element </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>local_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>对 <code>local_index</code>. 指定的数据字段进行读写访问 可以用索引 <code>[0,<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>)</code> 访问本地拥有的索引，用索引 <code>[<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>, <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a3db2bea96180138f039b9d2934534492">locally_owned_size()</a>+n_ghosts]</code> 访问幽灵索引。 性能。直接数组访问（快速）。 </p>

</div>
</div>
<a id="a8db545d71e642710a044554d6df060d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8db545d71e642710a044554d6df060d9">&#9670;&nbsp;</a></span>get_values()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Number* <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_values </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回指向底层原始数组的指针。 </p><dl class="section note"><dt>Note</dt><dd>对于CUDA内存空间，指针指向设备上的内存。 </dd></dl>

</div>
</div>
<a id="ad49497fa8fad0250a2bd0f4a36179ff2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad49497fa8fad0250a2bd0f4a36179ff2">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename OtherNumber &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; OtherNumber &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>与通过operator()获取向量的单个元素不同，这个函数允许一次性获取一整组元素。要读取的元素的索引在第一个参数中说明，相应的值在第二个参数中返回。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就等同于代码 </p><div class="fragment"><div class="line"><span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> i=0; i&lt;indices.size(); ++i)</div><div class="line">  <a class="code" href="namespaceEvaluationFlags.html#a9b7c6d689cb76386839d0d13640f59aeaf9825c682f693a6a200094641a0d6a58">values</a>[i] = v[indices[i]];</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd><code>indices</code> 和 <code>values</code> 数组的大小必须是一致的。 </dd></dl>
<dl class="section note"><dt>Note</dt><dd>这个函数在CUDA内存空间没有实现。 </dd></dl>

</div>
</div>
<a id="aeb9494a9258d9f0b06b97550921c5e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9494a9258d9f0b06b97550921c5e0e">&#9670;&nbsp;</a></span>extract_subvector_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename ForwardIterator , typename OutputIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::extract_subvector_to </td>
          <td>(</td>
          <td class="paramtype">ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ForwardIterator&#160;</td>
          <td class="paramname"><em>indices_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIterator&#160;</td>
          <td class="paramname"><em>values_begin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>这个函数不是通过operator()来获取向量的单个元素，而是允许一次性获取一整组元素。与前一个函数不同的是，这个函数通过取消引用前两个参数提供的迭代器范围内的所有元素来获得元素的索引，并将向量的值放入通过取消引用从第三个参数指向的位置开始的迭代器范围获得的内存位置。 如果当前的向量被称为 <code>v</code>, ，那么这个函数就相当于代码中的 </p><div class="fragment"><div class="line">ForwardIterator indices_p = indices_begin;</div><div class="line">OutputIterator  values_p  = values_begin;</div><div class="line"><span class="keywordflow">while</span> (indices_p != indices_end)</div><div class="line">{</div><div class="line"> values_p = v[*indices_p];</div><div class="line">  ++indices_p;</div><div class="line">  ++values_p;</div><div class="line">}</div></div><!-- fragment --> <dl class="section pre"><dt>Precondition</dt><dd>必须能够写进从 <code>values_begin</code> 开始的尽可能多的内存位置，因为有 <code>indices_begin</code> 和 <code>indices_end</code>. 之间的迭代器。 </dd></dl>

</div>
</div>
<a id="a5ed7dc1d792f9344f1c8720e5f639351"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed7dc1d792f9344f1c8720e5f639351">&#9670;&nbsp;</a></span>all_zero()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::all_zero </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回该向量是否只包含值为0的元素。 这是一个集体操作。这个函数很昂贵，因为有可能所有的元素都要被检查。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#a8c03a20480770e68f0d4e1e6456e78eb">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a64f0fddbf542f0e6ff6344e0fa7d55f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f0fddbf542f0e6ff6344e0fa7d55f9">&#9670;&nbsp;</a></span>mean_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mean_value </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>计算向量中所有条目的平均值。 </p>

<p>Implements <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html#ab3e11175ad9c308d796d72aa0fc6b44b">LinearAlgebra::VectorSpaceVector&lt; Number &gt;</a>.</p>

</div>
</div>
<a id="a8bf8c57a134cf1c5f27dab3a5cc1edf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf8c57a134cf1c5f27dab3a5cc1edf5">&#9670;&nbsp;</a></span>lp_norm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::lp_norm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>\(l_p\) &ndash;向量的正负值。元素绝对值的p次方之和的p次根。 </p>

</div>
</div>
<a id="a995b4962ed8eee92cb0db9678c2047eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a995b4962ed8eee92cb0db9678c2047eb">&#9670;&nbsp;</a></span>get_mpi_communicator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_mpi_communicator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回一个对与此向量一起使用的MPI通信器对象的引用。 </p>

</div>
</div>
<a id="a57d72f160499a5f0bc289da5b5187546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d72f160499a5f0bc289da5b5187546">&#9670;&nbsp;</a></span>get_partitioner()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::get_partitioner </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>返回描述向量的并行布局的MPI分区器。这个对象可以用来用各自的reinit()调用初始化另一个向量，用于有关并行通信的额外查询，或者分区器的兼容性。 </p>

</div>
</div>
<a id="a1121c9b5aa9c34d0fe36486fecf08b58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1121c9b5aa9c34d0fe36486fecf08b58">&#9670;&nbsp;</a></span>partitioners_are_compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioners_are_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检查给定的分区器是否与用于该向量的分区器兼容。如果两个分区器具有相同的局部大小和相同的ghost索引，那么它们就是兼容的。它们不一定需要是共享指针的同一个数据域。 这只是一个局部操作，即如果只有一些处理器决定分区不兼容，只有这些处理器会返回 <code>false</code>, ，而其他处理器会返回 <code>true</code>. 。 </p>

</div>
</div>
<a id="a8f678da4f2dec42cd6f9bc383c0f3c11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f678da4f2dec42cd6f9bc383c0f3c11">&#9670;&nbsp;</a></span>partitioners_are_globally_compatible()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioners_are_globally_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>检查给定的分区器是否与该向量使用的分区器兼容。如果两个分区器具有相同的局部大小和相同的ghost索引，那么它们就是兼容的。它们不一定需要是同一个数据域。与partitioners_are_compatible()相反，该方法检查所有处理器之间的兼容性，如果分区器在所有处理器上是相同的，该方法只返回 <code>true</code> 。 这个方法执行全局通信，所以要确保只在所有处理器调用它的次数相同的情况下使用它。 </p>

</div>
</div>
<a id="a662fd533f2cae84a902e7a587fc6f36c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a662fd533f2cae84a902e7a587fc6f36c">&#9670;&nbsp;</a></span>set_ghost_state()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::set_ghost_state </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classbool.html">bool</a>&#160;</td>
          <td class="paramname"><em>ghosted</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>将这个向量的幽灵状态改为 <code>ghosted</code>. 。 </p>

</div>
</div>
<a id="ad16bd935d90fe664309c52be1615bd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad16bd935d90fe664309c52be1615bd4b">&#9670;&nbsp;</a></span>shared_vector_data()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classArrayView.html">ArrayView</a>&lt;const Number&gt; &gt;&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::shared_vector_data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>获取指向同一共享内存域的其他进程的起始值的指针。 </p>

</div>
</div>
<a id="abcc9e52579ffedc85d0c0ef0e0936f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcc9e52579ffedc85d0c0ef0e0936f06">&#9670;&nbsp;</a></span>DeclException3()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::DeclException3 </td>
          <td>(</td>
          <td class="paramtype">ExcNonMatchingElements&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Number&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>int</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;Called &#160;</td>
          <td class="paramname"><em>compress</em>VectorOperation::insert, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but&quot;&lt;&lt; &quot; the element received from a remote&#160;</td>
          <td class="paramname"><em>processor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg1&lt;&lt; &quot;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">does not match with the value &quot;&lt;&lt; std::setprecision(16)&lt;&lt; arg2&lt;&lt; &quot; on the owner processor &quot;&lt;&lt;&#160;</td>
          <td class="paramname"><em>arg3</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="ab281998c9483096f9573b0dfd99a3f07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab281998c9483096f9573b0dfd99a3f07">&#9670;&nbsp;</a></span>DeclException4()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::DeclException4 </td>
          <td>(</td>
          <td class="paramtype">ExcAccessToNonLocalElement&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&lt;&lt; &quot;You tried to access element &quot;&lt;&lt; arg1&lt;&lt; &quot; of a distributed&#160;</td>
          <td class="paramname"><em>vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">but this element is not &quot;&lt;&lt; &quot;stored on the current processor. Note:The range of &quot;&lt;&lt; &quot;locally owned elements&#160;</td>
          <td class="paramname"><em>is</em>[&quot;&lt;&lt; arg2&lt;&lt; &quot;,&quot;&lt;&lt; arg3&lt;&lt; &quot;], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">and there are &quot;&lt;&lt; arg4&lt;&lt; &quot; ghost elements &quot;&lt;&lt; &quot;that this vector can access.&quot;&lt;&lt; &quot;\&quot;&lt;&lt; &quot;A common source for this kind of problem is that you &quot;&lt;&lt; &quot;are passing a 'fully distributed' vector into a function &quot;&lt;&lt; &quot;that needs read access to vector elements that correspond &quot;&lt;&lt; &quot;to degrees of freedom on ghost cells(or at least to &quot;&lt;&lt; &quot; 'locally active' degrees of freedom that are not also &quot;&lt;&lt; &quot; 'locally owned'). You need to pass a vector that has these &quot;&lt;&lt; &quot;elements as ghost entries.&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>异常情况 </p>

</div>
</div>
<a id="a9f9fec5521e69ebd55f8d7dac02cf610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f9fec5521e69ebd55f8d7dac02cf610">&#9670;&nbsp;</a></span>add_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>简单的向量的倍数加法，即<code>*this += a*V</code>，无需MPI通信。 </p>

</div>
</div>
<a id="ac7b56c7dbbe54762d35b9f536e9d9c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7b56c7dbbe54762d35b9f536e9d9c76">&#9670;&nbsp;</a></span>sadd_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::sadd_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">VectorSpaceVector</a>&lt; Number &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个向量的倍数的缩放和简单加法，即：<code>*this = s*(*this)+a*V</code>，无需MPI通信。 </p>

</div>
</div>
<a id="aec8a0511ae8151672f9a92a699523c52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec8a0511ae8151672f9a92a699523c52">&#9670;&nbsp;</a></span>inner_product_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::inner_product_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number2, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个向量的内积的局部部分。 </p>

</div>
</div>
<a id="a45739e3cb34a433f67b5c0e23fa5dcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45739e3cb34a433f67b5c0e23fa5dcf7">&#9670;&nbsp;</a></span>norm_sqr_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::norm_sqr_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#aeecc4f641fb6c425eb9f12048d7e8efd">norm_sqr()</a>的本地部分。 </p>

</div>
</div>
<a id="a0cab16fed261f1579c11ea5c81cb0eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cab16fed261f1579c11ea5c81cb0eb7">&#9670;&nbsp;</a></span>mean_value_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mean_value_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mean_value()的局部部分。 </p>

</div>
</div>
<a id="a2df86018fd6619067a0749deb49c6288"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df86018fd6619067a0749deb49c6288">&#9670;&nbsp;</a></span>l1_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::l1_norm_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a0e93518655d2231061f4eb916e98a130">l1_norm()</a>的本地部分。 </p>

</div>
</div>
<a id="ac6b149f392aea2068ad62632dd865e5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6b149f392aea2068ad62632dd865e5c">&#9670;&nbsp;</a></span>lp_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::lp_norm_local </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a8bf8c57a134cf1c5f27dab3a5cc1edf5">lp_norm()</a>的本地部分。 </p>

</div>
</div>
<a id="a21bc694084db3eb69bd8bb9439787131"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc694084db3eb69bd8bb9439787131">&#9670;&nbsp;</a></span>linfty_norm_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a34599939674e79cdc3808bb074bcf0ee">real_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::linfty_norm_local </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a2e7bf945225df27d522ec30f1530c0aa">linfty_norm()</a>的本地部分。 </p>

</div>
</div>
<a id="a1fb83d9dd19884023fb6c739c1958a7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb83d9dd19884023fb6c739c1958a7a">&#9670;&nbsp;</a></span>add_and_dot_local()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Number <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::add_and_dot_local </td>
          <td>(</td>
          <td class="paramtype">const Number&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; Number, MemorySpace &gt; &amp;&#160;</td>
          <td class="paramname"><em>W</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>两个向量的内积之后的加法的局部部分。这同样适用于复值向量的add_and_dot()函数。 </p>

</div>
</div>
<a id="a4aaa85ec1704806392274242fa705ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4aaa85ec1704806392274242fa705ed8">&#9670;&nbsp;</a></span>clear_mpi_requests()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::clear_mpi_requests </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个帮助函数，用于清除compress_requests和update_ghost_values_requests域。在reinit()函数中使用。 </p>

</div>
</div>
<a id="a0f5a3788d6c951791217cd59f8cd9fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f5a3788d6c951791217cd59f8cd9fbc">&#9670;&nbsp;</a></span>resize_val()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::resize_val </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a>&#160;</td>
          <td class="paramname"><em>new_allocated_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classMPI__Comm.html">MPI_Comm</a> &amp;&#160;</td>
          <td class="paramname"><em>comm_sm</em> = <code>MPI_COMM_SELF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个帮助函数，用于调整val数组的大小。 </p>

</div>
</div>
<a id="a12c6facf38639f49f73a041b901a2c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12c6facf38639f49f73a041b901a2c76">&#9670;&nbsp;</a></span>operator=() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&amp; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const ::<a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a>&lt; number &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="trilinos__vector_8cc_source.html#l00508">508</a> of file <a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a>.</p>

</div>
</div>
<a id="a6207efeaeff0d0f321b35d29d58e8df2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6207efeaeff0d0f321b35d29d58e8df2">&#9670;&nbsp;</a></span>compress() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classLinearAlgebra_1_1VectorSpaceVector.html">LinearAlgebra::VectorSpaceVector</a>&lt; Number &gt;::compress </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structVectorOperation.html#a40c50779cd14ba89bbf0bd9b4561964c">VectorOperation::values</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>这个函数什么都不做，只是为了向后兼容而存在。 </p>

<p class="definition">Definition at line <a class="el" href="vector__space__vector_8h_source.html#l00231">231</a> of file <a class="el" href="vector__space__vector_8h_source.html">vector_space_vector.h</a>.</p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>通过存储指针来订阅该对象的用户 <code>validity</code>. 订阅者可以通过提供的文本来识别 <code>identifier</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>从对象中取消用户的订阅。 </p><dl class="section note"><dt>Note</dt><dd><code>identifier</code> 和 <code>validity</code> 的指针必须与提供给subscribe()的指针相同。 </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>返回目前对这个对象的订阅数量。这允许使用这个类来确定引用计数的寿命，其中最后一个取消订阅的人也会删除该对象。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00273">273</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入的订阅者 <code>stream</code>. 。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00290">290</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>列出输入 <code>deallog</code>. 的订阅者。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>为了使用<a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST序列化库</a>进行序列化，将此对象的数据读入或写入一个流中。 这个函数实际上并没有对这个类的任何成员变量进行序列化。原因是这个类所存储的只是谁订阅了这个对象，但在存储这个对象的内容时，谁订阅了这个对象，与恢复时谁订阅了这个对象并不一定有关系。因此，我们不希望在恢复时覆盖订阅者，那么就没有理由在一开始就把订阅者写出来。 </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00282">282</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ac14c06b74acbf135ede85924e7b3d521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac14c06b74acbf135ede85924e7b3d521">&#9670;&nbsp;</a></span>Vector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 , typename MemorySpace2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">Vector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于向量类型的类型化定义</p>
<p>用于向量类型的类型定义。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01147">1147</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a07c61e4419c2e58a70f3798109c14fac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c61e4419c2e58a70f3798109c14fac">&#9670;&nbsp;</a></span>BlockVector</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<div class="memtemplate">
template&lt;typename Number2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">BlockVector</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于块向量类型的类型定义</p>
<p>用于描述由多个块组成的向量的类型的类型定义。</p>
<p>一个基于分布式deal.II向量的块向量的实现。虽然基类提供了大部分的接口，但这个类处理了向量的实际分配，并提供了底层向量类型的特定函数。 </p><dl class="section note"><dt>Note</dt><dd>这个模板的实例提供给<code> &lt;float&gt; 和 &lt;double&gt;</code>; 其他可以在应用程序中生成（见手册中的 <a class="el" href="Instantiations.html">Template instantiations</a> 部分）。 </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="DEALGlossary.html#GlossBlockLA">块（线性代数）</a> </dd></dl>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000047">Deprecated:</a></b></dt><dd>用 <a class="el" href="classLinearAlgebra_1_1distributed_1_1BlockVector.html">LinearAlgebra::distributed::BlockVector</a> 代替。</dd></dl>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01151">1151</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3f1e1f118b38f6731b99f2f5bed7cd18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f1e1f118b38f6731b99f2f5bed7cd18">&#9670;&nbsp;</a></span>partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;const <a class="el" href="classUtilities_1_1MPI_1_1Partitioner.html">Utilities::MPI::Partitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>共享指针，用于存储并行分区的信息。这个信息可以在具有相同分区的几个向量之间共享。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01068">1068</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a3654b450369a501269a65e8fe917ef7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3654b450369a501269a65e8fe917ef7b">&#9670;&nbsp;</a></span>allocated_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html#a301cc0a1214a6aeb04bb4e1dd06a8dfc">size_type</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::allocated_size</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>目前分配在val数组中的大小。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01074">1074</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2e986decf5878ef8fc13c691910bf263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e986decf5878ef8fc13c691910bf263">&#9670;&nbsp;</a></span>data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt;Number, MemorySpace&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>储存该向量本地元素的底层数据结构。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01080">1080</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="aa22a8f4e80c1fe4ff79779dcda71a0b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa22a8f4e80c1fe4ff79779dcda71a0b9">&#9670;&nbsp;</a></span>thread_loop_partitioner</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::shared_ptr&lt;::<a class="el" href="classparallel_1_1internal_1_1TBBPartitioner.html">parallel::internal::TBBPartitioner</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::thread_loop_partitioner</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>对于带有TBB的并行循环，这个成员变量存储循环的亲和力信息。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01087">1087</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a2c7e2584032a7c664c2c28c0436cd6ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7e2584032a7c664c2c28c0436cd6ce">&#9670;&nbsp;</a></span>import_data</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutable ::<a class="el" href="structMemorySpace_1_1MemorySpaceData.html">MemorySpace::MemorySpaceData</a>&lt;Number, MemorySpace&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::import_data</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>临时存储，用于保存在compress()中发送到这个处理器的数据，或者在update_ghost_values()中从这个处理器发送的数据。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01094">1094</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="af41fb0de7a379de6c6a58801bd93827b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af41fb0de7a379de6c6a58801bd93827b">&#9670;&nbsp;</a></span>vector_is_ghosted</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classbool.html">bool</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::vector_is_ghosted</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>存储向量当前是否允许读取ghost元素。请注意，这是为了确保一致的鬼魂数据，并不表明向量是否真的可以存储鬼魂元素。特别是在组装一个向量时，我们不允许读取元素，只允许写入元素。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01100">1100</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ae53eaaa25a65ca1ce774e713dd37154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae53eaaa25a65ca1ce774e713dd37154c">&#9670;&nbsp;</a></span>compress_requests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classMPI__Request.html">MPI_Request</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::compress_requests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个收集所有来自compress()操作的请求的向量。 这个类使用持久的MPI通信器，也就是说，在连续调用一个给定的函数时，通信通道被存储起来。这减少了设置MPI机器所涉及的开销，但它并没有消除在数据真正被发送之前发布接收操作的需要。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01108">1108</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="ada6604e63e86194c350e0c1ab9d70387"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6604e63e86194c350e0c1ab9d70387">&#9670;&nbsp;</a></span>update_ghost_values_requests</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classMPI__Request.html">MPI_Request</a>&gt; <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::update_ghost_values_requests</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个向量，收集来自update_ghost_values()操作的所有请求。这个类使用持久的MPI通信器。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01114">1114</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="af2ca9ef90490cbf818d17fcca54a76f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ca9ef90490cbf818d17fcca54a76f2">&#9670;&nbsp;</a></span>mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::mutex <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>一个锁，确保压缩()和update_ghost_values()函数在与多个线程一起使用时也能给出合理的结果。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01121">1121</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<a id="a4d06704d2372317ea90b5e5bd9c1dc9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d06704d2372317ea90b5e5bd9c1dc9f">&#9670;&nbsp;</a></span>comm_sm</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number, typename MemorySpace = MemorySpace::Host&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classMPI__Comm.html">MPI_Comm</a> <a class="el" href="classLinearAlgebra_1_1distributed_1_1Vector.html">LinearAlgebra::distributed::Vector</a>&lt; Number, MemorySpace &gt;::comm_sm</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>用于共享内存领域的通信器。关于 "comm_sm
"的用途的更多信息，请参见该类的一般文档。 </p>

<p class="definition">Definition at line <a class="el" href="la__parallel__vector_8h_source.html#l01128">1128</a> of file <a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/deal.II/lac/<a class="el" href="la__parallel__vector_8h_source.html">la_parallel_vector.h</a></li>
<li>source/lac/<a class="el" href="trilinos__vector_8cc_source.html">trilinos_vector.cc</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
