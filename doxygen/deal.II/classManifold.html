<!-- HTML header for doxygen 1.8.13-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<link rel="canonical" href="https://www.dealii.org/current/doxygen/deal.II/classManifold.html" />
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>The deal.II Library: Manifold&lt; dim, spacedim &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js", "TeX/AMSsymbols.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="SHORTCUT ICON" href="deal.ico"></link>
<script type="text/javascript" src="custom.js"></script>
<meta name="author" content="The deal.II Authors <authors@dealii.org>"></meta>
<meta name="copyright" content="Copyright (C) 1998 - 2021 by the deal.II authors"></meta>
<meta name="deal.II-version" content="10.0.0-pre"></meta>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="logo200.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">
   &#160;<span id="projectnumber">Reference documentation for deal.II version 10.0.0-pre</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!--Extra macros for MathJax:-->
<div style="display:none">
\(\newcommand{\dealvcentcolon}{\mathrel{\mathop{:}}}\)
\(\newcommand{\dealcoloneq}{\dealvcentcolon\mathrel{\mkern-1.2mu}=}\)
\(\newcommand{\jump}[1]{\left[\!\left[ #1 \right]\!\right]}\)
\(\newcommand{\average}[1]{\left\{\!\left\{ #1 \right\}\!\right\}}\)
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classManifold-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">Manifold&lt; dim, spacedim &gt; Class Template Reference<span class="mlabels"><span class="mlabel">abstract</span></span><div class="ingroups"><a class="el" href="group__grid.html">Grid classes</a> &raquo; <a class="el" href="group__manifold.html">Manifold description for triangulations</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">deal.II/grid/manifold.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for Manifold&lt; dim, spacedim &gt;:</div>
<div class="dyncontent">
<div class="center"><iframe scrolling="no" frameborder="0" src="classManifold__inherit__graph.svg" width="1720" height="1306"><p><b>This browser is not able to show SVG: try Firefox, Chrome, Safari, or Opera instead.</b></p></iframe>
</div>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> = std::array&lt; <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt; dim &gt;::vertices_per_face &gt;</td></tr>
<tr class="separator:a79eb483936cd38a0a9d42bf2071ee9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a70c02e6c388bf21f43ea09d29681fb34"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a70c02e6c388bf21f43ea09d29681fb34">~Manifold</a> () override=default</td></tr>
<tr class="separator:a70c02e6c388bf21f43ea09d29681fb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140e1b7c7334d16f99aa7ad0dbabb44a"><td class="memItemLeft" align="right" valign="top">virtual std::unique_ptr&lt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a140e1b7c7334d16f99aa7ad0dbabb44a">clone</a> () const =0</td></tr>
<tr class="separator:a140e1b7c7334d16f99aa7ad0dbabb44a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplParams" colspan="2">template&lt;class Archive &gt; </td></tr>
<tr class="memitem:a68efd17a8330ab676d9cd711029b0f38"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a68efd17a8330ab676d9cd711029b0f38">serialize</a> (Archive &amp;ar, const unsigned <a class="el" href="classint.html">int</a> version)</td></tr>
<tr class="separator:a68efd17a8330ab676d9cd711029b0f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing the location of points.</div></td></tr>
<tr class="memitem:a8a2c4e2d796956ec3eb825bb0bdae59f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">get_intermediate_point</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p2, const <a class="el" href="classdouble.html">double</a> w) const</td></tr>
<tr class="separator:a8a2c4e2d796956ec3eb825bb0bdae59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bf5770c24c142b30f2391897fe0656"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;weights) const</td></tr>
<tr class="separator:a04bf5770c24c142b30f2391897fe0656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d90f7b0e6f66ce0b84676d9aeacfc4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a3d90f7b0e6f66ce0b84676d9aeacfc4e">get_new_points</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;weights, <a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; new_points) const</td></tr>
<tr class="separator:a3d90f7b0e6f66ce0b84676d9aeacfc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0163e726b6c4af36638d889fb3afed4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">project_to_manifold</a> (const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;surrounding_points, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;candidate) const</td></tr>
<tr class="separator:af0163e726b6c4af36638d889fb3afed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be8b4b185d2469dcdfff826ff854cd7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a9be8b4b185d2469dcdfff826ff854cd7">get_new_point_on_line</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;line) const</td></tr>
<tr class="separator:a9be8b4b185d2469dcdfff826ff854cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f18f34e5f98fea7cbd40bd3245f0aee"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a6f18f34e5f98fea7cbd40bd3245f0aee">get_new_point_on_quad</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;quad) const</td></tr>
<tr class="separator:a6f18f34e5f98fea7cbd40bd3245f0aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b1f7a138589989fe84984e12f3d945"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a87b1f7a138589989fe84984e12f3d945">get_new_point_on_hex</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;hex) const</td></tr>
<tr class="separator:a87b1f7a138589989fe84984e12f3d945"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238d0f0a7f973ff25f4cab4ec21e9b56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a238d0f0a7f973ff25f4cab4ec21e9b56">get_new_point_on_face</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face) const</td></tr>
<tr class="separator:a238d0f0a7f973ff25f4cab4ec21e9b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e9a7899b69fbe5fdf7961f9c4c7374"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a39e9a7899b69fbe5fdf7961f9c4c7374">get_new_point_on_cell</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;cell) const</td></tr>
<tr class="separator:a39e9a7899b69fbe5fdf7961f9c4c7374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing tangent vectors</div></td></tr>
<tr class="memitem:a6bd82ff6170512f65ad5c43e8440c23a"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a6bd82ff6170512f65ad5c43e8440c23a">get_tangent_vector</a> (const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x1, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;x2) const</td></tr>
<tr class="separator:a6bd82ff6170512f65ad5c43e8440c23a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Computing normal vectors</div></td></tr>
<tr class="memitem:af0087568e69730a3acc7b42535ab3337"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classTensor.html">Tensor</a>&lt; 1, spacedim &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#af0087568e69730a3acc7b42535ab3337">normal_vector</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;p) const</td></tr>
<tr class="separator:af0087568e69730a3acc7b42535ab3337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a684ad0b97b0f225eb4eb7ee04ab41d7e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classManifold.html#a684ad0b97b0f225eb4eb7ee04ab41d7e">get_normals_at_vertices</a> (const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;face, <a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;face_vertex_normals) const</td></tr>
<tr class="separator:a684ad0b97b0f225eb4eb7ee04ab41d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Subscriptor functionality</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Classes derived from <a class="el" href="classSubscriptor.html">Subscriptor</a> provide a facility to subscribe to this object. This is mostly used by the <a class="el" href="classSmartPointer.html">SmartPointer</a> class. </p>
</div></td></tr>
<tr class="memitem:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a5f0a31fd6c55fba2d0f68ffed307832f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c341da7c0fafd60c30848103bf51dd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a09c341da7c0fafd60c30848103bf51dd">unsubscribe</a> (std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const validity, const std::string &amp;identifier=&quot;&quot;) const</td></tr>
<tr class="separator:a09c341da7c0fafd60c30848103bf51dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9b78412f1bad58f6578b1285611c9e5"><td class="memItemLeft" align="right" valign="top">unsigned <a class="el" href="classint.html">int</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af9b78412f1bad58f6578b1285611c9e5">n_subscriptions</a> () const</td></tr>
<tr class="separator:af9b78412f1bad58f6578b1285611c9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplParams" colspan="2">template&lt;typename StreamType &gt; </td></tr>
<tr class="memitem:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#af5dc5153076ef7e8c4806ef2b21dbc4f">list_subscribers</a> (StreamType &amp;stream) const</td></tr>
<tr class="separator:af5dc5153076ef7e8c4806ef2b21dbc4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classSubscriptor.html#a32b1dacf5ccfa29f7f093864a95e02b0">list_subscribers</a> () const</td></tr>
<tr class="separator:a32b1dacf5ccfa29f7f093864a95e02b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:gac763df3ce17c4ff01be5887902c88cb5"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#gac763df3ce17c4ff01be5887902c88cb5">ExcInUse</a> (<a class="el" href="classint.html">int</a> arg1, std::string arg2, std::string arg3)</td></tr>
<tr class="separator:gac763df3ce17c4ff01be5887902c88cb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memItemLeft" align="right" valign="top">static ::<a class="el" href="classExceptionBase.html">ExceptionBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__Exceptions.html#ga914cc7f7eb16630ed4b0afc37c233e2e">ExcNoSubscriber</a> (std::string arg1, std::string arg2)</td></tr>
<tr class="separator:ga914cc7f7eb16630ed4b0afc37c233e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;int dim, int spacedim = dim&gt;<br />
class Manifold&lt; dim, spacedim &gt;</h3>

<p><a class="el" href="namespaceManifolds.html">Manifolds</a> are used to describe the geometry of boundaries of domains as well as the geometry of the interior. <a class="el" href="classManifold.html">Manifold</a> objects are therefore associated with cells, faces, and/or edges, either by direct user action or, if a user program does not do this explicitly, a default manifold object is used.</p>
<p><a class="el" href="namespaceManifolds.html">Manifolds</a> are best understood by using the language of differential geometry, but their common uses can be easily described simply through examples. An exhaustive discussion of how, where, and why this class is used is provided in the <a class="el" href="DEALGlossary.html#geometry_paper">geometry paper</a>.</p>
<h3>Common use case: Creating a new vertex</h3>
<p>In the most essential use of manifolds, manifold descriptions are used to create a "point between other points". For example, when a triangulation creates a new vertex on a cell, face, or edge, it determines the new vertex' coordinates through the following function call: </p><div class="fragment"><div class="line">...</div><div class="line">Point&lt;spacedim&gt; new_vertex = manifold.get_new_point (points,weights);</div><div class="line">...</div></div><!-- fragment --><p> Here, <code>points</code> is a collection of points in <code>spacedim</code> dimension, and <code>a</code> collection of corresponding weights. The points in this context will then be the vertices of the cell, face, or edge, and the weights are typically one over the number of points when a new midpoint of the cell, face, or edge is needed. Derived classes then will implement the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold::get_new_point()</a> function in a way that computes the location of this new point. In the simplest case, for example in the <a class="el" href="classFlatManifold.html">FlatManifold</a> class, the function simply computes the arithmetic average (with given weights) of the given points. However, other classes do something differently; for example, the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> class, which is used to describe domains that form (part of) the sphere, will ensure that, given the two vertices of an edge at the boundary, the new returned point will lie on the grand circle that connects the two points, rather than choosing a point that is half-way between the two points in \({\mathbb R}^d\).</p>
<dl class="section note"><dt>Note</dt><dd>Unlike almost all other cases in the library, we here interpret the points to be in real space, not on the reference cell.</dd></dl>
<p><a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold::get_new_point()</a> has a default implementation that can simplify this process somewhat: Internally, the function calls the <a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">Manifold::get_intermediate_point()</a> to compute pair-wise intermediate points. Internally the <a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">Manifold::get_intermediate_point()</a> calls the <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold::project_to_manifold()</a> function after computing the convex combination of the given points. This allows derived classes to only overload <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold::project_to_manifold()</a> for simple situations. This is often useful when describing manifolds that are embedded in higher dimensional space, e.g., the surface of a sphere. In those cases, the desired new point may be computed simply by the (weighted) average of the provided points, projected back out onto the sphere.</p>
<h3>Common use case: Computing tangent vectors</h3>
<p>The second use of this class is in computing directions on domains and boundaries. For example, we may need to compute the normal vector to a face in order to impose the no-flow boundary condition \(\mathbf u \cdot \mathbf n = 0\) (see the <a class="el" href="group__constraints.html#ga0d16c332aaa652e8905a6f48208e4500">VectorTools::compute_no_normal_flux_constraints()</a> as an example). Similarly, we may need normal vectors in the computation of the normal component of the gradient of the numerical solution in order to compute the jump in the gradient of the solution in error estimators (see, for example, the <a class="el" href="classKellyErrorEstimator.html">KellyErrorEstimator</a> class).</p>
<p>To make this possible, the <a class="el" href="classManifold.html">Manifold</a> class provides a member function (to be implemented by derived classes) that computes a "vector tangent
to the manifold at one point, in direction of another point" via the <a class="el" href="classManifold.html#a6bd82ff6170512f65ad5c43e8440c23a">Manifold::get_tangent_vector()</a> function. For example, in 2d, one would use this function with the two vertices of an edge at the boundary to compute a "tangential" vector along the edge, and then get the normal vector by rotation by 90 degrees. In 3d, one would compute the two vectors "tangential" to the two edges of a boundary face adjacent to a boundary vertex, and then take the cross product of these two to obtain a vector normal to the boundary.</p>
<p>For reasons that are more difficult to understand, these direction vectors are normalized in a very specific way, rather than to have unit norm. See the documentation of <a class="el" href="classManifold.html#a6bd82ff6170512f65ad5c43e8440c23a">Manifold::get_tangent_vector()</a>, as well as below, for more information.</p>
<p>In the simplest case (namely, the <a class="el" href="classFlatManifold.html">FlatManifold</a> class), these tangent vectors are just the difference vector between the two given points. However, in more complicated (and more interesting) cases, the direction may be different. For example, for the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> case, if the two given points lie on a common grand circle around the origin, then the tangent vector will be tangential to the grand circle, rather than pointing straight from one point to the other.</p>
<h3>A unified description</h3>
<p>The "real" way to understand what this class does is to see it in the framework of differential geometry. More specifically, differential geometry is fundamentally based on the assumption that two sufficiently close points are connected via a line of "shortest distance". This line is called a "geodesic", and it is selected from all other lines that connect the two points by the property that it is shortest if distances are measured in terms of the "metric" that describes a manifold. To give examples, recall that the geodesics of a flat manifold (implemented in the <a class="el" href="classFlatManifold.html">FlatManifold</a> class) are simply the straight lines connecting two points, whereas for spherical manifolds (see the <a class="el" href="classSphericalManifold.html">SphericalManifold</a> class) geodesics between two points of same distance are the grand circles, and are in general curved lines when connecting two lines of different distance from the origin.</p>
<p>In the following discussion, and for the purposes of implementing the current class, the concept of "metrics" that is so fundamental to differential geometry is no longer of great importance to us. Rather, everything can simply be described by postulating the existence of geodesics connecting points on a manifold.</p>
<p>Given geodesics, the operations discussed in the previous two sections can be described in a more formal way. In essence, they rely on the fact that we can assume that a geodesic is parameterized by a "time" like variable \(t\) so that \(\mathbf s(t)\) describes the curve and so that \(\mathbf s(0)\) is the location of the first and \(\mathbf s(1)\) the location of the second point. Furthermore, \(\mathbf s(t)\) traces out the geodesic at constant speed, covering equal distance in equal time (as measured by the metric). Note that this parameterization uses time, not arc length to denote progress along the geodesic.</p>
<p>In this picture, computing a mid-point between points \(\mathbf x_1\) and \(\mathbf x_2\), with weights \(w_1\) and \(w_2=1-w_1\), simply requires computing the point \(\mathbf s(w_1)\). Computing a new point as a weighted average of more than two points can be done by considering pairwise geodesics, finding suitable points on the geodetic between the first two points, then on the geodetic between this new point and the third given point, etc.</p>
<p>Likewise, the "tangential" vector described above is simply the velocity vector, \(\mathbf s&#39;(t)\), evaluated at one of the end points of a geodesic (i.e., at \(t=0\) or \(t=1\)). In the case of a flat manifold, the geodesic is simply the straight line connecting two points, and the velocity vector is just the connecting vector in that case. On the other hand, for two points on a spherical manifold, the geodesic is a grand circle, and the velocity vector is tangent to the spherical surface.</p>
<p>Note that if we wanted to, we could use this to compute the length of the geodesic that connects two points \(\mathbf x_1\) and \(\mathbf x_2\) by computing \(\int_0^1 \|\mathbf s&#39;(t)\| dt\) along the geodesic that connects them, but this operation will not be of use to us in practice. One could also conceive computing the direction vector using the "new point" operation above, using the formula \(\mathbf s&#39;(0)=\lim_{w\rightarrow 0} \frac{\mathbf s(w)-\mathbf s(0)}{w}\) where all we need to do is compute the new point \(\mathbf s(w)\) with weights \(w\) and \(1-w\) along the geodesic connecting \(\mathbf x_1\) and \(\mathbf x_2\). The default implementation of the function does this, by evaluating the quotient for a small but finite weight \(w\). In practice, however, it is almost always possible to explicitly compute the direction vector, i.e., without the need to numerically approximate the limit process, and derived classes should do so. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00286">286</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a79eb483936cd38a0a9d42bf2071ee9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79eb483936cd38a0a9d42bf2071ee9ce">&#9670;&nbsp;</a></span>FaceVertexNormals</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::<a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> =  std::array&lt;<a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt;, <a class="el" href="structGeometryInfo.html">GeometryInfo</a>&lt;dim&gt;::vertices_per_face&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type keeping information about the normals at the vertices of a face of a cell. Thus, there are <code><a class="el" href="structGeometryInfo.html#aad8410f6471e4ac443b51f6c20809bfb">GeometryInfo&lt;dim&gt;::vertices_per_face</a></code> normal vectors, that define the tangent spaces of the boundary at the vertices. Note that the vectors stored in this object are not required to be normalized, nor to actually point outward, as one often will only want to check for orthogonality to define the tangent plane; if a function requires the normals to be normalized, then it must do so itself.</p>
<p>For obvious reasons, this type is not useful in 1d. </p>

<p class="definition">Definition at line <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html#l00307">307</a> of file <a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a70c02e6c388bf21f43ea09d29681fb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70c02e6c388bf21f43ea09d29681fb34">&#9670;&nbsp;</a></span>~Manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::~<a class="el" href="classManifold.html">Manifold</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">override</span><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Destructor. Does nothing here, but needs to be declared virtual to make class hierarchies derived from this class possible. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a140e1b7c7334d16f99aa7ad0dbabb44a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140e1b7c7334d16f99aa7ad0dbabb44a">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::unique_ptr&lt;<a class="el" href="classManifold.html">Manifold</a>&lt;dim, spacedim&gt; &gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a copy of this manifold.</p>
<p>Every derived class should implement this operation in a sensible manner. </p>

<p>Implemented in <a class="el" href="classTransfiniteInterpolationManifold.html#ac9394c3127aeb9beeff14c57af2d3a97">TransfiniteInterpolationManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classTorusManifold.html#a375b8bd63b79db8407228fec1666b63e">TorusManifold&lt; dim &gt;</a>, <a class="el" href="classFlatManifold.html#a767f5dded58e58793c10bc50ce858ba6">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a767f5dded58e58793c10bc50ce858ba6">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classFlatManifold.html#a767f5dded58e58793c10bc50ce858ba6">FlatManifold&lt; dim &gt;</a>, <a class="el" href="classFunctionManifold.html#a31f71cd51666e12fe54ccc8771fea634">FunctionManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classEllipticalManifold.html#aee071194b99ef94d726a436f3272755b">EllipticalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classCylindricalManifold.html#a538d5562488a15e77e0a024d5272ac2f">CylindricalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NURBSPatchManifold.html#a9690eb5f128777a17fb27909ab6053c3">OpenCASCADE::NURBSPatchManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1ArclengthProjectionLineManifold.html#af8aba682826106510d87872d74766cb3">OpenCASCADE::ArclengthProjectionLineManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classSphericalManifold.html#a7c2789d19572e9054df24d4f56ca89fb">SphericalManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a2962f36ba381305e0cfae7f549b17024">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a75669873052f45d101e1de640a02d5b1">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classTensorProductManifold.html#acfbc99450c4f60a3a8facf24ba4605d4">TensorProductManifold&lt; dim, dim_A, spacedim_A, chartdim_A, dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classCompositionManifold.html#a8ecb573a1be81528358e79b70010740f">CompositionManifold&lt; dim, spacedim, chartdim, intermediate_dim, dim1, dim2 &gt;</a>, <a class="el" href="classPolarManifold.html#a281b716f64f7811ee568b2d5be9ae6de">PolarManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classPolarManifold.html#a281b716f64f7811ee568b2d5be9ae6de">PolarManifold&lt; spacedim &gt;</a>, and <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#af40f56b8391e4c1c099f22de1e1f5364">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a8a2c4e2d796956ec3eb825bb0bdae59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a2c4e2d796956ec3eb825bb0bdae59f">&#9670;&nbsp;</a></span>get_intermediate_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_intermediate_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classdouble.html">double</a>&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return an intermediate point between two given points. Overloading this function allows the default pair-wise reduction implementation of the method <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point()</a> that takes a <a class="el" href="classQuadrature.html">Quadrature</a> object as input to work properly.</p>
<p>An implementation of this function should returns a parametric curve on the manifold, joining the points <code>p1</code> and <code>p2</code>, with parameter <code>w</code> in the interval [0,1]. In particular <code>get_intermediate_point(p1, p2, 0.0)</code> should return <code>p1</code> and <code>get_intermediate_point(p1, p2, 1.0)</code> should return <code>p2</code>.</p>
<p>In its default implementation, this function calls the <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">project_to_manifold()</a> method with the convex combination of <code>p1</code> and <code>p2</code>. User classes can get away by simply implementing the <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">project_to_manifold()</a> method. </p>

<p>Reimplemented in <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, 3 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, dim, dim &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#ab24f5adae12f44a702406ca361bc3abf">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, and <a class="el" href="classSphericalManifold.html#ac583ee1989abe66f8b9ead2c4cc79e38">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a04bf5770c24c142b30f2391897fe0656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bf5770c24c142b30f2391897fe0656">&#9670;&nbsp;</a></span>get_new_point()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the point which shall become the new vertex surrounded by the given points <code>surrounding_points</code>. <code>weights</code> contains appropriate weights for the surrounding points according to which the manifold determines the new point's position.</p>
<p>In its default implementation it uses a pair-wise reduction of the points by calling the function <a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">get_intermediate_point()</a> on the first two points, then on the resulting point and the next, until all points in the vector have been taken into account. User classes can get away by simply implementing the <a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">get_intermediate_point()</a> function. Notice that by default the <a class="el" href="classManifold.html#a8a2c4e2d796956ec3eb825bb0bdae59f">get_intermediate_point()</a> function calls the <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">project_to_manifold()</a> function with the convex combination of its arguments. For simple situations you may get away by implementing only the <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">project_to_manifold()</a> function. </p>

<p>Reimplemented in <a class="el" href="classTransfiniteInterpolationManifold.html#a746373ab852a03c44dd97dd6a6772a91">TransfiniteInterpolationManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, spacedim, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, dim, dim &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a0f8e15b3d972cee2d6ed0661e9b6cc33">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#a6ade4bf6598dda23e36f95a46fa026e7">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a6ade4bf6598dda23e36f95a46fa026e7">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classCylindricalManifold.html#a37d81a123cebd8f0ef76fce521e56b18">CylindricalManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classSphericalManifold.html#a5be1a0a1464f08ee3865462994be827f">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a3d90f7b0e6f66ce0b84676d9aeacfc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d90f7b0e6f66ce0b84676d9aeacfc4e">&#9670;&nbsp;</a></span>get_new_points()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classTable.html">Table</a>&lt; 2, <a class="el" href="classdouble.html">double</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classArrayView.html">ArrayView</a>&lt; <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt;&#160;</td>
          <td class="paramname"><em>new_points</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a new set of points that interpolate between the given points <code>surrounding_points</code>. <code>weights</code> is a table with as many columns as <code>surrounding_points.size()</code>. The number of rows in <code>weights</code> must match the length of <code>new_points</code>.</p>
<p>In its default implementation, this function simply calls <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point()</a> on each row of <code>weights</code> and writes those points into the output array <code>new_points</code>. However, this function is more efficient if multiple new points need to be generated like in <a class="el" href="classMappingQGeneric.html">MappingQGeneric</a> and the manifold does expensive transformations between a chart space and the physical space, such as <a class="el" href="classChartManifold.html">ChartManifold</a>. For this function, the surrounding points need to be transformed back to the chart sparse only once, rather than for every call to <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point()</a>. If efficiency is not important, you may get away by implementing only the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point()</a> function.</p>
<p>The implementation does not allow for <code>surrounding_points</code> and <code>new_points</code> to point to the same array, so make sure to pass different objects into the function. </p>

<p>Reimplemented in <a class="el" href="classTransfiniteInterpolationManifold.html#a3dd3389af0ad1bf43341770d03c73240">TransfiniteInterpolationManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, spacedim, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, dim, dim &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a999ef4b52e2c7d8e0abcb6c83bd27ae1">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#a10bffbfe9f60ee0cf9d8bb9bfd7f8384">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a10bffbfe9f60ee0cf9d8bb9bfd7f8384">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classSphericalManifold.html#af22df33a99a097469704e1209fbffda3">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af0163e726b6c4af36638d889fb3afed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0163e726b6c4af36638d889fb3afed4">&#9670;&nbsp;</a></span>project_to_manifold()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::project_to_manifold </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classArrayView.html">ArrayView</a>&lt; const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surrounding_points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>candidate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a point which lies close to the given manifold, it modifies it and projects it to manifold itself.</p>
<p>This class is used by the default implementation of the function <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point()</a> and should be implemented by derived classes. The default implementation simply throws an exception if called.</p>
<p>If your manifold is simple, you could implement this function only, and the default behavior should work out of the box. </p>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#a8f30acedc685f5263d5924e7dbbaa478">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1NormalToMeshProjectionManifold.html#a9dd1803613a175dd616669290bb12629">OpenCASCADE::NormalToMeshProjectionManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classOpenCASCADE_1_1DirectionalProjectionManifold.html#a6d29477876fbbd162af174e6fd4f6424">OpenCASCADE::DirectionalProjectionManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classOpenCASCADE_1_1NormalProjectionManifold.html#af3ed288cfa18c858f93ff95e4f45e539">OpenCASCADE::NormalProjectionManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a9be8b4b185d2469dcdfff826ff854cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be8b4b185d2469dcdfff826ff854cd7">&#9670;&nbsp;</a></span>get_new_point_on_line()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_line </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::line_iterator &amp;&#160;</td>
          <td class="paramname"><em>line</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the new middle vertex of the two children of a regular line. In 2D, this line is a line at the boundary, while in 3d, it is bounding a face at the boundary (the lines therefore is also on the boundary).</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a6f18f34e5f98fea7cbd40bd3245f0aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f18f34e5f98fea7cbd40bd3245f0aee">&#9670;&nbsp;</a></span>get_new_point_on_quad()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_quad </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::quad_iterator &amp;&#160;</td>
          <td class="paramname"><em>quad</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the four children of a quad at the boundary in three or more spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the four lines bounding the given <code>quad</code> are refined, so you may want to use the information provided by <code>quad-&gt;line(i)-&gt;child(j)</code>, <code>i=0...3</code>, <code>j=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a87b1f7a138589989fe84984e12f3d945"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b1f7a138589989fe84984e12f3d945">&#9670;&nbsp;</a></span>get_new_point_on_hex()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_hex </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::hex_iterator &amp;&#160;</td>
          <td class="paramname"><em>hex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Backward compatibility interface. Return the point which shall become the common point of the eight children of a hex in three or spatial dimensions. This function therefore is only useful in at least three dimensions and should not be called for lower dimensions.</p>
<p>This function is called after the all the bounding objects of the given <code>hex</code> are refined, so you may want to use the information provided by <code>hex-&gt;quad(i)-&gt;line(j)-&gt;child(k)</code>, <code>i=0...5</code>, <code>j=0...3</code>, <code>k=0,1</code>.</p>
<p>The default implementation of this function passes its argument to the <a class="el" href="namespaceManifolds.html#aa3ae330e2a2d8030955d5a395f3f1d18">Manifolds::get_default_points_and_weights()</a> function, and then calls the <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> function. User derived classes can overload <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a> or <a class="el" href="classManifold.html#af0163e726b6c4af36638d889fb3afed4">Manifold&lt;dim,spacedim&gt;::project_to_manifold()</a>, which is called by the default implementation of <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">Manifold&lt;dim,spacedim&gt;::get_new_point()</a>. </p>

</div>
</div>
<a id="a238d0f0a7f973ff25f4cab4ec21e9b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238d0f0a7f973ff25f4cab4ec21e9b56">&#9670;&nbsp;</a></span>get_new_point_on_face()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_face </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line or the get_new_point_on_quad function. It throws an exception for <code>dim=1</code>. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a39e9a7899b69fbe5fdf7961f9c4c7374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39e9a7899b69fbe5fdf7961f9c4c7374">&#9670;&nbsp;</a></span>get_new_point_on_cell()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classPoint.html">Point</a>&lt;spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_new_point_on_cell </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::cell_iterator &amp;&#160;</td>
          <td class="paramname"><em>cell</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Backward compatibility interface. Depending on <code>dim=1</code>, <code>dim=2</code> or <code>dim=3</code> this function calls the get_new_point_on_line, get_new_point_on_quad or the get_new_point_on_hex function. This wrapper allows dimension independent programming. </p>

</div>
</div>
<a id="a6bd82ff6170512f65ad5c43e8440c23a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6bd82ff6170512f65ad5c43e8440c23a">&#9670;&nbsp;</a></span>get_tangent_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_tangent_vector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>x2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return a vector that, at \(\mathbf x_1\), is tangential to the geodesic that connects two points \(\mathbf x_1,\mathbf x_2\). The geodesic is the shortest line between these two points, where "shortest" is defined via a metric specific to a particular implementation of this class in a derived class. For example, in the case of a <a class="el" href="classFlatManifold.html">FlatManifold</a>, the shortest line between two points is just the straight line, and in this case the tangent vector is just the difference \(\mathbf d=\mathbf x_2-\mathbf x_1\). On the other hand, for a manifold that describes a surface embedded in a higher dimensional space (e.g., the surface of a sphere), then the tangent vector is tangential to the surface, and consequently may point in a different direction than the straight line that connects the two points.</p>
<p>While tangent vectors are often normalized to unit length, the vectors returned by this function are normalized as described in the introduction of this class. Specifically, if \(\mathbf s(t)\) traces out the geodesic between the two points where \(\mathbf x_1 = \mathbf s(0)\) and \(\mathbf x_2 = \mathbf s(1)\), then the returned vector must equal \(\mathbf s&#39;(0)\). In other words, the norm of the returned vector also encodes, in some sense, the <em>length</em> of the geodesic because a curve \(\mathbf s(t)\) must move "faster" if the two points it connects between arguments \(t=0\) and \(t=1\) are farther apart.</p>
<p>The default implementation of this function approximates \(\mathbf s&#39;(0) \approx \frac{\mathbf s(\epsilon)-\mathbf x_1}{\epsilon}\) for a small value of \(\epsilon\), and the evaluation of \(\mathbf s(\epsilon)\) is done by calling <a class="el" href="classManifold.html#a04bf5770c24c142b30f2391897fe0656">get_new_point()</a>. If possible, derived classes should override this function by an implementation of the exact derivative.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x1</td><td>The first point that describes the geodesic, and the one at which the "direction" is to be evaluated. </td></tr>
    <tr><td class="paramname">x2</td><td>The second point that describes the geodesic. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A "direction" vector tangential to the geodesic. </dd></dl>

<p>Reimplemented in <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, spacedim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, spacedim, 2 &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, spacedim, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim_B, spacedim_B, chartdim_B &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, spacedim, 1 &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim_A, spacedim_A, chartdim_A &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim1, intermediate_dim, chartdim &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, spacedim, spacedim &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim2, spacedim, intermediate_dim &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, dim, dim &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, 3, 3 &gt;</a>, <a class="el" href="classChartManifold.html#a6ac57666eb157e97353a7c2d18d1ef91">ChartManifold&lt; dim, spacedim_A+spacedim_B, chartdim_A+chartdim_B &gt;</a>, <a class="el" href="classFlatManifold.html#ab5eec4132f6d653dea1380f7d587ecdf">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#ab5eec4132f6d653dea1380f7d587ecdf">FlatManifold&lt; chartdim, chartdim &gt;</a>, and <a class="el" href="classSphericalManifold.html#a95f186c631d913c683d687aee65b3f48">SphericalManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="af0087568e69730a3acc7b42535ab3337"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0087568e69730a3acc7b42535ab3337">&#9670;&nbsp;</a></span>normal_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classTensor.html">Tensor</a>&lt;1, spacedim&gt; <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::normal_vector </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classPoint.html">Point</a>&lt; spacedim &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the normal vector to a face embedded in this manifold, at the point p. If p is not in fact on the surface, but only close-by, try to return something reasonable, for example the normal vector at the surface point closest to p. (The point p will in fact not normally lie on the actual surface, but rather be a quadrature point mapped by some polynomial mapping; the mapped surface, however, will not usually coincide with the actual surface.)</p>
<p>This function only makes sense if dim==spacedim because otherwise there is no unique normal vector but in fact a (spacedim-dim+1)-dimensional tangent space of vectors that are all both normal to the face and normal to the dim-dimensional surface that lives in spacedim-dimensional space. For example, think of a two-dimensional mesh that covers a two-dimensional surface in three-dimensional space. In that case, each face (edge) is one-dimensional, and there are two linearly independent vectors that are both normal to the edge: one is normal to the edge and tangent to the surface (intuitively, that would be the one that points from the current cell to the neighboring one, if the surface was locally flat), and the other one is rooted in the edge but points perpendicular to the surface (which is also perpendicular to the edge that lives within the surface). Thus, because there are no obviously correct semantics for this function if spacedim is greater than dim, the function will simply throw an error in that situation.</p>
<p>The face iterator gives an indication which face this function is supposed to compute the normal vector for. This is useful if the boundary of the domain is composed of different nondifferential pieces (for example when using the <a class="el" href="classFlatManifold.html">FlatManifold</a> class to approximate a geometry that is completely described by the coarse mesh, with piecewise (bi-)linear components between the vertices, but where the boundary may have a kink at the vertices itself).</p>
<dl class="section note"><dt>Note</dt><dd>In 2d, the default implementation of this function computes the normal vector by taking the tangent direction from p to the further one of the two vertices that make up an edge, and then rotates it outward (with respect to the coordinate system of the edge) by 90 degrees. In 3d, the default implementation is more complicated, aiming at avoiding problems with numerical round-off for points close to one of the vertices, and avoiding tangent directions that are linearly dependent. </dd></dl>

<p>Reimplemented in <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; dim, spacedim &gt;</a>, <a class="el" href="classFlatManifold.html#aab60f221758b3a32a596dde96fc1188c">FlatManifold&lt; chartdim, chartdim &gt;</a>, <a class="el" href="classSphericalManifold.html#a3fa07d5cf46d4f9110887793475c4b5f">SphericalManifold&lt; dim, spacedim &gt;</a>, and <a class="el" href="classPolarManifold.html#a0b6e323582f73b658399a5afa44e32d0">PolarManifold&lt; dim, spacedim &gt;</a>.</p>

</div>
</div>
<a id="a684ad0b97b0f225eb4eb7ee04ab41d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a684ad0b97b0f225eb4eb7ee04ab41d7e">&#9670;&nbsp;</a></span>get_normals_at_vertices()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dim, int spacedim = dim&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void <a class="el" href="classManifold.html">Manifold</a>&lt; dim, spacedim &gt;::get_normals_at_vertices </td>
          <td>(</td>
          <td class="paramtype">const typename <a class="el" href="classTriangulation.html">Triangulation</a>&lt; dim, spacedim &gt;::face_iterator &amp;&#160;</td>
          <td class="paramname"><em>face</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classManifold.html#a79eb483936cd38a0a9d42bf2071ee9ce">FaceVertexNormals</a> &amp;&#160;</td>
          <td class="paramname"><em>face_vertex_normals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the normal vectors to the boundary at each vertex of the given face embedded in the <a class="el" href="classManifold.html">Manifold</a>. It is not required that the normal vectors be normed somehow. Neither is it required that the normals actually point outward.</p>
<p>This function is needed to compute data for C1 mappings. The default implementation calls <a class="el" href="classManifold.html#af0087568e69730a3acc7b42535ab3337">normal_vector()</a> on each vertex.</p>
<p>Note that when computing normal vectors at a vertex where the boundary is not differentiable, you have to make sure that you compute the one-sided limits, i.e. limit with respect to points inside the given face. </p>

</div>
</div>
<a id="a5f0a31fd6c55fba2d0f68ffed307832f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0a31fd6c55fba2d0f68ffed307832f">&#9670;&nbsp;</a></span>subscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::subscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Subscribes a user of the object by storing the pointer <code>validity</code>. The subscriber may be identified by text supplied as <code>identifier</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00136">136</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a09c341da7c0fafd60c30848103bf51dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c341da7c0fafd60c30848103bf51dd">&#9670;&nbsp;</a></span>unsubscribe()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::unsubscribe </td>
          <td>(</td>
          <td class="paramtype">std::atomic&lt; <a class="el" href="classbool.html">bool</a> &gt; *const&#160;</td>
          <td class="paramname"><em>validity</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>identifier</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Unsubscribes a user from the object.</p>
<dl class="section note"><dt>Note</dt><dd>The <code>identifier</code> and the <code>validity</code> pointer must be the same as the one supplied to <a class="el" href="classSubscriptor.html#a5f0a31fd6c55fba2d0f68ffed307832f">subscribe()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00156">156</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="af9b78412f1bad58f6578b1285611c9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9b78412f1bad58f6578b1285611c9e5">&#9670;&nbsp;</a></span>n_subscriptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned <a class="el" href="classint.html">int</a> Subscriptor::n_subscriptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the present number of subscriptions to this object. This allows to use this class for reference counted lifetime determination where the last one to unsubscribe also deletes the object. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00301">301</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="af5dc5153076ef7e8c4806ef2b21dbc4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5dc5153076ef7e8c4806ef2b21dbc4f">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename StreamType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramtype">StreamType &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to the input <code>stream</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00318">318</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<a id="a32b1dacf5ccfa29f7f093864a95e02b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32b1dacf5ccfa29f7f093864a95e02b0">&#9670;&nbsp;</a></span>list_subscribers() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::list_subscribers </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>List the subscribers to <code>deallog</code>. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8cc_source.html#l00204">204</a> of file <a class="el" href="subscriptor_8cc_source.html">subscriptor.cc</a>.</p>

</div>
</div>
<a id="a68efd17a8330ab676d9cd711029b0f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68efd17a8330ab676d9cd711029b0f38">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Archive &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void Subscriptor::serialize </td>
          <td>(</td>
          <td class="paramtype">Archive &amp;&#160;</td>
          <td class="paramname"><em>ar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unsigned <a class="el" href="classint.html">int</a>&#160;</td>
          <td class="paramname"><em>version</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">inherited</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Read or write the data of this object to or from a stream for the purpose of serialization using the <a href="https://www.boost.org/doc/libs/1_74_0/libs/serialization/doc/index.html">BOOST serialization library</a>.</p>
<p>This function does not actually serialize any of the member variables of this class. The reason is that what this class stores is only who subscribes to this object, but who does so at the time of storing the contents of this object does not necessarily have anything to do with who subscribes to the object when it is restored. Consequently, we do not want to overwrite the subscribers at the time of restoring, and then there is no reason to write the subscribers out in the first place. </p>

<p class="definition">Definition at line <a class="el" href="subscriptor_8h_source.html#l00310">310</a> of file <a class="el" href="subscriptor_8h_source.html">subscriptor.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/deal.II/grid/<a class="el" href="include_2deal_8II_2grid_2manifold_8h_source.html">manifold.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
